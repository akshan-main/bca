{"task_id": "usage-total-tokens-math", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "UsageBase.total_tokens subtracts output tokens instead of adding them, making the total_tokens property return wrong values.", "vague_description": "Token usage tracking seems off. The total token count is always lower than expected, even lower than the input tokens alone.", "test_cmd": "python -m pytest tests/test_usage_limits.py::test_total_token_limit -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/usage.py", "original": "return self.input_tokens + self.output_tokens", "mutated": "return self.input_tokens - self.output_tokens", "line_num": 66}, "source": "handcrafted", "category": "usage", "dev_report_description": "Test failure: tests/test_usage_limits.py::test_total_token_limit\n\nError: Failed: DID NOT RAISE <class 'pydantic_ai.exceptions.UsageLimitExceeded'>\n\nTraceback:\n____________________________ test_total_token_limit ____________________________\n\n    def test_total_token_limit() -> None:\n        test_agent = Agent(TestModel(custom_output_text='This utilizes 4 tokens!'))\n    \n>       with pytest.raises(UsageLimitExceeded, match=re.escape('Exceeded the total_tokens_limit of 50 (total_tokens=55)')):\nE       Failed: DID NOT RAISE <class 'pydantic_ai.exceptions.UsageLimitExceeded'>\n\ntests/test_usage_limits.py: Failed"}
{"task_id": "usage-request-limit-off-by-one", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "UsageLimits.check_before_request uses > instead of >= for the request limit check, allowing one extra request beyond the limit.", "vague_description": "Setting request_limit=1 still allows 2 requests before stopping. The limit is off by one.", "test_cmd": "python -m pytest tests/test_usage_limits.py::test_retry_limit -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/usage.py", "original": "if request_limit is not None and usage.requests >= request_limit:", "mutated": "if request_limit is not None and usage.requests > request_limit:", "line_num": 369}, "source": "handcrafted", "category": "usage", "dev_report_description": "Test failure: tests/test_usage_limits.py::test_retry_limit\n\nError: Failed: DID NOT RAISE <class 'pydantic_ai.exceptions.UsageLimitExceeded'>\n\nTraceback:\n_______________________________ test_retry_limit _______________________________\n\n    def test_retry_limit() -> None:\n        test_agent = Agent(TestModel())\n    \n        @test_agent.tool_plain\n        async def foo(x: str) -> str:\n            return x\n    \n        @test_agent.tool_plain\n        async def bar(y: str) -> str:\n            return y\n    \n>       with pytest.raises(UsageLimitExceeded, match=re.escape('The next request would exceed the request_limit of 1')):\nE       Failed: DID NOT RAISE <class 'pydantic_ai.exceptions.UsageLimitExceeded'>\n\ntests/test_usage_limits.py: Failed"}
{"task_id": "usage-check-tokens-output-inverted", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "check_tokens uses 'is None' instead of 'is not None' for output_tokens_limit, so the limit is never enforced.", "vague_description": "Output token limits are completely ignored. The agent generates unlimited output tokens even with output_tokens_limit set.", "test_cmd": "python -m pytest tests/test_usage_limits.py::test_response_token_limit -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/usage.py", "original": "if self.output_tokens_limit is not None and output_tokens > self.output_tokens_limit:", "mutated": "if self.output_tokens_limit is None and output_tokens > self.output_tokens_limit:", "line_num": 391}, "source": "handcrafted", "category": "usage", "dev_report_description": "Test failure: tests/test_usage_limits.py::test_response_token_limit\n\nError: Failed: DID NOT RAISE <class 'pydantic_ai.exceptions.UsageLimitExceeded'>\n\nTraceback:\n__________________________ test_response_token_limit ___________________________\n\n    def test_response_token_limit() -> None:\n        test_agent = Agent(\n            TestModel(custom_output_text='Unfortunately, this response exceeds the response tokens limit by a few!')\n        )\n    \n>       with pytest.raises(UsageLimitExceeded, match=re.escape('Exceeded the output_tokens_limit of 5 (output_tokens=11)')):\nE       Failed: DID NOT RAISE <class 'pydantic_ai.exceptions.UsageLimitExceeded'>\n\ntests/test_usage_limits.py: Failed"}
{"task_id": "usage-incr-tokens-wrong-op", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "_incr_usage_tokens subtracts input_tokens instead of adding, causing RunUsage.incr() to produce negative token counts.", "vague_description": "After multiple agent runs, the cumulative usage stats show negative input token counts. Something is wrong with the usage accumulation.", "test_cmd": "python -m pytest tests/test_usage_limits.py::test_add_usages -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/usage.py", "original": "slf.input_tokens += incr_usage.input_tokens", "mutated": "slf.input_tokens -= incr_usage.input_tokens", "line_num": 231}, "source": "handcrafted", "category": "usage", "dev_report_description": "Test failure: tests/test_usage_limits.py::test_add_usages\n\nError: AssertionError: assert RunUsage(cach... tool_calls=6) == RunUsage(inpu... tool_calls=6)\n\nTraceback:\n_______________________________ test_add_usages ________________________________\n\n    def test_add_usages():\n        usage = RunUsage(\n            requests=2,\n            input_tokens=10,\n            output_tokens=20,\n            cache_read_tokens=30,\n            cache_write_tokens=40,\n            input_audio_tokens=50,\n            cache_audio_read_tokens=60,\n            tool_calls=3,\n            details={\n                'custom1': 10,\n                'custom2': 20,\n            },\n        )\n>       assert usage + usage == snapshot(\n            RunUsage(\n                requests=4,\n                input_tokens=20,\n                output_tokens=40,\n                cache_write_tokens=80,\n                cache_read_tokens=60,\n                input_audio_tokens=100,\n    ..."}
{"task_id": "usage-tool-calls-limit-comparison", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "check_before_tool_call raises UsageLimitExceeded when tool calls are BELOW the limit instead of above it, blocking tools prematurely.", "vague_description": "Tool calls are being rejected immediately even though the tool call limit hasn't been reached. The limit enforcement seems inverted.", "test_cmd": "python -m pytest tests/test_usage_limits.py::test_tool_call_limit -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/usage.py", "original": "if tool_calls_limit is not None and tool_calls > tool_calls_limit:", "mutated": "if tool_calls_limit is not None and tool_calls < tool_calls_limit:", "line_num": 404}, "source": "handcrafted", "category": "usage", "dev_report_description": "Test failure: tests/test_usage_limits.py::test_tool_call_limit\n\nError: Failed: DID NOT RAISE <class 'pydantic_ai.exceptions.UsageLimitExceeded'>\n\nTraceback:\n_____________________________ test_tool_call_limit _____________________________\n\n    async def test_tool_call_limit() -> None:\n        test_agent = Agent(TestModel())\n    \n        @test_agent.tool_plain\n        async def ret_a(x: str) -> str:\n            return f'{x}-apple'\n    \n>       with pytest.raises(\n            UsageLimitExceeded,\n            match=re.escape('The next tool call(s) would exceed the tool_calls_limit of 0 (tool_calls=1).'),\n        ):\nE       Failed: DID NOT RAISE <class 'pydantic_ai.exceptions.UsageLimitExceeded'>\n\ntests/test_usage_limits.py: Failed"}
{"task_id": "ssrf-cloud-metadata-inverted", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "is_cloud_metadata_ip returns True for non-metadata IPs and False for actual cloud metadata endpoints — the check is inverted.", "vague_description": "URL downloads to public websites are being blocked as 'cloud metadata', but requests to 169.254.169.254 go through unchecked.", "test_cmd": "python -m pytest tests/test_ssrf.py::TestIsCloudMetadataIp -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "return ip_str in _CLOUD_METADATA_IPS", "mutated": "return ip_str not in _CLOUD_METADATA_IPS", "line_num": 79}, "source": "handcrafted", "category": "ssrf", "dev_report_description": "Test failure: tests/test_ssrf.py::TestIsCloudMetadataIp::test_cloud_metadata_ips_detected[169.254.169.254]\n\nError: AssertionError: assert False is True\n\nTraceback:\n___ TestIsCloudMetadataIp.test_cloud_metadata_ips_detected[169.254.169.254] ____\n\nself = <tests.test_ssrf.TestIsCloudMetadataIp object at 0x106f6fbd0>\nip = '169.254.169.254'\n\n    @pytest.mark.parametrize(\n        'ip',\n        [\n            '169.254.169.254',  # AWS, GCP, Azure\n            'fd00:ec2::254',  # AWS EC2 IPv6\n            '100.100.100.200',  # Alibaba Cloud\n        ],\n    )\n    def test_cloud_metadata_ips_detected(self, ip: str) -> None:\n>       assert is_cloud_metadata_ip(ip) is True\nE       AssertionError: assert False is True\nE        +  where False = is_cloud_metadata_ip('169.254.169.254')\n\ntests/test_ssrf.py: AssertionError"}
{"task_id": "ssrf-protocol-validation", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "validate_url_protocol rejects HTTPS URLs, only allowing plain HTTP — breaking all secure downloads.", "vague_description": "All HTTPS URL downloads fail with a protocol error. Only plain HTTP URLs work, which defeats the security purpose.", "test_cmd": "python -m pytest tests/test_ssrf.py::TestValidateUrlProtocol -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "if scheme not in ('http', 'https'):", "mutated": "if scheme not in ('http',):", "line_num": 145}, "source": "handcrafted", "category": "ssrf", "dev_report_description": "Test failure: tests/test_ssrf.py::TestValidateUrlProtocol::test_allowed_protocols[https://example.com]\n\nError: ValueError: URL protocol \"https\" is not allowed. Only http:// and https:// are supported.\n\nTraceback:\n_____ TestValidateUrlProtocol.test_allowed_protocols[https://example.com] ______\n\nself = <tests.test_ssrf.TestValidateUrlProtocol object at 0x112a58ad0>\nurl = 'https://example.com'\n\n    @pytest.mark.parametrize(\n        'url',\n        [\n            'http://example.com',\n            'https://example.com',\n            'HTTP://EXAMPLE.COM',\n            'HTTPS://EXAMPLE.COM',\n        ],\n    )\n    def test_allowed_protocols(self, url: str) -> None:\n>       scheme, is_https = validate_url_protocol(url)\n\ntests/test_ssrf.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'https://example.com'\n\n    def validate_url_protocol(url: str) -> tuple[str, bool]:\n        \"\"\"Validate that the URL uses an allowed protocol (http or https).\n    \n    ..."}
{"task_id": "ssrf-default-port-swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "extract_host_and_port swaps default ports — HTTPS gets port 80 and HTTP gets port 443, breaking URL resolution.", "vague_description": "URL downloads fail silently. HTTPS connections seem to be going to the wrong port.", "test_cmd": "python -m pytest tests/test_ssrf.py::TestExtractHostAndPort -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "default_port = 443 if is_https else 80", "mutated": "default_port = 80 if is_https else 443", "line_num": 169}, "source": "handcrafted", "category": "ssrf", "dev_report_description": "Test failure: tests/test_ssrf.py::TestExtractHostAndPort::test_basic_http_url\n\nError: AssertionError: assert 443 == 80\n\nTraceback:\n__________________ TestExtractHostAndPort.test_basic_http_url __________________\n\nself = <tests.test_ssrf.TestExtractHostAndPort object at 0x106c5fa50>\n\n    def test_basic_http_url(self) -> None:\n        hostname, path, port, is_https = extract_host_and_port('http://example.com/path')\n        assert hostname == 'example.com'\n        assert path == '/path'\n>       assert port == 80\nE       assert 443 == 80\n\ntests/test_ssrf.py: AssertionError"}
{"task_id": "ssrf-private-ip-allow-local-inverted", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "The allow_local guard is inverted — private IPs are blocked when allow_local=True and allowed when allow_local=False.", "vague_description": "Setting allow_local=True blocks local network requests, and removing it allows them. The flag seems to do the opposite of what it should.", "test_cmd": "python -m pytest tests/test_ssrf.py::TestValidateAndResolveUrl::test_private_ip_blocked_by_default -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "if not allow_local and is_private_ip(ip):", "mutated": "if allow_local and is_private_ip(ip):", "line_num": 241}, "source": "handcrafted", "category": "ssrf", "dev_report_description": "Test failure: tests/test_ssrf.py::TestValidateAndResolveUrl::test_private_ip_blocked_by_default\n\nError: Failed: DID NOT RAISE <class 'ValueError'>\n\nTraceback:\n_________ TestValidateAndResolveUrl.test_private_ip_blocked_by_default _________\n\nself = <tests.test_ssrf.TestValidateAndResolveUrl object at 0x10a063d10>\n\n    async def test_private_ip_blocked_by_default(self) -> None:\n        \"\"\"Test that private IPs are blocked by default.\"\"\"\n        with patch('pydantic_ai._ssrf.run_in_executor') as mock_executor:\n            mock_executor.return_value = [(2, 1, 6, '', ('192.168.1.1', 0))]\n>           with pytest.raises(ValueError, match='Access to private/internal IP address'):\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\ntests/test_ssrf.py: Failed"}
{"task_id": "tool-retry-isinstance-inverted", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "ToolRetryError._format_error_details inverts the isinstance check, passing string content to dict-processing code and crashing.", "vague_description": "Tool retry errors crash with a TypeError when the tool returns a simple string error message. Only structured errors work.", "test_cmd": "python -m pytest tests/test_exceptions.py::test_tool_retry_error_str_with_string_content -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/exceptions.py", "original": "if isinstance(tool_retry.content, str)", "mutated": "if not isinstance(tool_retry.content, str)", "line_num": 205}, "source": "handcrafted", "category": "exceptions", "dev_report_description": "Test failure: tests/test_exceptions.py::test_tool_retry_error_str_with_string_content\n\nError: TypeError: string indices must be integers, not 'str'\n\nTraceback:\n________________ test_tool_retry_error_str_with_string_content _________________\n\n    def test_tool_retry_error_str_with_string_content():\n        \"\"\"Test that ToolRetryError uses string content as message automatically.\"\"\"\n        part = RetryPromptPart(content='error from tool', tool_name='my_tool')\n>       error = ToolRetryError(part)\n\ntests/test_exceptions.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/exceptions.py: in __init__\n    else self._format_error_details(tool_retry.content, tool_retry.tool_name)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nerrors = 'error from tool', tool_name = 'my_tool'\n\n    @staticmethod\n    def _format_error_details(errors: list[pydantic_core.ErrorDetails], tool_name: str | None) -> str:\n        \"\"\"Format ErrorDetails as a human-readable message.\n    \n        We format manually rather than using ValidationError.from_exception_data because\n        some error types (value_error, assertion_error, etc.) require an 'error' key in ctx,\n        but when ErrorDetails are serialized, exception objects are stripped from ctx.\n        The 'msg' field already contains the human-readable message, so we use that directly.\n        \"\"\"\n        error_count = len(errors)\n    ..."}
{"task_id": "tool-retry-error-format", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "ToolRetryError pluralization is inverted — says 'errors' for 1 error and 'error' for multiple.", "vague_description": "Tool retry error messages have wrong grammar. A single validation error says 'errors' plural.", "test_cmd": "python -m pytest tests/test_exceptions.py::test_tool_retry_error_str_with_error_details -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/exceptions.py", "original": "f'{error_count} validation error{\"\" if error_count == 1 else \"s\"}{f\" for {tool_name!r}\" if tool_name else \"\"}'", "mutated": "f'{error_count} validation error{\"s\" if error_count == 1 else \"\"}{f\" for {tool_name!r}\" if tool_name else \"\"}'", "line_num": 221}, "source": "handcrafted", "category": "exceptions", "dev_report_description": "Test failure: tests/test_exceptions.py::test_tool_retry_error_str_with_error_details\n\nError: AssertionError: assert '1 validation...ut_value=123]' == '1 validation...ut_value=123]'\n\nTraceback:\n_________________ test_tool_retry_error_str_with_error_details _________________\n\n    def test_tool_retry_error_str_with_error_details():\n        \"\"\"Test that ToolRetryError formats ErrorDetails automatically.\"\"\"\n        validation_error = ValidationError.from_exception_data(\n            'Test', [{'type': 'string_type', 'loc': ('name',), 'input': 123}]\n        )\n        part = RetryPromptPart(content=validation_error.errors(include_url=False), tool_name='my_tool')\n        error = ToolRetryError(part)\n    \n>       assert str(error) == (\n            \"1 validation error for 'my_tool'\\nname\\n  Input should be a valid string [type=string_type, input_value=123]\"\n        )\nE       AssertionError: assert '1 validation...ut_value=123]' == '1 validation...ut_value=123]'\nE         \nE         - 1 validation error for 'my_tool'\nE         + 1 validation errors for 'my_tool'\nE         ?                   +\nE           name\nE             Input should be a valid string [type=string_type, input_value=123]\n\ntests/test_exceptions.py: AssertionError"}
{"task_id": "settings-merge-priority", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "merge_model_settings gives base settings priority over overrides instead of the other way around, ignoring per-run settings.", "vague_description": "Model settings passed to agent.run() are silently ignored. The agent always uses the settings from initialization.", "test_cmd": "python -m pytest tests/test_agent.py::test_model_settings_override -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/settings.py", "original": "return base | overrides", "mutated": "return overrides | base", "line_num": 192}, "source": "handcrafted", "category": "settings", "dev_report_description": "Test failure: tests/test_agent.py::test_model_settings_override\n\nError: AssertionError: assert '{\"temperature\":0.1}' == IsJson({'temperature': 0.5})\n\nTraceback:\n_________________________ test_model_settings_override _________________________\n\n    async def test_model_settings_override() -> None:\n        def return_settings(_: list[ModelMessage], info: AgentInfo) -> ModelResponse:\n            return ModelResponse(parts=[TextPart(to_json(info.model_settings).decode())])\n    \n        my_agent = Agent(FunctionModel(return_settings))\n        assert (await my_agent.run('Hello')).output == IsJson(None)\n        assert (await my_agent.run('Hello', model_settings={'temperature': 0.5})).output == IsJson({'temperature': 0.5})\n    \n        my_agent = Agent(FunctionModel(return_settings), model_settings={'temperature': 0.1})\n        assert (await my_agent.run('Hello')).output == IsJson({'temperature': 0.1})\n>       assert (await my_agent.run('Hello', model_settings={'temperature': 0.5})).output == IsJson({'temperature': 0.5})\nE       assert '{\"temperature\":0.1}' == IsJson({'temperature': 0.5})\nE        +  where '{\"temperature\":0.1}' = AgentRunResult(output='{\"temperature\":0.1}').output\nE        +  and   IsJson({'temperature': 0.5}) = IsJson({'temperature': 0.5})\n\ntests/test_agent.py: AssertionError"}
{"task_id": "ssrf-ipv4-mapped-ipv6-skip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "is_private_ip skips IPv4-mapped IPv6 unwrapping for actual mapped addresses, failing to detect private IPs in IPv6 form.", "vague_description": "Private IP addresses wrapped in IPv6 notation bypass the SSRF protection. For example ::ffff:192.168.1.1 is not blocked.", "test_cmd": "python -m pytest tests/test_ssrf.py::TestIsPrivateIp::test_ipv4_mapped_ipv6_private -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "if isinstance(ip, ipaddress.IPv6Address) and ip.ipv4_mapped:", "mutated": "if isinstance(ip, ipaddress.IPv6Address) and not ip.ipv4_mapped:", "line_num": 91}, "source": "handcrafted", "category": "ssrf", "dev_report_description": "Test failure: tests/test_ssrf.py::TestIsPrivateIp::test_ipv4_mapped_ipv6_private[::ffff:127.0.0.1]\n\nError: AssertionError: assert False is True\n\nTraceback:\n_______ TestIsPrivateIp.test_ipv4_mapped_ipv6_private[::ffff:127.0.0.1] ________\n\nself = <tests.test_ssrf.TestIsPrivateIp object at 0x109a79cd0>\nip = '::ffff:127.0.0.1'\n\n    @pytest.mark.parametrize(\n        'ip',\n        [\n            # IPv4-mapped IPv6 private addresses\n            '::ffff:127.0.0.1',\n            '::ffff:10.0.0.1',\n            '::ffff:192.168.1.1',\n            '::ffff:172.16.0.1',\n        ],\n    )\n    def test_ipv4_mapped_ipv6_private(self, ip: str) -> None:\n>       assert is_private_ip(ip) is True\nE       AssertionError: assert False is True\nE        +  where False = is_private_ip('::ffff:127.0.0.1')\n\ntests/test_ssrf.py: AssertionError"}
{"task_id": "ssrf-max-redirects-zero", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "_MAX_REDIRECTS is set to 0, preventing any HTTP redirects from being followed during safe downloads.", "vague_description": "URL downloads that involve redirects always fail. The downloader seems unable to follow even a single redirect.", "test_cmd": "python -m pytest tests/test_ssrf.py::TestSafeDownload::test_redirect_followed -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "_MAX_REDIRECTS = 10", "mutated": "_MAX_REDIRECTS = 0", "line_num": 50}, "source": "handcrafted", "category": "ssrf", "dev_report_description": "Test failure: tests/test_ssrf.py::TestSafeDownload::test_redirect_followed\n\nError: ValueError: Too many redirects (1). Maximum allowed: 0\n\nTraceback:\n___________________ TestSafeDownload.test_redirect_followed ____________________\n\nself = <tests.test_ssrf.TestSafeDownload object at 0x106a642d0>\n\n    async def test_redirect_followed(self) -> None:\n        \"\"\"Test that redirects are followed with validation.\"\"\"\n        redirect_response = AsyncMock()\n        redirect_response.is_redirect = True\n        redirect_response.headers = {'location': 'https://cdn.example.com/file.txt'}\n    \n        final_response = AsyncMock()\n        final_response.is_redirect = False\n        final_response.raise_for_status = lambda: None\n        final_response.content = b'final content'\n    \n        with (\n            patch('pydantic_ai._ssrf.run_in_executor') as mock_executor,\n            patch('pydantic_ai._ssrf.cached_async_http_client') as mock_client_fn,\n        ):\n            # First call for example.com, second for cdn.example.com\n            mock_executor.side_effect = [\n                [(2, 1, 6, '', ('93.184.215.14', 0))],\n                [(2, 1, 6, '', ('203.0.113.50', 0))],\n            ]\n    \n    ..."}
{"task_id": "d-builtin_tools-L74-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In builtin_tools.py:74, a condition was inverted: 'if cls is not AbstractBuiltinTool:' became 'if cls is AbstractBuiltinTool:'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_builtin_tools.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/builtin_tools.py", "original": "if cls is not AbstractBuiltinTool:", "mutated": "if cls is AbstractBuiltinTool:", "line_num": 74}, "source": "discovered", "category": "builtin_tools", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_builtin_tools.py::test_url_context_tool_backward_compatibility\n\nError: Failed: DID NOT WARN. No warnings of type (<class 'DeprecationWarning'>,) were emitted.\n\nTraceback:\n_________________ test_url_context_tool_backward_compatibility _________________\n\n    def test_url_context_tool_backward_compatibility():\n        \"\"\"Test that old payloads with 'url_context' kind can be deserialized.\"\"\"\n        adapter = TypeAdapter(AbstractBuiltinTool)\n    \n        # Test 1: Old payload with url_context should deserialize to UrlContextTool (which is deprecated)\n        old_payload = {'kind': 'url_context', 'max_uses': 5, 'enable_citations': True}\n>       with pytest.warns(DeprecationWarning, match='Use `WebFetchTool` instead.'):\nE       Failed: DID NOT WARN. No warnings of type (<class 'DeprecationWarning'>,) were emitted.\nE        Emitted warnings: [].\n\ntests/test_builtin_tools.py: Failed"}
{"task_id": "d-concurrency-L290-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In concurrency.py:290, a None check was inverted: 'if limit is None:' became 'if limit is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_concurrency.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/concurrency.py", "original": "if limit is None:", "mutated": "if limit is not None:", "line_num": 290}, "source": "discovered", "category": "concurrency", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_concurrency.py::TestAgentConcurrency::test_agent_concurrency_limit\n\nError: AssertionError: assert 5 <= 2\n\nTraceback:\n______________ TestAgentConcurrency.test_agent_concurrency_limit _______________\n\nself = <tests.test_concurrency.TestAgentConcurrency object at 0x107634e90>\n\n    async def test_agent_concurrency_limit(self):\n        \"\"\"Test that agent respects max_concurrency.\"\"\"\n        agent = Agent(TestModel(), max_concurrency=2)\n        running = 0\n        max_running = 0\n        lock = anyio.Lock()\n    \n        @agent.tool_plain\n        async def slow_tool() -> str:\n            nonlocal running, max_running\n            async with lock:\n                running += 1\n                max_running = max(max_running, running)\n            await anyio.sleep(0.1)\n            async with lock:\n                running -= 1\n            return 'done'\n    \n        results: list[Any] = []\n    \n        async def run_agent():\n    ..."}
{"task_id": "d-direct-L316-value_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In direct.py:316, a value was swapped: 'while True:' became 'while False:'.", "vague_description": "Two related values are mixed up. The system applies the wrong one of two options depending on context.", "test_cmd": "python -m pytest tests/test_direct.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/direct.py", "original": "while True:", "mutated": "while False:", "line_num": 316}, "source": "discovered", "category": "direct_api", "mutation_type": "value_swap", "dev_report_description": "Test failure: tests/test_direct.py::test_model_request_stream_sync\n\nError: AssertionError: assert [] == [PartStartEve...alls)')), ...]\n\nTraceback:\n________________________ test_model_request_stream_sync ________________________\n\n    def test_model_request_stream_sync():\n        with model_request_stream_sync('test', [ModelRequest.user_text_prompt('x')]) as stream:\n            chunks = list(stream)\n>           assert chunks == snapshot(\n                [\n                    PartStartEvent(index=0, part=TextPart(content='')),\n                    FinalResultEvent(tool_name=None, tool_call_id=None),\n                    PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='success ')),\n                    PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='(no ')),\n                    PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='tool ')),\n                    PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='calls)')),\n                    PartEndEvent(index=0, part=TextPart(content='success (no tool calls)')),\n                ]\n            )\nE           AssertionError: assert [] == [PartStartEve...alls)')), ...]\nE             \nE             Right contains 7 more items, first extra item: PartStartEvent(index=0, part=TextPart(content=''))\nE             Use -v to get more diff\n\ntests/test_direct.py: AssertionError"}
{"task_id": "d-json_schema-L128-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _json_schema.py:128, a None check was inverted: 'if (additional_properties := schema.get('additionalProperties')) is not None:' became 'if (additional_properties := schema.get('additionalProperties')) is None:'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_json_schema.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_json_schema.py", "original": "if (additional_properties := schema.get('additionalProperties')) is not None:", "mutated": "if (additional_properties := schema.get('additionalProperties')) is None:", "line_num": 128}, "source": "discovered", "category": "json_schema", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_json_schema.py::test_schema_defs_not_modified\n\nError: AttributeError: 'NoneType' object has no attribute 'get'\n\nTraceback:\n________________________ test_schema_defs_not_modified _________________________\n\n    def test_schema_defs_not_modified():\n        \"\"\"Test that the original schema $defs are not modified during transformation.\"\"\"\n    \n        # Create a concrete subclass for testing\n        class TestTransformer(JsonSchemaTransformer):\n            def transform(self, schema: dict[str, Any]) -> dict[str, Any]:\n                return schema\n    \n        # Create a schema with $defs that should not be modified\n        original_schema = {\n            'type': 'object',\n            'properties': {'value': {'$ref': '#/$defs/TestUnion'}},\n            '$defs': {\n                'TestUnion': {\n                    'anyOf': [\n                        {'type': 'string'},\n                        {'type': 'number'},\n                    ],\n                    'title': 'TestUnion',\n                }\n            },\n        }\n    \n    ..."}
{"task_id": "d-instrumented-L68-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In instrumented.py:68, a boolean operator was swapped: 'if instrument and not isinstance(model, InstrumentedModel):' became 'if instrument or not isinstance(model, InstrumentedModel):'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/test_direct.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/models/instrumented.py", "original": "if instrument and not isinstance(model, InstrumentedModel):", "mutated": "if instrument or not isinstance(model, InstrumentedModel):", "line_num": 68}, "source": "discovered", "category": "models", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_direct.py::test_prepare_model\n\nError: AssertionError: assert False\n\nTraceback:\n______________________________ test_prepare_model ______________________________\n\n    def test_prepare_model():\n        with set_instrument_default(False):\n            model = _prepare_model('test', None)\n>           assert isinstance(model, TestModel)\nE           AssertionError: assert False\nE            +  where False = isinstance(InstrumentedModel(wrapped=TestModel(call_tools='all', custom_output_text=None, custom_output_args=None, seed=0, last_m...ettings=InstrumentationSettings(event_mode='attributes', include_binary_content=True, include_content=True, version=2)), TestModel)\n\ntests/test_direct.py: AssertionError"}
{"task_id": "d-parts_manager-L211-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _parts_manager.py:211, a None check was inverted: 'if vendor_part_id is None:' became 'if vendor_part_id is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_parts_manager.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_parts_manager.py", "original": "if vendor_part_id is None:", "mutated": "if vendor_part_id is not None:", "line_num": 211}, "source": "discovered", "category": "parts_manager", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_parts_manager.py::test_handle_thinking_delta_no_vendor_id_with_existing_thinking_part\n\nError: AssertionError: assert False\n\nTraceback:\n_____ test_handle_thinking_delta_no_vendor_id_with_existing_thinking_part ______\n\n    def test_handle_thinking_delta_no_vendor_id_with_existing_thinking_part():\n        manager = ModelResponsePartsManager()\n    \n        # Add a thinking part first\n        event = next(manager.handle_thinking_delta(vendor_part_id='first', content='initial thought', signature=None))\n        assert isinstance(event, PartStartEvent)\n        assert event.index == 0\n    \n        # Now add another thinking delta with no vendor_part_id - should update the latest thinking part\n        event = next(manager.handle_thinking_delta(vendor_part_id=None, content=' more', signature=None))\n>       assert isinstance(event, PartDeltaEvent)\nE       AssertionError: assert False\nE        +  where False = isinstance(PartStartEvent(index=1, part=ThinkingPart(content=' more')), PartDeltaEvent)\n\ntests/test_parts_manager.py: AssertionError"}
{"task_id": "d-retries-L369-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In retries.py:369, a condition was inverted: 'assert isinstance(retry_time, datetime)' became 'assert not isinstance(retry_time, datetime)'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/test_tenacity.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/retries.py", "original": "assert isinstance(retry_time, datetime)", "mutated": "assert not isinstance(retry_time, datetime)", "line_num": 369}, "source": "discovered", "category": "retries", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_tenacity.py::TestWaitRetryAfter::test_retry_after_http_date_format\n\nError: TypeError: '<=' not supported between instances of 'int' and 'Mock'\n\nTraceback:\n_____________ TestWaitRetryAfter.test_retry_after_http_date_format _____________\n\nself = <tests.test_tenacity.TestWaitRetryAfter object at 0x10a4d0810>\n\n    def test_retry_after_http_date_format(self):\n        \"\"\"Test parsing Retry-After header in HTTP date format.\"\"\"\n        fallback = Mock()\n        wait_func = wait_retry_after(fallback_strategy=fallback, max_wait=300)\n    \n        # Create a future date (30 seconds from now)\n        future_time = datetime.now(timezone.utc).timestamp() + 30\n        http_date = formatdate(future_time, usegmt=True)\n    \n        # Create HTTP status error with Retry-After in HTTP date format\n        request = httpx.Request('GET', 'https://example.com')\n        response = Mock(spec=httpx.Response)\n        response.headers = {'retry-after': http_date}\n        http_error = httpx.HTTPStatusError('Rate limited', request=request, response=response)\n    \n        retry_state = Mock(spec=RetryCallState)\n        retry_state.outcome = Mock()\n        retry_state.outcome.failed = True\n        retry_state.outcome.exception.return_value = http_error\n    \n        result = wait_func(retry_state)\n    ..."}
{"task_id": "d-ssrf-L201-comparison_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _ssrf.py:201, the comparison operator was changed: 'if resolved.port != default_port:' became 'if resolved.port == default_port:'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_ssrf.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "if resolved.port != default_port:", "mutated": "if resolved.port == default_port:", "line_num": 201}, "source": "discovered", "category": "ssrf", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: tests/test_ssrf.py::TestBuildUrlWithIp::test_http_default_port\n\nError: AssertionError: assert 'http://203.0.113.50:80/path' == 'http://203.0.113.50/path'\n\nTraceback:\n__________________ TestBuildUrlWithIp.test_http_default_port ___________________\n\nself = <tests.test_ssrf.TestBuildUrlWithIp object at 0x104f49c10>\n\n    def test_http_default_port(self) -> None:\n        resolved = ResolvedUrl(\n            resolved_ip='203.0.113.50', hostname='example.com', port=80, is_https=False, path='/path'\n        )\n        url = build_url_with_ip(resolved)\n>       assert url == 'http://203.0.113.50/path'\nE       AssertionError: assert 'http://203.0.113.50:80/path' == 'http://203.0.113.50/path'\nE         \nE         - http://203.0.113.50/path\nE         + http://203.0.113.50:80/path\nE         ?                    +++\n\ntests/test_ssrf.py: AssertionError"}
{"task_id": "d-thinking_part-L22-arithmetic_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _thinking_part.py:22, an arithmetic operator was changed: 'think_content, content = content[:end_index], content[end_index + len(end_tag) :]' became 'think_content, content = content[:end_index], content[end_index - len(end_tag) :]'. This produces wrong numeric results.", "vague_description": "Computed values are consistently wrong. The computation seems to use subtraction where it should add, or vice versa.", "test_cmd": "python -m pytest tests/test_thinking_part.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_thinking_part.py", "original": "think_content, content = content[:end_index], content[end_index + len(end_tag) :]", "mutated": "think_content, content = content[:end_index], content[end_index - len(end_tag) :]", "line_num": 22}, "source": "discovered", "category": "thinking", "mutation_type": "arithmetic_swap", "dev_report_description": "Test failure: tests/test_thinking_part.py::test_split_content[thinking_tags1-foo bar<think>thinking</think>-parts1]\n\nError: AssertionError: assert [TextPart(con...ing</think>')] == [TextPart(con...t='thinking')]\n\nTraceback:\n___ test_split_content[thinking_tags1-foo bar<think>thinking</think>-parts1] ___\n\nthinking_tags = ('<think>', '</think>')\ncontent = 'foo bar<think>thinking</think>'\nparts = [TextPart(content='foo bar'), ThinkingPart(content='thinking')]\n\n    @pytest.mark.parametrize(\n        'thinking_tags, content, parts',\n        [\n            # default <think>…</think> cases\n            (\n                ('<think>', '</think>'),\n                'foo bar',\n                [TextPart(content='foo bar')],\n            ),\n            (\n                ('<think>', '</think>'),\n                'foo bar<think>thinking</think>',\n                [TextPart(content='foo bar'), ThinkingPart(content='thinking')],\n            ),\n            (\n                ('<think>', '</think>'),\n                'foo bar<think>thinking</think>baz',\n                [\n                    TextPart(content='foo bar'),\n    ..."}
{"task_id": "d-tools-L251-value_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In tools.py:251, a value was swapped: 'json_schema['additionalProperties'] = False' became 'json_schema['additionalProperties'] = True'.", "vague_description": "An assignment or return value is wrong — it returns the first argument where it should return the second, or similar.", "test_cmd": "python -m pytest tests/test_tools.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/tools.py", "original": "json_schema['additionalProperties'] = False", "mutated": "json_schema['additionalProperties'] = True", "line_num": 251}, "source": "discovered", "category": "tools", "mutation_type": "value_swap", "dev_report_description": "Test failure: tests/test_tools.py::test_docstring_google[google]\n\nError: AssertionError: assert {'description...cstring', ...} == {'description...cstring', ...}\n\nTraceback:\n________________________ test_docstring_google[google] _________________________\n\ndocstring_format = 'google'\n\n    @pytest.mark.parametrize('docstring_format', ['google', 'auto'])\n    def test_docstring_google(docstring_format: Literal['google', 'auto']):\n        agent = Agent(FunctionModel(get_json_schema))\n        agent.tool_plain(docstring_format=docstring_format)(google_style_docstring)\n    \n        result = agent.run_sync('Hello')\n        json_schema = json.loads(result.output)\n>       assert json_schema == snapshot(\n            {\n                'name': 'google_style_docstring',\n                'description': 'Do foobar stuff, a lot.',\n                'parameters_json_schema': {\n                    'properties': {\n                        'foo': {'description': 'The foo thing.', 'type': 'integer'},\n                        'bar': {'description': 'The bar thing.', 'type': 'string'},\n                    },\n                    'required': ['foo', 'bar'],\n                    'type': 'object',\n                    'additionalProperties': False,\n                },\n                'outer_typed_dict_key': None,\n    ..."}
{"task_id": "d-app-L89-constant_mutation", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In app.py:89, a constant was changed: 'url_hash = hashlib.sha256(html_source.encode()).hexdigest()[:16]' became 'url_hash = hashlib.sha256(html_source.encode()).hexdigest()[:17]'. This shifts a boundary or default.", "vague_description": "A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.", "test_cmd": "python -m pytest tests/test_ui_web.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/ui/_web/app.py", "original": "url_hash = hashlib.sha256(html_source.encode()).hexdigest()[:16]", "mutated": "url_hash = hashlib.sha256(html_source.encode()).hexdigest()[:17]", "line_num": 89}, "source": "discovered", "category": "ui", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: tests/test_ui_web.py::test_get_ui_html_custom_url_caching\n\nError: AssertionError: assert False\n\nTraceback:\n_____________________ test_get_ui_html_custom_url_caching ______________________\n\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x110fb9c50>\ntmp_path = PosixPath('/private/var/folders/vz/02yk36wx3dz6dw661rcdxcxr0000gn/T/pytest-of-akshankrithick/pytest-193/test_get_ui_html_custom_url_ca0')\n\n    @pytest.mark.anyio\n    async def test_get_ui_html_custom_url_caching(monkeypatch: pytest.MonkeyPatch, tmp_path: Path):\n        \"\"\"Test that custom URLs are cached to filesystem and not re-fetched.\"\"\"\n        monkeypatch.setattr(app_module, '_get_cache_dir', lambda: tmp_path)\n    \n        test_content = b'<html>Cached Custom UI</html>'\n        fetch_count = 0\n    \n        class MockResponse:\n            content = test_content\n    \n            def raise_for_status(self) -> None:\n                pass\n    \n        class MockAsyncClient:\n            async def __aenter__(self) -> MockAsyncClient:\n                return self\n    \n            async def __aexit__(self, *args: Any) -> None:\n                pass\n    ..."}
{"task_id": "d-usage-L240-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In usage.py:240, a condition was inverted: 'if isinstance(value, (int, float)):' became 'if not isinstance(value, (int, float)):'. The branch now triggers in the opposite case.", "vague_description": "A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.", "test_cmd": "python -m pytest tests/test_usage_limits.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/usage.py", "original": "if isinstance(value, (int, float)):", "mutated": "if not isinstance(value, (int, float)):", "line_num": 240}, "source": "discovered", "category": "usage", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_usage_limits.py::test_add_usages\n\nError: AssertionError: assert RunUsage(inpu... tool_calls=6) == RunUsage(inpu... tool_calls=6)\n\nTraceback:\n_______________________________ test_add_usages ________________________________\n\n    def test_add_usages():\n        usage = RunUsage(\n            requests=2,\n            input_tokens=10,\n            output_tokens=20,\n            cache_read_tokens=30,\n            cache_write_tokens=40,\n            input_audio_tokens=50,\n            cache_audio_read_tokens=60,\n            tool_calls=3,\n            details={\n                'custom1': 10,\n                'custom2': 20,\n            },\n        )\n>       assert usage + usage == snapshot(\n            RunUsage(\n                requests=4,\n                input_tokens=20,\n                output_tokens=40,\n                cache_write_tokens=80,\n                cache_read_tokens=60,\n                input_audio_tokens=100,\n    ..."}
{"task_id": "d-utils-L243-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _utils.py:243, a None check was inverted: 'if group_start_time is None:' became 'if group_start_time is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_utils.py", "original": "if group_start_time is None:", "mutated": "if group_start_time is not None:", "line_num": 243}, "source": "discovered", "category": "utils", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_utils.py::test_group_by_temporal[0.04-expected3]\n\nError: AssertionError: assert [[1, 2, 3]] == [[1, 2], [3]]\n\nTraceback:\n____________________ test_group_by_temporal[0.04-expected3] ____________________\n\ninterval = 0.04, expected = [[1, 2], [3]]\n\n    @pytest.mark.parametrize(\n        'interval,expected',\n        [\n            (None, snapshot([[1], [2], [3]])),\n            (0, snapshot([[1], [2], [3]])),\n            (0.02, snapshot([[1], [2], [3]])),\n            (0.04, snapshot([[1, 2], [3]])),\n            (0.1, snapshot([[1, 2, 3]])),\n        ],\n    )\n    async def test_group_by_temporal(interval: float | None, expected: list[list[int]]):\n        async def yield_groups() -> AsyncIterator[int]:\n            yield 1\n            await asyncio.sleep(0.02)\n            yield 2\n            await asyncio.sleep(0.02)\n            yield 3\n            await asyncio.sleep(0.02)\n    \n        async with group_by_temporal(yield_groups(), soft_max_interval=interval) as groups_iter:\n            groups: list[list[int]] = [g async for g in groups_iter]\n    ..."}
{"task_id": "d-builtin_tools-L469-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In builtin_tools.py:469, a condition was inverted: 'if isinstance(tool_data, dict):' became 'if not isinstance(tool_data, dict):'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_builtin_tools.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/builtin_tools.py", "original": "if isinstance(tool_data, dict):", "mutated": "if not isinstance(tool_data, dict):", "line_num": 469}, "source": "discovered", "category": "builtin_tools", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_builtin_tools.py::test_url_context_tool_backward_compatibility\n\nError: AttributeError: 'dict' object has no attribute 'kind'\n\nTraceback:\n_________________ test_url_context_tool_backward_compatibility _________________\n\n    def test_url_context_tool_backward_compatibility():\n        \"\"\"Test that old payloads with 'url_context' kind can be deserialized.\"\"\"\n        adapter = TypeAdapter(AbstractBuiltinTool)\n    \n        # Test 1: Old payload with url_context should deserialize to UrlContextTool (which is deprecated)\n        old_payload = {'kind': 'url_context', 'max_uses': 5, 'enable_citations': True}\n        with pytest.warns(DeprecationWarning, match='Use `WebFetchTool` instead.'):\n>           result = adapter.validate_python(old_payload)\n\ntests/test_builtin_tools.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../anaconda3/envs/vvenv/lib/python3.11/site-packages/pydantic/type_adapter.py: in validate_python\n    return self.validator.validate_python(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntool_data = {'enable_citations': True, 'kind': 'url_context', 'max_uses': 5}\n\n    def _tool_discriminator(tool_data: dict[str, Any] | AbstractBuiltinTool) -> str:\n        if not isinstance(tool_data, dict):\n            return tool_data.get('kind', AbstractBuiltinTool.kind)\n        else:\n>           return tool_data.kind\nE           AttributeError: 'dict' object has no attribute 'kind'\n    ..."}
{"task_id": "d-concurrency-L130-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In concurrency.py:130, a condition was inverted: 'if isinstance(limit, int):' became 'if not isinstance(limit, int):'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_concurrency.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/concurrency.py", "original": "if isinstance(limit, int):", "mutated": "if not isinstance(limit, int):", "line_num": 130}, "source": "discovered", "category": "concurrency", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_concurrency.py::TestConcurrencyLimiter::test_from_int_limit\n\nError: AttributeError: 'int' object has no attribute 'max_running'\n\nTraceback:\n__________________ TestConcurrencyLimiter.test_from_int_limit __________________\n\nself = <tests.test_concurrency.TestConcurrencyLimiter object at 0x10556b250>\n\n    async def test_from_int_limit(self):\n        \"\"\"Test creating from simple int.\"\"\"\n>       limiter = ConcurrencyLimiter.from_limit(5)\n\ntests/test_concurrency.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'pydantic_ai.concurrency.ConcurrencyLimiter'>, limit = 5\n\n    @classmethod\n    def from_limit(\n        cls,\n        limit: int | ConcurrencyLimit,\n        *,\n        name: str | None = None,\n        tracer: Tracer | None = None,\n    ) -> Self:\n        \"\"\"Create a ConcurrencyLimiter from a ConcurrencyLimit configuration.\n    \n        Args:\n            limit: Either an int for simple limiting or a ConcurrencyLimit for full config.\n    ..."}
{"task_id": "d-direct-L343-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In direct.py:343, a None check was inverted: 'if self._stream_response is None:' became 'if self._stream_response is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_direct.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/direct.py", "original": "if self._stream_response is None:", "mutated": "if self._stream_response is not None:", "line_num": 343}, "source": "discovered", "category": "direct_api", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_direct.py::test_model_request_stream_sync_timeout\n\nError: AttributeError: 'NoneType' object has no attribute 'get'\n\nTraceback:\n____________________ test_model_request_stream_sync_timeout ____________________\n\n    def test_model_request_stream_sync_timeout():\n        \"\"\"Test timeout when stream fails to initialize.\"\"\"\n        async_stream_mock = AsyncMock()\n    \n        async def slow_init():\n            await asyncio.sleep(0.1)\n    \n        async_stream_mock.__aenter__ = AsyncMock(side_effect=slow_init)\n    \n        stream_sync = StreamedResponseSync(_async_stream_cm=async_stream_mock)\n    \n        with patch('pydantic_ai.direct.STREAM_INITIALIZATION_TIMEOUT', 0.01):\n            with stream_sync:\n                with pytest.raises(RuntimeError, match='Stream failed to initialize within timeout'):\n>                   stream_sync.get()\n\ntests/test_direct.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = StreamedResponseSync(context_entered=True)\n\n    def get(self) -> messages.ModelResponse:\n        \"\"\"Build a ModelResponse from the data received from the stream so far.\"\"\"\n    ..."}
{"task_id": "d-parts_manager-L223-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _parts_manager.py:223, a None check was inverted: 'if existing_thinking_part_and_index is None:' became 'if existing_thinking_part_and_index is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_parts_manager.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_parts_manager.py", "original": "if existing_thinking_part_and_index is None:", "mutated": "if existing_thinking_part_and_index is not None:", "line_num": 223}, "source": "discovered", "category": "parts_manager", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_parts_manager.py::test_handle_thinking_delta_no_vendor_id_with_existing_thinking_part\n\nError: TypeError: cannot unpack non-iterable NoneType object\n\nTraceback:\n_____ test_handle_thinking_delta_no_vendor_id_with_existing_thinking_part ______\n\n    def test_handle_thinking_delta_no_vendor_id_with_existing_thinking_part():\n        manager = ModelResponsePartsManager()\n    \n        # Add a thinking part first\n>       event = next(manager.handle_thinking_delta(vendor_part_id='first', content='initial thought', signature=None))\n\ntests/test_parts_manager.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = ModelResponsePartsManager(_parts=[], _vendor_id_to_part_index={})\n\n    def handle_thinking_delta(\n        self,\n        *,\n        vendor_part_id: Hashable | None,\n        content: str | None = None,\n        id: str | None = None,\n        signature: str | None = None,\n        provider_name: str | None = None,\n        provider_details: ProviderDetailsDelta = None,\n    ) -> Iterator[ModelResponseStreamEvent]:\n        \"\"\"Handle incoming thinking content, creating or updating a ThinkingPart in the manager as appropriate.\n    \n    ..."}
{"task_id": "d-retries-L354-constant_mutation", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In retries.py:354, a constant was changed: 'fallback_strategy = wait_exponential(multiplier=1, max=60)' became 'fallback_strategy = wait_exponential(multiplier=0, max=60)'. This shifts a boundary or default.", "vague_description": "A hardcoded value is slightly off. Behavior at specific boundaries doesn't match expectations — like an off-by-one in a limit.", "test_cmd": "python -m pytest tests/test_tenacity.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/retries.py", "original": "fallback_strategy = wait_exponential(multiplier=1, max=60)", "mutated": "fallback_strategy = wait_exponential(multiplier=0, max=60)", "line_num": 354}, "source": "discovered", "category": "retries", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: tests/test_tenacity.py::TestWaitRetryAfter::test_default_fallback_strategy\n\nError: AssertionError: assert 0 == 1\n\nTraceback:\n______________ TestWaitRetryAfter.test_default_fallback_strategy _______________\n\nself = <tests.test_tenacity.TestWaitRetryAfter object at 0x10968d050>\n\n    def test_default_fallback_strategy(self):\n        \"\"\"Test that default fallback strategy is used when none is provided.\"\"\"\n        wait_func = wait_retry_after(max_wait=300)\n    \n        # Create a retry state with no exception to trigger fallback\n        retry_state = Mock(spec=RetryCallState)\n        retry_state.outcome = None\n        retry_state.attempt_number = 1\n    \n        # Should use default exponential backoff, exact value depends on retry state\n        result = wait_func(retry_state)\n    \n>       assert result == 1  # first backoff\nE       assert 0 == 1\n\ntests/test_tenacity.py: AssertionError"}
{"task_id": "d-ssrf-L166-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _ssrf.py:166, a condition was inverted: 'if not hostname:' became 'if hostname:'. The branch now triggers in the opposite case.", "vague_description": "A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.", "test_cmd": "python -m pytest tests/test_ssrf.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "if not hostname:", "mutated": "if hostname:", "line_num": 166}, "source": "discovered", "category": "ssrf", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_ssrf.py::TestExtractHostAndPort::test_basic_http_url\n\nError: ValueError: Invalid URL: no hostname found in \"http://example.com/path\"\n\nTraceback:\n__________________ TestExtractHostAndPort.test_basic_http_url __________________\n\nself = <tests.test_ssrf.TestExtractHostAndPort object at 0x107a4a790>\n\n    def test_basic_http_url(self) -> None:\n>       hostname, path, port, is_https = extract_host_and_port('http://example.com/path')\n\ntests/test_ssrf.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://example.com/path'\n\n    def extract_host_and_port(url: str) -> tuple[str, str, int, bool]:\n        \"\"\"Extract hostname, path, port, and protocol info from a URL.\n    \n        Returns:\n            Tuple of (hostname, path_with_query, port, is_https)\n    \n        Raises:\n            ValueError: If the URL is malformed or uses an unsupported protocol.\n        \"\"\"\n        # Validate protocol first, before trying to extract hostname\n        _, is_https = validate_url_protocol(url)\n    \n        parsed = urlparse(url)\n    ..."}
{"task_id": "d-thinking_part-L17-arithmetic_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _thinking_part.py:17, an arithmetic operator was changed: 'before_think, content = content[:start_index], content[start_index + len(start_tag) :]' became 'before_think, content = content[:start_index], content[start_index - len(start_tag) :]'. This produces wrong numeric results.", "vague_description": "An accumulator or counter is going in the wrong direction. Values that should increase are decreasing, or the formula uses the wrong operator.", "test_cmd": "python -m pytest tests/test_thinking_part.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_thinking_part.py", "original": "before_think, content = content[:start_index], content[start_index + len(start_tag) :]", "mutated": "before_think, content = content[:start_index], content[start_index - len(start_tag) :]", "line_num": 17}, "source": "discovered", "category": "thinking", "mutation_type": "arithmetic_swap", "dev_report_description": "Test failure: tests/test_thinking_part.py::test_split_content[thinking_tags1-foo bar<think>thinking</think>-parts1]\n\nError: AssertionError: assert [TextPart(con...nk>thinking')] == [TextPart(con...t='thinking')]\n\nTraceback:\n___ test_split_content[thinking_tags1-foo bar<think>thinking</think>-parts1] ___\n\nthinking_tags = ('<think>', '</think>')\ncontent = 'foo bar<think>thinking</think>'\nparts = [TextPart(content='foo bar'), ThinkingPart(content='thinking')]\n\n    @pytest.mark.parametrize(\n        'thinking_tags, content, parts',\n        [\n            # default <think>…</think> cases\n            (\n                ('<think>', '</think>'),\n                'foo bar',\n                [TextPart(content='foo bar')],\n            ),\n            (\n                ('<think>', '</think>'),\n                'foo bar<think>thinking</think>',\n                [TextPart(content='foo bar'), ThinkingPart(content='thinking')],\n            ),\n            (\n                ('<think>', '</think>'),\n                'foo bar<think>thinking</think>baz',\n                [\n                    TextPart(content='foo bar'),\n    ..."}
{"task_id": "d-tools-L377-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In tools.py:377, a boolean operator was swapped: 'self.name = name or function.__name__' became 'self.name = name and function.__name__'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/test_tools.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/tools.py", "original": "self.name = name or function.__name__", "mutated": "self.name = name and function.__name__", "line_num": 377}, "source": "discovered", "category": "tools", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_tools.py::test_docstring_google[google]\n\nError: AssertionError: assert {'description...e': None, ...} == {'description...cstring', ...}\n\nTraceback:\n________________________ test_docstring_google[google] _________________________\n\ndocstring_format = 'google'\n\n    @pytest.mark.parametrize('docstring_format', ['google', 'auto'])\n    def test_docstring_google(docstring_format: Literal['google', 'auto']):\n        agent = Agent(FunctionModel(get_json_schema))\n        agent.tool_plain(docstring_format=docstring_format)(google_style_docstring)\n    \n        result = agent.run_sync('Hello')\n        json_schema = json.loads(result.output)\n>       assert json_schema == snapshot(\n            {\n                'name': 'google_style_docstring',\n                'description': 'Do foobar stuff, a lot.',\n                'parameters_json_schema': {\n                    'properties': {\n                        'foo': {'description': 'The foo thing.', 'type': 'integer'},\n                        'bar': {'description': 'The bar thing.', 'type': 'string'},\n                    },\n                    'required': ['foo', 'bar'],\n                    'type': 'object',\n                    'additionalProperties': False,\n                },\n                'outer_typed_dict_key': None,\n    ..."}
{"task_id": "d-app-L80-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In app.py:80, a condition was inverted: 'if isinstance(html_source, Path):' became 'if not isinstance(html_source, Path):'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_ui_web.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/ui/_web/app.py", "original": "if isinstance(html_source, Path):", "mutated": "if not isinstance(html_source, Path):", "line_num": 80}, "source": "discovered", "category": "ui", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_ui_web.py::test_get_ui_html_custom_url\n\nError: AttributeError: 'str' object has no attribute 'expanduser'\n\nTraceback:\n_________________________ test_get_ui_html_custom_url __________________________\n\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x109bd8cd0>\ntmp_path = PosixPath('/private/var/folders/vz/02yk36wx3dz6dw661rcdxcxr0000gn/T/pytest-of-akshankrithick/pytest-194/test_get_ui_html_custom_url0')\n\n    @pytest.mark.anyio\n    async def test_get_ui_html_custom_url(monkeypatch: pytest.MonkeyPatch, tmp_path: Path):\n        \"\"\"Test that _get_ui_html fetches from custom URL when provided.\"\"\"\n        monkeypatch.setattr(app_module, '_get_cache_dir', lambda: tmp_path)\n    \n        test_content = b'<html>Custom CDN UI</html>'\n        captured_url: list[str] = []\n    \n        class MockResponse:\n            content = test_content\n    \n            def raise_for_status(self) -> None:\n                pass\n    \n        class MockAsyncClient:\n            async def __aenter__(self) -> MockAsyncClient:\n                return self\n    \n            async def __aexit__(self, *args: Any) -> None:\n                pass\n    ..."}
{"task_id": "d-usage-L373-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In usage.py:373, a None check was inverted: 'if self.input_tokens_limit is not None and input_tokens > self.input_tokens_limit:' became 'if self.input_tokens_limit is None and input_tokens > self.input_tokens_limit:'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_usage_limits.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/usage.py", "original": "if self.input_tokens_limit is not None and input_tokens > self.input_tokens_limit:", "mutated": "if self.input_tokens_limit is None and input_tokens > self.input_tokens_limit:", "line_num": 373}, "source": "discovered", "category": "usage", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_usage_limits.py::test_response_token_limit\n\nError: TypeError: '>' not supported between instances of 'int' and 'NoneType'\n\nTraceback:\n__________________________ test_response_token_limit ___________________________\n\n    def test_response_token_limit() -> None:\n        test_agent = Agent(\n            TestModel(custom_output_text='Unfortunately, this response exceeds the response tokens limit by a few!')\n        )\n    \n        with pytest.raises(UsageLimitExceeded, match=re.escape('Exceeded the output_tokens_limit of 5 (output_tokens=11)')):\n>           test_agent.run_sync('Hello', usage_limits=UsageLimits(output_tokens_limit=5))\n\ntests/test_usage_limits.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/agent/abstract.py: in run_sync\n    return _utils.get_event_loop().run_until_complete(\n../../anaconda3/envs/vvenv/lib/python3.11/asyncio/base_events.py: in run_until_complete\n    return future.result()\npydantic_ai_slim/pydantic_ai/agent/abstract.py: in run\n    async with self.iter(\n../../anaconda3/envs/vvenv/lib/python3.11/contextlib.py: in __aexit__\n    await self.gen.athrow(typ, value, traceback)\npydantic_ai_slim/pydantic_ai/agent/__init__.py: in iter\n    async with (\n../../anaconda3/envs/vvenv/lib/python3.11/contextlib.py: in __aexit__\n    await self.gen.athrow(typ, value, traceback)\npydantic_graph/pydantic_graph/beta/graph.py: in iter\n    ..."}
{"task_id": "d-utils-L212-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _utils.py:212, a None check was inverted: 'if group_start_time is None:' became 'if group_start_time is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_utils.py", "original": "if group_start_time is None:", "mutated": "if group_start_time is not None:", "line_num": 212}, "source": "discovered", "category": "utils", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_utils.py::test_group_by_temporal[0-expected1]\n\nError: TypeError: unsupported operand type(s) for -: 'float' and 'NoneType'\n\nTraceback:\n_____________________ test_group_by_temporal[0-expected1] ______________________\n\ninterval = 0, expected = [[1], [2], [3]]\n\n    @pytest.mark.parametrize(\n        'interval,expected',\n        [\n            (None, snapshot([[1], [2], [3]])),\n            (0, snapshot([[1], [2], [3]])),\n            (0.02, snapshot([[1], [2], [3]])),\n            (0.04, snapshot([[1, 2], [3]])),\n            (0.1, snapshot([[1, 2, 3]])),\n        ],\n    )\n    async def test_group_by_temporal(interval: float | None, expected: list[list[int]]):\n        async def yield_groups() -> AsyncIterator[int]:\n            yield 1\n            await asyncio.sleep(0.02)\n            yield 2\n            await asyncio.sleep(0.02)\n            yield 3\n            await asyncio.sleep(0.02)\n    \n        async with group_by_temporal(yield_groups(), soft_max_interval=interval) as groups_iter:\n>           groups: list[list[int]] = [g async for g in groups_iter]\n    ..."}
{"task_id": "d-concurrency-L222-constant_mutation", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In concurrency.py:222, a constant was changed: 'self._waiting_count -= 1' became 'self._waiting_count -= 0'. This shifts a boundary or default.", "vague_description": "A hardcoded value is slightly off. Behavior at specific boundaries doesn't match expectations — like an off-by-one in a limit.", "test_cmd": "python -m pytest tests/test_concurrency.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/concurrency.py", "original": "self._waiting_count -= 1", "mutated": "self._waiting_count -= 0", "line_num": 222}, "source": "discovered", "category": "concurrency", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: tests/test_concurrency.py::TestConcurrencyLimiter::test_waiting_count_tracking\n\nError: AssertionError: assert 3 == 0\n\nTraceback:\n______________ TestConcurrencyLimiter.test_waiting_count_tracking ______________\n\nself = <tests.test_concurrency.TestConcurrencyLimiter object at 0x106369a90>\n\n    async def test_waiting_count_tracking(self):\n        \"\"\"Test that waiting_count is accurately tracked.\"\"\"\n        limiter = ConcurrencyLimiter(max_running=1)\n        started = anyio.Event()\n        release = anyio.Event()\n    \n        async def holder():\n            async with get_concurrency_context(limiter, 'test'):\n                started.set()\n                await release.wait()\n    \n        async def waiter():\n            async with get_concurrency_context(limiter, 'test'):\n                pass\n    \n        async with anyio.create_task_group() as tg:\n            tg.start_soon(holder)\n            await started.wait()\n    \n            # Now limiter is held, check waiting count as we add waiters\n            assert limiter.waiting_count == 0\n    ..."}
{"task_id": "d-direct-L320-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In direct.py:320, a condition was inverted: 'elif isinstance(item, Exception):' became 'elif not isinstance(item, Exception):'. The branch now triggers in the opposite case.", "vague_description": "A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.", "test_cmd": "python -m pytest tests/test_direct.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/direct.py", "original": "elif isinstance(item, Exception):", "mutated": "elif not isinstance(item, Exception):", "line_num": 320}, "source": "discovered", "category": "direct_api", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_direct.py::test_model_request_stream_sync\n\nError: TypeError: exceptions must derive from BaseException\n\nTraceback:\n________________________ test_model_request_stream_sync ________________________\n\n    def test_model_request_stream_sync():\n        with model_request_stream_sync('test', [ModelRequest.user_text_prompt('x')]) as stream:\n>           chunks = list(stream)\n\ntests/test_direct.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = TestStreamedResponse(model_request_parameters=ModelRequestParameters(function_tools=[], builtin_tools=[], output_tools...test', _provider_url=None, _timestamp=datetime.datetime(2026, 2, 12, 14, 54, 21, 559403, tzinfo=datetime.timezone.utc))\n\n    def __iter__(self) -> Iterator[messages.ModelResponseStreamEvent]:\n        \"\"\"Stream the response as an iterable of [`ModelResponseStreamEvent`][pydantic_ai.messages.ModelResponseStreamEvent]s.\"\"\"\n        self._check_context_manager_usage()\n    \n        while True:\n            item = self._queue.get()\n            if item is None:  # End of stream\n                break\n            elif not isinstance(item, Exception):\n>               raise item\nE               TypeError: exceptions must derive from BaseException\n\npydantic_ai_slim/pydantic_ai/direct.py: TypeError"}
{"task_id": "d-exceptions-L147-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In exceptions.py:147, a None check was inverted: 'if body is None:' became 'if body is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_exceptions.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/exceptions.py", "original": "if body is None:", "mutated": "if body is not None:", "line_num": 147}, "source": "discovered", "category": "exceptions", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_exceptions.py::test_exceptions_hashable[UnexpectedModelBehavior]\n\nError: TypeError: the JSON object must be str, bytes or bytearray, not NoneType\n\nTraceback:\n______________ test_exceptions_hashable[UnexpectedModelBehavior] _______________\n\nexc_factory = <function <lambda> at 0x10fd02f20>\n\n    @pytest.mark.parametrize(\n        'exc_factory',\n        [\n            lambda: ModelRetry('test'),\n            lambda: CallDeferred(),\n            lambda: ApprovalRequired(),\n            lambda: UserError('test'),\n            lambda: AgentRunError('test'),\n            lambda: UnexpectedModelBehavior('test'),\n            lambda: UsageLimitExceeded('test'),\n            lambda: ModelAPIError('model', 'test message'),\n            lambda: ModelHTTPError(500, 'model'),\n            lambda: IncompleteToolCall('test'),\n            lambda: ToolRetryError(RetryPromptPart(content='test', tool_name='test')),\n        ],\n        ids=[\n            'ModelRetry',\n            'CallDeferred',\n            'ApprovalRequired',\n            'UserError',\n            'AgentRunError',\n    ..."}
{"task_id": "d-json_schema-L109-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _json_schema.py:109, a None check was inverted: 'elif type_ is None:' became 'elif type_ is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_json_schema.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_json_schema.py", "original": "elif type_ is None:", "mutated": "elif type_ is not None:", "line_num": 109}, "source": "discovered", "category": "json_schema", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_json_schema.py::test_simplify_nullable_unions\n\nError: AssertionError: assert {'anyOf': [{'...pe': 'null'}]} == {'nullable': ...pe': 'string'}\n\nTraceback:\n________________________ test_simplify_nullable_unions _________________________\n\n    def test_simplify_nullable_unions():\n        \"\"\"Test the simplify_nullable_unions feature (deprecated, to be removed in v2).\"\"\"\n    \n        # Create a concrete subclass for testing\n        class TestTransformer(JsonSchemaTransformer):\n            def transform(self, schema: dict[str, Any]) -> dict[str, Any]:\n                return schema\n    \n        # Test with simplify_nullable_unions=True\n        schema_with_null = {\n            'anyOf': [\n                {'type': 'string'},\n                {'type': 'null'},\n            ]\n        }\n        transformer = TestTransformer(schema_with_null, simplify_nullable_unions=True)\n        result = transformer.walk()\n    \n        # Should collapse to a single nullable string\n>       assert result == {'type': 'string', 'nullable': True}\nE       AssertionError: assert {'anyOf': [{'...pe': 'null'}]} == {'nullable': ...pe': 'string'}\nE         \nE         Left contains 1 more item:\n    ..."}
{"task_id": "d-messages-L165-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In messages.py:165, a condition was inverted: 'if isinstance(identifier, str):' became 'if not isinstance(identifier, str):'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/test_messages.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/messages.py", "original": "if isinstance(identifier, str):", "mutated": "if not isinstance(identifier, str):", "line_num": 165}, "source": "discovered", "category": "messages", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_messages.py::test_file_part_serialization_roundtrip\n\nError: AttributeError: 'bytes' object has no attribute 'encode'\n\nTraceback:\n____________________ test_file_part_serialization_roundtrip ____________________\n\n    def test_file_part_serialization_roundtrip():\n        # Verify that a serialized BinaryImage doesn't come back as a BinaryContent.\n        messages: list[ModelMessage] = [\n            ModelResponse(parts=[FilePart(content=BinaryImage(data=b'fake', media_type='image/jpeg'))])\n        ]\n>       serialized = ModelMessagesTypeAdapter.dump_python(messages, mode='json')\n\ntests/test_messages.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../anaconda3/envs/vvenv/lib/python3.11/site-packages/pydantic/type_adapter.py: in dump_python\n    return self.serializer.to_python(\npydantic_ai_slim/pydantic_ai/messages.py: in identifier\n    return self._identifier or _multi_modal_content_identifier(self.data)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nidentifier = b'fake'\n\n    def _multi_modal_content_identifier(identifier: str | bytes) -> str:\n        \"\"\"Generate stable identifier for multi-modal content to help LLM in finding a specific file in tool call responses.\"\"\"\n        if not isinstance(identifier, str):\n>           identifier = identifier.encode('utf-8')\nE           AttributeError: 'bytes' object has no attribute 'encode'\n\n    ..."}
{"task_id": "d-parts_manager-L135-comparison_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _parts_manager.py:135, the comparison operator was changed: 'if content == thinking_tags[1]:' became 'if content != thinking_tags[1]:'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_parts_manager.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_parts_manager.py", "original": "if content == thinking_tags[1]:", "mutated": "if content != thinking_tags[1]:", "line_num": 135}, "source": "discovered", "category": "parts_manager", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: tests/test_parts_manager.py::test_handle_text_deltas_with_think_tags\n\nError: AssertionError: StopIteration\n\nTraceback:\n___________________ test_handle_text_deltas_with_think_tags ____________________\n\n    def test_handle_text_deltas_with_think_tags():\n        manager = ModelResponsePartsManager()\n        thinking_tags = ('<think>', '</think>')\n    \n        event = next(manager.handle_text_delta(vendor_part_id='content', content='pre-', thinking_tags=thinking_tags))\n        assert event == snapshot(\n            PartStartEvent(index=0, part=TextPart(content='pre-', part_kind='text'), event_kind='part_start')\n        )\n        assert manager.get_parts() == snapshot([TextPart(content='pre-', part_kind='text')])\n    \n        event = next(manager.handle_text_delta(vendor_part_id='content', content='thinking', thinking_tags=thinking_tags))\n        assert event == snapshot(\n            PartDeltaEvent(\n                index=0, delta=TextPartDelta(content_delta='thinking', part_delta_kind='text'), event_kind='part_delta'\n            )\n        )\n        assert manager.get_parts() == snapshot([TextPart(content='pre-thinking', part_kind='text')])\n    \n        event = next(manager.handle_text_delta(vendor_part_id='content', content='<think>', thinking_tags=thinking_tags))\n        assert event == snapshot(\n            PartStartEvent(index=1, part=ThinkingPart(content='', part_kind='thinking'), event_kind='part_start')\n        )\n        assert manager.get_parts() == snapshot(\n    ..."}
{"task_id": "d-retries-L165-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In retries.py:165, a boolean operator was swapped: 'self.wrapped = wrapped or HTTPTransport()' became 'self.wrapped = wrapped and HTTPTransport()'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/test_tenacity.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/retries.py", "original": "self.wrapped = wrapped or HTTPTransport()", "mutated": "self.wrapped = wrapped and HTTPTransport()", "line_num": 165}, "source": "discovered", "category": "retries", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_tenacity.py::TestTenacityTransport::test_successful_request\n\nError: AssertionError: assert <Response [200 OK]> is <Mock name='mock.handle_request()' spec='Response' id='4377489296'>\n\nTraceback:\n________________ TestTenacityTransport.test_successful_request _________________\n\nself = <tests.test_tenacity.TestTenacityTransport object at 0x104e0e750>\n\n    def test_successful_request(self):\n        \"\"\"Test that successful requests pass through without retry.\"\"\"\n        mock_transport = Mock(spec=httpx.BaseTransport)\n        mock_transport.__enter__ = Mock(return_value=mock_transport)\n        mock_transport.__exit__ = Mock(return_value=None)\n        mock_response = Mock(spec=httpx.Response)\n        mock_transport.handle_request.return_value = mock_response\n    \n        config = RetryConfig(stop=stop_after_attempt(3), reraise=True)\n        transport = TenacityTransport(config, mock_transport)\n    \n        request = httpx.Request('GET', 'https://example.com')\n        with transport:\n            result = transport.handle_request(request)\n    \n>       assert result is mock_response\nE       AssertionError: assert <Response [200 OK]> is <Mock name='mock.handle_request()' spec='Response' id='4377489296'>\n\ntests/test_tenacity.py: AssertionError"}
{"task_id": "d-ssrf-L94-membership_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _ssrf.py:94, a membership test was inverted: 'return any(ip in network for network in _PRIVATE_NETWORKS)' became 'return any(ip not in network for network in _PRIVATE_NETWORKS)'. This reverses which values pass the check.", "vague_description": "A filter or validation check accepts the wrong set of values. Things that should match don't, and things that shouldn't match do.", "test_cmd": "python -m pytest tests/test_ssrf.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "return any(ip in network for network in _PRIVATE_NETWORKS)", "mutated": "return any(ip not in network for network in _PRIVATE_NETWORKS)", "line_num": 94}, "source": "discovered", "category": "ssrf", "mutation_type": "membership_swap", "dev_report_description": "Test failure: tests/test_ssrf.py::TestIsPrivateIp::test_public_ips_allowed[8.8.8.8]\n\nError: AssertionError: assert True is False\n\nTraceback:\n_______________ TestIsPrivateIp.test_public_ips_allowed[8.8.8.8] _______________\n\nself = <tests.test_ssrf.TestIsPrivateIp object at 0x1071d3a90>, ip = '8.8.8.8'\n\n    @pytest.mark.parametrize(\n        'ip',\n        [\n            # Public IPv4\n            '8.8.8.8',\n            '1.1.1.1',\n            '203.0.113.50',\n            '198.51.100.1',\n            # Public IPv6\n            '2001:4860::8888',\n            '2606:4700::1111',\n        ],\n    )\n    def test_public_ips_allowed(self, ip: str) -> None:\n>       assert is_private_ip(ip) is False\nE       AssertionError: assert True is False\nE        +  where True = is_private_ip('8.8.8.8')\n\ntests/test_ssrf.py: AssertionError"}
{"task_id": "d-tools-L247-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In tools.py:247, a boolean operator was swapped: 'json_schema['additionalProperties'] = self.generate_inner(extras_schema) or True' became 'json_schema['additionalProperties'] = self.generate_inner(extras_schema) and True'. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/test_tools.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/tools.py", "original": "json_schema['additionalProperties'] = self.generate_inner(extras_schema) or True", "mutated": "json_schema['additionalProperties'] = self.generate_inner(extras_schema) and True", "line_num": 247}, "source": "discovered", "category": "tools", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_tools.py::test_docstring_unknown\n\nError: AssertionError: assert {'description...cstring', ...} == {'description...cstring', ...}\n\nTraceback:\n____________________________ test_docstring_unknown ____________________________\n\n    def test_docstring_unknown():\n        agent = Agent(FunctionModel(get_json_schema))\n        agent.tool_plain(unknown_docstring)\n    \n        result = agent.run_sync('Hello')\n        json_schema = json.loads(result.output)\n>       assert json_schema == snapshot(\n            {\n                'name': 'unknown_docstring',\n                'description': 'Unknown style docstring.',\n                'parameters_json_schema': {'additionalProperties': {'type': 'integer'}, 'properties': {}, 'type': 'object'},\n                'outer_typed_dict_key': None,\n                'strict': None,\n                'kind': 'function',\n                'sequential': False,\n                'metadata': None,\n                'timeout': None,\n            }\n        )\nE       AssertionError: assert {'description...cstring', ...} == {'description...cstring', ...}\nE         \nE         Omitting 8 identical items, use -vv to show\nE         Differing items:\n    ..."}
{"task_id": "d-utils-L133-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _utils.py:133, a boolean operator was swapped: 'return any(isinstance(item, dict | list) and _contains_ref(item) for item in items)  # pyright: ignore[reportUnknownArgumentType]' became 'return any(isinstance(item, dict | list) or _contains_ref(item) for item in items)  # pyright: ignore[reportUnknownArgumentType]'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_utils.py", "original": "return any(isinstance(item, dict | list) and _contains_ref(item) for item in items)  # pyright: ignore[reportUnknownArgumentType]", "mutated": "return any(isinstance(item, dict | list) or _contains_ref(item) for item in items)  # pyright: ignore[reportUnknownArgumentType]", "line_num": 133}, "source": "discovered", "category": "utils", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_utils.py::test_check_object_json_schema\n\nError: AssertionError: assert {'$defs': {'J...fs/JsonModel'} == {'properties'...pe': 'object'}\n\nTraceback:\n________________________ test_check_object_json_schema _________________________\n\n    def test_check_object_json_schema():\n        object_schema = {'type': 'object', 'properties': {'a': {'type': 'string'}}}\n        assert check_object_json_schema(object_schema) == object_schema\n    \n>       assert check_object_json_schema(\n            {\n                '$defs': {\n                    'JsonModel': {\n                        'properties': {\n                            'type': {'title': 'Type', 'type': 'string'},\n                            'items': {'anyOf': [{'type': 'string'}, {'type': 'null'}]},\n                        },\n                        'required': ['type', 'items'],\n                        'title': 'JsonModel',\n                        'type': 'object',\n                    }\n                },\n                '$ref': '#/$defs/JsonModel',\n            }\n        ) == {\n            'properties': {\n                'items': {'anyOf': [{'type': 'string'}, {'type': 'null'}]},\n                'type': {'title': 'Type', 'type': 'string'},\n    ..."}
{"task_id": "d-builtin_tools-L78-comparison_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In builtin_tools.py:78, the comparison operator was changed: 'if len(tools) == 1:  # pragma: no cover' became 'if len(tools) != 1:  # pragma: no cover'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/test_builtin_tools.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/builtin_tools.py", "original": "if len(tools) == 1:  # pragma: no cover", "mutated": "if len(tools) != 1:  # pragma: no cover", "line_num": 78}, "source": "discovered", "category": "builtin_tools", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: tests/test_builtin_tools.py::test_url_context_tool_backward_compatibility\n\nError: Failed: DID NOT WARN. No warnings of type (<class 'DeprecationWarning'>,) were emitted.\n\nTraceback:\n_________________ test_url_context_tool_backward_compatibility _________________\n\n    def test_url_context_tool_backward_compatibility():\n        \"\"\"Test that old payloads with 'url_context' kind can be deserialized.\"\"\"\n        adapter = TypeAdapter(AbstractBuiltinTool)\n    \n        # Test 1: Old payload with url_context should deserialize to UrlContextTool (which is deprecated)\n        old_payload = {'kind': 'url_context', 'max_uses': 5, 'enable_citations': True}\n>       with pytest.warns(DeprecationWarning, match='Use `WebFetchTool` instead.'):\nE       Failed: DID NOT WARN. No warnings of type (<class 'DeprecationWarning'>,) were emitted.\nE        Emitted warnings: [].\n\ntests/test_builtin_tools.py: Failed"}
{"task_id": "d-concurrency-L73-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In concurrency.py:73, a condition was inverted: 'if isinstance(limiter, AbstractConcurrencyLimiter):' became 'if not isinstance(limiter, AbstractConcurrencyLimiter):'. The branch now triggers in the opposite case.", "vague_description": "A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.", "test_cmd": "python -m pytest tests/test_concurrency.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/models/concurrency.py", "original": "if isinstance(limiter, AbstractConcurrencyLimiter):", "mutated": "if not isinstance(limiter, AbstractConcurrencyLimiter):", "line_num": 73}, "source": "discovered", "category": "concurrency", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_concurrency.py::TestConcurrencyLimitedModel::test_basic_concurrency_limit\n\nTraceback:\n___________ TestConcurrencyLimitedModel.test_basic_concurrency_limit ___________\n  + Exception Group Traceback (most recent call last):\n  File \"runner.py\", in from_call\n  |     result: TResult | None = func()\n  |                              ^^^^^^\n  File \"runner.py\", in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"_hooks.py\", in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"_manager.py\", in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"_callers.py\", in _multicall\n  |     return outcome.get_result()\n  |            ^^^^^^^^^^^^^^^^^^^^\n  File \"_result.py\", in get_result\n  |     raise exc.with_traceback(exc.__traceback__)\n  File \"_callers.py\", in _multicall\n  |     teardown.throw(outcome._exception)\n  File \"threadexception.py\", in pytest_runtest_call\n  |     yield from thread_exception_runtest_hook()\n  File \"threadexception.py\", in thread_exception_runtest_hook\n  |     yield\n    ..."}
{"task_id": "d-direct-L300-value_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In direct.py:300, a value was swapped: 'self._context_entered = True' became 'self._context_entered = False'.", "vague_description": "Two values appear to be swapped. The system uses value A where it should use value B, and value B where it should use value A.", "test_cmd": "python -m pytest tests/test_direct.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/direct.py", "original": "self._context_entered = True", "mutated": "self._context_entered = False", "line_num": 300}, "source": "discovered", "category": "direct_api", "mutation_type": "value_swap", "dev_report_description": "Test failure: tests/test_direct.py::test_model_request_stream_sync\n\nError: RuntimeError: StreamedResponseSync must be used as a context manager. Use: `with model_request_stream_sync(...) as stream:`\n\nTraceback:\n________________________ test_model_request_stream_sync ________________________\n\n    def test_model_request_stream_sync():\n        with model_request_stream_sync('test', [ModelRequest.user_text_prompt('x')]) as stream:\n>           chunks = list(stream)\n\ntests/test_direct.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/direct.py: in __iter__\n    self._check_context_manager_usage()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = TestStreamedResponse(model_request_parameters=ModelRequestParameters(function_tools=[], builtin_tools=[], output_tools...test', _provider_url=None, _timestamp=datetime.datetime(2026, 2, 12, 14, 54, 40, 412930, tzinfo=datetime.timezone.utc))\n\n    def _check_context_manager_usage(self) -> None:\n        if not self._context_entered:\n>           raise RuntimeError(\n                'StreamedResponseSync must be used as a context manager. '\n                'Use: `with model_request_stream_sync(...) as stream:`'\n            )\nE           RuntimeError: StreamedResponseSync must be used as a context manager. Use: `with model_request_stream_sync(...) as stream:`\n\npydantic_ai_slim/pydantic_ai/direct.py: RuntimeError"}
{"task_id": "d-parts_manager-L83-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _parts_manager.py:83, a None check was inverted: 'if part_index is not None:' became 'if part_index is None:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_parts_manager.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_parts_manager.py", "original": "if part_index is not None:", "mutated": "if part_index is None:", "line_num": 83}, "source": "discovered", "category": "parts_manager", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_parts_manager.py::test_get_part_by_vendor_id\n\nError: AssertionError: assert None == TextPart(content='hello')\n\nTraceback:\n__________________________ test_get_part_by_vendor_id __________________________\n\n    def test_get_part_by_vendor_id():\n        manager = ModelResponsePartsManager()\n    \n        event = next(manager.handle_text_delta(vendor_part_id='content', content='hello'))\n        assert isinstance(event, PartStartEvent)\n    \n        part = manager.get_part_by_vendor_id('content')\n>       assert part == snapshot(TextPart(content='hello', part_kind='text'))\nE       AssertionError: assert None == TextPart(content='hello')\nE        +  where TextPart(content='hello') = snapshot(TextPart(content='hello'))\nE        +    where TextPart(content='hello') = TextPart(content='hello', part_kind='text')\n\ntests/test_parts_manager.py: AssertionError"}
{"task_id": "d-retries-L358-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In retries.py:358, a condition was inverted: 'if isinstance(exc, HTTPStatusError):' became 'if not isinstance(exc, HTTPStatusError):'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_tenacity.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/retries.py", "original": "if isinstance(exc, HTTPStatusError):", "mutated": "if not isinstance(exc, HTTPStatusError):", "line_num": 358}, "source": "discovered", "category": "retries", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_tenacity.py::TestWaitRetryAfter::test_no_exception_uses_fallback\n\nError: AttributeError: 'NoneType' object has no attribute 'response'\n\nTraceback:\n______________ TestWaitRetryAfter.test_no_exception_uses_fallback ______________\n\nself = <tests.test_tenacity.TestWaitRetryAfter object at 0x1128be6d0>\n\n    def test_no_exception_uses_fallback(self):\n        \"\"\"Test that fallback strategy is used when there's no exception.\"\"\"\n        fallback = Mock(return_value=5.0)\n        wait_func = wait_retry_after(fallback_strategy=fallback, max_wait=300)\n    \n        # Create a retry state with no exception\n        retry_state = Mock(spec=RetryCallState)\n        retry_state.outcome = None\n    \n>       result = wait_func(retry_state)\n\ntests/test_tenacity.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nstate = <Mock spec='RetryCallState' id='4606667536'>\n\n    def wait_func(state: RetryCallState) -> float:\n        exc = state.outcome.exception() if state.outcome else None\n        if not isinstance(exc, HTTPStatusError):\n>           retry_after = exc.response.headers.get('retry-after')\nE           AttributeError: 'NoneType' object has no attribute 'response'\n    ..."}
{"task_id": "d-ssrf-L193-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _ssrf.py:193, a condition was inverted: 'if isinstance(ip_obj, ipaddress.IPv6Address):' became 'if not isinstance(ip_obj, ipaddress.IPv6Address):'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_ssrf.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "if isinstance(ip_obj, ipaddress.IPv6Address):", "mutated": "if not isinstance(ip_obj, ipaddress.IPv6Address):", "line_num": 193}, "source": "discovered", "category": "ssrf", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_ssrf.py::TestBuildUrlWithIp::test_http_default_port\n\nError: AssertionError: assert 'http://[203.0.113.50]/path' == 'http://203.0.113.50/path'\n\nTraceback:\n__________________ TestBuildUrlWithIp.test_http_default_port ___________________\n\nself = <tests.test_ssrf.TestBuildUrlWithIp object at 0x1053e1790>\n\n    def test_http_default_port(self) -> None:\n        resolved = ResolvedUrl(\n            resolved_ip='203.0.113.50', hostname='example.com', port=80, is_https=False, path='/path'\n        )\n        url = build_url_with_ip(resolved)\n>       assert url == 'http://203.0.113.50/path'\nE       AssertionError: assert 'http://[203.0.113.50]/path' == 'http://203.0.113.50/path'\nE         \nE         - http://203.0.113.50/path\nE         + http://[203.0.113.50]/path\nE         ?        +            +\n\ntests/test_ssrf.py: AssertionError"}
{"task_id": "d-tools-L190-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In tools.py:190, a condition was inverted: 'if isinstance(x, dict):' became 'if not isinstance(x, dict):'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_tools.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/tools.py", "original": "if isinstance(x, dict):", "mutated": "if not isinstance(x, dict):", "line_num": 190}, "source": "discovered", "category": "tools", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_tools.py::test_deferred_tool_results_serializable\n\nError: AssertionError: assert DeferredToolR..., metadata={}) == DeferredToolR..., metadata={})\n\nTraceback:\n___________________ test_deferred_tool_results_serializable ____________________\n\n    def test_deferred_tool_results_serializable():\n        results = DeferredToolResults(\n            calls={\n                'tool-return': ToolReturn(\n                    return_value=1,\n                    content='The tool call was approved.',\n                    metadata={'foo': 'bar'},\n                ),\n                'model-retry': ModelRetry('The tool call was denied.'),\n                'retry-prompt-part': RetryPromptPart(\n                    content='The tool call was denied.',\n                    tool_name='foo',\n                    tool_call_id='foo',\n                ),\n                'any': {'foo': 'bar'},\n            },\n            approvals={\n                'true': True,\n                'false': False,\n                'tool-approved': ToolApproved(override_args={'foo': 'bar'}),\n                'tool-denied': ToolDenied('The tool call was denied.'),\n            },\n        )\n    ..."}
{"task_id": "d-app-L64-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In app.py:64, a None check was inverted: 'if html_source is None:' became 'if html_source is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_ui_web.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/ui/_web/app.py", "original": "if html_source is None:", "mutated": "if html_source is not None:", "line_num": 64}, "source": "discovered", "category": "ui", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_ui_web.py::test_chat_app_index_endpoint\n\nError: AttributeError: 'NoneType' object has no attribute 'startswith'\n\nTraceback:\n_________________________ test_chat_app_index_endpoint _________________________\n\n    def test_chat_app_index_endpoint():\n        \"\"\"Test that the index endpoint serves HTML with proper caching headers.\"\"\"\n        agent = Agent('test')\n        app = create_web_app(agent)\n    \n        with TestClient(app) as client:\n>           response = client.get('/')\n\ntests/test_ui_web.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../anaconda3/envs/vvenv/lib/python3.11/site-packages/starlette/testclient.py: in get\n    return super().get(\n../httpx/httpx/_client.py: in get\n    return self.request(\n../../anaconda3/envs/vvenv/lib/python3.11/site-packages/starlette/testclient.py: in request\n    return super().request(\n../httpx/httpx/_client.py: in request\n    return self.send(request, auth=auth, follow_redirects=follow_redirects)\n../httpx/httpx/_client.py: in send\n    response = self._send_handling_auth(\n../httpx/httpx/_client.py: in _send_handling_auth\n    response = self._send_handling_redirects(\n../httpx/httpx/_client.py: in _send_handling_redirects\n    ..."}
{"task_id": "d-utils-L115-comparison_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _utils.py:115, the comparison operator was changed: 'and resolved.get('type') == 'object'' became 'and resolved.get('type') != 'object''. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_utils.py", "original": "and resolved.get('type') == 'object'", "mutated": "and resolved.get('type') != 'object'", "line_num": 115}, "source": "discovered", "category": "utils", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: tests/test_utils.py::test_check_object_json_schema\n\nError: AssertionError: assert {'$defs': {'J...fs/JsonModel'} == {'properties'...pe': 'object'}\n\nTraceback:\n________________________ test_check_object_json_schema _________________________\n\n    def test_check_object_json_schema():\n        object_schema = {'type': 'object', 'properties': {'a': {'type': 'string'}}}\n        assert check_object_json_schema(object_schema) == object_schema\n    \n>       assert check_object_json_schema(\n            {\n                '$defs': {\n                    'JsonModel': {\n                        'properties': {\n                            'type': {'title': 'Type', 'type': 'string'},\n                            'items': {'anyOf': [{'type': 'string'}, {'type': 'null'}]},\n                        },\n                        'required': ['type', 'items'],\n                        'title': 'JsonModel',\n                        'type': 'object',\n                    }\n                },\n                '$ref': '#/$defs/JsonModel',\n            }\n        ) == {\n            'properties': {\n                'items': {'anyOf': [{'type': 'string'}, {'type': 'null'}]},\n                'type': {'title': 'Type', 'type': 'string'},\n    ..."}
{"task_id": "d-concurrency-L271-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In concurrency.py:271, a None check was inverted: 'if limiter is None:' became 'if limiter is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_concurrency.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/concurrency.py", "original": "if limiter is None:", "mutated": "if limiter is not None:", "line_num": 271}, "source": "discovered", "category": "concurrency", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_concurrency.py::TestConcurrencyLimiter::test_basic_acquisition\n\nError: AssertionError: assert 3 == 2\n\nTraceback:\n________________ TestConcurrencyLimiter.test_basic_acquisition _________________\n\nself = <tests.test_concurrency.TestConcurrencyLimiter object at 0x105176750>\n\n    async def test_basic_acquisition(self):\n        \"\"\"Test that limiter limits concurrent access.\"\"\"\n        limiter = ConcurrencyLimiter(max_running=2)\n        acquired: list[int] = []\n    \n        async def acquire_and_hold(id: int, hold_time: float):\n            async with get_concurrency_context(limiter, 'test'):\n                acquired.append(id)\n                await anyio.sleep(hold_time)\n    \n        # Start 3 tasks with limit of 2\n        async with anyio.create_task_group() as tg:\n            for i in range(3):\n                tg.start_soon(acquire_and_hold, i, 0.1)\n            await anyio.sleep(0.05)\n>           assert len(acquired) == 2  # Only 2 can proceed\nE           assert 3 == 2\nE            +  where 3 = len([0, 1, 2])\n\ntests/test_concurrency.py: AssertionError\n\n    ..."}
{"task_id": "d-direct-L276-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In direct.py:276, a None check was inverted: 'if instrument is None:' became 'if instrument is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_direct.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/direct.py", "original": "if instrument is None:", "mutated": "if instrument is not None:", "line_num": 276}, "source": "discovered", "category": "direct_api", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_direct.py::test_prepare_model\n\nError: AssertionError: assert False\n\nTraceback:\n______________________________ test_prepare_model ______________________________\n\n    def test_prepare_model():\n        with set_instrument_default(False):\n            model = _prepare_model('test', None)\n            assert isinstance(model, TestModel)\n    \n            model = _prepare_model('test', True)\n>           assert isinstance(model, InstrumentedModel)\nE           AssertionError: assert False\nE            +  where False = isinstance(TestModel(call_tools='all', custom_output_text=None, custom_output_args=None, seed=0, last_model_request_parameters=None), InstrumentedModel)\n\ntests/test_direct.py: AssertionError"}
{"task_id": "d-json_schema-L177-comparison_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _json_schema.py:177, the comparison operator was changed: '(item for item in cases if item != {'type': 'null'}),' became '(item for item in cases if item == {'type': 'null'}),'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/test_json_schema.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_json_schema.py", "original": "(item for item in cases if item != {'type': 'null'}),", "mutated": "(item for item in cases if item == {'type': 'null'}),", "line_num": 177}, "source": "discovered", "category": "json_schema", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: tests/test_json_schema.py::test_simplify_nullable_unions\n\nError: AssertionError: assert {'nullable': ...type': 'null'} == {'nullable': ...pe': 'string'}\n\nTraceback:\n________________________ test_simplify_nullable_unions _________________________\n\n    def test_simplify_nullable_unions():\n        \"\"\"Test the simplify_nullable_unions feature (deprecated, to be removed in v2).\"\"\"\n    \n        # Create a concrete subclass for testing\n        class TestTransformer(JsonSchemaTransformer):\n            def transform(self, schema: dict[str, Any]) -> dict[str, Any]:\n                return schema\n    \n        # Test with simplify_nullable_unions=True\n        schema_with_null = {\n            'anyOf': [\n                {'type': 'string'},\n                {'type': 'null'},\n            ]\n        }\n        transformer = TestTransformer(schema_with_null, simplify_nullable_unions=True)\n        result = transformer.walk()\n    \n        # Should collapse to a single nullable string\n>       assert result == {'type': 'string', 'nullable': True}\nE       AssertionError: assert {'nullable': ...type': 'null'} == {'nullable': ...pe': 'string'}\nE         \nE         Omitting 1 identical items, use -vv to show\n    ..."}
{"task_id": "d-instrumented-L149-comparison_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In instrumented.py:149, the comparison operator was changed: 'if event_mode == 'logs' and version != 1:' became 'if event_mode != 'logs' and version != 1:'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/test_direct.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/models/instrumented.py", "original": "if event_mode == 'logs' and version != 1:", "mutated": "if event_mode != 'logs' and version != 1:", "line_num": 149}, "source": "discovered", "category": "models", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: tests/test_direct.py::test_prepare_model\n\nError: UserWarning: event_mode is only relevant for version=1 which is deprecated and will be removed in a future release.\n\nTraceback:\n______________________________ test_prepare_model ______________________________\n\n    def test_prepare_model():\n        with set_instrument_default(False):\n            model = _prepare_model('test', None)\n            assert isinstance(model, TestModel)\n    \n>           model = _prepare_model('test', True)\n\ntests/test_direct.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/direct.py: in _prepare_model\n    return instrumented_models.instrument_model(model_instance, instrument)\npydantic_ai_slim/pydantic_ai/models/instrumented.py: in instrument_model\n    instrument = InstrumentationSettings()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = InstrumentationSettings(event_mode='attributes', include_binary_content=True, include_content=True, version=2)\n\n    def __init__(\n        self,\n        *,\n        tracer_provider: TracerProvider | None = None,\n        meter_provider: MeterProvider | None = None,\n        include_binary_content: bool = True,\n    ..."}
{"task_id": "d-parts_manager-L246-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _parts_manager.py:246, a None check was inverted: 'if content is None and signature is None and provider_name is None and provider_details is None:' became 'if content is not None and signature is None and provider_name is None and provider_details is None:'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_parts_manager.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_parts_manager.py", "original": "if content is None and signature is None and provider_name is None and provider_details is None:", "mutated": "if content is not None and signature is None and provider_name is None and provider_details is None:", "line_num": 246}, "source": "discovered", "category": "parts_manager", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_parts_manager.py::test_handle_thinking_delta_no_vendor_id_with_existing_thinking_part\n\nError: AssertionError: StopIteration\n\nTraceback:\n_____ test_handle_thinking_delta_no_vendor_id_with_existing_thinking_part ______\n\n    def test_handle_thinking_delta_no_vendor_id_with_existing_thinking_part():\n        manager = ModelResponsePartsManager()\n    \n        # Add a thinking part first\n        event = next(manager.handle_thinking_delta(vendor_part_id='first', content='initial thought', signature=None))\n        assert isinstance(event, PartStartEvent)\n        assert event.index == 0\n    \n        # Now add another thinking delta with no vendor_part_id - should update the latest thinking part\n>       event = next(manager.handle_thinking_delta(vendor_part_id=None, content=' more', signature=None))\nE       StopIteration\n\ntests/test_parts_manager.py: StopIteration\n\nThe above exception was the direct cause of the following exception:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_and_report.<locals>.<lambda> at 0x104b37100>\nwhen = 'call'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n    ..."}
{"task_id": "d-retries-L371-arithmetic_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In retries.py:371, an arithmetic operator was changed: 'wait_seconds = (retry_time - now).total_seconds()' became 'wait_seconds = (retry_time + now).total_seconds()'. This produces wrong numeric results.", "vague_description": "Computed values are consistently wrong. The computation seems to use subtraction where it should add, or vice versa.", "test_cmd": "python -m pytest tests/test_tenacity.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/retries.py", "original": "wait_seconds = (retry_time - now).total_seconds()", "mutated": "wait_seconds = (retry_time + now).total_seconds()", "line_num": 371}, "source": "discovered", "category": "retries", "mutation_type": "arithmetic_swap", "dev_report_description": "Test failure: tests/test_tenacity.py::TestWaitRetryAfter::test_retry_after_http_date_format\n\nError: TypeError: '<=' not supported between instances of 'int' and 'Mock'\n\nTraceback:\n_____________ TestWaitRetryAfter.test_retry_after_http_date_format _____________\n\nself = <tests.test_tenacity.TestWaitRetryAfter object at 0x108f48510>\n\n    def test_retry_after_http_date_format(self):\n        \"\"\"Test parsing Retry-After header in HTTP date format.\"\"\"\n        fallback = Mock()\n        wait_func = wait_retry_after(fallback_strategy=fallback, max_wait=300)\n    \n        # Create a future date (30 seconds from now)\n        future_time = datetime.now(timezone.utc).timestamp() + 30\n        http_date = formatdate(future_time, usegmt=True)\n    \n        # Create HTTP status error with Retry-After in HTTP date format\n        request = httpx.Request('GET', 'https://example.com')\n        response = Mock(spec=httpx.Response)\n        response.headers = {'retry-after': http_date}\n        http_error = httpx.HTTPStatusError('Rate limited', request=request, response=response)\n    \n        retry_state = Mock(spec=RetryCallState)\n        retry_state.outcome = Mock()\n        retry_state.outcome.failed = True\n        retry_state.outcome.exception.return_value = http_error\n    \n        result = wait_func(retry_state)\n    ..."}
{"task_id": "d-ssrf-L249-constant_mutation", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _ssrf.py:249, a constant was changed: 'resolved_ip=ips[0],' became 'resolved_ip=ips[1],'. This shifts a boundary or default.", "vague_description": "A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.", "test_cmd": "python -m pytest tests/test_ssrf.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "resolved_ip=ips[0],", "mutated": "resolved_ip=ips[1],", "line_num": 249}, "source": "discovered", "category": "ssrf", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: tests/test_ssrf.py::TestValidateAndResolveUrl::test_public_ip_allowed\n\nError: IndexError: list index out of range\n\nTraceback:\n_______________ TestValidateAndResolveUrl.test_public_ip_allowed _______________\n\nself = <tests.test_ssrf.TestValidateAndResolveUrl object at 0x10957dd10>\n\n    async def test_public_ip_allowed(self) -> None:\n        \"\"\"Test that public IPs are allowed.\"\"\"\n        with patch('pydantic_ai._ssrf.run_in_executor') as mock_executor:\n            mock_executor.return_value = [(2, 1, 6, '', ('93.184.215.14', 0))]\n>           resolved = await validate_and_resolve_url('https://example.com/path', allow_local=False)\n\ntests/test_ssrf.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'https://example.com/path', allow_local = False\n\n    async def validate_and_resolve_url(url: str, allow_local: bool) -> ResolvedUrl:\n        \"\"\"Validate URL and resolve hostname to IP addresses.\n    \n        Performs protocol validation, DNS resolution, and IP validation.\n    \n        Args:\n            url: The URL to validate.\n            allow_local: Whether to allow private/internal IP addresses.\n    \n        Returns:\n    ..."}
{"task_id": "d-tools-L250-comparison_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In tools.py:250, the comparison operator was changed: 'elif extra == 'forbid':' became 'elif extra != 'forbid':'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_tools.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/tools.py", "original": "elif extra == 'forbid':", "mutated": "elif extra != 'forbid':", "line_num": 250}, "source": "discovered", "category": "tools", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: tests/test_tools.py::test_docstring_google[google]\n\nError: AssertionError: assert {'description...cstring', ...} == {'description...cstring', ...}\n\nTraceback:\n________________________ test_docstring_google[google] _________________________\n\ndocstring_format = 'google'\n\n    @pytest.mark.parametrize('docstring_format', ['google', 'auto'])\n    def test_docstring_google(docstring_format: Literal['google', 'auto']):\n        agent = Agent(FunctionModel(get_json_schema))\n        agent.tool_plain(docstring_format=docstring_format)(google_style_docstring)\n    \n        result = agent.run_sync('Hello')\n        json_schema = json.loads(result.output)\n>       assert json_schema == snapshot(\n            {\n                'name': 'google_style_docstring',\n                'description': 'Do foobar stuff, a lot.',\n                'parameters_json_schema': {\n                    'properties': {\n                        'foo': {'description': 'The foo thing.', 'type': 'integer'},\n                        'bar': {'description': 'The bar thing.', 'type': 'string'},\n                    },\n                    'required': ['foo', 'bar'],\n                    'type': 'object',\n                    'additionalProperties': False,\n                },\n                'outer_typed_dict_key': None,\n    ..."}
{"task_id": "d-usage-L241-arithmetic_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In usage.py:241, an arithmetic operator was changed: 'slf.details[key] = slf.details.get(key, 0) + value' became 'slf.details[key] = slf.details.get(key, 0) - value'. This produces wrong numeric results.", "vague_description": "Computed values are consistently wrong. The computation seems to use subtraction where it should add, or vice versa.", "test_cmd": "python -m pytest tests/test_usage_limits.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/usage.py", "original": "slf.details[key] = slf.details.get(key, 0) + value", "mutated": "slf.details[key] = slf.details.get(key, 0) - value", "line_num": 241}, "source": "discovered", "category": "usage", "mutation_type": "arithmetic_swap", "dev_report_description": "Test failure: tests/test_usage_limits.py::test_add_usages\n\nError: AssertionError: assert RunUsage(inpu... tool_calls=6) == RunUsage(inpu... tool_calls=6)\n\nTraceback:\n_______________________________ test_add_usages ________________________________\n\n    def test_add_usages():\n        usage = RunUsage(\n            requests=2,\n            input_tokens=10,\n            output_tokens=20,\n            cache_read_tokens=30,\n            cache_write_tokens=40,\n            input_audio_tokens=50,\n            cache_audio_read_tokens=60,\n            tool_calls=3,\n            details={\n                'custom1': 10,\n                'custom2': 20,\n            },\n        )\n>       assert usage + usage == snapshot(\n            RunUsage(\n                requests=4,\n                input_tokens=20,\n                output_tokens=40,\n                cache_write_tokens=80,\n                cache_read_tokens=60,\n                input_audio_tokens=100,\n    ..."}
{"task_id": "d-utils-L191-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _utils.py:191, a None check was inverted: 'if soft_max_interval is None:' became 'if soft_max_interval is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_utils.py", "original": "if soft_max_interval is None:", "mutated": "if soft_max_interval is not None:", "line_num": 191}, "source": "discovered", "category": "utils", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_utils.py::test_group_by_temporal[None-expected0]\n\nError: AssertionError: soft_max_interval must be a positive number\n\nTraceback:\n____________________ test_group_by_temporal[None-expected0] ____________________\n\ninterval = None, expected = [[1], [2], [3]]\n\n    @pytest.mark.parametrize(\n        'interval,expected',\n        [\n            (None, snapshot([[1], [2], [3]])),\n            (0, snapshot([[1], [2], [3]])),\n            (0.02, snapshot([[1], [2], [3]])),\n            (0.04, snapshot([[1, 2], [3]])),\n            (0.1, snapshot([[1, 2, 3]])),\n        ],\n    )\n    async def test_group_by_temporal(interval: float | None, expected: list[list[int]]):\n        async def yield_groups() -> AsyncIterator[int]:\n            yield 1\n            await asyncio.sleep(0.02)\n            yield 2\n            await asyncio.sleep(0.02)\n            yield 3\n            await asyncio.sleep(0.02)\n    \n        async with group_by_temporal(yield_groups(), soft_max_interval=interval) as groups_iter:\n>           groups: list[list[int]] = [g async for g in groups_iter]\n    ..."}
{"task_id": "d-concurrency-L292-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In concurrency.py:292, a condition was inverted: 'elif isinstance(limit, AbstractConcurrencyLimiter):' became 'elif not isinstance(limit, AbstractConcurrencyLimiter):'. The branch now triggers in the opposite case.", "vague_description": "A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.", "test_cmd": "python -m pytest tests/test_concurrency.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/concurrency.py", "original": "elif isinstance(limit, AbstractConcurrencyLimiter):", "mutated": "elif not isinstance(limit, AbstractConcurrencyLimiter):", "line_num": 292}, "source": "discovered", "category": "concurrency", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_concurrency.py::TestAgentConcurrency::test_agent_concurrency_limit\n\nTraceback:\n______________ TestAgentConcurrency.test_agent_concurrency_limit _______________\n  + Exception Group Traceback (most recent call last):\n  File \"runner.py\", in from_call\n  |     result: TResult | None = func()\n  |                              ^^^^^^\n  File \"runner.py\", in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"_hooks.py\", in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"_manager.py\", in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"_callers.py\", in _multicall\n  |     return outcome.get_result()\n  |            ^^^^^^^^^^^^^^^^^^^^\n  File \"_result.py\", in get_result\n  |     raise exc.with_traceback(exc.__traceback__)\n  File \"_callers.py\", in _multicall\n  |     teardown.throw(outcome._exception)\n  File \"threadexception.py\", in pytest_runtest_call\n  |     yield from thread_exception_runtest_hook()\n  File \"threadexception.py\", in thread_exception_runtest_hook\n  |     yield\n    ..."}
{"task_id": "d-direct-L334-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In direct.py:334, a condition was inverted: 'if not self._context_entered:' became 'if self._context_entered:'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/test_direct.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/direct.py", "original": "if not self._context_entered:", "mutated": "if self._context_entered:", "line_num": 334}, "source": "discovered", "category": "direct_api", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_direct.py::test_model_request_stream_sync\n\nError: RuntimeError: StreamedResponseSync must be used as a context manager. Use: `with model_request_stream_sync(...) as stream:`\n\nTraceback:\n________________________ test_model_request_stream_sync ________________________\n\n    def test_model_request_stream_sync():\n        with model_request_stream_sync('test', [ModelRequest.user_text_prompt('x')]) as stream:\n>           chunks = list(stream)\n\ntests/test_direct.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/direct.py: in __iter__\n    self._check_context_manager_usage()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = TestStreamedResponse(model_request_parameters=ModelRequestParameters(function_tools=[], builtin_tools=[], output_tools...test', _provider_url=None, _timestamp=datetime.datetime(2026, 2, 12, 14, 55, 11, 570474, tzinfo=datetime.timezone.utc))\n\n    def _check_context_manager_usage(self) -> None:\n        if self._context_entered:\n>           raise RuntimeError(\n                'StreamedResponseSync must be used as a context manager. '\n                'Use: `with model_request_stream_sync(...) as stream:`'\n            )\nE           RuntimeError: StreamedResponseSync must be used as a context manager. Use: `with model_request_stream_sync(...) as stream:`\n\npydantic_ai_slim/pydantic_ai/direct.py: RuntimeError"}
{"task_id": "d-json_schema-L174-comparison_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _json_schema.py:174, the comparison operator was changed: 'if len(cases) == 2 and {'type': 'null'} in cases:' became 'if len(cases) != 2 and {'type': 'null'} in cases:'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/test_json_schema.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_json_schema.py", "original": "if len(cases) == 2 and {'type': 'null'} in cases:", "mutated": "if len(cases) != 2 and {'type': 'null'} in cases:", "line_num": 174}, "source": "discovered", "category": "json_schema", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: tests/test_json_schema.py::test_simplify_nullable_unions\n\nError: AssertionError: assert {'anyOf': [{'...pe': 'null'}]} == {'nullable': ...pe': 'string'}\n\nTraceback:\n________________________ test_simplify_nullable_unions _________________________\n\n    def test_simplify_nullable_unions():\n        \"\"\"Test the simplify_nullable_unions feature (deprecated, to be removed in v2).\"\"\"\n    \n        # Create a concrete subclass for testing\n        class TestTransformer(JsonSchemaTransformer):\n            def transform(self, schema: dict[str, Any]) -> dict[str, Any]:\n                return schema\n    \n        # Test with simplify_nullable_unions=True\n        schema_with_null = {\n            'anyOf': [\n                {'type': 'string'},\n                {'type': 'null'},\n            ]\n        }\n        transformer = TestTransformer(schema_with_null, simplify_nullable_unions=True)\n        result = transformer.walk()\n    \n        # Should collapse to a single nullable string\n>       assert result == {'type': 'string', 'nullable': True}\nE       AssertionError: assert {'anyOf': [{'...pe': 'null'}]} == {'nullable': ...pe': 'string'}\nE         \nE         Left contains 1 more item:\n    ..."}
{"task_id": "d-messages-L167-constant_mutation", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In messages.py:167, a constant was changed: 'return hashlib.sha1(identifier).hexdigest()[:6]' became 'return hashlib.sha1(identifier).hexdigest()[:7]'. This shifts a boundary or default.", "vague_description": "A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.", "test_cmd": "python -m pytest tests/test_messages.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/messages.py", "original": "return hashlib.sha1(identifier).hexdigest()[:6]", "mutated": "return hashlib.sha1(identifier).hexdigest()[:7]", "line_num": 167}, "source": "discovered", "category": "messages", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: tests/test_messages.py::test_file_part_serialization_roundtrip\n\nError: AssertionError: assert [{'finish_rea...': None, ...}] == [{'finish_rea...': None, ...}]\n\nTraceback:\n____________________ test_file_part_serialization_roundtrip ____________________\n\n    def test_file_part_serialization_roundtrip():\n        # Verify that a serialized BinaryImage doesn't come back as a BinaryContent.\n        messages: list[ModelMessage] = [\n            ModelResponse(parts=[FilePart(content=BinaryImage(data=b'fake', media_type='image/jpeg'))])\n        ]\n        serialized = ModelMessagesTypeAdapter.dump_python(messages, mode='json')\n>       assert serialized == snapshot(\n            [\n                {\n                    'parts': [\n                        {\n                            'content': {\n                                'data': 'ZmFrZQ==',\n                                'media_type': 'image/jpeg',\n                                'identifier': 'c053ec',\n                                'vendor_metadata': None,\n                                'kind': 'binary',\n                            },\n                            'id': None,\n                            'provider_name': None,\n                            'part_kind': 'file',\n                            'provider_details': None,\n                        }\n    ..."}
{"task_id": "d-parts_manager-L124-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _parts_manager.py:124, a None check was inverted: 'if vendor_part_id is None:' became 'if vendor_part_id is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_parts_manager.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_parts_manager.py", "original": "if vendor_part_id is None:", "mutated": "if vendor_part_id is not None:", "line_num": 124}, "source": "discovered", "category": "parts_manager", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_parts_manager.py::test_handle_text_deltas[None]\n\nError: AssertionError: assert PartStartEvent(index=1, part=TextPart(content='world')) == PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='world'))\n\nTraceback:\n________________________ test_handle_text_deltas[None] _________________________\n\nvendor_part_id = None\n\n    @pytest.mark.parametrize('vendor_part_id', [None, 'content'])\n    def test_handle_text_deltas(vendor_part_id: str | None):\n        manager = ModelResponsePartsManager()\n        assert manager.get_parts() == []\n    \n        event = next(manager.handle_text_delta(vendor_part_id=vendor_part_id, content='hello '))\n        assert event == snapshot(\n            PartStartEvent(index=0, part=TextPart(content='hello ', part_kind='text'), event_kind='part_start')\n        )\n        assert manager.get_parts() == snapshot([TextPart(content='hello ', part_kind='text')])\n    \n        event = next(manager.handle_text_delta(vendor_part_id=vendor_part_id, content='world'))\n>       assert event == snapshot(\n            PartDeltaEvent(\n                index=0, delta=TextPartDelta(content_delta='world', part_delta_kind='text'), event_kind='part_delta'\n            )\n        )\nE       AssertionError: assert PartStartEvent(index=1, part=TextPart(content='world')) == PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='world'))\nE        +  where PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='world')) = snapshot(PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='world')))\nE        +    where PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='world')) = PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='world'), event_kind='part_delta')\nE        +      where TextPartDelta(content_delta='world') = TextPartDelta(content_delta='world', part_delta_kind='text')\n    ..."}
{"task_id": "d-retries-L353-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In retries.py:353, a None check was inverted: 'if fallback_strategy is None:' became 'if fallback_strategy is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_tenacity.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/retries.py", "original": "if fallback_strategy is None:", "mutated": "if fallback_strategy is not None:", "line_num": 353}, "source": "discovered", "category": "retries", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_tenacity.py::TestWaitRetryAfter::test_no_exception_uses_fallback\n\nError: AttributeError: Mock object has no attribute 'attempt_number'\n\nTraceback:\n______________ TestWaitRetryAfter.test_no_exception_uses_fallback ______________\n\nself = <tests.test_tenacity.TestWaitRetryAfter object at 0x1078be990>\n\n    def test_no_exception_uses_fallback(self):\n        \"\"\"Test that fallback strategy is used when there's no exception.\"\"\"\n        fallback = Mock(return_value=5.0)\n        wait_func = wait_retry_after(fallback_strategy=fallback, max_wait=300)\n    \n        # Create a retry state with no exception\n        retry_state = Mock(spec=RetryCallState)\n        retry_state.outcome = None\n    \n>       result = wait_func(retry_state)\n\ntests/test_tenacity.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/retries.py: in wait_func\n    return fallback_strategy(state)\n../../anaconda3/envs/vvenv/lib/python3.11/site-packages/tenacity/wait.py: in __call__\n    exp = self.exp_base ** (retry_state.attempt_number - 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Mock spec='RetryCallState' id='4424215888'>, name = 'attempt_number'\n\n    ..."}
{"task_id": "d-ssrf-L170-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _ssrf.py:170, a boolean operator was swapped: 'port = parsed.port or default_port' became 'port = parsed.port and default_port'. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/test_ssrf.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "port = parsed.port or default_port", "mutated": "port = parsed.port and default_port", "line_num": 170}, "source": "discovered", "category": "ssrf", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_ssrf.py::TestExtractHostAndPort::test_basic_http_url\n\nError: AssertionError: assert None == 80\n\nTraceback:\n__________________ TestExtractHostAndPort.test_basic_http_url __________________\n\nself = <tests.test_ssrf.TestExtractHostAndPort object at 0x104c2a0d0>\n\n    def test_basic_http_url(self) -> None:\n        hostname, path, port, is_https = extract_host_and_port('http://example.com/path')\n        assert hostname == 'example.com'\n        assert path == '/path'\n>       assert port == 80\nE       assert None == 80\n\ntests/test_ssrf.py: AssertionError"}
{"task_id": "d-tools-L378-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In tools.py:378, a boolean operator was swapped: 'self.description = description or self.function_schema.description' became 'self.description = description and self.function_schema.description'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/test_tools.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/tools.py", "original": "self.description = description or self.function_schema.description", "mutated": "self.description = description and self.function_schema.description", "line_num": 378}, "source": "discovered", "category": "tools", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_tools.py::test_docstring_google[google]\n\nError: AssertionError: assert {'description...cstring', ...} == {'description...cstring', ...}\n\nTraceback:\n________________________ test_docstring_google[google] _________________________\n\ndocstring_format = 'google'\n\n    @pytest.mark.parametrize('docstring_format', ['google', 'auto'])\n    def test_docstring_google(docstring_format: Literal['google', 'auto']):\n        agent = Agent(FunctionModel(get_json_schema))\n        agent.tool_plain(docstring_format=docstring_format)(google_style_docstring)\n    \n        result = agent.run_sync('Hello')\n        json_schema = json.loads(result.output)\n>       assert json_schema == snapshot(\n            {\n                'name': 'google_style_docstring',\n                'description': 'Do foobar stuff, a lot.',\n                'parameters_json_schema': {\n                    'properties': {\n                        'foo': {'description': 'The foo thing.', 'type': 'integer'},\n                        'bar': {'description': 'The bar thing.', 'type': 'string'},\n                    },\n                    'required': ['foo', 'bar'],\n                    'type': 'object',\n                    'additionalProperties': False,\n                },\n                'outer_typed_dict_key': None,\n    ..."}
{"task_id": "d-usage-L209-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In usage.py:209, a condition was inverted: 'if isinstance(incr_usage, RunUsage):' became 'if not isinstance(incr_usage, RunUsage):'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_usage_limits.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/usage.py", "original": "if isinstance(incr_usage, RunUsage):", "mutated": "if not isinstance(incr_usage, RunUsage):", "line_num": 209}, "source": "discovered", "category": "usage", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_usage_limits.py::test_request_token_limit\n\nError: AttributeError: 'RequestUsage' object has no attribute 'tool_calls'\n\nTraceback:\n___________________________ test_request_token_limit ___________________________\n\n    def test_request_token_limit() -> None:\n        test_agent = Agent(TestModel())\n    \n        with pytest.raises(UsageLimitExceeded, match=re.escape('Exceeded the input_tokens_limit of 5 (input_tokens=59)')):\n>           test_agent.run_sync(\n                'Hello, this prompt exceeds the request tokens limit.', usage_limits=UsageLimits(input_tokens_limit=5)\n            )\n\ntests/test_usage_limits.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/agent/abstract.py: in run_sync\n    return _utils.get_event_loop().run_until_complete(\n../../anaconda3/envs/vvenv/lib/python3.11/asyncio/base_events.py: in run_until_complete\n    return future.result()\npydantic_ai_slim/pydantic_ai/agent/abstract.py: in run\n    async with self.iter(\n../../anaconda3/envs/vvenv/lib/python3.11/contextlib.py: in __aexit__\n    await self.gen.athrow(typ, value, traceback)\npydantic_ai_slim/pydantic_ai/agent/__init__.py: in iter\n    async with (\n../../anaconda3/envs/vvenv/lib/python3.11/contextlib.py: in __aexit__\n    await self.gen.athrow(typ, value, traceback)\npydantic_graph/pydantic_graph/beta/graph.py: in iter\n    ..."}
{"task_id": "d-utils-L206-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _utils.py:206, a None check was inverted: 'assert soft_max_interval is not None and soft_max_interval >= 0, 'soft_max_interval must be a positive number'' became 'assert soft_max_interval is None and soft_max_interval >= 0, 'soft_max_interval must be a positive number''. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_utils.py", "original": "assert soft_max_interval is not None and soft_max_interval >= 0, 'soft_max_interval must be a positive number'", "mutated": "assert soft_max_interval is None and soft_max_interval >= 0, 'soft_max_interval must be a positive number'", "line_num": 206}, "source": "discovered", "category": "utils", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_utils.py::test_group_by_temporal[0-expected1]\n\nError: AssertionError: soft_max_interval must be a positive number\n\nTraceback:\n_____________________ test_group_by_temporal[0-expected1] ______________________\n\ninterval = 0, expected = [[1], [2], [3]]\n\n    @pytest.mark.parametrize(\n        'interval,expected',\n        [\n            (None, snapshot([[1], [2], [3]])),\n            (0, snapshot([[1], [2], [3]])),\n            (0.02, snapshot([[1], [2], [3]])),\n            (0.04, snapshot([[1, 2], [3]])),\n            (0.1, snapshot([[1, 2, 3]])),\n        ],\n    )\n    async def test_group_by_temporal(interval: float | None, expected: list[list[int]]):\n        async def yield_groups() -> AsyncIterator[int]:\n            yield 1\n            await asyncio.sleep(0.02)\n            yield 2\n            await asyncio.sleep(0.02)\n            yield 3\n            await asyncio.sleep(0.02)\n    \n        async with group_by_temporal(yield_groups(), soft_max_interval=interval) as groups_iter:\n>           groups: list[list[int]] = [g async for g in groups_iter]\n    ..."}
{"task_id": "d-concurrency-L138-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In concurrency.py:138, a None check was inverted: 'if normalized_limiter is None:' became 'if normalized_limiter is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_concurrency.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/models/concurrency.py", "original": "if normalized_limiter is None:", "mutated": "if normalized_limiter is not None:", "line_num": 138}, "source": "discovered", "category": "concurrency", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_concurrency.py::TestConcurrencyLimitedModel::test_limit_model_concurrency_helper\n\nError: AssertionError: assert False\n\nTraceback:\n_______ TestConcurrencyLimitedModel.test_limit_model_concurrency_helper ________\n\nself = <tests.test_concurrency.TestConcurrencyLimitedModel object at 0x106ab5490>\n\n    async def test_limit_model_concurrency_helper(self):\n        \"\"\"Test the limit_model_concurrency helper function.\"\"\"\n        from pydantic_ai.models.concurrency import ConcurrencyLimitedModel, limit_model_concurrency\n    \n        # With limiter\n        model = limit_model_concurrency(TestModel(), limiter=5)\n>       assert isinstance(model, ConcurrencyLimitedModel)\nE       AssertionError: assert False\nE        +  where False = isinstance(TestModel(call_tools='all', custom_output_text=None, custom_output_args=None, seed=0, last_model_request_parameters=None), <class 'pydantic_ai.models.concurrency.ConcurrencyLimitedModel'>)\n\ntests/test_concurrency.py: AssertionError"}
{"task_id": "d-direct-L202-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In direct.py:202, a boolean operator was swapped: 'model_request_parameters or models.ModelRequestParameters(),' became 'model_request_parameters and models.ModelRequestParameters(),'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/test_direct.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/direct.py", "original": "model_request_parameters or models.ModelRequestParameters(),", "mutated": "model_request_parameters and models.ModelRequestParameters(),", "line_num": 202}, "source": "discovered", "category": "direct_api", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_direct.py::test_model_request_stream_sync\n\nError: AttributeError: 'NoneType' object has no attribute 'builtin_tools'\n\nTraceback:\n________________________ test_model_request_stream_sync ________________________\n\n    def test_model_request_stream_sync():\n        with model_request_stream_sync('test', [ModelRequest.user_text_prompt('x')]) as stream:\n>           chunks = list(stream)\n\ntests/test_direct.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/direct.py: in __iter__\n    raise item\npydantic_ai_slim/pydantic_ai/direct.py: in _consume_async_stream\n    async with self._async_stream_cm as stream:\n../../anaconda3/envs/vvenv/lib/python3.11/contextlib.py: in __aenter__\n    return await anext(self.gen)\npydantic_ai_slim/pydantic_ai/models/test.py: in request_stream\n    model_settings, model_request_parameters = self.prepare_request(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = TestModel(call_tools='all', custom_output_text=None, custom_output_args=None, seed=0, last_model_request_parameters=None)\nmodel_settings = None, model_request_parameters = None\n\n    def prepare_request(\n        self,\n        model_settings: ModelSettings | None,\n        model_request_parameters: ModelRequestParameters,\n    ..."}
{"task_id": "d-json_schema-L164-constant_mutation", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _json_schema.py:164, a constant was changed: 'return handled[0] | schema' became 'return handled[1] | schema'. This shifts a boundary or default.", "vague_description": "A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.", "test_cmd": "python -m pytest tests/test_json_schema.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_json_schema.py", "original": "return handled[0] | schema", "mutated": "return handled[1] | schema", "line_num": 164}, "source": "discovered", "category": "json_schema", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: tests/test_json_schema.py::test_simplify_nullable_unions\n\nError: IndexError: list index out of range\n\nTraceback:\n________________________ test_simplify_nullable_unions _________________________\n\n    def test_simplify_nullable_unions():\n        \"\"\"Test the simplify_nullable_unions feature (deprecated, to be removed in v2).\"\"\"\n    \n        # Create a concrete subclass for testing\n        class TestTransformer(JsonSchemaTransformer):\n            def transform(self, schema: dict[str, Any]) -> dict[str, Any]:\n                return schema\n    \n        # Test with simplify_nullable_unions=True\n        schema_with_null = {\n            'anyOf': [\n                {'type': 'string'},\n                {'type': 'null'},\n            ]\n        }\n        transformer = TestTransformer(schema_with_null, simplify_nullable_unions=True)\n>       result = transformer.walk()\n\ntests/test_json_schema.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/_json_schema.py: in walk\n    handled = self._handle(schema)\npydantic_ai_slim/pydantic_ai/_json_schema.py: in _handle\n    ..."}
{"task_id": "d-messages-L596-membership_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In messages.py:596, a membership test was inverted: 'return self.media_type in _document_format_lookup' became 'return self.media_type not in _document_format_lookup'. This reverses which values pass the check.", "vague_description": "A filter or validation check accepts the wrong set of values. Things that should match don't, and things that shouldn't match do.", "test_cmd": "python -m pytest tests/test_messages.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/messages.py", "original": "return self.media_type in _document_format_lookup", "mutated": "return self.media_type not in _document_format_lookup", "line_num": 596}, "source": "discovered", "category": "messages", "mutation_type": "membership_swap", "dev_report_description": "Test failure: tests/test_messages.py::test_binary_content_document[application/pdf-pdf]\n\nError: AssertionError: assert False\n\nTraceback:\n______________ test_binary_content_document[application/pdf-pdf] _______________\n\nmedia_type = 'application/pdf', format = 'pdf'\n\n    @pytest.mark.parametrize(\n        'media_type, format',\n        [\n            ('application/pdf', 'pdf'),\n            ('text/plain', 'txt'),\n            ('text/csv', 'csv'),\n            ('application/msword', 'doc'),\n            ('application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'docx'),\n            ('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'xlsx'),\n            ('text/html', 'html'),\n            ('text/markdown', 'md'),\n            ('application/vnd.ms-excel', 'xls'),\n        ],\n    )\n    def test_binary_content_document(media_type: str, format: str):\n        binary_content = BinaryContent(data=b'Hello, world!', media_type=media_type)\n>       assert binary_content.is_document\nE       AssertionError: assert False\nE        +  where False = BinaryContent(data=b'Hello, world!', media_type='application/pdf').is_document\n\ntests/test_messages.py: AssertionError"}
{"task_id": "d-instrumented-L140-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In instrumented.py:140, a boolean operator was swapped: 'logger_provider = logger_provider or get_logger_provider()' became 'logger_provider = logger_provider and get_logger_provider()'. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/test_direct.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/models/instrumented.py", "original": "logger_provider = logger_provider or get_logger_provider()", "mutated": "logger_provider = logger_provider and get_logger_provider()", "line_num": 140}, "source": "discovered", "category": "models", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_direct.py::test_prepare_model\n\nError: AttributeError: 'NoneType' object has no attribute 'get_logger'\n\nTraceback:\n______________________________ test_prepare_model ______________________________\n\n    def test_prepare_model():\n        with set_instrument_default(False):\n            model = _prepare_model('test', None)\n            assert isinstance(model, TestModel)\n    \n>           model = _prepare_model('test', True)\n\ntests/test_direct.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/direct.py: in _prepare_model\n    return instrumented_models.instrument_model(model_instance, instrument)\npydantic_ai_slim/pydantic_ai/models/instrumented.py: in instrument_model\n    instrument = InstrumentationSettings()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = InstrumentationSettings(event_mode='attributes', include_binary_content=True, include_content=True, version=2)\n\n    def __init__(\n        self,\n        *,\n        tracer_provider: TracerProvider | None = None,\n        meter_provider: MeterProvider | None = None,\n        include_binary_content: bool = True,\n    ..."}
{"task_id": "d-parts_manager-L133-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _parts_manager.py:133, a boolean operator was swapped: 'if thinking_tags and isinstance(existing_part, ThinkingPart):' became 'if thinking_tags or isinstance(existing_part, ThinkingPart):'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/test_parts_manager.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_parts_manager.py", "original": "if thinking_tags and isinstance(existing_part, ThinkingPart):", "mutated": "if thinking_tags or isinstance(existing_part, ThinkingPart):", "line_num": 133}, "source": "discovered", "category": "parts_manager", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_parts_manager.py::test_handle_text_deltas_with_think_tags\n\nError: ValueError: Cannot apply ThinkingPartDeltas to non-ThinkingParts or non-ThinkingPartDeltas (part=TextPart(content='pre-'), self=ThinkingPartDelta(content_delta='thinking'))\n\nTraceback:\n___________________ test_handle_text_deltas_with_think_tags ____________________\n\n    def test_handle_text_deltas_with_think_tags():\n        manager = ModelResponsePartsManager()\n        thinking_tags = ('<think>', '</think>')\n    \n        event = next(manager.handle_text_delta(vendor_part_id='content', content='pre-', thinking_tags=thinking_tags))\n        assert event == snapshot(\n            PartStartEvent(index=0, part=TextPart(content='pre-', part_kind='text'), event_kind='part_start')\n        )\n        assert manager.get_parts() == snapshot([TextPart(content='pre-', part_kind='text')])\n    \n>       event = next(manager.handle_text_delta(vendor_part_id='content', content='thinking', thinking_tags=thinking_tags))\n\ntests/test_parts_manager.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/_parts_manager.py: in handle_text_delta\n    yield from self._handle_embedded_thinking_content(\npydantic_ai_slim/pydantic_ai/_parts_manager.py: in _handle_embedded_thinking_content\n    self._parts[part_index] = part_delta.apply(existing_part)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = ThinkingPartDelta(content_delta='thinking')\npart = TextPart(content='pre-')\n\n    ..."}
{"task_id": "d-tools-L368-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In tools.py:368, a boolean operator was swapped: 'self.function_schema = function_schema or _function_schema.function_schema(' became 'self.function_schema = function_schema and _function_schema.function_schema('. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/test_tools.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/tools.py", "original": "self.function_schema = function_schema or _function_schema.function_schema(", "mutated": "self.function_schema = function_schema and _function_schema.function_schema(", "line_num": 368}, "source": "discovered", "category": "tools", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_tools.py::test_tool_no_ctx\n\nError: AttributeError: 'NoneType' object has no attribute 'takes_ctx'\n\nTraceback:\n_______________________________ test_tool_no_ctx _______________________________\n\n    def test_tool_no_ctx():\n        agent = Agent(TestModel())\n    \n        with pytest.raises(UserError) as exc_info:\n    \n>           @agent.tool  # pyright: ignore[reportArgumentType]\n\ntests/test_tools.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/agent/__init__.py: in tool\n    return tool_decorator if func is None else tool_decorator(func)\npydantic_ai_slim/pydantic_ai/agent/__init__.py: in tool_decorator\n    self._function_toolset.add_function(\npydantic_ai_slim/pydantic_ai/toolsets/function.py: in add_function\n    tool = Tool[AgentDepsT](\n../../anaconda3/envs/vvenv/lib/python3.11/typing.py: in __call__\n    result = self.__origin__(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <[AttributeError(\"'Tool' object has no attribute 'takes_ctx'\") raised in repr()] Tool object at 0x105691c10>\nfunction = <function test_tool_no_ctx.<locals>.invalid_tool at 0x10573aa20>\n\n    def __init__(\n    ..."}
{"task_id": "d-usage-L349-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In usage.py:349, a None check was inverted: 'self.input_tokens_limit = input_tokens_limit if input_tokens_limit is not None else request_tokens_limit' became 'self.input_tokens_limit = input_tokens_limit if input_tokens_limit is None else request_tokens_limit'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_usage_limits.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/usage.py", "original": "self.input_tokens_limit = input_tokens_limit if input_tokens_limit is not None else request_tokens_limit", "mutated": "self.input_tokens_limit = input_tokens_limit if input_tokens_limit is None else request_tokens_limit", "line_num": 349}, "source": "discovered", "category": "usage", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_usage_limits.py::test_request_token_limit\n\nError: Failed: DID NOT RAISE <class 'pydantic_ai.exceptions.UsageLimitExceeded'>\n\nTraceback:\n___________________________ test_request_token_limit ___________________________\n\n    def test_request_token_limit() -> None:\n        test_agent = Agent(TestModel())\n    \n>       with pytest.raises(UsageLimitExceeded, match=re.escape('Exceeded the input_tokens_limit of 5 (input_tokens=59)')):\nE       Failed: DID NOT RAISE <class 'pydantic_ai.exceptions.UsageLimitExceeded'>\n\ntests/test_usage_limits.py: Failed"}
{"task_id": "d-utils-L107-comparison_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _utils.py:107, the comparison operator was changed: 'if schema.get('type') == 'object':' became 'if schema.get('type') != 'object':'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_utils.py", "original": "if schema.get('type') == 'object':", "mutated": "if schema.get('type') != 'object':", "line_num": 107}, "source": "discovered", "category": "utils", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: tests/test_utils.py::test_check_object_json_schema\n\nError: pydantic_ai.exceptions.UserError: Schema must be an object\n\nTraceback:\n________________________ test_check_object_json_schema _________________________\n\n    def test_check_object_json_schema():\n        object_schema = {'type': 'object', 'properties': {'a': {'type': 'string'}}}\n>       assert check_object_json_schema(object_schema) == object_schema\n\ntests/test_utils.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nschema = {'properties': {'a': {'type': 'string'}}, 'type': 'object'}\n\n    def check_object_json_schema(schema: JsonSchemaValue) -> ObjectJsonSchema:\n        from .exceptions import UserError\n    \n        if schema.get('type') != 'object':\n            return schema\n        elif ref := schema.get('$ref'):\n            prefix = '#/$defs/'\n            # Return the referenced schema unless it contains additional nested references.\n            if (\n                ref.startswith(prefix)\n                and (resolved := schema.get('$defs', {}).get(ref[len(prefix) :]))\n                and resolved.get('type') == 'object'\n                and not _contains_ref(resolved)\n            ):\n    ..."}
{"task_id": "d-concurrency-L198-constant_mutation", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In concurrency.py:198, a constant was changed: 'self._waiting_count += 1' became 'self._waiting_count += 0'. This shifts a boundary or default.", "vague_description": "A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.", "test_cmd": "python -m pytest tests/test_concurrency.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/concurrency.py", "original": "self._waiting_count += 1", "mutated": "self._waiting_count += 0", "line_num": 198}, "source": "discovered", "category": "concurrency", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: tests/test_concurrency.py::TestConcurrencyLimiter::test_waiting_count_tracking\n\nError: AssertionError: assert 0 == 3\n\nTraceback:\n______________ TestConcurrencyLimiter.test_waiting_count_tracking ______________\n\nself = <tests.test_concurrency.TestConcurrencyLimiter object at 0x105041790>\n\n    async def test_waiting_count_tracking(self):\n        \"\"\"Test that waiting_count is accurately tracked.\"\"\"\n        limiter = ConcurrencyLimiter(max_running=1)\n        started = anyio.Event()\n        release = anyio.Event()\n    \n        async def holder():\n            async with get_concurrency_context(limiter, 'test'):\n                started.set()\n                await release.wait()\n    \n        async def waiter():\n            async with get_concurrency_context(limiter, 'test'):\n                pass\n    \n        async with anyio.create_task_group() as tg:\n            tg.start_soon(holder)\n            await started.wait()\n    \n            # Now limiter is held, check waiting count as we add waiters\n            assert limiter.waiting_count == 0\n    ..."}
{"task_id": "d-direct-L84-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In direct.py:84, a boolean operator was swapped: 'model_request_parameters or models.ModelRequestParameters(),' became 'model_request_parameters and models.ModelRequestParameters(),'. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/test_direct.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/direct.py", "original": "model_request_parameters or models.ModelRequestParameters(),", "mutated": "model_request_parameters and models.ModelRequestParameters(),", "line_num": 84}, "source": "discovered", "category": "direct_api", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_direct.py::test_model_request\n\nError: AttributeError: 'NoneType' object has no attribute 'builtin_tools'\n\nTraceback:\n______________________________ test_model_request ______________________________\n\n    async def test_model_request():\n>       model_response = await model_request('test', [ModelRequest.user_text_prompt('x')])\n\ntests/test_direct.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/direct.py: in model_request\n    return await model_instance.request(\npydantic_ai_slim/pydantic_ai/models/test.py: in request\n    model_settings, model_request_parameters = self.prepare_request(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = TestModel(call_tools='all', custom_output_text=None, custom_output_args=None, seed=0, last_model_request_parameters=None)\nmodel_settings = None, model_request_parameters = None\n\n    def prepare_request(\n        self,\n        model_settings: ModelSettings | None,\n        model_request_parameters: ModelRequestParameters,\n    ) -> tuple[ModelSettings | None, ModelRequestParameters]:\n        \"\"\"Prepare request inputs before they are passed to the provider.\n    \n        This merges the given `model_settings` with the model's own `settings` attribute and ensures\n        `customize_request_parameters` is applied to the resolved\n    ..."}
{"task_id": "d-messages-L394-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In messages.py:394, a None check was inverted: 'if mime_type is None:' became 'if mime_type is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_messages.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/messages.py", "original": "if mime_type is None:", "mutated": "if mime_type is not None:", "line_num": 394}, "source": "discovered", "category": "messages", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_messages.py::test_image_url\n\nError: ValueError: Could not infer media type from image URL: https://example.com/image.jpg. Explicitly provide a `media_type` instead.\n\nTraceback:\n________________________________ test_image_url ________________________________\n\n    def test_image_url():\n        image_url = ImageUrl(url='https://example.com/image.jpg')\n>       assert image_url.media_type == 'image/jpeg'\n\ntests/test_messages.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/messages.py: in media_type\n    return self._media_type or self._infer_media_type()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = ImageUrl(url='https://example.com/image.jpg')\n\n    def _infer_media_type(self) -> str:\n        \"\"\"Return the media type of the image, based on the url.\"\"\"\n        mime_type, _ = _mime_types.guess_type(self.url)\n        if mime_type is not None:\n>           raise ValueError(\n                f'Could not infer media type from image URL: {self.url}. Explicitly provide a `media_type` instead.'\n            )\nE           ValueError: Could not infer media type from image URL: https://example.com/image.jpg. Explicitly provide a `media_type` instead.\n\npydantic_ai_slim/pydantic_ai/messages.py: ValueError"}
{"task_id": "d-parts_manager-L299-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _parts_manager.py:299, a None check was inverted: 'if vendor_part_id is None:' became 'if vendor_part_id is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_parts_manager.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_parts_manager.py", "original": "if vendor_part_id is None:", "mutated": "if vendor_part_id is not None:", "line_num": 299}, "source": "discovered", "category": "parts_manager", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_parts_manager.py::test_handle_tool_call_deltas\n\nError: AssertionError: assert PartStartEven...foo': 'bar'})) == PartStartEven...foo': 'bar'}))\n\nTraceback:\n_________________________ test_handle_tool_call_deltas _________________________\n\n    def test_handle_tool_call_deltas():\n        manager = ModelResponsePartsManager()\n    \n        event = manager.handle_tool_call_delta(vendor_part_id='first', tool_name=None, args='{\"arg1\":', tool_call_id=None)\n        # Not enough information to produce a part, so no event and no part\n        assert event == snapshot(None)\n        assert manager.get_parts() == snapshot([])\n    \n        # Now that we have a tool name, we can produce a part:\n        event = manager.handle_tool_call_delta(\n            vendor_part_id='first',\n            tool_name='tool',\n            args=None,\n            tool_call_id='call',\n            provider_name='test_provider',\n            provider_details={'foo': 'bar'},\n        )\n>       assert event == snapshot(\n            PartStartEvent(\n                index=0,\n                part=ToolCallPart(\n                    tool_name='tool',\n                    args='{\"arg1\":',\n    ..."}
{"task_id": "d-retries-L262-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In retries.py:262, a boolean operator was swapped: 'self.wrapped = wrapped or AsyncHTTPTransport()' became 'self.wrapped = wrapped and AsyncHTTPTransport()'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/test_tenacity.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/retries.py", "original": "self.wrapped = wrapped or AsyncHTTPTransport()", "mutated": "self.wrapped = wrapped and AsyncHTTPTransport()", "line_num": 262}, "source": "discovered", "category": "retries", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_tenacity.py::TestAsyncTenacityTransport::test_successful_request\n\nError: AssertionError: assert <Response [200 OK]> is <Mock name='mock.handle_async_request()' spec='Response' id='4413579280'>\n\nTraceback:\n______________ TestAsyncTenacityTransport.test_successful_request ______________\n\nself = <tests.test_tenacity.TestAsyncTenacityTransport object at 0x1071cbed0>\n\n    async def test_successful_request(self):\n        \"\"\"Test that successful requests pass through without retry.\"\"\"\n        mock_transport = AsyncMock(spec=httpx.AsyncBaseTransport)\n        mock_response = Mock(spec=httpx.Response)\n        mock_transport.handle_async_request.return_value = mock_response\n    \n        config = RetryConfig(stop=stop_after_attempt(3), reraise=True)\n        transport = AsyncTenacityTransport(config, mock_transport)\n    \n        request = httpx.Request('GET', 'https://example.com')\n        async with transport:\n            result = await transport.handle_async_request(request)\n    \n>       assert result is mock_response\nE       AssertionError: assert <Response [200 OK]> is <Mock name='mock.handle_async_request()' spec='Response' id='4413579280'>\n\ntests/test_tenacity.py: AssertionError"}
{"task_id": "d-ssrf-L173-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _ssrf.py:173, a boolean operator was swapped: 'path = parsed.path or '/'' became 'path = parsed.path and '/''. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/test_ssrf.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "path = parsed.path or '/'", "mutated": "path = parsed.path and '/'", "line_num": 173}, "source": "discovered", "category": "ssrf", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_ssrf.py::TestExtractHostAndPort::test_basic_http_url\n\nError: AssertionError: assert '/' == '/path'\n\nTraceback:\n__________________ TestExtractHostAndPort.test_basic_http_url __________________\n\nself = <tests.test_ssrf.TestExtractHostAndPort object at 0x10529e050>\n\n    def test_basic_http_url(self) -> None:\n        hostname, path, port, is_https = extract_host_and_port('http://example.com/path')\n        assert hostname == 'example.com'\n>       assert path == '/path'\nE       AssertionError: assert '/' == '/path'\nE         \nE         - /path\nE         + /\n\ntests/test_ssrf.py: AssertionError"}
{"task_id": "d-tools-L244-comparison_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In tools.py:244, the comparison operator was changed: 'if extra == 'allow':' became 'if extra != 'allow':'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_tools.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/tools.py", "original": "if extra == 'allow':", "mutated": "if extra != 'allow':", "line_num": 244}, "source": "discovered", "category": "tools", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: tests/test_tools.py::test_docstring_google[google]\n\nError: AssertionError: assert {'description...cstring', ...} == {'description...cstring', ...}\n\nTraceback:\n________________________ test_docstring_google[google] _________________________\n\ndocstring_format = 'google'\n\n    @pytest.mark.parametrize('docstring_format', ['google', 'auto'])\n    def test_docstring_google(docstring_format: Literal['google', 'auto']):\n        agent = Agent(FunctionModel(get_json_schema))\n        agent.tool_plain(docstring_format=docstring_format)(google_style_docstring)\n    \n        result = agent.run_sync('Hello')\n        json_schema = json.loads(result.output)\n>       assert json_schema == snapshot(\n            {\n                'name': 'google_style_docstring',\n                'description': 'Do foobar stuff, a lot.',\n                'parameters_json_schema': {\n                    'properties': {\n                        'foo': {'description': 'The foo thing.', 'type': 'integer'},\n                        'bar': {'description': 'The bar thing.', 'type': 'string'},\n                    },\n                    'required': ['foo', 'bar'],\n                    'type': 'object',\n                    'additionalProperties': False,\n                },\n                'outer_typed_dict_key': None,\n    ..."}
{"task_id": "d-usage-L92-arithmetic_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In usage.py:92, an arithmetic operator was changed: 'result[prefix + key] = value' became 'result[prefix - key] = value'. This produces wrong numeric results.", "vague_description": "A numerical calculation gives wrong output. The math is off — values are larger or smaller than expected by a consistent amount.", "test_cmd": "python -m pytest tests/test_usage_limits.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/usage.py", "original": "result[prefix + key] = value", "mutated": "result[prefix - key] = value", "line_num": 92}, "source": "discovered", "category": "usage", "mutation_type": "arithmetic_swap", "dev_report_description": "Test failure: tests/test_usage_limits.py::test_multi_agent_usage_no_incr\n\nError: TypeError: unsupported operand type(s) for -: 'str' and 'str'\n\nTraceback:\n________________________ test_multi_agent_usage_no_incr ________________________\n\n    async def test_multi_agent_usage_no_incr():\n        delegate_agent = Agent(TestModel(), output_type=int)\n    \n        controller_agent1 = Agent(TestModel())\n        run_1_usages: list[RunUsage] = []\n    \n        @controller_agent1.tool\n        async def delegate_to_other_agent1(ctx: RunContext[None], sentence: str) -> int:\n            delegate_result = await delegate_agent.run(sentence)\n            delegate_usage = delegate_result.usage()\n            run_1_usages.append(delegate_usage)\n            assert delegate_usage == snapshot(RunUsage(requests=1, input_tokens=51, output_tokens=4))\n            return delegate_result.output\n    \n        result1 = await controller_agent1.run('foobar')\n        assert result1.output == snapshot('{\"delegate_to_other_agent1\":0}')\n        run_1_usages.append(result1.usage())\n        assert result1.usage() == snapshot(RunUsage(requests=2, input_tokens=103, output_tokens=13, tool_calls=1))\n    \n        controller_agent2 = Agent(TestModel())\n    \n        @controller_agent2.tool\n        async def delegate_to_other_agent2(ctx: RunContext[None], sentence: str) -> int:\n    ..."}
{"task_id": "d-utils-L220-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _utils.py:220, a None check was inverted: 'if task is None:' became 'if task is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_utils.py", "original": "if task is None:", "mutated": "if task is not None:", "line_num": 220}, "source": "discovered", "category": "utils", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_utils.py::test_group_by_temporal[0-expected1]\n\nError: AttributeError: 'NoneType' object has no attribute 'add_done_callback'\n\nTraceback:\n_____________________ test_group_by_temporal[0-expected1] ______________________\n\ninterval = 0, expected = [[1], [2], [3]]\n\n    @pytest.mark.parametrize(\n        'interval,expected',\n        [\n            (None, snapshot([[1], [2], [3]])),\n            (0, snapshot([[1], [2], [3]])),\n            (0.02, snapshot([[1], [2], [3]])),\n            (0.04, snapshot([[1, 2], [3]])),\n            (0.1, snapshot([[1, 2, 3]])),\n        ],\n    )\n    async def test_group_by_temporal(interval: float | None, expected: list[list[int]]):\n        async def yield_groups() -> AsyncIterator[int]:\n            yield 1\n            await asyncio.sleep(0.02)\n            yield 2\n            await asyncio.sleep(0.02)\n            yield 3\n            await asyncio.sleep(0.02)\n    \n        async with group_by_temporal(yield_groups(), soft_max_interval=interval) as groups_iter:\n>           groups: list[list[int]] = [g async for g in groups_iter]\n    ..."}
{"task_id": "d-concurrency-L190-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In concurrency.py:190, a None check was inverted: 'if self._max_queued is not None and self._waiting_count >= self._max_queued:' became 'if self._max_queued is None and self._waiting_count >= self._max_queued:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_concurrency.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/concurrency.py", "original": "if self._max_queued is not None and self._waiting_count >= self._max_queued:", "mutated": "if self._max_queued is None and self._waiting_count >= self._max_queued:", "line_num": 190}, "source": "discovered", "category": "concurrency", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_concurrency.py::TestConcurrencyLimiter::test_basic_acquisition\n\nError: asyncio.exceptions.CancelledError: Cancelled by cancel scope 107f75f10\n\nTraceback:\n________________ TestConcurrencyLimiter.test_basic_acquisition _________________\n\nself = <tests.test_concurrency.TestConcurrencyLimiter object at 0x107f75ad0>\n\n    async def test_basic_acquisition(self):\n        \"\"\"Test that limiter limits concurrent access.\"\"\"\n        limiter = ConcurrencyLimiter(max_running=2)\n        acquired: list[int] = []\n    \n        async def acquire_and_hold(id: int, hold_time: float):\n            async with get_concurrency_context(limiter, 'test'):\n                acquired.append(id)\n                await anyio.sleep(hold_time)\n    \n        # Start 3 tasks with limit of 2\n        async with anyio.create_task_group() as tg:\n            for i in range(3):\n                tg.start_soon(acquire_and_hold, i, 0.1)\n>           await anyio.sleep(0.05)\n\ntests/test_concurrency.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../anaconda3/envs/vvenv/lib/python3.11/site-packages/anyio/_core/_eventloop.py: in sleep\n    return await get_async_backend().sleep(delay)\n../../anaconda3/envs/vvenv/lib/python3.11/site-packages/anyio/_backends/_asyncio.py: in sleep\n    ..."}
{"task_id": "d-direct-L318-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In direct.py:318, a None check was inverted: 'if item is None:  # End of stream' became 'if item is not None:  # End of stream'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_direct.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/direct.py", "original": "if item is None:  # End of stream", "mutated": "if item is not None:  # End of stream", "line_num": 318}, "source": "discovered", "category": "direct_api", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_direct.py::test_model_request_stream_sync\n\nError: AssertionError: assert [] == [PartStartEve...alls)')), ...]\n\nTraceback:\n________________________ test_model_request_stream_sync ________________________\n\n    def test_model_request_stream_sync():\n        with model_request_stream_sync('test', [ModelRequest.user_text_prompt('x')]) as stream:\n            chunks = list(stream)\n>           assert chunks == snapshot(\n                [\n                    PartStartEvent(index=0, part=TextPart(content='')),\n                    FinalResultEvent(tool_name=None, tool_call_id=None),\n                    PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='success ')),\n                    PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='(no ')),\n                    PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='tool ')),\n                    PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='calls)')),\n                    PartEndEvent(index=0, part=TextPart(content='success (no tool calls)')),\n                ]\n            )\nE           AssertionError: assert [] == [PartStartEve...alls)')), ...]\nE             \nE             Right contains 7 more items, first extra item: PartStartEvent(index=0, part=TextPart(content=''))\nE             Use -v to get more diff\n\ntests/test_direct.py: AssertionError"}
{"task_id": "d-json_schema-L134-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _json_schema.py:134, a None check was inverted: 'if (pattern_properties := schema.get('patternProperties')) is not None:' became 'if (pattern_properties := schema.get('patternProperties')) is None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_json_schema.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_json_schema.py", "original": "if (pattern_properties := schema.get('patternProperties')) is not None:", "mutated": "if (pattern_properties := schema.get('patternProperties')) is None:", "line_num": 134}, "source": "discovered", "category": "json_schema", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_json_schema.py::test_schema_defs_not_modified\n\nError: AttributeError: 'NoneType' object has no attribute 'items'\n\nTraceback:\n________________________ test_schema_defs_not_modified _________________________\n\n    def test_schema_defs_not_modified():\n        \"\"\"Test that the original schema $defs are not modified during transformation.\"\"\"\n    \n        # Create a concrete subclass for testing\n        class TestTransformer(JsonSchemaTransformer):\n            def transform(self, schema: dict[str, Any]) -> dict[str, Any]:\n                return schema\n    \n        # Create a schema with $defs that should not be modified\n        original_schema = {\n            'type': 'object',\n            'properties': {'value': {'$ref': '#/$defs/TestUnion'}},\n            '$defs': {\n                'TestUnion': {\n                    'anyOf': [\n                        {'type': 'string'},\n                        {'type': 'number'},\n                    ],\n                    'title': 'TestUnion',\n                }\n            },\n        }\n    \n    ..."}
{"task_id": "d-parts_manager-L224-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _parts_manager.py:224, a None check was inverted: 'if content is not None or signature is not None or provider_details is not None:' became 'if content is None or signature is not None or provider_details is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_parts_manager.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_parts_manager.py", "original": "if content is not None or signature is not None or provider_details is not None:", "mutated": "if content is None or signature is not None or provider_details is not None:", "line_num": 224}, "source": "discovered", "category": "parts_manager", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_parts_manager.py::test_handle_thinking_delta_no_vendor_id_with_existing_thinking_part\n\nError: AssertionError: pydantic_ai.exceptions.UnexpectedModelBehavior: Cannot create a ThinkingPart with no content, signature, or provider_details\n\nTraceback:\n_____ test_handle_thinking_delta_no_vendor_id_with_existing_thinking_part ______\n\n    def test_handle_thinking_delta_no_vendor_id_with_existing_thinking_part():\n        manager = ModelResponsePartsManager()\n    \n        # Add a thinking part first\n>       event = next(manager.handle_thinking_delta(vendor_part_id='first', content='initial thought', signature=None))\n\ntests/test_parts_manager.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = ModelResponsePartsManager(_parts=[], _vendor_id_to_part_index={})\n\n    def handle_thinking_delta(\n        self,\n        *,\n        vendor_part_id: Hashable | None,\n        content: str | None = None,\n        id: str | None = None,\n        signature: str | None = None,\n        provider_name: str | None = None,\n        provider_details: ProviderDetailsDelta = None,\n    ) -> Iterator[ModelResponseStreamEvent]:\n        \"\"\"Handle incoming thinking content, creating or updating a ThinkingPart in the manager as appropriate.\n    \n    ..."}
{"task_id": "d-ssrf-L148-comparison_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _ssrf.py:148, the comparison operator was changed: 'return scheme, scheme == 'https'' became 'return scheme, scheme != 'https''. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/test_ssrf.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "return scheme, scheme == 'https'", "mutated": "return scheme, scheme != 'https'", "line_num": 148}, "source": "discovered", "category": "ssrf", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: tests/test_ssrf.py::TestValidateUrlProtocol::test_allowed_protocols[http://example.com]\n\nError: AssertionError: assert True == ('http' == 'https'\n\nTraceback:\n______ TestValidateUrlProtocol.test_allowed_protocols[http://example.com] ______\n\nself = <tests.test_ssrf.TestValidateUrlProtocol object at 0x104e17c50>\nurl = 'http://example.com'\n\n    @pytest.mark.parametrize(\n        'url',\n        [\n            'http://example.com',\n            'https://example.com',\n            'HTTP://EXAMPLE.COM',\n            'HTTPS://EXAMPLE.COM',\n        ],\n    )\n    def test_allowed_protocols(self, url: str) -> None:\n        scheme, is_https = validate_url_protocol(url)\n        assert scheme in ('http', 'https')\n>       assert is_https == (scheme == 'https')\nE       AssertionError: assert True == ('http' == 'https'\nE         \nE         - https\nE         ?     -\nE         + http)\n\ntests/test_ssrf.py: AssertionError"}
{"task_id": "d-tools-L246-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In tools.py:246, a None check was inverted: 'if extras_schema is not None:' became 'if extras_schema is None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_tools.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/tools.py", "original": "if extras_schema is not None:", "mutated": "if extras_schema is None:", "line_num": 246}, "source": "discovered", "category": "tools", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_tools.py::test_docstring_unknown\n\nError: AssertionError: assert {'description...cstring', ...} == {'description...cstring', ...}\n\nTraceback:\n____________________________ test_docstring_unknown ____________________________\n\n    def test_docstring_unknown():\n        agent = Agent(FunctionModel(get_json_schema))\n        agent.tool_plain(unknown_docstring)\n    \n        result = agent.run_sync('Hello')\n        json_schema = json.loads(result.output)\n>       assert json_schema == snapshot(\n            {\n                'name': 'unknown_docstring',\n                'description': 'Unknown style docstring.',\n                'parameters_json_schema': {'additionalProperties': {'type': 'integer'}, 'properties': {}, 'type': 'object'},\n                'outer_typed_dict_key': None,\n                'strict': None,\n                'kind': 'function',\n                'sequential': False,\n                'metadata': None,\n                'timeout': None,\n            }\n        )\nE       AssertionError: assert {'description...cstring', ...} == {'description...cstring', ...}\nE         \nE         Omitting 8 identical items, use -vv to show\nE         Differing items:\n    ..."}
{"task_id": "d-usage-L350-none_check_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In usage.py:350, a None check was inverted: 'self.output_tokens_limit = output_tokens_limit if output_tokens_limit is not None else response_tokens_limit' became 'self.output_tokens_limit = output_tokens_limit if output_tokens_limit is None else response_tokens_limit'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_usage_limits.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/usage.py", "original": "self.output_tokens_limit = output_tokens_limit if output_tokens_limit is not None else response_tokens_limit", "mutated": "self.output_tokens_limit = output_tokens_limit if output_tokens_limit is None else response_tokens_limit", "line_num": 350}, "source": "discovered", "category": "usage", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: tests/test_usage_limits.py::test_response_token_limit\n\nError: Failed: DID NOT RAISE <class 'pydantic_ai.exceptions.UsageLimitExceeded'>\n\nTraceback:\n__________________________ test_response_token_limit ___________________________\n\n    def test_response_token_limit() -> None:\n        test_agent = Agent(\n            TestModel(custom_output_text='Unfortunately, this response exceeds the response tokens limit by a few!')\n        )\n    \n>       with pytest.raises(UsageLimitExceeded, match=re.escape('Exceeded the output_tokens_limit of 5 (output_tokens=11)')):\nE       Failed: DID NOT RAISE <class 'pydantic_ai.exceptions.UsageLimitExceeded'>\n\ntests/test_usage_limits.py: Failed"}
{"task_id": "d-utils-L116-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _utils.py:116, a boolean operator was swapped: 'and not _contains_ref(resolved)' became 'or not _contains_ref(resolved)'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_utils.py", "original": "and not _contains_ref(resolved)", "mutated": "or not _contains_ref(resolved)", "line_num": 116}, "source": "discovered", "category": "utils", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_utils.py::test_check_object_json_schema\n\nError: AssertionError: assert {'properties'...pe': 'object'} == {'$defs': {'J...fs/JsonModel'}\n\nTraceback:\n________________________ test_check_object_json_schema _________________________\n\n    def test_check_object_json_schema():\n        object_schema = {'type': 'object', 'properties': {'a': {'type': 'string'}}}\n        assert check_object_json_schema(object_schema) == object_schema\n    \n        assert check_object_json_schema(\n            {\n                '$defs': {\n                    'JsonModel': {\n                        'properties': {\n                            'type': {'title': 'Type', 'type': 'string'},\n                            'items': {'anyOf': [{'type': 'string'}, {'type': 'null'}]},\n                        },\n                        'required': ['type', 'items'],\n                        'title': 'JsonModel',\n                        'type': 'object',\n                    }\n                },\n                '$ref': '#/$defs/JsonModel',\n            }\n        ) == {\n            'properties': {\n                'items': {'anyOf': [{'type': 'string'}, {'type': 'null'}]},\n                'type': {'title': 'Type', 'type': 'string'},\n    ..."}
{"task_id": "d-messages-L566-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In messages.py:566, a boolean operator was swapped: 'return self._identifier or _multi_modal_content_identifier(self.data)' became 'return self._identifier and _multi_modal_content_identifier(self.data)'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/test_messages.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/messages.py", "original": "return self._identifier or _multi_modal_content_identifier(self.data)", "mutated": "return self._identifier and _multi_modal_content_identifier(self.data)", "line_num": 566}, "source": "discovered", "category": "messages", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_messages.py::test_file_part_serialization_roundtrip\n\nError: AssertionError: assert [{'finish_rea...': None, ...}] == [{'finish_rea...': None, ...}]\n\nTraceback:\n____________________ test_file_part_serialization_roundtrip ____________________\n\n    def test_file_part_serialization_roundtrip():\n        # Verify that a serialized BinaryImage doesn't come back as a BinaryContent.\n        messages: list[ModelMessage] = [\n            ModelResponse(parts=[FilePart(content=BinaryImage(data=b'fake', media_type='image/jpeg'))])\n        ]\n        serialized = ModelMessagesTypeAdapter.dump_python(messages, mode='json')\n>       assert serialized == snapshot(\n            [\n                {\n                    'parts': [\n                        {\n                            'content': {\n                                'data': 'ZmFrZQ==',\n                                'media_type': 'image/jpeg',\n                                'identifier': 'c053ec',\n                                'vendor_metadata': None,\n                                'kind': 'binary',\n                            },\n                            'id': None,\n                            'provider_name': None,\n                            'part_kind': 'file',\n                            'provider_details': None,\n                        }\n    ..."}
{"task_id": "d-instrumented-L139-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In instrumented.py:139, a boolean operator was swapped: 'meter_provider = meter_provider or get_meter_provider()' became 'meter_provider = meter_provider and get_meter_provider()'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/test_direct.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/models/instrumented.py", "original": "meter_provider = meter_provider or get_meter_provider()", "mutated": "meter_provider = meter_provider and get_meter_provider()", "line_num": 139}, "source": "discovered", "category": "models", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_direct.py::test_prepare_model\n\nError: AttributeError: 'NoneType' object has no attribute 'get_meter'\n\nTraceback:\n______________________________ test_prepare_model ______________________________\n\n    def test_prepare_model():\n        with set_instrument_default(False):\n            model = _prepare_model('test', None)\n            assert isinstance(model, TestModel)\n    \n>           model = _prepare_model('test', True)\n\ntests/test_direct.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/direct.py: in _prepare_model\n    return instrumented_models.instrument_model(model_instance, instrument)\npydantic_ai_slim/pydantic_ai/models/instrumented.py: in instrument_model\n    instrument = InstrumentationSettings()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = InstrumentationSettings(event_mode='attributes', include_binary_content=True, include_content=True, version=2)\n\n    def __init__(\n        self,\n        *,\n        tracer_provider: TracerProvider | None = None,\n        meter_provider: MeterProvider | None = None,\n        include_binary_content: bool = True,\n    ..."}
{"task_id": "d-parts_manager-L143-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _parts_manager.py:143, a condition was inverted: 'elif isinstance(existing_part, TextPart):' became 'elif not isinstance(existing_part, TextPart):'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/test_parts_manager.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_parts_manager.py", "original": "elif isinstance(existing_part, TextPart):", "mutated": "elif not isinstance(existing_part, TextPart):", "line_num": 143}, "source": "discovered", "category": "parts_manager", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_parts_manager.py::test_handle_text_deltas[content]\n\nError: AssertionError: pydantic_ai.exceptions.UnexpectedModelBehavior: Cannot apply a text delta to existing_part=TextPart(content='hello ')\n\nTraceback:\n_______________________ test_handle_text_deltas[content] _______________________\n\nvendor_part_id = 'content'\n\n    @pytest.mark.parametrize('vendor_part_id', [None, 'content'])\n    def test_handle_text_deltas(vendor_part_id: str | None):\n        manager = ModelResponsePartsManager()\n        assert manager.get_parts() == []\n    \n        event = next(manager.handle_text_delta(vendor_part_id=vendor_part_id, content='hello '))\n        assert event == snapshot(\n            PartStartEvent(index=0, part=TextPart(content='hello ', part_kind='text'), event_kind='part_start')\n        )\n        assert manager.get_parts() == snapshot([TextPart(content='hello ', part_kind='text')])\n    \n>       event = next(manager.handle_text_delta(vendor_part_id=vendor_part_id, content='world'))\n\ntests/test_parts_manager.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = ModelResponsePartsManager(_parts=[TextPart(content='hello ')], _vendor_id_to_part_index={'content': 0})\n\n    def handle_text_delta(\n        self,\n        *,\n    ..."}
{"task_id": "d-ssrf-L293-constant_mutation", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _ssrf.py:293, a constant was changed: 'base_path = parsed_current.path.rsplit('/', 1)[0]' became 'base_path = parsed_current.path.rsplit('/', 0)[0]'. This shifts a boundary or default.", "vague_description": "A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.", "test_cmd": "python -m pytest tests/test_ssrf.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "base_path = parsed_current.path.rsplit('/', 1)[0]", "mutated": "base_path = parsed_current.path.rsplit('/', 0)[0]", "line_num": 293}, "source": "discovered", "category": "ssrf", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: tests/test_ssrf.py::TestResolveRedirectUrl::test_relative_path\n\nError: AssertionError: assert 'https://exam.../new-file.txt' == 'https://exam.../new-file.txt'\n\nTraceback:\n__________________ TestResolveRedirectUrl.test_relative_path ___________________\n\nself = <tests.test_ssrf.TestResolveRedirectUrl object at 0x107b93c10>\n\n    def test_relative_path(self) -> None:\n        \"\"\"Test that relative paths are resolved against the current URL.\"\"\"\n        result = resolve_redirect_url('https://example.com/old/path', 'new-file.txt')\n>       assert result == 'https://example.com/old/new-file.txt'\nE       AssertionError: assert 'https://exam.../new-file.txt' == 'https://exam.../new-file.txt'\nE         \nE         - https://example.com/old/new-file.txt\nE         + https://example.com/old/path/new-file.txt\nE         ?                         +++++\n\ntests/test_ssrf.py: AssertionError"}
{"task_id": "d-tools-L243-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In tools.py:243, a boolean operator was swapped: 'extra = schema.get('extra_behavior') or schema.get('config', {}).get('extra_fields_behavior')' became 'extra = schema.get('extra_behavior') and schema.get('config', {}).get('extra_fields_behavior')'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/test_tools.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/tools.py", "original": "extra = schema.get('extra_behavior') or schema.get('config', {}).get('extra_fields_behavior')", "mutated": "extra = schema.get('extra_behavior') and schema.get('config', {}).get('extra_fields_behavior')", "line_num": 243}, "source": "discovered", "category": "tools", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_tools.py::test_docstring_google[google]\n\nError: AssertionError: assert {'description...cstring', ...} == {'description...cstring', ...}\n\nTraceback:\n________________________ test_docstring_google[google] _________________________\n\ndocstring_format = 'google'\n\n    @pytest.mark.parametrize('docstring_format', ['google', 'auto'])\n    def test_docstring_google(docstring_format: Literal['google', 'auto']):\n        agent = Agent(FunctionModel(get_json_schema))\n        agent.tool_plain(docstring_format=docstring_format)(google_style_docstring)\n    \n        result = agent.run_sync('Hello')\n        json_schema = json.loads(result.output)\n>       assert json_schema == snapshot(\n            {\n                'name': 'google_style_docstring',\n                'description': 'Do foobar stuff, a lot.',\n                'parameters_json_schema': {\n                    'properties': {\n                        'foo': {'description': 'The foo thing.', 'type': 'integer'},\n                        'bar': {'description': 'The bar thing.', 'type': 'string'},\n                    },\n                    'required': ['foo', 'bar'],\n                    'type': 'object',\n                    'additionalProperties': False,\n                },\n                'outer_typed_dict_key': None,\n    ..."}
{"task_id": "d-usage-L114-constant_mutation", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In usage.py:114, a constant was changed: 'return 1' became 'return 0'. This shifts a boundary or default.", "vague_description": "A default value or configuration constant seems wrong. The system uses a different threshold or limit than what's documented.", "test_cmd": "python -m pytest tests/test_usage_limits.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/usage.py", "original": "return 1", "mutated": "return 0", "line_num": 114}, "source": "discovered", "category": "usage", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: tests/test_usage_limits.py::test_request_usage_basics\n\nError: AssertionError: assert 0 == 1\n\nTraceback:\n__________________________ test_request_usage_basics ___________________________\n\n    def test_request_usage_basics():\n        usage = RequestUsage()\n        assert usage.output_audio_tokens == 0\n>       assert usage.requests == 1\nE       assert 0 == 1\nE        +  where 0 = RequestUsage().requests\n\ntests/test_usage_limits.py: AssertionError"}
{"task_id": "d-utils-L129-value_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _utils.py:129, a value was swapped: 'return True' became 'return False'.", "vague_description": "Two related values are mixed up. The system applies the wrong one of two options depending on context.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_utils.py", "original": "return True", "mutated": "return False", "line_num": 129}, "source": "discovered", "category": "utils", "mutation_type": "value_swap", "dev_report_description": "Test failure: tests/test_utils.py::test_check_object_json_schema\n\nError: AssertionError: assert {'properties'...pe': 'object'} == {'$defs': {'J...fs/JsonModel'}\n\nTraceback:\n________________________ test_check_object_json_schema _________________________\n\n    def test_check_object_json_schema():\n        object_schema = {'type': 'object', 'properties': {'a': {'type': 'string'}}}\n        assert check_object_json_schema(object_schema) == object_schema\n    \n        assert check_object_json_schema(\n            {\n                '$defs': {\n                    'JsonModel': {\n                        'properties': {\n                            'type': {'title': 'Type', 'type': 'string'},\n                            'items': {'anyOf': [{'type': 'string'}, {'type': 'null'}]},\n                        },\n                        'required': ['type', 'items'],\n                        'title': 'JsonModel',\n                        'type': 'object',\n                    }\n                },\n                '$ref': '#/$defs/JsonModel',\n            }\n        ) == {\n            'properties': {\n                'items': {'anyOf': [{'type': 'string'}, {'type': 'null'}]},\n                'type': {'title': 'Type', 'type': 'string'},\n    ..."}
{"task_id": "d-json_schema-L162-comparison_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _json_schema.py:162, the comparison operator was changed: 'if len(handled) == 1:' became 'if len(handled) != 1:'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_json_schema.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_json_schema.py", "original": "if len(handled) == 1:", "mutated": "if len(handled) != 1:", "line_num": 162}, "source": "discovered", "category": "json_schema", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: tests/test_json_schema.py::test_simplify_nullable_unions\n\nError: AssertionError: assert {'anyOf': [{'...': 'string'}]} == {'nullable': ...pe': 'string'}\n\nTraceback:\n________________________ test_simplify_nullable_unions _________________________\n\n    def test_simplify_nullable_unions():\n        \"\"\"Test the simplify_nullable_unions feature (deprecated, to be removed in v2).\"\"\"\n    \n        # Create a concrete subclass for testing\n        class TestTransformer(JsonSchemaTransformer):\n            def transform(self, schema: dict[str, Any]) -> dict[str, Any]:\n                return schema\n    \n        # Test with simplify_nullable_unions=True\n        schema_with_null = {\n            'anyOf': [\n                {'type': 'string'},\n                {'type': 'null'},\n            ]\n        }\n        transformer = TestTransformer(schema_with_null, simplify_nullable_unions=True)\n        result = transformer.walk()\n    \n        # Should collapse to a single nullable string\n>       assert result == {'type': 'string', 'nullable': True}\nE       AssertionError: assert {'anyOf': [{'...': 'string'}]} == {'nullable': ...pe': 'string'}\nE         \nE         Left contains 1 more item:\n    ..."}
{"task_id": "d-instrumented-L138-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In instrumented.py:138, a boolean operator was swapped: 'tracer_provider = tracer_provider or get_tracer_provider()' became 'tracer_provider = tracer_provider and get_tracer_provider()'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/test_direct.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/models/instrumented.py", "original": "tracer_provider = tracer_provider or get_tracer_provider()", "mutated": "tracer_provider = tracer_provider and get_tracer_provider()", "line_num": 138}, "source": "discovered", "category": "models", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_direct.py::test_prepare_model\n\nError: AttributeError: 'NoneType' object has no attribute 'get_tracer'\n\nTraceback:\n______________________________ test_prepare_model ______________________________\n\n    def test_prepare_model():\n        with set_instrument_default(False):\n            model = _prepare_model('test', None)\n            assert isinstance(model, TestModel)\n    \n>           model = _prepare_model('test', True)\n\ntests/test_direct.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/direct.py: in _prepare_model\n    return instrumented_models.instrument_model(model_instance, instrument)\npydantic_ai_slim/pydantic_ai/models/instrumented.py: in instrument_model\n    instrument = InstrumentationSettings()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = InstrumentationSettings(event_mode='attributes', include_binary_content=True, include_content=True, version=2)\n\n    def __init__(\n        self,\n        *,\n        tracer_provider: TracerProvider | None = None,\n        meter_provider: MeterProvider | None = None,\n        include_binary_content: bool = True,\n    ..."}
{"task_id": "d-parts_manager-L230-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _parts_manager.py:230, a boolean operator was swapped: 'content=content or '',' became 'content=content and '','. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/test_parts_manager.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_parts_manager.py", "original": "content=content or '',", "mutated": "content=content and '',", "line_num": 230}, "source": "discovered", "category": "parts_manager", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_parts_manager.py::test_handle_thinking_delta_no_vendor_id_with_existing_thinking_part\n\nError: AssertionError: assert [ThinkingPart...tent=' more')] == [ThinkingPart...hought more')]\n\nTraceback:\n_____ test_handle_thinking_delta_no_vendor_id_with_existing_thinking_part ______\n\n    def test_handle_thinking_delta_no_vendor_id_with_existing_thinking_part():\n        manager = ModelResponsePartsManager()\n    \n        # Add a thinking part first\n        event = next(manager.handle_thinking_delta(vendor_part_id='first', content='initial thought', signature=None))\n        assert isinstance(event, PartStartEvent)\n        assert event.index == 0\n    \n        # Now add another thinking delta with no vendor_part_id - should update the latest thinking part\n        event = next(manager.handle_thinking_delta(vendor_part_id=None, content=' more', signature=None))\n        assert isinstance(event, PartDeltaEvent)\n        assert event.index == 0\n    \n        parts = manager.get_parts()\n>       assert parts == snapshot([ThinkingPart(content='initial thought more')])\nE       AssertionError: assert [ThinkingPart...tent=' more')] == [ThinkingPart...hought more')]\nE         \nE         At index 0 diff: ThinkingPart(content=' more') != ThinkingPart(content='initial thought more')\nE         Use -v to get more diff\n\ntests/test_parts_manager.py: AssertionError"}
{"task_id": "d-ssrf-L97-value_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _ssrf.py:97, a value was swapped: 'return True' became 'return False'.", "vague_description": "Two values appear to be swapped. The system uses value A where it should use value B, and value B where it should use value A.", "test_cmd": "python -m pytest tests/test_ssrf.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "return True", "mutated": "return False", "line_num": 97}, "source": "discovered", "category": "ssrf", "mutation_type": "value_swap", "dev_report_description": "Test failure: tests/test_ssrf.py::TestIsPrivateIp::test_invalid_ip_treated_as_private\n\nError: AssertionError: assert False is True\n\nTraceback:\n______________ TestIsPrivateIp.test_invalid_ip_treated_as_private ______________\n\nself = <tests.test_ssrf.TestIsPrivateIp object at 0x15837b250>\n\n    def test_invalid_ip_treated_as_private(self) -> None:\n        \"\"\"Invalid IP addresses should be treated as potentially dangerous.\"\"\"\n>       assert is_private_ip('not-an-ip') is True\nE       AssertionError: assert False is True\nE        +  where False = is_private_ip('not-an-ip')\n\ntests/test_ssrf.py: AssertionError"}
{"task_id": "d-usage-L158-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In usage.py:158, a boolean operator was swapped: 'details = details or {}' became 'details = details and {}'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/test_usage_limits.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/usage.py", "original": "details = details or {}", "mutated": "details = details and {}", "line_num": 158}, "source": "discovered", "category": "usage", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_usage_limits.py::test_usage_unknown_provider\n\nError: AssertionError: assert RequestUsage() == RequestUsage()\n\nTraceback:\n_________________________ test_usage_unknown_provider __________________________\n\n    def test_usage_unknown_provider():\n>       assert RequestUsage.extract({}, provider='unknown', provider_url='', provider_fallback='') == RequestUsage()\nE       AssertionError: assert RequestUsage() == RequestUsage()\nE         \nE         Omitting 7 identical items, use -vv to show\nE         Differing attributes:\nE         ['details']\nE         \nE         Drill down into differing attribute details:\nE           details: None != {}\n\ntests/test_usage_limits.py: AssertionError"}
{"task_id": "d-json_schema-L183-value_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _json_schema.py:183, a value was swapped: 'new_schema['nullable'] = True' became 'new_schema['nullable'] = False'.", "vague_description": "Two values appear to be swapped. The system uses value A where it should use value B, and value B where it should use value A.", "test_cmd": "python -m pytest tests/test_json_schema.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_json_schema.py", "original": "new_schema['nullable'] = True", "mutated": "new_schema['nullable'] = False", "line_num": 183}, "source": "discovered", "category": "json_schema", "mutation_type": "value_swap", "dev_report_description": "Test failure: tests/test_json_schema.py::test_simplify_nullable_unions\n\nError: AssertionError: assert {'nullable': ...pe': 'string'} == {'nullable': ...pe': 'string'}\n\nTraceback:\n________________________ test_simplify_nullable_unions _________________________\n\n    def test_simplify_nullable_unions():\n        \"\"\"Test the simplify_nullable_unions feature (deprecated, to be removed in v2).\"\"\"\n    \n        # Create a concrete subclass for testing\n        class TestTransformer(JsonSchemaTransformer):\n            def transform(self, schema: dict[str, Any]) -> dict[str, Any]:\n                return schema\n    \n        # Test with simplify_nullable_unions=True\n        schema_with_null = {\n            'anyOf': [\n                {'type': 'string'},\n                {'type': 'null'},\n            ]\n        }\n        transformer = TestTransformer(schema_with_null, simplify_nullable_unions=True)\n        result = transformer.walk()\n    \n        # Should collapse to a single nullable string\n>       assert result == {'type': 'string', 'nullable': True}\nE       AssertionError: assert {'nullable': ...pe': 'string'} == {'nullable': ...pe': 'string'}\nE         \nE         Omitting 1 identical items, use -vv to show\n    ..."}
{"task_id": "d-messages-L641-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In messages.py:641, a condition was inverted: 'if not self.is_image:' became 'if self.is_image:'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/test_messages.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/messages.py", "original": "if not self.is_image:", "mutated": "if self.is_image:", "line_num": 641}, "source": "discovered", "category": "messages", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_messages.py::test_binary_image_requires_image_media_type\n\nError: pydantic_core._pydantic_core.ValidationError: 1 validation error for BinaryImage\n\nTraceback:\n_________________ test_binary_image_requires_image_media_type __________________\n\n    def test_binary_image_requires_image_media_type():\n        # Valid image media type should work\n>       img = BinaryImage(data=b'test', media_type='image/png')\nE       pydantic_core._pydantic_core.ValidationError: 1 validation error for BinaryImage\nE         Value error, `BinaryImage` must have a media type that starts with \"image/\" [type=value_error, input_value=ArgsKwargs((), {'data': b...dia_type': 'image/png'}), input_type=ArgsKwargs]\nE           For further information visit https://errors.pydantic.dev/2.10/v/value_error\n\ntests/test_messages.py: ValidationError"}
{"task_id": "d-parts_manager-L219-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _parts_manager.py:219, a condition was inverted: 'if not isinstance(existing_part, ThinkingPart):' became 'if isinstance(existing_part, ThinkingPart):'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/test_parts_manager.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_parts_manager.py", "original": "if not isinstance(existing_part, ThinkingPart):", "mutated": "if isinstance(existing_part, ThinkingPart):", "line_num": 219}, "source": "discovered", "category": "parts_manager", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_parts_manager.py::test_handle_thinking_delta_wrong_part_type\n\nError: ValueError: Cannot apply ThinkingPartDeltas to non-ThinkingParts or non-ThinkingPartDeltas (part=TextPart(content='hello'), self=ThinkingPartDelta(content_delta='thinking'))\n\nTraceback:\n__________________ test_handle_thinking_delta_wrong_part_type __________________\n\n    def test_handle_thinking_delta_wrong_part_type():\n        manager = ModelResponsePartsManager()\n    \n        # Add a text part first\n        list(manager.handle_text_delta(vendor_part_id='text', content='hello'))\n    \n        # Try to apply thinking delta to the text part - should raise error\n        with pytest.raises(UnexpectedModelBehavior, match=r'Cannot apply a thinking delta to existing_part='):\n>           list(manager.handle_thinking_delta(vendor_part_id='text', content='thinking', signature=None))\n\ntests/test_parts_manager.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npydantic_ai_slim/pydantic_ai/_parts_manager.py: in handle_thinking_delta\n    self._parts[part_index] = part_delta.apply(existing_thinking_part)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = ThinkingPartDelta(content_delta='thinking')\npart = TextPart(content='hello')\n\n    def apply(self, part: ModelResponsePart | ThinkingPartDelta) -> ThinkingPart | ThinkingPartDelta:\n        \"\"\"Apply this thinking delta to an existing `ThinkingPart`.\n    \n        Args:\n    ..."}
{"task_id": "d-ssrf-L123-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _ssrf.py:123, a condition was inverted: 'if not ips:' became 'if ips:'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/test_ssrf.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "if not ips:", "mutated": "if ips:", "line_num": 123}, "source": "discovered", "category": "ssrf", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_ssrf.py::TestResolveHostname::test_resolve_success\n\nError: ValueError: DNS resolution failed for hostname: example.com\n\nTraceback:\n___________________ TestResolveHostname.test_resolve_success ___________________\n\nself = <tests.test_ssrf.TestResolveHostname object at 0x114da5090>\n\n    async def test_resolve_success(self) -> None:\n        \"\"\"Test that hostname resolution returns IP addresses.\"\"\"\n        with patch('pydantic_ai._ssrf.run_in_executor') as mock_executor:\n            mock_executor.return_value = [\n                (2, 1, 6, '', ('93.184.215.14', 0)),\n                (2, 1, 6, '', ('93.184.215.14', 0)),  # Duplicate should be removed\n            ]\n>           ips = await resolve_hostname('example.com')\n\ntests/test_ssrf.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhostname = 'example.com'\n\n    async def resolve_hostname(hostname: str) -> list[str]:\n        \"\"\"Resolve a hostname to its IP addresses using DNS.\n    \n        Uses run_in_executor to run DNS resolution in a thread pool to avoid blocking.\n    \n        Returns:\n            List of IP address strings, preserving DNS order with duplicates removed.\n    ..."}
{"task_id": "d-utils-L127-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _utils.py:127, a condition was inverted: 'if isinstance(obj, dict):' became 'if not isinstance(obj, dict):'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_utils.py", "original": "if isinstance(obj, dict):", "mutated": "if not isinstance(obj, dict):", "line_num": 127}, "source": "discovered", "category": "utils", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_utils.py::test_check_object_json_schema\n\nError: AssertionError: assert {'properties'...pe': 'object'} == {'$defs': {'J...fs/JsonModel'}\n\nTraceback:\n________________________ test_check_object_json_schema _________________________\n\n    def test_check_object_json_schema():\n        object_schema = {'type': 'object', 'properties': {'a': {'type': 'string'}}}\n        assert check_object_json_schema(object_schema) == object_schema\n    \n        assert check_object_json_schema(\n            {\n                '$defs': {\n                    'JsonModel': {\n                        'properties': {\n                            'type': {'title': 'Type', 'type': 'string'},\n                            'items': {'anyOf': [{'type': 'string'}, {'type': 'null'}]},\n                        },\n                        'required': ['type', 'items'],\n                        'title': 'JsonModel',\n                        'type': 'object',\n                    }\n                },\n                '$ref': '#/$defs/JsonModel',\n            }\n        ) == {\n            'properties': {\n                'items': {'anyOf': [{'type': 'string'}, {'type': 'null'}]},\n                'type': {'title': 'Type', 'type': 'string'},\n    ..."}
{"task_id": "d-json_schema-L64-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _json_schema.py:64, a boolean operator was swapped: 'if not self.prefer_inlined_defs and self.defs:' became 'if not self.prefer_inlined_defs or self.defs:'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/test_json_schema.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_json_schema.py", "original": "if not self.prefer_inlined_defs and self.defs:", "mutated": "if not self.prefer_inlined_defs or self.defs:", "line_num": 64}, "source": "discovered", "category": "json_schema", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_json_schema.py::test_simplify_nullable_unions\n\nError: AssertionError: assert {'$defs': {},...pe': 'string'} == {'nullable': ...pe': 'string'}\n\nTraceback:\n________________________ test_simplify_nullable_unions _________________________\n\n    def test_simplify_nullable_unions():\n        \"\"\"Test the simplify_nullable_unions feature (deprecated, to be removed in v2).\"\"\"\n    \n        # Create a concrete subclass for testing\n        class TestTransformer(JsonSchemaTransformer):\n            def transform(self, schema: dict[str, Any]) -> dict[str, Any]:\n                return schema\n    \n        # Test with simplify_nullable_unions=True\n        schema_with_null = {\n            'anyOf': [\n                {'type': 'string'},\n                {'type': 'null'},\n            ]\n        }\n        transformer = TestTransformer(schema_with_null, simplify_nullable_unions=True)\n        result = transformer.walk()\n    \n        # Should collapse to a single nullable string\n>       assert result == {'type': 'string', 'nullable': True}\nE       AssertionError: assert {'$defs': {},...pe': 'string'} == {'nullable': ...pe': 'string'}\nE         \nE         Omitting 2 identical items, use -vv to show\n    ..."}
{"task_id": "d-messages-L224-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In messages.py:224, a boolean operator was swapped: 'return self._media_type or self._infer_media_type()' became 'return self._media_type and self._infer_media_type()'. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/test_messages.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/messages.py", "original": "return self._media_type or self._infer_media_type()", "mutated": "return self._media_type and self._infer_media_type()", "line_num": 224}, "source": "discovered", "category": "messages", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_messages.py::test_image_url\n\nError: AssertionError: assert None == 'image/jpeg'\n\nTraceback:\n________________________________ test_image_url ________________________________\n\n    def test_image_url():\n        image_url = ImageUrl(url='https://example.com/image.jpg')\n>       assert image_url.media_type == 'image/jpeg'\nE       AssertionError: assert None == 'image/jpeg'\nE        +  where None = ImageUrl(url='https://example.com/image.jpg').media_type\n\ntests/test_messages.py: AssertionError"}
{"task_id": "d-ssrf-L119-constant_mutation", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _ssrf.py:119, a constant was changed: 'ip = str(result[4][0])' became 'ip = str(result[5][0])'. This shifts a boundary or default.", "vague_description": "A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.", "test_cmd": "python -m pytest tests/test_ssrf.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "ip = str(result[4][0])", "mutated": "ip = str(result[5][0])", "line_num": 119}, "source": "discovered", "category": "ssrf", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: tests/test_ssrf.py::TestResolveHostname::test_resolve_success\n\nError: IndexError: tuple index out of range\n\nTraceback:\n___________________ TestResolveHostname.test_resolve_success ___________________\n\nself = <tests.test_ssrf.TestResolveHostname object at 0x10b2a4b90>\n\n    async def test_resolve_success(self) -> None:\n        \"\"\"Test that hostname resolution returns IP addresses.\"\"\"\n        with patch('pydantic_ai._ssrf.run_in_executor') as mock_executor:\n            mock_executor.return_value = [\n                (2, 1, 6, '', ('93.184.215.14', 0)),\n                (2, 1, 6, '', ('93.184.215.14', 0)),  # Duplicate should be removed\n            ]\n>           ips = await resolve_hostname('example.com')\n\ntests/test_ssrf.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhostname = 'example.com'\n\n    async def resolve_hostname(hostname: str) -> list[str]:\n        \"\"\"Resolve a hostname to its IP addresses using DNS.\n    \n        Uses run_in_executor to run DNS resolution in a thread pool to avoid blocking.\n    \n        Returns:\n            List of IP address strings, preserving DNS order with duplicates removed.\n    ..."}
{"task_id": "d-utils-L114-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _utils.py:114, a boolean operator was swapped: 'and (resolved := schema.get('$defs', {}).get(ref[len(prefix) :]))' became 'or (resolved := schema.get('$defs', {}).get(ref[len(prefix) :]))'. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_utils.py", "original": "and (resolved := schema.get('$defs', {}).get(ref[len(prefix) :]))", "mutated": "or (resolved := schema.get('$defs', {}).get(ref[len(prefix) :]))", "line_num": 114}, "source": "discovered", "category": "utils", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_utils.py::test_check_object_json_schema\n\nError: UnboundLocalError: cannot access local variable 'resolved' where it is not associated with a value\n\nTraceback:\n________________________ test_check_object_json_schema _________________________\n\n    def test_check_object_json_schema():\n        object_schema = {'type': 'object', 'properties': {'a': {'type': 'string'}}}\n        assert check_object_json_schema(object_schema) == object_schema\n    \n>       assert check_object_json_schema(\n            {\n                '$defs': {\n                    'JsonModel': {\n                        'properties': {\n                            'type': {'title': 'Type', 'type': 'string'},\n                            'items': {'anyOf': [{'type': 'string'}, {'type': 'null'}]},\n                        },\n                        'required': ['type', 'items'],\n                        'title': 'JsonModel',\n                        'type': 'object',\n                    }\n                },\n                '$ref': '#/$defs/JsonModel',\n            }\n        ) == {\n            'properties': {\n                'items': {'anyOf': [{'type': 'string'}, {'type': 'null'}]},\n                'type': {'title': 'Type', 'type': 'string'},\n    ..."}
{"task_id": "d-messages-L241-boolean_flip", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In messages.py:241, a boolean operator was swapped: 'return self._identifier or _multi_modal_content_identifier(self.url)' became 'return self._identifier and _multi_modal_content_identifier(self.url)'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/test_messages.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/messages.py", "original": "return self._identifier or _multi_modal_content_identifier(self.url)", "mutated": "return self._identifier and _multi_modal_content_identifier(self.url)", "line_num": 241}, "source": "discovered", "category": "messages", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: tests/test_messages.py::test_image_url_validation_with_optional_identifier\n\nError: AssertionError: assert None == '39cfc4'\n\nTraceback:\n______________ test_image_url_validation_with_optional_identifier ______________\n\n    def test_image_url_validation_with_optional_identifier():\n        image_url_ta = TypeAdapter(ImageUrl)\n        image = image_url_ta.validate_python({'url': 'https://example.com/image.jpg'})\n        assert image.url == snapshot('https://example.com/image.jpg')\n>       assert image.identifier == snapshot('39cfc4')\nE       AssertionError: assert None == '39cfc4'\nE        +  where None = ImageUrl(url='https://example.com/image.jpg').identifier\nE        +  and   '39cfc4' = snapshot('39cfc4')\n\ntests/test_messages.py: AssertionError"}
{"task_id": "d-ssrf-L188-constant_mutation", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _ssrf.py:188, a constant was changed: 'default_port = 443 if resolved.is_https else 80' became 'default_port = 444 if resolved.is_https else 80'. This shifts a boundary or default.", "vague_description": "A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.", "test_cmd": "python -m pytest tests/test_ssrf.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_ssrf.py", "original": "default_port = 443 if resolved.is_https else 80", "mutated": "default_port = 444 if resolved.is_https else 80", "line_num": 188}, "source": "discovered", "category": "ssrf", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: tests/test_ssrf.py::TestBuildUrlWithIp::test_https_default_port\n\nError: AssertionError: assert 'https://203....3.50:443/path' == 'https://203.0.113.50/path'\n\nTraceback:\n__________________ TestBuildUrlWithIp.test_https_default_port __________________\n\nself = <tests.test_ssrf.TestBuildUrlWithIp object at 0x107791b50>\n\n    def test_https_default_port(self) -> None:\n        resolved = ResolvedUrl(\n            resolved_ip='203.0.113.50', hostname='example.com', port=443, is_https=True, path='/path'\n        )\n        url = build_url_with_ip(resolved)\n>       assert url == 'https://203.0.113.50/path'\nE       AssertionError: assert 'https://203....3.50:443/path' == 'https://203.0.113.50/path'\nE         \nE         - https://203.0.113.50/path\nE         + https://203.0.113.50:443/path\nE         ?                     ++++\n\ntests/test_ssrf.py: AssertionError"}
{"task_id": "d-utils-L211-value_swap", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In _utils.py:211, a value was swapped: 'while True:' became 'while False:'.", "vague_description": "An assignment or return value is wrong — it returns the first argument where it should return the second, or similar.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/_utils.py", "original": "while True:", "mutated": "while False:", "line_num": 211}, "source": "discovered", "category": "utils", "mutation_type": "value_swap", "dev_report_description": "Test failure: tests/test_utils.py::test_group_by_temporal[0-expected1]\n\nError: AssertionError: assert [] == [[1], [2], [3]]\n\nTraceback:\n_____________________ test_group_by_temporal[0-expected1] ______________________\n\ninterval = 0, expected = [[1], [2], [3]]\n\n    @pytest.mark.parametrize(\n        'interval,expected',\n        [\n            (None, snapshot([[1], [2], [3]])),\n            (0, snapshot([[1], [2], [3]])),\n            (0.02, snapshot([[1], [2], [3]])),\n            (0.04, snapshot([[1, 2], [3]])),\n            (0.1, snapshot([[1, 2, 3]])),\n        ],\n    )\n    async def test_group_by_temporal(interval: float | None, expected: list[list[int]]):\n        async def yield_groups() -> AsyncIterator[int]:\n            yield 1\n            await asyncio.sleep(0.02)\n            yield 2\n            await asyncio.sleep(0.02)\n            yield 3\n            await asyncio.sleep(0.02)\n    \n        async with group_by_temporal(yield_groups(), soft_max_interval=interval) as groups_iter:\n            groups: list[list[int]] = [g async for g in groups_iter]\n    ..."}
{"task_id": "d-messages-L543-condition_inversion", "repo_path": "/Users/akshankrithick/projects/pydantic-ai", "repo_url": "https://github.com/pydantic/pydantic-ai", "commit": "69a578a1e1012e0241d15321e45ab978962ed0d7", "setup_cmd": "pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot", "description": "In messages.py:543, a condition was inverted: 'if not path.exists():' became 'if path.exists():'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/test_messages.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "pydantic_ai_slim/pydantic_ai/messages.py", "original": "if not path.exists():", "mutated": "if path.exists():", "line_num": 543}, "source": "discovered", "category": "messages", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: tests/test_messages.py::test_binary_content_from_path\n\nError: FileNotFoundError: File not found: /private/var/folders/vz/02yk36wx3dz6dw661rcdxcxr0000gn/T/pytest-of-akshankrithick/pytest-196/test_binary_content_from_path0/test.xml\n\nTraceback:\n________________________ test_binary_content_from_path _________________________\n\ntmp_path = PosixPath('/private/var/folders/vz/02yk36wx3dz6dw661rcdxcxr0000gn/T/pytest-of-akshankrithick/pytest-196/test_binary_content_from_path0')\n\n    def test_binary_content_from_path(tmp_path: Path):\n        # test normal file\n        test_xml_file = tmp_path / 'test.xml'\n        test_xml_file.write_text('<think>about trains</think>', encoding='utf-8')\n>       binary_content = BinaryContent.from_path(test_xml_file)\n\ntests/test_messages.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'pydantic_ai.messages.BinaryContent'>\npath = PosixPath('/private/var/folders/vz/02yk36wx3dz6dw661rcdxcxr0000gn/T/pytest-of-akshankrithick/pytest-196/test_binary_content_from_path0/test.xml')\n\n    @classmethod\n    def from_path(cls, path: PathLike[str]) -> BinaryContent:\n        \"\"\"Create a `BinaryContent` from a path.\n    \n        Defaults to 'application/octet-stream' if the media type cannot be inferred.\n    \n        Raises:\n            FileNotFoundError: if the file does not exist.\n            PermissionError: if the file cannot be read.\n    ..."}
{"task_id": "httpx-auth-L272-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:272, a constant was changed: 'self._nonce_count += 1' became 'self._nonce_count += 0'. This shifts a boundary or default.", "vague_description": "A default value or configuration constant seems wrong. The system uses a different threshold or limit than what's documented.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "self._nonce_count += 1", "mutated": "self._nonce_count += 0", "line_num": 272}, "source": "discovered", "category": "auth", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: test_digest_auth_with_401_nonce_counting\n\nError: AssertionError: assert (1 + 1) == 1\n\nTraceback:\n___________________ test_digest_auth_with_401_nonce_counting ___________________\n\n    def test_digest_auth_with_401_nonce_counting():\n        auth = httpx.DigestAuth(username=\"user\", password=\"pass\")\n        request = httpx.Request(\"GET\", \"https://www.example.com\")\n    \n        # The initial request should not include an auth header.\n        flow = auth.sync_auth_flow(request)\n        request = next(flow)\n        assert \"Authorization\" not in request.headers\n    \n        # If a 401 response is returned, then a digest auth request is made.\n        headers = {\n            \"WWW-Authenticate\": 'Digest realm=\"...\", qop=\"auth\", nonce=\"...\", opaque=\"...\"'\n        }\n        response = httpx.Response(\n            content=b\"Auth required\", status_code=401, headers=headers, request=request\n        )\n        first_request = flow.send(response)\n        assert first_request.headers[\"Authorization\"].startswith(\"Digest\")\n    \n        # Each subsequent request contains the digest header by default...\n        request = httpx.Request(\"GET\", \"https://www.example.com\")\n        flow = auth.sync_auth_flow(request)\n        second_request = next(flow)\n    ..."}
{"task_id": "httpx-main-L235-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:235, the comparison operator was changed: 'elif name == \"http11.send_request_headers.started\" and verbose:' became 'elif name != \"http11.send_request_headers.started\" and verbose:'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "elif name == \"http11.send_request_headers.started\" and verbose:", "mutated": "elif name != \"http11.send_request_headers.started\" and verbose:", "line_num": 235}, "source": "discovered", "category": "cli", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_verbose\n\nError: AssertionError: assert 1 == 0\n\nTraceback:\n_________________________________ test_verbose _________________________________\n\nserver = <tests.conftest.TestServer object at 0x10acadf10>\n\n    def test_verbose(server):\n        url = str(server.url)\n        runner = CliRunner()\n        result = runner.invoke(httpx.main, [url, \"-v\"])\n>       assert result.exit_code == 0\nE       AssertionError: assert 1 == 0\nE        +  where 1 = <Result KeyError('request')>.exit_code\n\ntests/test_main.py: AssertionError\n--------------------------- Captured stdout teardown ---------------------------\nINFO:     127.0.0.1:57819 - \"GET / HTTP/1.1\" 200 OK\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56657]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-client-L228-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _client.py:228, the comparison operator was changed: 'return self._state == ClientState.CLOSED' became 'return self._state != ClientState.CLOSED'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/client/test_client.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_client.py", "original": "return self._state == ClientState.CLOSED", "mutated": "return self._state != ClientState.CLOSED", "line_num": 228}, "source": "discovered", "category": "client", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_client_closed_state_using_implicit_open\n\nError: AssertionError: assert not True\n\nTraceback:\n_________________ test_client_closed_state_using_implicit_open _________________\n\n    def test_client_closed_state_using_implicit_open():\n        client = httpx.Client(transport=httpx.MockTransport(hello_world))\n    \n>       assert not client.is_closed\nE       assert not True\nE        +  where True = <httpx.Client object at 0x1052a11d0>.is_closed\n\ntests/client/test_client.py: AssertionError\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56677]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-config-L108-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:108, a constant was changed: 'self.read = timeout[1]' became 'self.read = timeout[0]'. This shifts a boundary or default.", "vague_description": "A hardcoded value is slightly off. Behavior at specific boundaries doesn't match expectations — like an off-by-one in a limit.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "self.read = timeout[1]", "mutated": "self.read = timeout[0]", "line_num": 108}, "source": "discovered", "category": "config", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: test_timeout_from_one_value\n\nError: AssertionError: assert Timeout(connect=None, read=5.0, write=None, pool=None) == Timeout(timeout=None)\n\nTraceback:\n_________________________ test_timeout_from_one_value __________________________\n\n    def test_timeout_from_one_value():\n        timeout = httpx.Timeout(None, read=5.0)\n>       assert timeout == httpx.Timeout(timeout=(None, 5.0, None, None))\nE       AssertionError: assert Timeout(connect=None, read=5.0, write=None, pool=None) == Timeout(timeout=None)\nE        +  where Timeout(timeout=None) = <class 'httpx.Timeout'>(timeout=(None, 5.0, None, None))\nE        +    where <class 'httpx.Timeout'> = httpx.Timeout\n\ntests/test_config.py: AssertionError\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56678]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-decoders-L224-arithmetic_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:224, an arithmetic operator was changed: 'data = child.decode(data) + child.flush()' became 'data = child.decode(data) - child.flush()'. This produces wrong numeric results.", "vague_description": "A numerical calculation gives wrong output. The math is off — values are larger or smaller than expected by a consistent amount.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "data = child.decode(data) + child.flush()", "mutated": "data = child.decode(data) - child.flush()", "line_num": 224}, "source": "discovered", "category": "decoders", "mutation_type": "arithmetic_swap", "dev_report_description": "Test failure: test_multi\n\nError: TypeError: unsupported operand type(s) for -: 'bytes' and 'bytes'\n\nTraceback:\n__________________________________ test_multi __________________________________\n\n    def test_multi():\n        body = b\"test 123\"\n    \n        deflate_compressor = zlib.compressobj(9, zlib.DEFLATED, -zlib.MAX_WBITS)\n        compressed_body = deflate_compressor.compress(body) + deflate_compressor.flush()\n    \n        gzip_compressor = zlib.compressobj(9, zlib.DEFLATED, zlib.MAX_WBITS | 16)\n        compressed_body = (\n            gzip_compressor.compress(compressed_body) + gzip_compressor.flush()\n        )\n    \n        headers = [(b\"Content-Encoding\", b\"deflate, gzip\")]\n>       response = httpx.Response(\n            200,\n            headers=headers,\n            content=compressed_body,\n        )\n\ntests/test_decoders.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_models.py: in __init__\n    self.read()\nhttpx/_models.py: in read\n    ..."}
{"task_id": "httpx-exceptions-L98-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _exceptions.py:98, a None check was inverted: 'if self._request is None:' became 'if self._request is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_exceptions.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_exceptions.py", "original": "if self._request is None:", "mutated": "if self._request is not None:", "line_num": 98}, "source": "discovered", "category": "exceptions", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_request_attribute\n\nError: Failed: DID NOT RAISE <class 'RuntimeError'>\n\nTraceback:\n____________________________ test_request_attribute ____________________________\n\n    def test_request_attribute() -> None:\n        # Exception without request attribute\n        exc = httpx.ReadTimeout(\"Read operation timed out\")\n>       with pytest.raises(RuntimeError):\nE       Failed: DID NOT RAISE <class 'RuntimeError'>\n\ntests/test_exceptions.py: Failed\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Waiting for background tasks to complete. (CTRL+C to force quit)\nINFO:     Finished server process [56719]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-multipart-L80-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:80, a None check was inverted: 'if value is not None and not isinstance(value, (str, bytes, int, float)):' became 'if value is None and not isinstance(value, (str, bytes, int, float)):'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "if value is not None and not isinstance(value, (str, bytes, int, float)):", "mutated": "if value is None and not isinstance(value, (str, bytes, int, float)):", "line_num": 80}, "source": "discovered", "category": "multipart", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_multipart_invalid_value[value0]\n\nError: Failed: DID NOT RAISE <class 'TypeError'>\n\nTraceback:\n_____________________ test_multipart_invalid_value[value0] _____________________\n\nvalue = <object object at 0x105405da0>\n\n    @pytest.mark.parametrize((\"value\"), (object(), {\"key\": \"value\"}))\n    def test_multipart_invalid_value(value):\n        client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n    \n        data = {\"text\": value}\n        files = {\"file\": io.BytesIO(b\"<file content>\")}\n>       with pytest.raises(TypeError) as e:\nE       Failed: DID NOT RAISE <class 'TypeError'>\n\ntests/test_multipart.py: Failed\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-urlparse-L311-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _urlparse.py:311, a boolean operator was swapped: 'userinfo = kwargs.get(\"userinfo\", authority_dict[\"userinfo\"]) or \"\"' became 'userinfo = kwargs.get(\"userinfo\", authority_dict[\"userinfo\"]) and \"\"'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/models/test_whatwg.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_urlparse.py", "original": "userinfo = kwargs.get(\"userinfo\", authority_dict[\"userinfo\"]) or \"\"", "mutated": "userinfo = kwargs.get(\"userinfo\", authority_dict[\"userinfo\"]) and \"\"", "line_num": 311}, "source": "discovered", "category": "url_parsing", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: test_urlparse[test_case0]\n\nError: TypeError: expected string or bytes-like object, got 'NoneType'\n\nTraceback:\n__________________________ test_urlparse[test_case0] ___________________________\n\ntest_case = {'base': 'http://example.org/foo/bar', 'hash': '', 'host': 'example.org', 'hostname': 'example.org', ...}\n\n    @pytest.mark.parametrize(\"test_case\", test_cases)\n    def test_urlparse(test_case):\n        if test_case[\"href\"] in (\"a: foo.com\", \"lolscheme:x x#x%20x\"):\n            # Skip these two test cases.\n            # WHATWG cases where are not using percent-encoding for the space character.\n            # Anyone know what's going on here?\n            return\n    \n>       p = urlparse(test_case[\"href\"])\n\ntests/models/test_whatwg.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_urlparse.py: in urlparse\n    parsed_userinfo: str = quote(userinfo, safe=USERINFO_SAFE)\nhttpx/_urlparse.py: in quote\n    for match in re.finditer(PERCENT_ENCODED_REGEX, string):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npattern = re.compile('%[A-Fa-f0-9]{2}'), string = None, flags = 0\n\n    def finditer(pattern, string, flags=0):\n    ..."}
{"task_id": "httpx-main-L223-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:223, the comparison operator was changed: 'elif name == \"connection.start_tls.complete\" and verbose:  # pragma: no cover' became 'elif name != \"connection.start_tls.complete\" and verbose:  # pragma: no cover'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "elif name == \"connection.start_tls.complete\" and verbose:  # pragma: no cover", "mutated": "elif name != \"connection.start_tls.complete\" and verbose:  # pragma: no cover", "line_num": 223}, "source": "discovered", "category": "cli", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_verbose\n\nError: AssertionError: assert 1 == 0\n\nTraceback:\n_________________________________ test_verbose _________________________________\n\nserver = <tests.conftest.TestServer object at 0x1187a0750>\n\n    def test_verbose(server):\n        url = str(server.url)\n        runner = CliRunner()\n        result = runner.invoke(httpx.main, [url, \"-v\"])\n>       assert result.exit_code == 0\nE       AssertionError: assert 1 == 0\nE        +  where 1 = <Result KeyError('return_value')>.exit_code\n\ntests/test_main.py: AssertionError\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56741]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-config-L41-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:41, a value was swapped: 'elif verify is False:' became 'elif verify is True:'.", "vague_description": "An assignment or return value is wrong — it returns the first argument where it should return the second, or similar.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "elif verify is False:", "mutated": "elif verify is True:", "line_num": 41}, "source": "discovered", "category": "config", "mutation_type": "value_swap", "dev_report_description": "Test failure: test_load_ssl_config_no_verify\n\nError: AttributeError: 'bool' object has no attribute 'verify_mode'\n\nTraceback:\n________________________ test_load_ssl_config_no_verify ________________________\n\n    def test_load_ssl_config_no_verify():\n        context = httpx.create_ssl_context(verify=False)\n>       assert context.verify_mode == ssl.VerifyMode.CERT_NONE\nE       AttributeError: 'bool' object has no attribute 'verify_mode'\n\ntests/test_config.py: AttributeError\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-decoders-L69-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:69, a value was swapped: 'self.first_attempt = False' became 'self.first_attempt = True'.", "vague_description": "An assignment or return value is wrong — it returns the first argument where it should return the second, or similar.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "self.first_attempt = False", "mutated": "self.first_attempt = True", "line_num": 69}, "source": "discovered", "category": "decoders", "mutation_type": "value_swap", "dev_report_description": "Test failure: test_decoding_errors[deflate]\n\nError: AssertionError: zlib.error: Error -3 while decompressing data: incorrect header check\n\nTraceback:\n________________________ test_decoding_errors[deflate] _________________________\n\nself = <httpx._decoders.DeflateDecoder object at 0x105f9d250>, data = b'invalid'\n\n    def decode(self, data: bytes) -> bytes:\n        was_first_attempt = self.first_attempt\n        self.first_attempt = True\n        try:\n>           return self.decompressor.decompress(data)\nE           zlib.error: Error -3 while decompressing data: incorrect header check\n\nhttpx/_decoders.py: error\n\nDuring handling of the above exception, another exception occurred:\n\nself = <httpx._decoders.DeflateDecoder object at 0x105f9d250>, data = b'invalid'\n\n    def decode(self, data: bytes) -> bytes:\n        was_first_attempt = self.first_attempt\n        self.first_attempt = True\n        try:\n>           return self.decompressor.decompress(data)\nE           zlib.error: Error -3 while decompressing data: invalid stored block lengths\n\nhttpx/_decoders.py: error\n    ..."}
{"task_id": "httpx-multipart-L134-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:134, a condition was inverted: 'if isinstance(value, tuple):' became 'if not isinstance(value, tuple):'. The branch now triggers in the opposite case.", "vague_description": "A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "if isinstance(value, tuple):", "mutated": "if not isinstance(value, tuple):", "line_num": 134}, "source": "discovered", "category": "multipart", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_multipart[abc-abc0]\n\nError: TypeError: object of type '_io.BytesIO' has no len()\n\nTraceback:\n___________________________ test_multipart[abc-abc0] ___________________________\n\nvalue = 'abc', output = b'abc'\n\n    @pytest.mark.parametrize((\"value,output\"), ((\"abc\", b\"abc\"), (b\"abc\", b\"abc\")))\n    def test_multipart(value, output):\n        client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n    \n        # Test with a single-value 'data' argument, and a plain file 'files' argument.\n        data = {\"text\": value}\n        files = {\"file\": io.BytesIO(b\"<file content>\")}\n>       response = client.post(\"http://127.0.0.1:8000/\", data=data, files=files)\n\ntests/test_multipart.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_client.py: in post\n    return self.request(\nhttpx/_client.py: in request\n    request = self.build_request(\nhttpx/_client.py: in build_request\n    return Request(\nhttpx/_models.py: in __init__\n    headers, stream = encode_request(\nhttpx/_content.py: in encode_request\n    return encode_multipart_data(data or {}, files, boundary)\n    ..."}
{"task_id": "httpx-urlparse-L299-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _urlparse.py:299, a boolean operator was swapped: 'authority = kwargs.get(\"authority\", url_dict[\"authority\"]) or \"\"' became 'authority = kwargs.get(\"authority\", url_dict[\"authority\"]) and \"\"'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/models/test_whatwg.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_urlparse.py", "original": "authority = kwargs.get(\"authority\", url_dict[\"authority\"]) or \"\"", "mutated": "authority = kwargs.get(\"authority\", url_dict[\"authority\"]) and \"\"", "line_num": 299}, "source": "discovered", "category": "url_parsing", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: test_urlparse[test_case0]\n\nError: AssertionError: assert '' == 'example.org'\n\nTraceback:\n__________________________ test_urlparse[test_case0] ___________________________\n\ntest_case = {'base': 'http://example.org/foo/bar', 'hash': '', 'host': 'example.org', 'hostname': 'example.org', ...}\n\n    @pytest.mark.parametrize(\"test_case\", test_cases)\n    def test_urlparse(test_case):\n        if test_case[\"href\"] in (\"a: foo.com\", \"lolscheme:x x#x%20x\"):\n            # Skip these two test cases.\n            # WHATWG cases where are not using percent-encoding for the space character.\n            # Anyone know what's going on here?\n            return\n    \n        p = urlparse(test_case[\"href\"])\n    \n        # Test cases include the protocol with the trailing \":\"\n        protocol = p.scheme + \":\"\n        # Include the square brackets for IPv6 addresses.\n        hostname = f\"[{p.host}]\" if \":\" in p.host else p.host\n        # The test cases use a string representation of the port.\n        port = \"\" if p.port is None else str(p.port)\n        # I have nothing to say about this one.\n        path = p.path\n        # The 'search' and 'hash' components in the whatwg tests are semantic, not literal.\n        # Our parsing differentiates between no query/hash and empty-string query/hash.\n        search = \"\" if p.query in (None, \"\") else \"?\" + str(p.query)\n    ..."}
{"task_id": "httpx-utils-L200-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:200, a value was swapped: 'return False' became 'return True'.", "vague_description": "Two related values are mixed up. The system applies the wrong one of two options depending on context.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "return False", "mutated": "return True", "line_num": 200}, "source": "discovered", "category": "utils", "mutation_type": "value_swap", "dev_report_description": "Test failure: test_url_matches[http://example.com-http://other.com-False]\n\nError: AssertionError: assert True == False\n\nTraceback:\n_________ test_url_matches[http://example.com-http://other.com-False] __________\n\npattern = <httpx._utils.URLPattern object at 0x104440d90>\nurl = 'http://other.com', expected = False\n\n    @pytest.mark.parametrize(\n        [\"pattern\", \"url\", \"expected\"],\n        [\n            (\"http://example.com\", \"http://example.com\", True),\n            (\"http://example.com\", \"https://example.com\", False),\n            (\"http://example.com\", \"http://other.com\", False),\n            (\"http://example.com:123\", \"http://example.com:123\", True),\n            (\"http://example.com:123\", \"http://example.com:456\", False),\n            (\"http://example.com:123\", \"http://example.com\", False),\n            (\"all://example.com\", \"http://example.com\", True),\n            (\"all://example.com\", \"https://example.com\", True),\n            (\"http://\", \"http://example.com\", True),\n            (\"http://\", \"https://example.com\", False),\n            (\"all://\", \"https://example.com:123\", True),\n            (\"\", \"https://example.com:123\", True),\n        ],\n    )\n    def test_url_matches(pattern, url, expected):\n        pattern = URLPattern(pattern)\n>       assert pattern.matches(httpx.URL(url)) == expected\n    ..."}
{"task_id": "httpx-main-L237-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:237, a value was swapped: 'print_request_headers(request, http2=False)' became 'print_request_headers(request, http2=True)'.", "vague_description": "Two values appear to be swapped. The system uses value A where it should use value B, and value B where it should use value A.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "print_request_headers(request, http2=False)", "mutated": "print_request_headers(request, http2=True)", "line_num": 237}, "source": "discovered", "category": "cli", "mutation_type": "value_swap", "dev_report_description": "Test failure: test_verbose\n\nError: AssertionError: assert [\"* Connectin...r, zstd', ...] == [\"* Connectin...r, zstd', ...]\n\nTraceback:\n_________________________________ test_verbose _________________________________\n\nserver = <tests.conftest.TestServer object at 0x107c37bd0>\n\n    def test_verbose(server):\n        url = str(server.url)\n        runner = CliRunner()\n        result = runner.invoke(httpx.main, [url, \"-v\"])\n        assert result.exit_code == 0\n>       assert remove_date_header(splitlines(result.output)) == [\n            \"* Connecting to '127.0.0.1'\",\n            \"* Connected to '127.0.0.1' on port 8000\",\n            \"GET / HTTP/1.1\",\n            f\"Host: {server.url.netloc.decode('ascii')}\",\n            \"Accept: */*\",\n            \"Accept-Encoding: gzip, deflate, br, zstd\",\n            \"Connection: keep-alive\",\n            f\"User-Agent: python-httpx/{httpx.__version__}\",\n            \"\",\n            \"HTTP/1.1 200 OK\",\n            \"server: uvicorn\",\n            \"content-type: text/plain\",\n            \"Transfer-Encoding: chunked\",\n            \"\",\n            \"Hello, world!\",\n    ..."}
{"task_id": "httpx-client-L204-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _client.py:204, a None check was inverted: 'event_hooks = {} if event_hooks is None else event_hooks' became 'event_hooks = {} if event_hooks is not None else event_hooks'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/client/test_client.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_client.py", "original": "event_hooks = {} if event_hooks is None else event_hooks", "mutated": "event_hooks = {} if event_hooks is not None else event_hooks", "line_num": 204}, "source": "discovered", "category": "client", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_get\n\nError: AttributeError: 'NoneType' object has no attribute 'get'\n\nTraceback:\n___________________________________ test_get ___________________________________\n\nserver = <tests.conftest.TestServer object at 0x10aee0ad0>\n\n    def test_get(server):\n        url = server.url\n>       with httpx.Client(http2=True) as http:\n\ntests/client/test_client.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_client.py: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx.Client object at 0x10b84fa50>\n\n    def __init__(\n        self,\n        *,\n        auth: AuthTypes | None = None,\n        params: QueryParamTypes | None = None,\n        headers: HeaderTypes | None = None,\n        cookies: CookieTypes | None = None,\n        timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n        follow_redirects: bool = False,\n    ..."}
{"task_id": "httpx-config-L110-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:110, the comparison operator was changed: 'self.pool = None if len(timeout) < 4 else timeout[3]' became 'self.pool = None if len(timeout) <= 4 else timeout[3]'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "self.pool = None if len(timeout) < 4 else timeout[3]", "mutated": "self.pool = None if len(timeout) <= 4 else timeout[3]", "line_num": 110}, "source": "discovered", "category": "config", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_timeout_from_one_value_and_default\n\nError: AssertionError: assert Timeout(connect=5.0, read=5.0, write=5.0, pool=60.0) == Timeout(connect=5.0, read=5.0, write=5.0, pool=None)\n\nTraceback:\n___________________ test_timeout_from_one_value_and_default ____________________\n\n    def test_timeout_from_one_value_and_default():\n        timeout = httpx.Timeout(5.0, pool=60.0)\n>       assert timeout == httpx.Timeout(timeout=(5.0, 5.0, 5.0, 60.0))\nE       AssertionError: assert Timeout(connect=5.0, read=5.0, write=5.0, pool=60.0) == Timeout(connect=5.0, read=5.0, write=5.0, pool=None)\nE        +  where Timeout(connect=5.0, read=5.0, write=5.0, pool=None) = <class 'httpx.Timeout'>(timeout=(5.0, 5.0, 5.0, 60.0))\nE        +    where <class 'httpx.Timeout'> = httpx.Timeout\n\ntests/test_config.py: AssertionError\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56752]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-content-L110-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:110, a condition was inverted: 'if isinstance(content, (bytes, str)):' became 'if not isinstance(content, (bytes, str)):'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "if isinstance(content, (bytes, str)):", "mutated": "if not isinstance(content, (bytes, str)):", "line_num": 110}, "source": "discovered", "category": "content", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_bytes_content[asyncio]\n\nError: AssertionError: assert False\n\nTraceback:\n_________________________ test_bytes_content[asyncio] __________________________\n\n    @pytest.mark.anyio\n    async def test_bytes_content():\n        request = httpx.Request(method, url, content=b\"Hello, world!\")\n        assert isinstance(request.stream, typing.Iterable)\n>       assert isinstance(request.stream, typing.AsyncIterable)\nE       AssertionError: assert False\nE        +  where False = isinstance(<httpx._content.IteratorByteStream object at 0x103406690>, typing.AsyncIterable)\nE        +    where <httpx._content.IteratorByteStream object at 0x103406690> = <Request('POST', 'https://www.example.com')>.stream\nE        +    and   typing.AsyncIterable = typing.AsyncIterable\n\ntests/test_content.py: AssertionError\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-decoders-L171-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:171, a None check was inverted: 'if zstandard is None:  # pragma: no cover' became 'if zstandard is not None:  # pragma: no cover'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "if zstandard is None:  # pragma: no cover", "mutated": "if zstandard is not None:  # pragma: no cover", "line_num": 171}, "source": "discovered", "category": "decoders", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_zstd\n\nError: ImportError: Using 'ZStandardDecoder', ...Make sure to install httpx using `pip install httpx[zstd]`.\n\nTraceback:\n__________________________________ test_zstd ___________________________________\n\n    def test_zstd():\n        body = b\"test 123\"\n        compressed_body = zstd.compress(body)\n    \n        headers = [(b\"Content-Encoding\", b\"zstd\")]\n>       response = httpx.Response(\n            200,\n            headers=headers,\n            content=compressed_body,\n        )\n\ntests/test_decoders.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_models.py: in __init__\n    self.read()\nhttpx/_models.py: in read\n    self._content = b\"\".join(self.iter_bytes())\nhttpx/_models.py: in iter_bytes\n    decoder = self._get_content_decoder()\nhttpx/_models.py: in _get_content_decoder\n    decoders.append(decoder_cls())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    ..."}
{"task_id": "httpx-asgi-L159-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:159, a condition was inverted: 'assert not response_complete.is_set()' became 'assert response_complete.is_set()'. The branch now triggers in the opposite case.", "vague_description": "A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "assert not response_complete.is_set()", "mutated": "assert response_complete.is_set()", "line_num": 159}, "source": "discovered", "category": "transports", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_asgi_transport[asyncio]\n\nError: AssertionError: AssertionError\n\nTraceback:\n_________________________ test_asgi_transport[asyncio] _________________________\n\n    @pytest.mark.anyio\n    async def test_asgi_transport():\n        async with httpx.ASGITransport(app=hello_world) as transport:\n            request = httpx.Request(\"GET\", \"http://www.example.com/\")\n>           response = await transport.handle_async_request(request)\n\ntests/test_asgi.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_transports/asgi.py: in handle_async_request\n    await self.app(scope, receive, send)\ntests/test_asgi.py: in hello_world\n    await send({\"type\": \"http.response.body\", \"body\": output})\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmessage = {'body': b'Hello, World!', 'type': 'http.response.body'}\n\n    async def send(message: typing.MutableMapping[str, typing.Any]) -> None:\n        nonlocal status_code, response_headers, response_started\n    \n        if message[\"type\"] == \"http.response.start\":\n            assert not response_started\n    \n            status_code = message[\"status\"]\n    ..."}
{"task_id": "httpx-urlparse-L290-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _urlparse.py:290, a None check was inverted: 'assert url_match is not None' became 'assert url_match is None'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/models/test_whatwg.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_urlparse.py", "original": "assert url_match is not None", "mutated": "assert url_match is None", "line_num": 290}, "source": "discovered", "category": "url_parsing", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_urlparse[test_case0]\n\nError: AssertionError: AssertionError\n\nTraceback:\n__________________________ test_urlparse[test_case0] ___________________________\n\ntest_case = {'base': 'http://example.org/foo/bar', 'hash': '', 'host': 'example.org', 'hostname': 'example.org', ...}\n\n    @pytest.mark.parametrize(\"test_case\", test_cases)\n    def test_urlparse(test_case):\n        if test_case[\"href\"] in (\"a: foo.com\", \"lolscheme:x x#x%20x\"):\n            # Skip these two test cases.\n            # WHATWG cases where are not using percent-encoding for the space character.\n            # Anyone know what's going on here?\n            return\n    \n>       p = urlparse(test_case[\"href\"])\n\ntests/models/test_whatwg.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://example.org/', kwargs = {}\n\n    def urlparse(url: str = \"\", **kwargs: str | None) -> ParseResult:\n        # Initial basic checks on allowable URLs.\n        # ---------------------------------------\n    \n        # Hard limit the maximum allowable URL length.\n        if len(url) > MAX_URL_LENGTH:\n    ..."}
{"task_id": "httpx-auth-L279-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:279, a None check was inverted: 'if qop is None:' became 'if qop is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "if qop is None:", "mutated": "if qop is not None:", "line_num": 279}, "source": "discovered", "category": "auth", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_digest_auth_rfc_2069\n\nError: TypeError: sequence item 4: expected a bytes-like object, NoneType found\n\nTraceback:\n__________________________ test_digest_auth_rfc_2069 ___________________________\n\n    def test_digest_auth_rfc_2069():\n        # Example from https://datatracker.ietf.org/doc/html/rfc2069#section-2.4\n        # with corrected response from https://www.rfc-editor.org/errata/eid749\n    \n        auth = httpx.DigestAuth(username=\"Mufasa\", password=\"CircleOfLife\")\n        request = httpx.Request(\"GET\", \"https://www.example.com/dir/index.html\")\n    \n        # The initial request should not include an auth header.\n        flow = auth.sync_auth_flow(request)\n        request = next(flow)\n        assert \"Authorization\" not in request.headers\n    \n        # If a 401 response is returned, then a digest auth request is made.\n        headers = {\n            \"WWW-Authenticate\": (\n                'Digest realm=\"testrealm@host.com\", '\n                'nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", '\n                'opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"'\n            )\n        }\n        response = httpx.Response(\n            content=b\"Auth required\", status_code=401, headers=headers, request=request\n        )\n    ..."}
{"task_id": "httpx-main-L216-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:216, the comparison operator was changed: 'if name == \"connection.connect_tcp.started\" and verbose:' became 'if name != \"connection.connect_tcp.started\" and verbose:'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "if name == \"connection.connect_tcp.started\" and verbose:", "mutated": "if name != \"connection.connect_tcp.started\" and verbose:", "line_num": 216}, "source": "discovered", "category": "cli", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_verbose\n\nError: AssertionError: assert 1 == 0\n\nTraceback:\n_________________________________ test_verbose _________________________________\n\nserver = <tests.conftest.TestServer object at 0x104185490>\n\n    def test_verbose(server):\n        url = str(server.url)\n        runner = CliRunner()\n        result = runner.invoke(httpx.main, [url, \"-v\"])\n>       assert result.exit_code == 0\nE       AssertionError: assert 1 == 0\nE        +  where 1 = <Result KeyError('host')>.exit_code\n\ntests/test_main.py: AssertionError\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56763]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-client-L237-arithmetic_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _client.py:237, an arithmetic operator was changed: 'return url.copy_with(raw_path=url.raw_path + b\"/\")' became 'return url.copy_with(raw_path=url.raw_path - b\"/\")'. This produces wrong numeric results.", "vague_description": "A numerical calculation gives wrong output. The math is off — values are larger or smaller than expected by a consistent amount.", "test_cmd": "python -m pytest tests/client/test_client.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_client.py", "original": "return url.copy_with(raw_path=url.raw_path + b\"/\")", "mutated": "return url.copy_with(raw_path=url.raw_path - b\"/\")", "line_num": 237}, "source": "discovered", "category": "client", "mutation_type": "arithmetic_swap", "dev_report_description": "Test failure: test_merge_relative_url_with_path\n\nError: TypeError: unsupported operand type(s) for -: 'bytes' and 'bytes'\n\nTraceback:\n______________________ test_merge_relative_url_with_path _______________________\n\n    def test_merge_relative_url_with_path():\n>       client = httpx.Client(base_url=\"https://www.example.com/some/path\")\n\ntests/client/test_client.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_client.py: in __init__\n    super().__init__(\nhttpx/_client.py: in __init__\n    self._base_url = self._enforce_trailing_slash(URL(base_url))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx.Client object at 0x110e37fd0>\nurl = URL('https://www.example.com/some/path')\n\n    def _enforce_trailing_slash(self, url: URL) -> URL:\n        if url.raw_path.endswith(b\"/\"):\n            return url\n>       return url.copy_with(raw_path=url.raw_path - b\"/\")\nE       TypeError: unsupported operand type(s) for -: 'bytes' and 'bytes'\n\nhttpx/_client.py: TypeError\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\n    ..."}
{"task_id": "httpx-config-L130-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:130, a condition was inverted: 'self.pool = timeout if isinstance(pool, UnsetType) else pool' became 'self.pool = timeout if not isinstance(pool, UnsetType) else pool'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "self.pool = timeout if isinstance(pool, UnsetType) else pool", "mutated": "self.pool = timeout if not isinstance(pool, UnsetType) else pool", "line_num": 130}, "source": "discovered", "category": "config", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_timeout_all_parameters_set\n\nError: AssertionError: assert Timeout(timeout=5.0) == Timeout(connect=5.0, read=5.0, write=5.0, pool=<httpx._config.UnsetType object at 0x1060544d0>)\n\nTraceback:\n_______________________ test_timeout_all_parameters_set ________________________\n\n    def test_timeout_all_parameters_set():\n        timeout = httpx.Timeout(connect=5.0, read=5.0, write=5.0, pool=5.0)\n>       assert timeout == httpx.Timeout(timeout=5.0)\nE       AssertionError: assert Timeout(timeout=5.0) == Timeout(connect=5.0, read=5.0, write=5.0, pool=<httpx._config.UnsetType object at 0x1060544d0>)\nE        +  where Timeout(connect=5.0, read=5.0, write=5.0, pool=<httpx._config.UnsetType object at 0x1060544d0>) = <class 'httpx.Timeout'>(timeout=5.0)\nE        +    where <class 'httpx.Timeout'> = httpx.Timeout\n\ntests/test_config.py: AssertionError\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56765]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-multipart-L181-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:181, a None check was inverted: 'if file_length is None:' became 'if file_length is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "if file_length is None:", "mutated": "if file_length is not None:", "line_num": 181}, "source": "discovered", "category": "multipart", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_multipart_file_tuple_headers[None]\n\nError: AssertionError: assert Headers({'hos...': 'chunked'}) == {'Content-Len....example.com'}\n\nTraceback:\n___________________ test_multipart_file_tuple_headers[None] ____________________\n\nfile_content_type = None\n\n    @pytest.mark.parametrize(\"file_content_type\", [None, \"text/plain\"])\n    def test_multipart_file_tuple_headers(file_content_type: str | None) -> None:\n        file_name = \"test.txt\"\n        file_content = io.BytesIO(b\"<file content>\")\n        file_headers = {\"Expires\": \"0\"}\n    \n        url = \"https://www.example.com/\"\n        headers = {\"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\"}\n        files = {\"file\": (file_name, file_content, file_content_type, file_headers)}\n    \n        request = httpx.Request(\"POST\", url, headers=headers, files=files)\n        request.read()\n    \n>       assert request.headers == {\n            \"Host\": \"www.example.com\",\n            \"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\",\n            \"Content-Length\": str(len(request.content)),\n        }\nE       AssertionError: assert Headers({'hos...': 'chunked'}) == {'Content-Len....example.com'}\nE         \nE         Use -v to get more diff\n    ..."}
{"task_id": "httpx-wsgi-L40-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In wsgi.py:40, a None check was inverted: 'if self._close is not None:' became 'if self._close is None:'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_wsgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/wsgi.py", "original": "if self._close is not None:", "mutated": "if self._close is None:", "line_num": 40}, "source": "discovered", "category": "transports", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_wsgi_upload\n\nError: TypeError: 'NoneType' object is not callable\n\nTraceback:\n_______________________________ test_wsgi_upload _______________________________\n\n    def test_wsgi_upload():\n        transport = httpx.WSGITransport(app=echo_body)\n        client = httpx.Client(transport=transport)\n>       response = client.post(\"http://www.example.org/\", content=b\"example\")\n\ntests/test_wsgi.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_client.py: in post\n    return self.request(\nhttpx/_client.py: in request\n    return self.send(request, auth=auth, follow_redirects=follow_redirects)\nhttpx/_client.py: in send\n    raise exc\nhttpx/_client.py: in send\n    response.read()\nhttpx/_models.py: in read\n    self._content = b\"\".join(self.iter_bytes())\nhttpx/_models.py: in iter_bytes\n    for raw_bytes in self.iter_raw():\nhttpx/_models.py: in iter_raw\n    self.close()\nhttpx/_models.py: in close\n    self.stream.close()\n    ..."}
{"task_id": "httpx-urlparse-L306-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _urlparse.py:306, a None check was inverted: 'assert authority_match is not None' became 'assert authority_match is None'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/models/test_whatwg.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_urlparse.py", "original": "assert authority_match is not None", "mutated": "assert authority_match is None", "line_num": 306}, "source": "discovered", "category": "url_parsing", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_urlparse[test_case0]\n\nError: AssertionError: AssertionError\n\nTraceback:\n__________________________ test_urlparse[test_case0] ___________________________\n\ntest_case = {'base': 'http://example.org/foo/bar', 'hash': '', 'host': 'example.org', 'hostname': 'example.org', ...}\n\n    @pytest.mark.parametrize(\"test_case\", test_cases)\n    def test_urlparse(test_case):\n        if test_case[\"href\"] in (\"a: foo.com\", \"lolscheme:x x#x%20x\"):\n            # Skip these two test cases.\n            # WHATWG cases where are not using percent-encoding for the space character.\n            # Anyone know what's going on here?\n            return\n    \n>       p = urlparse(test_case[\"href\"])\n\ntests/models/test_whatwg.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://example.org/', kwargs = {}\n\n    def urlparse(url: str = \"\", **kwargs: str | None) -> ParseResult:\n        # Initial basic checks on allowable URLs.\n        # ---------------------------------------\n    \n        # Hard limit the maximum allowable URL length.\n        if len(url) > MAX_URL_LENGTH:\n    ..."}
{"task_id": "httpx-utils-L197-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:197, a None check was inverted: 'and self.host_regex is not None' became 'and self.host_regex is None'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "and self.host_regex is not None", "mutated": "and self.host_regex is None", "line_num": 197}, "source": "discovered", "category": "utils", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_url_matches[http://example.com-http://other.com-False]\n\nError: AssertionError: assert True == False\n\nTraceback:\n_________ test_url_matches[http://example.com-http://other.com-False] __________\n\npattern = <httpx._utils.URLPattern object at 0x105ad9950>\nurl = 'http://other.com', expected = False\n\n    @pytest.mark.parametrize(\n        [\"pattern\", \"url\", \"expected\"],\n        [\n            (\"http://example.com\", \"http://example.com\", True),\n            (\"http://example.com\", \"https://example.com\", False),\n            (\"http://example.com\", \"http://other.com\", False),\n            (\"http://example.com:123\", \"http://example.com:123\", True),\n            (\"http://example.com:123\", \"http://example.com:456\", False),\n            (\"http://example.com:123\", \"http://example.com\", False),\n            (\"all://example.com\", \"http://example.com\", True),\n            (\"all://example.com\", \"https://example.com\", True),\n            (\"http://\", \"http://example.com\", True),\n            (\"http://\", \"https://example.com\", False),\n            (\"all://\", \"https://example.com:123\", True),\n            (\"\", \"https://example.com:123\", True),\n        ],\n    )\n    def test_url_matches(pattern, url, expected):\n        pattern = URLPattern(pattern)\n>       assert pattern.matches(httpx.URL(url)) == expected\n    ..."}
{"task_id": "httpx-auth-L318-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:318, the comparison operator was changed: 'if i > 0:' became 'if i >= 0:'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "if i > 0:", "mutated": "if i >= 0:", "line_num": 318}, "source": "discovered", "category": "auth", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_digest_auth_with_401_nonce_counting\n\nError: ValueError: not enough values to unpack (expected 2, got 1)\n\nTraceback:\n___________________ test_digest_auth_with_401_nonce_counting ___________________\n\n    def test_digest_auth_with_401_nonce_counting():\n        auth = httpx.DigestAuth(username=\"user\", password=\"pass\")\n        request = httpx.Request(\"GET\", \"https://www.example.com\")\n    \n        # The initial request should not include an auth header.\n        flow = auth.sync_auth_flow(request)\n        request = next(flow)\n        assert \"Authorization\" not in request.headers\n    \n        # If a 401 response is returned, then a digest auth request is made.\n        headers = {\n            \"WWW-Authenticate\": 'Digest realm=\"...\", qop=\"auth\", nonce=\"...\", opaque=\"...\"'\n        }\n        response = httpx.Response(\n            content=b\"Auth required\", status_code=401, headers=headers, request=request\n        )\n        first_request = flow.send(response)\n        assert first_request.headers[\"Authorization\"].startswith(\"Digest\")\n    \n        # Each subsequent request contains the digest header by default...\n        request = httpx.Request(\"GET\", \"https://www.example.com\")\n        flow = auth.sync_auth_flow(request)\n        second_request = next(flow)\n    ..."}
{"task_id": "httpx-config-L129-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:129, a condition was inverted: 'self.write = timeout if isinstance(write, UnsetType) else write' became 'self.write = timeout if not isinstance(write, UnsetType) else write'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "self.write = timeout if isinstance(write, UnsetType) else write", "mutated": "self.write = timeout if not isinstance(write, UnsetType) else write", "line_num": 129}, "source": "discovered", "category": "config", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_SSLContext_with_get_request\n\nError: TypeError: 'UnsetType' object cannot be interpreted as an integer\n\nTraceback:\n_______________________ test_SSLContext_with_get_request _______________________\n\nserver = <tests.conftest.TestServer object at 0x103479210>\ncert_pem_file = '/var/folders/vz/02yk36wx3dz6dw661rcdxcxr0000gn/T/tmpkdxpj3_i.pem'\n\n    def test_SSLContext_with_get_request(server, cert_pem_file):\n        context = httpx.create_ssl_context()\n        context.load_verify_locations(cert_pem_file)\n>       response = httpx.get(server.url, verify=context)\n\ntests/test_config.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_api.py: in get\n    return request(\nhttpx/_api.py: in request\n    return client.request(\nhttpx/_client.py: in request\n    return self.send(request, auth=auth, follow_redirects=follow_redirects)\nhttpx/_client.py: in send\n    response = self._send_handling_auth(\nhttpx/_client.py: in _send_handling_auth\n    response = self._send_handling_redirects(\nhttpx/_client.py: in _send_handling_redirects\n    response = self._send_single_request(request)\nhttpx/_client.py: in _send_single_request\n    ..."}
{"task_id": "httpx-content-L111-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:111, a condition was inverted: 'body = content.encode(\"utf-8\") if isinstance(content, str) else content' became 'body = content.encode(\"utf-8\") if not isinstance(content, str) else content'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "body = content.encode(\"utf-8\") if isinstance(content, str) else content", "mutated": "body = content.encode(\"utf-8\") if not isinstance(content, str) else content", "line_num": 111}, "source": "discovered", "category": "content", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_bytes_content[asyncio]\n\nError: AttributeError: 'bytes' object has no attribute 'encode'\n\nTraceback:\n_________________________ test_bytes_content[asyncio] __________________________\n\n    @pytest.mark.anyio\n    async def test_bytes_content():\n>       request = httpx.Request(method, url, content=b\"Hello, world!\")\n\ntests/test_content.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_models.py: in __init__\n    headers, stream = encode_request(\nhttpx/_content.py: in encode_request\n    return encode_content(content)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncontent = b'Hello, world!'\n\n    def encode_content(\n        content: str | bytes | Iterable[bytes] | AsyncIterable[bytes],\n    ) -> tuple[dict[str, str], SyncByteStream | AsyncByteStream]:\n        if isinstance(content, (bytes, str)):\n>           body = content.encode(\"utf-8\") if not isinstance(content, str) else content\nE           AttributeError: 'bytes' object has no attribute 'encode'\n\nhttpx/_content.py: AttributeError\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-asgi-L152-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:152, a condition was inverted: 'assert not response_started' became 'assert response_started'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "assert not response_started", "mutated": "assert response_started", "line_num": 152}, "source": "discovered", "category": "transports", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_asgi_transport[asyncio]\n\nError: AssertionError: AssertionError\n\nTraceback:\n_________________________ test_asgi_transport[asyncio] _________________________\n\n    @pytest.mark.anyio\n    async def test_asgi_transport():\n        async with httpx.ASGITransport(app=hello_world) as transport:\n            request = httpx.Request(\"GET\", \"http://www.example.com/\")\n>           response = await transport.handle_async_request(request)\n\ntests/test_asgi.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_transports/asgi.py: in handle_async_request\n    await self.app(scope, receive, send)\ntests/test_asgi.py: in hello_world\n    await send({\"type\": \"http.response.start\", \"status\": status, \"headers\": headers})\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmessage = {'headers': [(b'content-type', 'text/plain'), (b'content-length', '13')], 'status': 200, 'type': 'http.response.start'}\n\n    async def send(message: typing.MutableMapping[str, typing.Any]) -> None:\n        nonlocal status_code, response_headers, response_started\n    \n        if message[\"type\"] == \"http.response.start\":\n>           assert response_started\nE           AssertionError\n\n    ..."}
{"task_id": "httpx-urlparse-L312-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _urlparse.py:312, a boolean operator was swapped: 'host = kwargs.get(\"host\", authority_dict[\"host\"]) or \"\"' became 'host = kwargs.get(\"host\", authority_dict[\"host\"]) and \"\"'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/models/test_whatwg.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_urlparse.py", "original": "host = kwargs.get(\"host\", authority_dict[\"host\"]) or \"\"", "mutated": "host = kwargs.get(\"host\", authority_dict[\"host\"]) and \"\"", "line_num": 312}, "source": "discovered", "category": "url_parsing", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: test_urlparse[test_case0]\n\nError: AssertionError: assert '' == 'example.org'\n\nTraceback:\n__________________________ test_urlparse[test_case0] ___________________________\n\ntest_case = {'base': 'http://example.org/foo/bar', 'hash': '', 'host': 'example.org', 'hostname': 'example.org', ...}\n\n    @pytest.mark.parametrize(\"test_case\", test_cases)\n    def test_urlparse(test_case):\n        if test_case[\"href\"] in (\"a: foo.com\", \"lolscheme:x x#x%20x\"):\n            # Skip these two test cases.\n            # WHATWG cases where are not using percent-encoding for the space character.\n            # Anyone know what's going on here?\n            return\n    \n        p = urlparse(test_case[\"href\"])\n    \n        # Test cases include the protocol with the trailing \":\"\n        protocol = p.scheme + \":\"\n        # Include the square brackets for IPv6 addresses.\n        hostname = f\"[{p.host}]\" if \":\" in p.host else p.host\n        # The test cases use a string representation of the port.\n        port = \"\" if p.port is None else str(p.port)\n        # I have nothing to say about this one.\n        path = p.path\n        # The 'search' and 'hash' components in the whatwg tests are semantic, not literal.\n        # Our parsing differentiates between no query/hash and empty-string query/hash.\n        search = \"\" if p.query in (None, \"\") else \"?\" + str(p.query)\n    ..."}
{"task_id": "httpx-utils-L177-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:177, the comparison operator was changed: 'if not url.host or url.host == \"*\":' became 'if not url.host or url.host != \"*\":'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "if not url.host or url.host == \"*\":", "mutated": "if not url.host or url.host != \"*\":", "line_num": 177}, "source": "discovered", "category": "utils", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_url_matches[http://example.com-http://other.com-False]\n\nError: AssertionError: assert True == False\n\nTraceback:\n_________ test_url_matches[http://example.com-http://other.com-False] __________\n\npattern = <httpx._utils.URLPattern object at 0x103be6310>\nurl = 'http://other.com', expected = False\n\n    @pytest.mark.parametrize(\n        [\"pattern\", \"url\", \"expected\"],\n        [\n            (\"http://example.com\", \"http://example.com\", True),\n            (\"http://example.com\", \"https://example.com\", False),\n            (\"http://example.com\", \"http://other.com\", False),\n            (\"http://example.com:123\", \"http://example.com:123\", True),\n            (\"http://example.com:123\", \"http://example.com:456\", False),\n            (\"http://example.com:123\", \"http://example.com\", False),\n            (\"all://example.com\", \"http://example.com\", True),\n            (\"all://example.com\", \"https://example.com\", True),\n            (\"http://\", \"http://example.com\", True),\n            (\"http://\", \"https://example.com\", False),\n            (\"all://\", \"https://example.com:123\", True),\n            (\"\", \"https://example.com:123\", True),\n        ],\n    )\n    def test_url_matches(pattern, url, expected):\n        pattern = URLPattern(pattern)\n>       assert pattern.matches(httpx.URL(url)) == expected\n    ..."}
{"task_id": "httpx-auth-L239-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:239, a constant was changed: 'key, value = field.strip().split(\"=\", 1)' became 'key, value = field.strip().split(\"=\", 0)'. This shifts a boundary or default.", "vague_description": "A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "key, value = field.strip().split(\"=\", 1)", "mutated": "key, value = field.strip().split(\"=\", 0)", "line_num": 239}, "source": "discovered", "category": "auth", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: test_digest_auth_with_401\n\nError: ValueError: not enough values to unpack (expected 2, got 1)\n\nTraceback:\n__________________________ test_digest_auth_with_401 ___________________________\n\n    def test_digest_auth_with_401():\n        auth = httpx.DigestAuth(username=\"user\", password=\"pass\")\n        request = httpx.Request(\"GET\", \"https://www.example.com\")\n    \n        # The initial request should not include an auth header.\n        flow = auth.sync_auth_flow(request)\n        request = next(flow)\n        assert \"Authorization\" not in request.headers\n    \n        # If a 401 response is returned, then a digest auth request is made.\n        headers = {\n            \"WWW-Authenticate\": 'Digest realm=\"...\", qop=\"auth\", nonce=\"...\", opaque=\"...\"'\n        }\n        response = httpx.Response(\n            content=b\"Auth required\", status_code=401, headers=headers, request=request\n        )\n>       request = flow.send(response)\n\ntests/test_auth.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_auth.py: in sync_auth_flow\n    request = flow.send(response)\nhttpx/_auth.py: in auth_flow\n    ..."}
{"task_id": "httpx-main-L238-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:238, the comparison operator was changed: 'elif name == \"http2.send_request_headers.started\" and verbose:  # pragma: no cover' became 'elif name != \"http2.send_request_headers.started\" and verbose:  # pragma: no cover'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "elif name == \"http2.send_request_headers.started\" and verbose:  # pragma: no cover", "mutated": "elif name != \"http2.send_request_headers.started\" and verbose:  # pragma: no cover", "line_num": 238}, "source": "discovered", "category": "cli", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_verbose\n\nError: AssertionError: assert 1 == 0\n\nTraceback:\n_________________________________ test_verbose _________________________________\n\nserver = <tests.conftest.TestServer object at 0x107651190>\n\n    def test_verbose(server):\n        url = str(server.url)\n        runner = CliRunner()\n        result = runner.invoke(httpx.main, [url, \"-v\"])\n>       assert result.exit_code == 0\nE       AssertionError: assert 1 == 0\nE        +  where 1 = <Result KeyError('request')>.exit_code\n\ntests/test_main.py: AssertionError\n--------------------------- Captured stdout teardown ---------------------------\nINFO:     127.0.0.1:57941 - \"GET / HTTP/1.1\" 200 OK\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56777]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-client-L248-return_value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _client.py:248, the code was changed from 'return {}' to 'return {\"_\": None}' (return_value_swap).", "vague_description": "The return value from a function doesn't match its contract. Callers get unexpected results.", "test_cmd": "python -m pytest tests/client/test_client.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_client.py", "original": "return {}", "mutated": "return {\"_\": None}", "line_num": 248}, "source": "discovered", "category": "client", "mutation_type": "return_value_swap", "dev_report_description": "Test failure: test_context_managed_transport\n\nError: ValueError: Proxy keys should use proper URL forms rather than plain scheme strings. Instead of \"_\", use \"_://\"\n\nTraceback:\n________________________ test_context_managed_transport ________________________\n\n    def test_context_managed_transport():\n        class Transport(httpx.BaseTransport):\n            def __init__(self) -> None:\n                self.events: list[str] = []\n    \n            def close(self):\n                # The base implementation of httpx.BaseTransport just\n                # calls into `.close`, so simple transport cases can just override\n                # this method for any cleanup, where more complex cases\n                # might want to additionally override `__enter__`/`__exit__`.\n                self.events.append(\"transport.close\")\n    \n            def __enter__(self):\n                super().__enter__()\n                self.events.append(\"transport.__enter__\")\n    \n            def __exit__(self, *args):\n                super().__exit__(*args)\n                self.events.append(\"transport.__exit__\")\n    \n        transport = Transport()\n>       with httpx.Client(transport=transport):\n\n    ..."}
{"task_id": "httpx-config-L143-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:143, the comparison operator was changed: 'and self.connect == other.connect' became 'and self.connect != other.connect'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "and self.connect == other.connect", "mutated": "and self.connect != other.connect", "line_num": 143}, "source": "discovered", "category": "config", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_timeout_eq\n\nError: AssertionError: assert Timeout(timeout=5.0) == Timeout(timeout=5.0)\n\nTraceback:\n_______________________________ test_timeout_eq ________________________________\n\n    def test_timeout_eq():\n        timeout = httpx.Timeout(timeout=5.0)\n>       assert timeout == httpx.Timeout(timeout=5.0)\nE       AssertionError: assert Timeout(timeout=5.0) == Timeout(timeout=5.0)\nE        +  where Timeout(timeout=5.0) = <class 'httpx.Timeout'>(timeout=5.0)\nE        +    where <class 'httpx.Timeout'> = httpx.Timeout\n\ntests/test_config.py: AssertionError\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56779]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-content-L235-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:235, a None check was inverted: 'elif html is not None:' became 'elif html is None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "elif html is not None:", "mutated": "elif html is None:", "line_num": 235}, "source": "discovered", "category": "content", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_response_empty_content[asyncio]\n\nError: AttributeError: 'NoneType' object has no attribute 'encode'\n\nTraceback:\n_____________________ test_response_empty_content[asyncio] _____________________\n\n    @pytest.mark.anyio\n    async def test_response_empty_content():\n>       response = httpx.Response(200)\n\ntests/test_content.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_models.py: in __init__\n    headers, stream = encode_response(content, text, html, json)\nhttpx/_content.py: in encode_response\n    return encode_html(html)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhtml = None\n\n    def encode_html(html: str) -> tuple[dict[str, str], ByteStream]:\n>       body = html.encode(\"utf-8\")\nE       AttributeError: 'NoneType' object has no attribute 'encode'\n\nhttpx/_content.py: AttributeError\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-decoders-L238-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:238, a None check was inverted: 'if self._chunk_size is None:' became 'if self._chunk_size is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "if self._chunk_size is None:", "mutated": "if self._chunk_size is not None:", "line_num": 238}, "source": "discovered", "category": "decoders", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_deflate\n\nError: TypeError: '>=' not supported between instances of 'int' and 'NoneType'\n\nTraceback:\n_________________________________ test_deflate _________________________________\n\n    def test_deflate():\n        \"\"\"\n        Deflate encoding may use either 'zlib' or 'deflate' in the wild.\n    \n        https://stackoverflow.com/questions/1838699/how-can-i-decompress-a-gzip-stream-with-zlib#answer-22311297\n        \"\"\"\n        body = b\"test 123\"\n        compressor = zlib.compressobj(9, zlib.DEFLATED, -zlib.MAX_WBITS)\n        compressed_body = compressor.compress(body) + compressor.flush()\n    \n        headers = [(b\"Content-Encoding\", b\"deflate\")]\n>       response = httpx.Response(\n            200,\n            headers=headers,\n            content=compressed_body,\n        )\n\ntests/test_decoders.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_models.py: in __init__\n    self.read()\nhttpx/_models.py: in read\n    self._content = b\"\".join(self.iter_bytes())\n    ..."}
{"task_id": "httpx-multipart-L210-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:210, a constant was changed: 'self.file.seek(0)' became 'self.file.seek(1)'. This shifts a boundary or default.", "vague_description": "A default value or configuration constant seems wrong. The system uses a different threshold or limit than what's documented.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "self.file.seek(0)", "mutated": "self.file.seek(1)", "line_num": 210}, "source": "discovered", "category": "multipart", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: test_multipart[abc-abc0]\n\nError: AssertionError: assert b'--6f90c6ad7...acf696b--\\r\\n' == b'--6f90c6ad7...acf696b--\\r\\n'\n\nTraceback:\n___________________________ test_multipart[abc-abc0] ___________________________\n\nvalue = 'abc', output = b'abc'\n\n    @pytest.mark.parametrize((\"value,output\"), ((\"abc\", b\"abc\"), (b\"abc\", b\"abc\")))\n    def test_multipart(value, output):\n        client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n    \n        # Test with a single-value 'data' argument, and a plain file 'files' argument.\n        data = {\"text\": value}\n        files = {\"file\": io.BytesIO(b\"<file content>\")}\n        response = client.post(\"http://127.0.0.1:8000/\", data=data, files=files)\n        boundary = response.request.headers[\"Content-Type\"].split(\"boundary=\")[-1]\n        boundary_bytes = boundary.encode(\"ascii\")\n    \n        assert response.status_code == 200\n>       assert response.content == b\"\".join(\n            [\n                b\"--\" + boundary_bytes + b\"\\r\\n\",\n                b'Content-Disposition: form-data; name=\"text\"\\r\\n',\n                b\"\\r\\n\",\n                b\"abc\\r\\n\",\n                b\"--\" + boundary_bytes + b\"\\r\\n\",\n                b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n',\n                b\"Content-Type: application/octet-stream\\r\\n\",\n    ..."}
{"task_id": "httpx-wsgi-L140-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In wsgi.py:140, a boolean operator was swapped: 'if seen_exc_info and seen_exc_info[0] and self.raise_app_exceptions:' became 'if seen_exc_info or seen_exc_info[0] and self.raise_app_exceptions:'. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/test_wsgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/wsgi.py", "original": "if seen_exc_info and seen_exc_info[0] and self.raise_app_exceptions:", "mutated": "if seen_exc_info or seen_exc_info[0] and self.raise_app_exceptions:", "line_num": 140}, "source": "discovered", "category": "transports", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: test_wsgi\n\nError: TypeError: 'NoneType' object is not subscriptable\n\nTraceback:\n__________________________________ test_wsgi ___________________________________\n\n    def test_wsgi():\n        transport = httpx.WSGITransport(app=application_factory([b\"Hello, World!\"]))\n        client = httpx.Client(transport=transport)\n>       response = client.get(\"http://www.example.org/\")\n\ntests/test_wsgi.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_client.py: in get\n    return self.request(\nhttpx/_client.py: in request\n    return self.send(request, auth=auth, follow_redirects=follow_redirects)\nhttpx/_client.py: in send\n    response = self._send_handling_auth(\nhttpx/_client.py: in _send_handling_auth\n    response = self._send_handling_redirects(\nhttpx/_client.py: in _send_handling_redirects\n    response = self._send_single_request(request)\nhttpx/_client.py: in _send_single_request\n    response = transport.handle_request(request)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx.WSGITransport object at 0x107dc21d0>\nrequest = <Request('GET', 'http://www.example.org/')>\n    ..."}
{"task_id": "httpx-urlparse-L300-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _urlparse.py:300, a boolean operator was swapped: 'path = kwargs.get(\"path\", url_dict[\"path\"]) or \"\"' became 'path = kwargs.get(\"path\", url_dict[\"path\"]) and \"\"'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/models/test_whatwg.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_urlparse.py", "original": "path = kwargs.get(\"path\", url_dict[\"path\"]) or \"\"", "mutated": "path = kwargs.get(\"path\", url_dict[\"path\"]) and \"\"", "line_num": 300}, "source": "discovered", "category": "url_parsing", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: test_urlparse[test_case0]\n\nError: AssertionError: assert '' == '/'\n\nTraceback:\n__________________________ test_urlparse[test_case0] ___________________________\n\ntest_case = {'base': 'http://example.org/foo/bar', 'hash': '', 'host': 'example.org', 'hostname': 'example.org', ...}\n\n    @pytest.mark.parametrize(\"test_case\", test_cases)\n    def test_urlparse(test_case):\n        if test_case[\"href\"] in (\"a: foo.com\", \"lolscheme:x x#x%20x\"):\n            # Skip these two test cases.\n            # WHATWG cases where are not using percent-encoding for the space character.\n            # Anyone know what's going on here?\n            return\n    \n        p = urlparse(test_case[\"href\"])\n    \n        # Test cases include the protocol with the trailing \":\"\n        protocol = p.scheme + \":\"\n        # Include the square brackets for IPv6 addresses.\n        hostname = f\"[{p.host}]\" if \":\" in p.host else p.host\n        # The test cases use a string representation of the port.\n        port = \"\" if p.port is None else str(p.port)\n        # I have nothing to say about this one.\n        path = p.path\n        # The 'search' and 'hash' components in the whatwg tests are semantic, not literal.\n        # Our parsing differentiates between no query/hash and empty-string query/hash.\n        search = \"\" if p.query in (None, \"\") else \"?\" + str(p.query)\n    ..."}
{"task_id": "httpx-utils-L201-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:201, a None check was inverted: 'if self.port is not None and self.port != other.port:' became 'if self.port is None and self.port != other.port:'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "if self.port is not None and self.port != other.port:", "mutated": "if self.port is None and self.port != other.port:", "line_num": 201}, "source": "discovered", "category": "utils", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_url_matches[http://example.com:123-http://example.com:456-False]\n\nError: AssertionError: assert True == False\n\nTraceback:\n____ test_url_matches[http://example.com:123-http://example.com:456-False] _____\n\npattern = <httpx._utils.URLPattern object at 0x10395ea50>\nurl = 'http://example.com:456', expected = False\n\n    @pytest.mark.parametrize(\n        [\"pattern\", \"url\", \"expected\"],\n        [\n            (\"http://example.com\", \"http://example.com\", True),\n            (\"http://example.com\", \"https://example.com\", False),\n            (\"http://example.com\", \"http://other.com\", False),\n            (\"http://example.com:123\", \"http://example.com:123\", True),\n            (\"http://example.com:123\", \"http://example.com:456\", False),\n            (\"http://example.com:123\", \"http://example.com\", False),\n            (\"all://example.com\", \"http://example.com\", True),\n            (\"all://example.com\", \"https://example.com\", True),\n            (\"http://\", \"http://example.com\", True),\n            (\"http://\", \"https://example.com\", False),\n            (\"all://\", \"https://example.com:123\", True),\n            (\"\", \"https://example.com:123\", True),\n        ],\n    )\n    def test_url_matches(pattern, url, expected):\n        pattern = URLPattern(pattern)\n>       assert pattern.matches(httpx.URL(url)) == expected\n    ..."}
{"task_id": "httpx-auth-L330-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:330, a None check was inverted: 'if qop is None:' became 'if qop is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "if qop is None:", "mutated": "if qop is not None:", "line_num": 330}, "source": "discovered", "category": "auth", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_digest_auth_with_401_nonce_counting\n\nError: KeyError: 'nc'\n\nTraceback:\n___________________ test_digest_auth_with_401_nonce_counting ___________________\n\n    def test_digest_auth_with_401_nonce_counting():\n        auth = httpx.DigestAuth(username=\"user\", password=\"pass\")\n        request = httpx.Request(\"GET\", \"https://www.example.com\")\n    \n        # The initial request should not include an auth header.\n        flow = auth.sync_auth_flow(request)\n        request = next(flow)\n        assert \"Authorization\" not in request.headers\n    \n        # If a 401 response is returned, then a digest auth request is made.\n        headers = {\n            \"WWW-Authenticate\": 'Digest realm=\"...\", qop=\"auth\", nonce=\"...\", opaque=\"...\"'\n        }\n        response = httpx.Response(\n            content=b\"Auth required\", status_code=401, headers=headers, request=request\n        )\n        first_request = flow.send(response)\n        assert first_request.headers[\"Authorization\"].startswith(\"Digest\")\n    \n        # Each subsequent request contains the digest header by default...\n        request = httpx.Request(\"GET\", \"https://www.example.com\")\n        flow = auth.sync_auth_flow(request)\n        second_request = next(flow)\n    ..."}
{"task_id": "httpx-main-L105-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:105, a None check was inverted: 'if content_type is not None:' became 'if content_type is None:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "if content_type is not None:", "mutated": "if content_type is None:", "line_num": 105}, "source": "discovered", "category": "cli", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_get\n\nError: AssertionError: assert ['HTTP/1.1 20...binary data>'] == ['HTTP/1.1 20...ello, world!']\n\nTraceback:\n___________________________________ test_get ___________________________________\n\nserver = <tests.conftest.TestServer object at 0x107d65490>\n\n    def test_get(server):\n        url = str(server.url)\n        runner = CliRunner()\n        result = runner.invoke(httpx.main, [url])\n        assert result.exit_code == 0\n>       assert remove_date_header(splitlines(result.output)) == [\n            \"HTTP/1.1 200 OK\",\n            \"server: uvicorn\",\n            \"content-type: text/plain\",\n            \"Transfer-Encoding: chunked\",\n            \"\",\n            \"Hello, world!\",\n        ]\nE       AssertionError: assert ['HTTP/1.1 20...binary data>'] == ['HTTP/1.1 20...ello, world!']\nE         \nE         At index 5 diff: '<13 bytes of binary data>' != 'Hello, world!'\nE         Use -v to get more diff\n\ntests/test_main.py: AssertionError\n---------------------------- Captured stderr setup -----------------------------\nINFO:     Started server process [56787]\n    ..."}
{"task_id": "httpx-client-L370-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _client.py:370, a None check was inverted: 'extensions = {} if extensions is None else extensions' became 'extensions = {} if extensions is not None else extensions'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/client/test_client.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_client.py", "original": "extensions = {} if extensions is None else extensions", "mutated": "extensions = {} if extensions is not None else extensions", "line_num": 370}, "source": "discovered", "category": "client", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_get\n\nError: TypeError: argument of type 'NoneType' is not iterable\n\nTraceback:\n___________________________________ test_get ___________________________________\n\nserver = <tests.conftest.TestServer object at 0x1035d9f90>\n\n    def test_get(server):\n        url = server.url\n        with httpx.Client(http2=True) as http:\n>           response = http.get(url)\n\ntests/client/test_client.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_client.py: in get\n    return self.request(\nhttpx/_client.py: in request\n    request = self.build_request(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx.Client object at 0x1019ba590>, method = 'GET'\nurl = URL('http://127.0.0.1:8000/')\n\n    def build_request(\n        self,\n        method: str,\n        url: URL | str,\n        *,\n    ..."}
{"task_id": "httpx-config-L34-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:34, a boolean operator was swapped: 'if trust_env and os.environ.get(\"SSL_CERT_FILE\"):  # pragma: nocover' became 'if trust_env or os.environ.get(\"SSL_CERT_FILE\"):  # pragma: nocover'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "if trust_env and os.environ.get(\"SSL_CERT_FILE\"):  # pragma: nocover", "mutated": "if trust_env or os.environ.get(\"SSL_CERT_FILE\"):  # pragma: nocover", "line_num": 34}, "source": "discovered", "category": "config", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: test_load_ssl_config\n\nError: KeyError: 'SSL_CERT_FILE'\n\nTraceback:\n_____________________________ test_load_ssl_config _____________________________\n\n    def test_load_ssl_config():\n>       context = httpx.create_ssl_context()\n\ntests/test_config.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_config.py: in create_ssl_context\n    ctx = ssl.create_default_context(cafile=os.environ[\"SSL_CERT_FILE\"])\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    self = environ({...})\nkey = 'SSL_CERT_FILE'\n\n>   ???\nE   KeyError: 'SSL_CERT_FILE'\n\n<frozen os>: KeyError\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-content-L51-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:51, a boolean operator was swapped: 'if self._is_stream_consumed and self._is_generator:' became 'if self._is_stream_consumed or self._is_generator:'. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "if self._is_stream_consumed and self._is_generator:", "mutated": "if self._is_stream_consumed or self._is_generator:", "line_num": 51}, "source": "discovered", "category": "content", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: test_iterator_content[asyncio]\n\nError: AssertionError: httpx.StreamConsumed: Attempted to read or stream some content, but the content has already been streamed. For requests, this could be due to passing a generator as request content, and then receiving a redirect response or a secondary request as part of an authentication flow.For responses, this could be due to attempting to stream the response content more than once.\n\nTraceback:\n________________________ test_iterator_content[asyncio] ________________________\n\n    @pytest.mark.anyio\n    async def test_iterator_content():\n        def hello_world() -> typing.Iterator[bytes]:\n            yield b\"Hello, \"\n            yield b\"world!\"\n    \n        request = httpx.Request(method, url, content=hello_world())\n        assert isinstance(request.stream, typing.Iterable)\n        assert not isinstance(request.stream, typing.AsyncIterable)\n    \n>       content = b\"\".join(list(request.stream))\n\ntests/test_content.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx._content.IteratorByteStream object at 0x107d26190>\n\n    def __iter__(self) -> Iterator[bytes]:\n        if self._is_stream_consumed or self._is_generator:\n>           raise StreamConsumed()\nE           httpx.StreamConsumed: Attempted to read or stream some content, but the content has already been streamed. For requests, this could be due to passing a generator as request content, and then receiving a redirect response or a secondary request as part of an authentication flow.For responses, this could be due to attempting to stream the response content more than once.\n\nhttpx/_content.py: StreamConsumed\n    ..."}
{"task_id": "httpx-multipart-L152-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:152, a None check was inverted: 'if content_type is not None and not has_content_type_header:' became 'if content_type is None and not has_content_type_header:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "if content_type is not None and not has_content_type_header:", "mutated": "if content_type is None and not has_content_type_header:", "line_num": 152}, "source": "discovered", "category": "multipart", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_multipart[abc-abc0]\n\nError: AssertionError: assert b'--7ffbd9849...22fc149--\\r\\n' == b'--7ffbd9849...22fc149--\\r\\n'\n\nTraceback:\n___________________________ test_multipart[abc-abc0] ___________________________\n\nvalue = 'abc', output = b'abc'\n\n    @pytest.mark.parametrize((\"value,output\"), ((\"abc\", b\"abc\"), (b\"abc\", b\"abc\")))\n    def test_multipart(value, output):\n        client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n    \n        # Test with a single-value 'data' argument, and a plain file 'files' argument.\n        data = {\"text\": value}\n        files = {\"file\": io.BytesIO(b\"<file content>\")}\n        response = client.post(\"http://127.0.0.1:8000/\", data=data, files=files)\n        boundary = response.request.headers[\"Content-Type\"].split(\"boundary=\")[-1]\n        boundary_bytes = boundary.encode(\"ascii\")\n    \n        assert response.status_code == 200\n>       assert response.content == b\"\".join(\n            [\n                b\"--\" + boundary_bytes + b\"\\r\\n\",\n                b'Content-Disposition: form-data; name=\"text\"\\r\\n',\n                b\"\\r\\n\",\n                b\"abc\\r\\n\",\n                b\"--\" + boundary_bytes + b\"\\r\\n\",\n                b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n',\n                b\"Content-Type: application/octet-stream\\r\\n\",\n    ..."}
{"task_id": "httpx-asgi-L146-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:146, a value was swapped: 'return {\"type\": \"http.request\", \"body\": body, \"more_body\": True}' became 'return {\"type\": \"http.request\", \"body\": body, \"more_body\": False}'.", "vague_description": "Two related values are mixed up. The system applies the wrong one of two options depending on context.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "return {\"type\": \"http.request\", \"body\": body, \"more_body\": True}", "mutated": "return {\"type\": \"http.request\", \"body\": body, \"more_body\": False}", "line_num": 146}, "source": "discovered", "category": "transports", "mutation_type": "value_swap", "dev_report_description": "Test failure: test_asgi_disconnect_after_response_complete[asyncio]\n\nError: AssertionError: assert False\n\nTraceback:\n____________ test_asgi_disconnect_after_response_complete[asyncio] _____________\n\n    @pytest.mark.anyio\n    async def test_asgi_disconnect_after_response_complete():\n        disconnect = False\n    \n        async def read_body(scope, receive, send):\n            nonlocal disconnect\n    \n            status = 200\n            headers = [(b\"content-type\", \"text/plain\")]\n    \n            await send(\n                {\"type\": \"http.response.start\", \"status\": status, \"headers\": headers}\n            )\n            more_body = True\n            while more_body:\n                message = await receive()\n                more_body = message.get(\"more_body\", False)\n    \n            await send({\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False})\n    \n            # The ASGI spec says of the Disconnect message:\n            # \"Sent to the application when a HTTP connection is closed or if receive is\n            # called after a response has been sent.\"\n    ..."}
{"task_id": "httpx-urlparse-L223-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _urlparse.py:223, a boolean operator was swapped: 'if any(char.isascii() and not char.isprintable() for char in url):' became 'if any(char.isascii() or not char.isprintable() for char in url):'. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/models/test_whatwg.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_urlparse.py", "original": "if any(char.isascii() and not char.isprintable() for char in url):", "mutated": "if any(char.isascii() or not char.isprintable() for char in url):", "line_num": 223}, "source": "discovered", "category": "url_parsing", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: test_urlparse[test_case0]\n\nError: AssertionError: StopIteration\n\nTraceback:\n__________________________ test_urlparse[test_case0] ___________________________\n\ntest_case = {'base': 'http://example.org/foo/bar', 'hash': '', 'host': 'example.org', 'hostname': 'example.org', ...}\n\n    @pytest.mark.parametrize(\"test_case\", test_cases)\n    def test_urlparse(test_case):\n        if test_case[\"href\"] in (\"a: foo.com\", \"lolscheme:x x#x%20x\"):\n            # Skip these two test cases.\n            # WHATWG cases where are not using percent-encoding for the space character.\n            # Anyone know what's going on here?\n            return\n    \n>       p = urlparse(test_case[\"href\"])\n\ntests/models/test_whatwg.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://example.org/', kwargs = {}\n\n    def urlparse(url: str = \"\", **kwargs: str | None) -> ParseResult:\n        # Initial basic checks on allowable URLs.\n        # ---------------------------------------\n    \n        # Hard limit the maximum allowable URL length.\n        if len(url) > MAX_URL_LENGTH:\n    ..."}
{"task_id": "httpx-utils-L174-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:174, the comparison operator was changed: 'self.scheme = \"\" if url.scheme == \"all\" else url.scheme' became 'self.scheme = \"\" if url.scheme != \"all\" else url.scheme'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "self.scheme = \"\" if url.scheme == \"all\" else url.scheme", "mutated": "self.scheme = \"\" if url.scheme != \"all\" else url.scheme", "line_num": 174}, "source": "discovered", "category": "utils", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_url_matches[http://example.com-https://example.com-False]\n\nError: AssertionError: assert True == False\n\nTraceback:\n________ test_url_matches[http://example.com-https://example.com-False] ________\n\npattern = <httpx._utils.URLPattern object at 0x105fec790>\nurl = 'https://example.com', expected = False\n\n    @pytest.mark.parametrize(\n        [\"pattern\", \"url\", \"expected\"],\n        [\n            (\"http://example.com\", \"http://example.com\", True),\n            (\"http://example.com\", \"https://example.com\", False),\n            (\"http://example.com\", \"http://other.com\", False),\n            (\"http://example.com:123\", \"http://example.com:123\", True),\n            (\"http://example.com:123\", \"http://example.com:456\", False),\n            (\"http://example.com:123\", \"http://example.com\", False),\n            (\"all://example.com\", \"http://example.com\", True),\n            (\"all://example.com\", \"https://example.com\", True),\n            (\"http://\", \"http://example.com\", True),\n            (\"http://\", \"https://example.com\", False),\n            (\"all://\", \"https://example.com:123\", True),\n            (\"\", \"https://example.com:123\", True),\n        ],\n    )\n    def test_url_matches(pattern, url, expected):\n        pattern = URLPattern(pattern)\n>       assert pattern.matches(httpx.URL(url)) == expected\n    ..."}
{"task_id": "httpx-auth-L215-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:215, a constant was changed: 'self._nonce_count = 1' became 'self._nonce_count = 0'. This shifts a boundary or default.", "vague_description": "A hardcoded value is slightly off. Behavior at specific boundaries doesn't match expectations — like an off-by-one in a limit.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "self._nonce_count = 1", "mutated": "self._nonce_count = 0", "line_num": 215}, "source": "discovered", "category": "auth", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: test_digest_auth_rfc_7616_md5\n\nError: AssertionError: assert 'nc=00000001' in 'Digest username=\"Mufasa\", realm=\"http-auth@example.org\", nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\", uri=\"/...qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\", qop=auth, nc=00000000, cnonce=\"f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ\"'\n\nTraceback:\n________________________ test_digest_auth_rfc_7616_md5 _________________________\n\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x1077b49d0>\n\n    def test_digest_auth_rfc_7616_md5(monkeypatch):\n        # Example from https://datatracker.ietf.org/doc/html/rfc7616#section-3.9.1\n    \n        def mock_get_client_nonce(nonce_count: int, nonce: bytes) -> bytes:\n            return \"f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ\".encode()\n    \n        auth = httpx.DigestAuth(username=\"Mufasa\", password=\"Circle of Life\")\n        monkeypatch.setattr(auth, \"_get_client_nonce\", mock_get_client_nonce)\n    \n        request = httpx.Request(\"GET\", \"https://www.example.com/dir/index.html\")\n    \n        # The initial request should not include an auth header.\n        flow = auth.sync_auth_flow(request)\n        request = next(flow)\n        assert \"Authorization\" not in request.headers\n    \n        # If a 401 response is returned, then a digest auth request is made.\n        headers = {\n            \"WWW-Authenticate\": (\n                'Digest realm=\"http-auth@example.org\", '\n                'qop=\"auth, auth-int\", '\n    ..."}
{"task_id": "httpx-config-L144-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:144, the comparison operator was changed: 'and self.read == other.read' became 'and self.read != other.read'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "and self.read == other.read", "mutated": "and self.read != other.read", "line_num": 144}, "source": "discovered", "category": "config", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_timeout_eq\n\nError: AssertionError: assert Timeout(timeout=5.0) == Timeout(timeout=5.0)\n\nTraceback:\n_______________________________ test_timeout_eq ________________________________\n\n    def test_timeout_eq():\n        timeout = httpx.Timeout(timeout=5.0)\n>       assert timeout == httpx.Timeout(timeout=5.0)\nE       AssertionError: assert Timeout(timeout=5.0) == Timeout(timeout=5.0)\nE        +  where Timeout(timeout=5.0) = <class 'httpx.Timeout'>(timeout=5.0)\nE        +    where <class 'httpx.Timeout'> = httpx.Timeout\n\ntests/test_config.py: AssertionError\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56834]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-content-L212-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:212, a boolean operator was swapped: 'return encode_multipart_data(data or {}, files, boundary)' became 'return encode_multipart_data(data and {}, files, boundary)'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "return encode_multipart_data(data or {}, files, boundary)", "mutated": "return encode_multipart_data(data and {}, files, boundary)", "line_num": 212}, "source": "discovered", "category": "content", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: test_multipart_files_content[asyncio]\n\nError: AttributeError: 'NoneType' object has no attribute 'items'\n\nTraceback:\n____________________ test_multipart_files_content[asyncio] _____________________\n\n    @pytest.mark.anyio\n    async def test_multipart_files_content():\n        files = {\"file\": io.BytesIO(b\"<file content>\")}\n        headers = {\"Content-Type\": \"multipart/form-data; boundary=+++\"}\n>       request = httpx.Request(\n            method,\n            url,\n            files=files,\n            headers=headers,\n        )\n\ntests/test_content.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_models.py: in __init__\n    headers, stream = encode_request(\nhttpx/_content.py: in encode_request\n    return encode_multipart_data(data and {}, files, boundary)\nhttpx/_content.py: in encode_multipart_data\n    multipart = MultipartStream(data=data, files=files, boundary=boundary)\nhttpx/_multipart.py: in __init__\n    self.fields = list(self._iter_fields(data, files))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    ..."}
{"task_id": "httpx-decoders-L137-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:137, a condition was inverted: 'if not data:' became 'if data:'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "if not data:", "mutated": "if data:", "line_num": 137}, "source": "discovered", "category": "decoders", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_brotli\n\nError: AssertionError: assert b'' == b'test 123'\n\nTraceback:\n_________________________________ test_brotli __________________________________\n\n    def test_brotli():\n        body = b\"test 123\"\n        compressed_body = b\"\\x8b\\x03\\x80test 123\\x03\"\n    \n        headers = [(b\"Content-Encoding\", b\"br\")]\n        response = httpx.Response(\n            200,\n            headers=headers,\n            content=compressed_body,\n        )\n>       assert response.content == body\nE       AssertionError: assert b'' == b'test 123'\nE         \nE         Use -v to get more diff\n\ntests/test_decoders.py: AssertionError\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-multipart-L87-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:87, a condition was inverted: 'value if isinstance(value, bytes) else primitive_value_to_str(value)' became 'value if not isinstance(value, bytes) else primitive_value_to_str(value)'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "value if isinstance(value, bytes) else primitive_value_to_str(value)", "mutated": "value if not isinstance(value, bytes) else primitive_value_to_str(value)", "line_num": 87}, "source": "discovered", "category": "multipart", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_multipart[abc-abc1]\n\nError: AssertionError: assert b'--c29eaf817...4a8b76f--\\r\\n' == b'--c29eaf817...4a8b76f--\\r\\n'\n\nTraceback:\n___________________________ test_multipart[abc-abc1] ___________________________\n\nvalue = b'abc', output = b'abc'\n\n    @pytest.mark.parametrize((\"value,output\"), ((\"abc\", b\"abc\"), (b\"abc\", b\"abc\")))\n    def test_multipart(value, output):\n        client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n    \n        # Test with a single-value 'data' argument, and a plain file 'files' argument.\n        data = {\"text\": value}\n        files = {\"file\": io.BytesIO(b\"<file content>\")}\n        response = client.post(\"http://127.0.0.1:8000/\", data=data, files=files)\n        boundary = response.request.headers[\"Content-Type\"].split(\"boundary=\")[-1]\n        boundary_bytes = boundary.encode(\"ascii\")\n    \n        assert response.status_code == 200\n>       assert response.content == b\"\".join(\n            [\n                b\"--\" + boundary_bytes + b\"\\r\\n\",\n                b'Content-Disposition: form-data; name=\"text\"\\r\\n',\n                b\"\\r\\n\",\n                b\"abc\\r\\n\",\n                b\"--\" + boundary_bytes + b\"\\r\\n\",\n                b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n',\n                b\"Content-Type: application/octet-stream\\r\\n\",\n    ..."}
{"task_id": "httpx-utils-L198-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:198, a boolean operator was swapped: 'and not self.host_regex.match(other.host)' became 'or not self.host_regex.match(other.host)'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "and not self.host_regex.match(other.host)", "mutated": "or not self.host_regex.match(other.host)", "line_num": 198}, "source": "discovered", "category": "utils", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: test_url_matches[http://example.com-http://example.com-True]\n\nError: AssertionError: assert False == True\n\nTraceback:\n_________ test_url_matches[http://example.com-http://example.com-True] _________\n\npattern = <httpx._utils.URLPattern object at 0x1043c9dd0>\nurl = 'http://example.com', expected = True\n\n    @pytest.mark.parametrize(\n        [\"pattern\", \"url\", \"expected\"],\n        [\n            (\"http://example.com\", \"http://example.com\", True),\n            (\"http://example.com\", \"https://example.com\", False),\n            (\"http://example.com\", \"http://other.com\", False),\n            (\"http://example.com:123\", \"http://example.com:123\", True),\n            (\"http://example.com:123\", \"http://example.com:456\", False),\n            (\"http://example.com:123\", \"http://example.com\", False),\n            (\"all://example.com\", \"http://example.com\", True),\n            (\"all://example.com\", \"https://example.com\", True),\n            (\"http://\", \"http://example.com\", True),\n            (\"http://\", \"https://example.com\", False),\n            (\"all://\", \"https://example.com:123\", True),\n            (\"\", \"https://example.com:123\", True),\n        ],\n    )\n    def test_url_matches(pattern, url, expected):\n        pattern = URLPattern(pattern)\n>       assert pattern.matches(httpx.URL(url)) == expected\n    ..."}
{"task_id": "httpx-auth-L235-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:235, the comparison operator was changed: 'assert scheme.lower() == \"digest\"' became 'assert scheme.lower() != \"digest\"'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "assert scheme.lower() == \"digest\"", "mutated": "assert scheme.lower() != \"digest\"", "line_num": 235}, "source": "discovered", "category": "auth", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_digest_auth_with_401\n\nError: AssertionError: AssertionError\n\nTraceback:\n__________________________ test_digest_auth_with_401 ___________________________\n\n    def test_digest_auth_with_401():\n        auth = httpx.DigestAuth(username=\"user\", password=\"pass\")\n        request = httpx.Request(\"GET\", \"https://www.example.com\")\n    \n        # The initial request should not include an auth header.\n        flow = auth.sync_auth_flow(request)\n        request = next(flow)\n        assert \"Authorization\" not in request.headers\n    \n        # If a 401 response is returned, then a digest auth request is made.\n        headers = {\n            \"WWW-Authenticate\": 'Digest realm=\"...\", qop=\"auth\", nonce=\"...\", opaque=\"...\"'\n        }\n        response = httpx.Response(\n            content=b\"Auth required\", status_code=401, headers=headers, request=request\n        )\n>       request = flow.send(response)\n\ntests/test_auth.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_auth.py: in sync_auth_flow\n    request = flow.send(response)\nhttpx/_auth.py: in auth_flow\n    ..."}
{"task_id": "httpx-main-L241-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:241, the comparison operator was changed: 'elif name == \"http11.receive_response_headers.complete\":' became 'elif name != \"http11.receive_response_headers.complete\":'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "elif name == \"http11.receive_response_headers.complete\":", "mutated": "elif name != \"http11.receive_response_headers.complete\":", "line_num": 241}, "source": "discovered", "category": "cli", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_get\n\nError: AssertionError: assert 1 == 0\n\nTraceback:\n___________________________________ test_get ___________________________________\n\nserver = <tests.conftest.TestServer object at 0x105b48d50>\n\n    def test_get(server):\n        url = str(server.url)\n        runner = CliRunner()\n        result = runner.invoke(httpx.main, [url])\n>       assert result.exit_code == 0\nE       AssertionError: assert 1 == 0\nE        +  where 1 = <Result KeyError('return_value')>.exit_code\n\ntests/test_main.py: AssertionError\n---------------------------- Captured stderr setup -----------------------------\nINFO:     Started server process [56840]\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56840]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-config-L43-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:43, a value was swapped: 'ctx.check_hostname = False' became 'ctx.check_hostname = True'.", "vague_description": "An assignment or return value is wrong — it returns the first argument where it should return the second, or similar.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "ctx.check_hostname = False", "mutated": "ctx.check_hostname = True", "line_num": 43}, "source": "discovered", "category": "config", "mutation_type": "value_swap", "dev_report_description": "Test failure: test_load_ssl_config_no_verify\n\nError: ValueError: Cannot set verify_mode to CERT_NONE when check_hostname is enabled.\n\nTraceback:\n________________________ test_load_ssl_config_no_verify ________________________\n\n    def test_load_ssl_config_no_verify():\n>       context = httpx.create_ssl_context(verify=False)\n\ntests/test_config.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_config.py: in create_ssl_context\n    ctx.verify_mode = ssl.CERT_NONE\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ssl.SSLContext object at 0x107aa0170>, value = <VerifyMode.CERT_NONE: 0>\n\n    @verify_mode.setter\n    def verify_mode(self, value):\n>       super(SSLContext, SSLContext).verify_mode.__set__(self, value)\nE       ValueError: Cannot set verify_mode to CERT_NONE when check_hostname is enabled.\n\n../../anaconda3/envs/vvenv/lib/python3.11/ssl.py: ValueError\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-content-L197-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:197, a None check was inverted: 'if data is not None and not isinstance(data, Mapping):' became 'if data is None and not isinstance(data, Mapping):'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "if data is not None and not isinstance(data, Mapping):", "mutated": "if data is None and not isinstance(data, Mapping):", "line_num": 197}, "source": "discovered", "category": "content", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_empty_content[asyncio]\n\nError: DeprecationWarning: Use 'content=<...>' to upload raw bytes/text content.\n\nTraceback:\n_________________________ test_empty_content[asyncio] __________________________\n\n    @pytest.mark.anyio\n    async def test_empty_content():\n>       request = httpx.Request(method, url)\n\ntests/test_content.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_models.py: in __init__\n    headers, stream = encode_request(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncontent = None, data = None, files = None, json = None, boundary = None\n\n    def encode_request(\n        content: RequestContent | None = None,\n        data: RequestData | None = None,\n        files: RequestFiles | None = None,\n        json: Any | None = None,\n        boundary: bytes | None = None,\n    ) -> tuple[dict[str, str], SyncByteStream | AsyncByteStream]:\n        \"\"\"\n        Handles encoding the given `content`, `data`, `files`, and `json`,\n        returning a two-tuple of (<headers>, <stream>).\n        \"\"\"\n    ..."}
{"task_id": "httpx-decoders-L186-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:186, a boolean operator was swapped: 'while self.decompressor.eof and self.decompressor.unused_data:' became 'while self.decompressor.eof or self.decompressor.unused_data:'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "while self.decompressor.eof and self.decompressor.unused_data:", "mutated": "while self.decompressor.eof or self.decompressor.unused_data:", "line_num": 186}, "source": "discovered", "category": "decoders", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: test_zstd\n\nError: httpx.DecodingError: Zstandard data is incomplete\n\nTraceback:\n__________________________________ test_zstd ___________________________________\n\n    def test_zstd():\n        body = b\"test 123\"\n        compressed_body = zstd.compress(body)\n    \n        headers = [(b\"Content-Encoding\", b\"zstd\")]\n>       response = httpx.Response(\n            200,\n            headers=headers,\n            content=compressed_body,\n        )\n\ntests/test_decoders.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_models.py: in __init__\n    self.read()\nhttpx/_models.py: in read\n    self._content = b\"\".join(self.iter_bytes())\nhttpx/_models.py: in iter_bytes\n    decoded = decoder.flush()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx._decoders.ZStandardDecoder object at 0x1062f3310>\n\n    ..."}
{"task_id": "httpx-multipart-L108-arithmetic_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:108, an arithmetic operator was changed: 'return len(headers) + len(data)' became 'return len(headers) - len(data)'. This produces wrong numeric results.", "vague_description": "A numerical calculation gives wrong output. The math is off — values are larger or smaller than expected by a consistent amount.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "return len(headers) + len(data)", "mutated": "return len(headers) - len(data)", "line_num": 108}, "source": "discovered", "category": "multipart", "mutation_type": "arithmetic_swap", "dev_report_description": "Test failure: test_multipart_encode\n\nError: AssertionError: assert Headers({'hos...ngth': '588'}) == {'Content-Len....example.com'}\n\nTraceback:\n____________________________ test_multipart_encode _____________________________\n\ntmp_path = PosixPath('/private/var/folders/vz/02yk36wx3dz6dw661rcdxcxr0000gn/T/pytest-of-akshankrithick/pytest-197/test_multipart_encode0')\n\n    def test_multipart_encode(tmp_path: typing.Any) -> None:\n        path = str(tmp_path / \"name.txt\")\n        with open(path, \"wb\") as f:\n            f.write(b\"<file content>\")\n    \n        url = \"https://www.example.com/\"\n        headers = {\"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\"}\n        data = {\n            \"a\": \"1\",\n            \"b\": b\"C\",\n            \"c\": [\"11\", \"22\", \"33\"],\n            \"d\": \"\",\n            \"e\": True,\n            \"f\": \"\",\n        }\n        with open(path, \"rb\") as input_file:\n            files = {\"file\": (\"name.txt\", input_file)}\n    \n            request = httpx.Request(\"POST\", url, headers=headers, data=data, files=files)\n            request.read()\n    \n    ..."}
{"task_id": "httpx-urlparse-L298-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _urlparse.py:298, a boolean operator was swapped: 'scheme = kwargs.get(\"scheme\", url_dict[\"scheme\"]) or \"\"' became 'scheme = kwargs.get(\"scheme\", url_dict[\"scheme\"]) and \"\"'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/models/test_whatwg.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_urlparse.py", "original": "scheme = kwargs.get(\"scheme\", url_dict[\"scheme\"]) or \"\"", "mutated": "scheme = kwargs.get(\"scheme\", url_dict[\"scheme\"]) and \"\"", "line_num": 298}, "source": "discovered", "category": "url_parsing", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: test_urlparse[test_case0]\n\nError: AssertionError: assert ':' == 'http:'\n\nTraceback:\n__________________________ test_urlparse[test_case0] ___________________________\n\ntest_case = {'base': 'http://example.org/foo/bar', 'hash': '', 'host': 'example.org', 'hostname': 'example.org', ...}\n\n    @pytest.mark.parametrize(\"test_case\", test_cases)\n    def test_urlparse(test_case):\n        if test_case[\"href\"] in (\"a: foo.com\", \"lolscheme:x x#x%20x\"):\n            # Skip these two test cases.\n            # WHATWG cases where are not using percent-encoding for the space character.\n            # Anyone know what's going on here?\n            return\n    \n        p = urlparse(test_case[\"href\"])\n    \n        # Test cases include the protocol with the trailing \":\"\n        protocol = p.scheme + \":\"\n        # Include the square brackets for IPv6 addresses.\n        hostname = f\"[{p.host}]\" if \":\" in p.host else p.host\n        # The test cases use a string representation of the port.\n        port = \"\" if p.port is None else str(p.port)\n        # I have nothing to say about this one.\n        path = p.path\n        # The 'search' and 'hash' components in the whatwg tests are semantic, not literal.\n        # Our parsing differentiates between no query/hash and empty-string query/hash.\n        search = \"\" if p.query in (None, \"\") else \"?\" + str(p.query)\n    ..."}
{"task_id": "httpx-utils-L71-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:71, the comparison operator was changed: 'elif hostname.lower() == \"localhost\":' became 'elif hostname.lower() != \"localhost\":'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "elif hostname.lower() == \"localhost\":", "mutated": "elif hostname.lower() != \"localhost\":", "line_num": 71}, "source": "discovered", "category": "utils", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_get_environment_proxies[environment8-proxies8]\n\nError: AssertionError: assert {'all://*localhost': None} == {'all://localhost': None}\n\nTraceback:\n_____________ test_get_environment_proxies[environment8-proxies8] ______________\n\nenvironment = {'no_proxy': 'localhost'}, proxies = {'all://localhost': None}\n\n    @pytest.mark.parametrize(\n        [\"environment\", \"proxies\"],\n        [\n            ({}, {}),\n            ({\"HTTP_PROXY\": \"http://127.0.0.1\"}, {\"http://\": \"http://127.0.0.1\"}),\n            (\n                {\"https_proxy\": \"http://127.0.0.1\", \"HTTP_PROXY\": \"https://127.0.0.1\"},\n                {\"https://\": \"http://127.0.0.1\", \"http://\": \"https://127.0.0.1\"},\n            ),\n            ({\"all_proxy\": \"http://127.0.0.1\"}, {\"all://\": \"http://127.0.0.1\"}),\n            ({\"TRAVIS_APT_PROXY\": \"http://127.0.0.1\"}, {}),\n            ({\"no_proxy\": \"127.0.0.1\"}, {\"all://127.0.0.1\": None}),\n            ({\"no_proxy\": \"192.168.0.0/16\"}, {\"all://192.168.0.0/16\": None}),\n            ({\"no_proxy\": \"::1\"}, {\"all://[::1]\": None}),\n            ({\"no_proxy\": \"localhost\"}, {\"all://localhost\": None}),\n            ({\"no_proxy\": \"github.com\"}, {\"all://*github.com\": None}),\n            ({\"no_proxy\": \".github.com\"}, {\"all://*.github.com\": None}),\n            ({\"no_proxy\": \"http://github.com\"}, {\"http://github.com\": None}),\n        ],\n    )\n    def test_get_environment_proxies(environment, proxies):\n    ..."}
{"task_id": "httpx-auth-L77-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:77, a value was swapped: 'while True:' became 'while False:'.", "vague_description": "An assignment or return value is wrong — it returns the first argument where it should return the second, or similar.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "while True:", "mutated": "while False:", "line_num": 77}, "source": "discovered", "category": "auth", "mutation_type": "value_swap", "dev_report_description": "Test failure: test_basic_auth\n\nError: AssertionError: StopIteration\n\nTraceback:\n_______________________________ test_basic_auth ________________________________\n\n    def test_basic_auth():\n        auth = httpx.BasicAuth(username=\"user\", password=\"pass\")\n        request = httpx.Request(\"GET\", \"https://www.example.com\")\n    \n        # The initial request should include a basic auth header.\n        flow = auth.sync_auth_flow(request)\n>       request = next(flow)\nE       StopIteration\n\ntests/test_auth.py: StopIteration\n\nThe above exception was the direct cause of the following exception:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_and_report.<locals>.<lambda> at 0x10787d760>\nwhen = 'call'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n    ..."}
{"task_id": "httpx-config-L45-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:45, a condition was inverted: 'elif isinstance(verify, str):  # pragma: nocover' became 'elif not isinstance(verify, str):  # pragma: nocover'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "elif isinstance(verify, str):  # pragma: nocover", "mutated": "elif not isinstance(verify, str):  # pragma: nocover", "line_num": 45}, "source": "discovered", "category": "config", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_SSLContext_with_get_request\n\nError: DeprecationWarning: `verify=<str>` is deprecated. Use `verify=ssl.create_default_context(cafile=...)` or `verify=ssl.create_default_context(capath=...)` instead.\n\nTraceback:\n_______________________ test_SSLContext_with_get_request _______________________\n\nserver = <tests.conftest.TestServer object at 0x105c65810>\ncert_pem_file = '/var/folders/vz/02yk36wx3dz6dw661rcdxcxr0000gn/T/tmpok_axwn6.pem'\n\n    def test_SSLContext_with_get_request(server, cert_pem_file):\n        context = httpx.create_ssl_context()\n        context.load_verify_locations(cert_pem_file)\n>       response = httpx.get(server.url, verify=context)\n\ntests/test_config.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_api.py: in get\n    return request(\nhttpx/_api.py: in request\n    with Client(\nhttpx/_client.py: in __init__\n    self._transport = self._init_transport(\nhttpx/_client.py: in _init_transport\n    return HTTPTransport(\nhttpx/_transports/default.py: in __init__\n    ssl_context = create_ssl_context(verify=verify, cert=cert, trust_env=trust_env)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nverify = <ssl.SSLContext object at 0x105fd4170>, cert = None, trust_env = True\n    ..."}
{"task_id": "httpx-decoders-L198-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:198, a condition was inverted: 'if not self.decompressor.eof:' became 'if self.decompressor.eof:'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "if not self.decompressor.eof:", "mutated": "if self.decompressor.eof:", "line_num": 198}, "source": "discovered", "category": "decoders", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_zstd\n\nError: httpx.DecodingError: Zstandard data is incomplete\n\nTraceback:\n__________________________________ test_zstd ___________________________________\n\n    def test_zstd():\n        body = b\"test 123\"\n        compressed_body = zstd.compress(body)\n    \n        headers = [(b\"Content-Encoding\", b\"zstd\")]\n>       response = httpx.Response(\n            200,\n            headers=headers,\n            content=compressed_body,\n        )\n\ntests/test_decoders.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_models.py: in __init__\n    self.read()\nhttpx/_models.py: in read\n    self._content = b\"\".join(self.iter_bytes())\nhttpx/_models.py: in iter_bytes\n    decoded = decoder.flush()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx._decoders.ZStandardDecoder object at 0x1065376d0>\n\n    ..."}
{"task_id": "httpx-multipart-L59-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:59, a boolean operator was swapped: 'if not content_type or not content_type.startswith(b\"multipart/form-data\"):' became 'if not content_type and not content_type.startswith(b\"multipart/form-data\"):'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "if not content_type or not content_type.startswith(b\"multipart/form-data\"):", "mutated": "if not content_type and not content_type.startswith(b\"multipart/form-data\"):", "line_num": 59}, "source": "discovered", "category": "multipart", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: test_multipart[abc-abc0]\n\nError: AttributeError: 'NoneType' object has no attribute 'startswith'\n\nTraceback:\n___________________________ test_multipart[abc-abc0] ___________________________\n\nvalue = 'abc', output = b'abc'\n\n    @pytest.mark.parametrize((\"value,output\"), ((\"abc\", b\"abc\"), (b\"abc\", b\"abc\")))\n    def test_multipart(value, output):\n        client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n    \n        # Test with a single-value 'data' argument, and a plain file 'files' argument.\n        data = {\"text\": value}\n        files = {\"file\": io.BytesIO(b\"<file content>\")}\n>       response = client.post(\"http://127.0.0.1:8000/\", data=data, files=files)\n\ntests/test_multipart.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_client.py: in post\n    return self.request(\nhttpx/_client.py: in request\n    request = self.build_request(\nhttpx/_client.py: in build_request\n    return Request(\nhttpx/_models.py: in __init__\n    boundary=get_multipart_boundary_from_content_type(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    ..."}
{"task_id": "httpx-asgi-L176-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:176, a None check was inverted: 'if status_code is None:' became 'if status_code is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "if status_code is None:", "mutated": "if status_code is not None:", "line_num": 176}, "source": "discovered", "category": "transports", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_asgi_exc_no_raise[asyncio]\n\nError: AssertionError: AssertionError\n\nTraceback:\n_______________________ test_asgi_exc_no_raise[asyncio] ________________________\n\n    @pytest.mark.anyio\n    async def test_asgi_exc_no_raise():\n        transport = httpx.ASGITransport(app=raise_exc, raise_app_exceptions=False)\n        async with httpx.AsyncClient(transport=transport) as client:\n>           response = await client.get(\"http://www.example.org/\")\n\ntests/test_asgi.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_client.py: in get\n    return await self.request(\nhttpx/_client.py: in request\n    return await self.send(request, auth=auth, follow_redirects=follow_redirects)\nhttpx/_client.py: in send\n    response = await self._send_handling_auth(\nhttpx/_client.py: in _send_handling_auth\n    response = await self._send_handling_redirects(\nhttpx/_client.py: in _send_handling_redirects\n    response = await self._send_single_request(request)\nhttpx/_client.py: in _send_single_request\n    response = await transport.handle_async_request(request)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx.ASGITransport object at 0x10646fcd0>\n    ..."}
{"task_id": "httpx-utils-L175-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:175, the comparison operator was changed: 'self.host = \"\" if url.host == \"*\" else url.host' became 'self.host = \"\" if url.host != \"*\" else url.host'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "self.host = \"\" if url.host == \"*\" else url.host", "mutated": "self.host = \"\" if url.host != \"*\" else url.host", "line_num": 175}, "source": "discovered", "category": "utils", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_url_matches[http://example.com-http://other.com-False]\n\nError: AssertionError: assert True == False\n\nTraceback:\n_________ test_url_matches[http://example.com-http://other.com-False] __________\n\npattern = <httpx._utils.URLPattern object at 0x1060b1990>\nurl = 'http://other.com', expected = False\n\n    @pytest.mark.parametrize(\n        [\"pattern\", \"url\", \"expected\"],\n        [\n            (\"http://example.com\", \"http://example.com\", True),\n            (\"http://example.com\", \"https://example.com\", False),\n            (\"http://example.com\", \"http://other.com\", False),\n            (\"http://example.com:123\", \"http://example.com:123\", True),\n            (\"http://example.com:123\", \"http://example.com:456\", False),\n            (\"http://example.com:123\", \"http://example.com\", False),\n            (\"all://example.com\", \"http://example.com\", True),\n            (\"all://example.com\", \"https://example.com\", True),\n            (\"http://\", \"http://example.com\", True),\n            (\"http://\", \"https://example.com\", False),\n            (\"all://\", \"https://example.com:123\", True),\n            (\"\", \"https://example.com:123\", True),\n        ],\n    )\n    def test_url_matches(pattern, url, expected):\n        pattern = URLPattern(pattern)\n>       assert pattern.matches(httpx.URL(url)) == expected\n    ..."}
{"task_id": "httpx-auth-L201-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:201, the comparison operator was changed: 'if response.status_code != 401 or \"www-authenticate\" not in response.headers:' became 'if response.status_code == 401 or \"www-authenticate\" not in response.headers:'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "if response.status_code != 401 or \"www-authenticate\" not in response.headers:", "mutated": "if response.status_code == 401 or \"www-authenticate\" not in response.headers:", "line_num": 201}, "source": "discovered", "category": "auth", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_digest_auth_with_401\n\nError: AssertionError: StopIteration\n\nTraceback:\n__________________________ test_digest_auth_with_401 ___________________________\n\n    def test_digest_auth_with_401():\n        auth = httpx.DigestAuth(username=\"user\", password=\"pass\")\n        request = httpx.Request(\"GET\", \"https://www.example.com\")\n    \n        # The initial request should not include an auth header.\n        flow = auth.sync_auth_flow(request)\n        request = next(flow)\n        assert \"Authorization\" not in request.headers\n    \n        # If a 401 response is returned, then a digest auth request is made.\n        headers = {\n            \"WWW-Authenticate\": 'Digest realm=\"...\", qop=\"auth\", nonce=\"...\", opaque=\"...\"'\n        }\n        response = httpx.Response(\n            content=b\"Auth required\", status_code=401, headers=headers, request=request\n        )\n>       request = flow.send(response)\nE       StopIteration\n\ntests/test_auth.py: StopIteration\n\nThe above exception was the direct cause of the following exception:\n\n    ..."}
{"task_id": "httpx-main-L219-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:219, the comparison operator was changed: 'elif name == \"connection.connect_tcp.complete\" and verbose:' became 'elif name != \"connection.connect_tcp.complete\" and verbose:'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "elif name == \"connection.connect_tcp.complete\" and verbose:", "mutated": "elif name != \"connection.connect_tcp.complete\" and verbose:", "line_num": 219}, "source": "discovered", "category": "cli", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_verbose\n\nError: AssertionError: assert 1 == 0\n\nTraceback:\n_________________________________ test_verbose _________________________________\n\nserver = <tests.conftest.TestServer object at 0x107f7d4d0>\n\n    def test_verbose(server):\n        url = str(server.url)\n        runner = CliRunner()\n        result = runner.invoke(httpx.main, [url, \"-v\"])\n>       assert result.exit_code == 0\nE       AssertionError: assert 1 == 0\nE        +  where 1 = <Result KeyError('return_value')>.exit_code\n\ntests/test_main.py: AssertionError\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56854]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-config-L186-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:186, a condition was inverted: 'isinstance(other, self.__class__)' became 'not isinstance(other, self.__class__)'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "isinstance(other, self.__class__)", "mutated": "not isinstance(other, self.__class__)", "line_num": 186}, "source": "discovered", "category": "config", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_limits_eq\n\nError: AssertionError: assert Limits(max_connections=100, max_keepalive_connections=None, keepalive_expiry=5.0) == Limits(max_connections=100, max_keepalive_connections=None, keepalive_expiry=5.0)\n\nTraceback:\n________________________________ test_limits_eq ________________________________\n\n    def test_limits_eq():\n        limits = httpx.Limits(max_connections=100)\n>       assert limits == httpx.Limits(max_connections=100)\nE       AssertionError: assert Limits(max_connections=100, max_keepalive_connections=None, keepalive_expiry=5.0) == Limits(max_connections=100, max_keepalive_connections=None, keepalive_expiry=5.0)\nE        +  where Limits(max_connections=100, max_keepalive_connections=None, keepalive_expiry=5.0) = <class 'httpx.Limits'>(max_connections=100)\nE        +    where <class 'httpx.Limits'> = httpx.Limits\n\ntests/test_config.py: AssertionError\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56855]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-content-L123-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:123, a None check was inverted: 'if content_length_or_none is None:' became 'if content_length_or_none is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "if content_length_or_none is None:", "mutated": "if content_length_or_none is not None:", "line_num": 123}, "source": "discovered", "category": "content", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_bytesio_content[asyncio]\n\nError: AssertionError: assert Headers({'hos...': 'chunked'}) == {'Content-Len....example.com'}\n\nTraceback:\n________________________ test_bytesio_content[asyncio] _________________________\n\n    @pytest.mark.anyio\n    async def test_bytesio_content():\n        request = httpx.Request(method, url, content=io.BytesIO(b\"Hello, world!\"))\n        assert isinstance(request.stream, typing.Iterable)\n        assert not isinstance(request.stream, typing.AsyncIterable)\n    \n        content = b\"\".join(list(request.stream))\n    \n>       assert request.headers == {\"Host\": \"www.example.com\", \"Content-Length\": \"13\"}\nE       AssertionError: assert Headers({'hos...': 'chunked'}) == {'Content-Len....example.com'}\nE         \nE         Use -v to get more diff\n\ntests/test_content.py: AssertionError\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-decoders-L181-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:181, a None check was inverted: 'assert zstandard is not None' became 'assert zstandard is None'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "assert zstandard is not None", "mutated": "assert zstandard is None", "line_num": 181}, "source": "discovered", "category": "decoders", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_zstd\n\nError: AssertionError: AssertionError\n\nTraceback:\n__________________________________ test_zstd ___________________________________\n\n    def test_zstd():\n        body = b\"test 123\"\n        compressed_body = zstd.compress(body)\n    \n        headers = [(b\"Content-Encoding\", b\"zstd\")]\n>       response = httpx.Response(\n            200,\n            headers=headers,\n            content=compressed_body,\n        )\n\ntests/test_decoders.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_models.py: in __init__\n    self.read()\nhttpx/_models.py: in read\n    self._content = b\"\".join(self.iter_bytes())\nhttpx/_models.py: in iter_bytes\n    decoded = decoder.decode(raw_bytes)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx._decoders.ZStandardDecoder object at 0x104be34d0>\ndata = b'(\\xb5/\\xfd \\x08A\\x00\\x00test 123'\n    ..."}
{"task_id": "httpx-multipart-L175-arithmetic_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:175, an arithmetic operator was changed: 'return len(headers) + len(to_bytes(self.file))' became 'return len(headers) - len(to_bytes(self.file))'. This produces wrong numeric results.", "vague_description": "A numerical calculation gives wrong output. The math is off — values are larger or smaller than expected by a consistent amount.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "return len(headers) + len(to_bytes(self.file))", "mutated": "return len(headers) - len(to_bytes(self.file))", "line_num": 175}, "source": "discovered", "category": "multipart", "mutation_type": "arithmetic_swap", "dev_report_description": "Test failure: test_multipart_encode_unicode_file_contents\n\nError: AssertionError: assert Headers({'hos...ngth': '107'}) == {'Content-Len....example.com'}\n\nTraceback:\n_________________ test_multipart_encode_unicode_file_contents __________________\n\n    def test_multipart_encode_unicode_file_contents() -> None:\n        url = \"https://www.example.com/\"\n        headers = {\"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\"}\n        files = {\"file\": (\"name.txt\", b\"<bytes content>\")}\n    \n        request = httpx.Request(\"POST\", url, headers=headers, files=files)\n        request.read()\n    \n>       assert request.headers == {\n            \"Host\": \"www.example.com\",\n            \"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\",\n            \"Content-Length\": str(len(request.content)),\n        }\nE       AssertionError: assert Headers({'hos...ngth': '107'}) == {'Content-Len....example.com'}\nE         \nE         Use -v to get more diff\n\ntests/test_multipart.py: AssertionError\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-mock-L40-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In mock.py:40, a condition was inverted: 'if not isinstance(response, Response):' became 'if isinstance(response, Response):'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/client/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/mock.py", "original": "if not isinstance(response, Response):", "mutated": "if isinstance(response, Response):", "line_num": 40}, "source": "discovered", "category": "transports", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_basic_auth[asyncio]\n\nError: TypeError: object Response can't be used in 'await' expression\n\nTraceback:\n___________________________ test_basic_auth[asyncio] ___________________________\n\n    @pytest.mark.anyio\n    async def test_basic_auth() -> None:\n        url = \"https://example.org/\"\n        auth = (\"user\", \"password123\")\n        app = App()\n    \n        async with httpx.AsyncClient(transport=httpx.MockTransport(app)) as client:\n>           response = await client.get(url, auth=auth)\n\ntests/client/test_auth.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_client.py: in get\n    return await self.request(\nhttpx/_client.py: in request\n    return await self.send(request, auth=auth, follow_redirects=follow_redirects)\nhttpx/_client.py: in send\n    response = await self._send_handling_auth(\nhttpx/_client.py: in _send_handling_auth\n    response = await self._send_handling_redirects(\nhttpx/_client.py: in _send_handling_redirects\n    response = await self._send_single_request(request)\nhttpx/_client.py: in _send_single_request\n    response = await transport.handle_async_request(request)\n    ..."}
{"task_id": "httpx-utils-L194-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:194, a value was swapped: 'return False' became 'return True'.", "vague_description": "Two related values are mixed up. The system applies the wrong one of two options depending on context.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "return False", "mutated": "return True", "line_num": 194}, "source": "discovered", "category": "utils", "mutation_type": "value_swap", "dev_report_description": "Test failure: test_url_matches[http://example.com-https://example.com-False]\n\nError: AssertionError: assert True == False\n\nTraceback:\n________ test_url_matches[http://example.com-https://example.com-False] ________\n\npattern = <httpx._utils.URLPattern object at 0x107273a50>\nurl = 'https://example.com', expected = False\n\n    @pytest.mark.parametrize(\n        [\"pattern\", \"url\", \"expected\"],\n        [\n            (\"http://example.com\", \"http://example.com\", True),\n            (\"http://example.com\", \"https://example.com\", False),\n            (\"http://example.com\", \"http://other.com\", False),\n            (\"http://example.com:123\", \"http://example.com:123\", True),\n            (\"http://example.com:123\", \"http://example.com:456\", False),\n            (\"http://example.com:123\", \"http://example.com\", False),\n            (\"all://example.com\", \"http://example.com\", True),\n            (\"all://example.com\", \"https://example.com\", True),\n            (\"http://\", \"http://example.com\", True),\n            (\"http://\", \"https://example.com\", False),\n            (\"all://\", \"https://example.com:123\", True),\n            (\"\", \"https://example.com:123\", True),\n        ],\n    )\n    def test_url_matches(pattern, url, expected):\n        pattern = URLPattern(pattern)\n>       assert pattern.matches(httpx.URL(url)) == expected\n    ..."}
{"task_id": "httpx-main-L244-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:244, the comparison operator was changed: 'elif name == \"http2.receive_response_headers.complete\":  # pragma: no cover' became 'elif name != \"http2.receive_response_headers.complete\":  # pragma: no cover'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "elif name == \"http2.receive_response_headers.complete\":  # pragma: no cover", "mutated": "elif name != \"http2.receive_response_headers.complete\":  # pragma: no cover", "line_num": 244}, "source": "discovered", "category": "cli", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_get\n\nError: AssertionError: assert 1 == 0\n\nTraceback:\n___________________________________ test_get ___________________________________\n\nserver = <tests.conftest.TestServer object at 0x103e71410>\n\n    def test_get(server):\n        url = str(server.url)\n        runner = CliRunner()\n        result = runner.invoke(httpx.main, [url])\n>       assert result.exit_code == 0\nE       AssertionError: assert 1 == 0\nE        +  where 1 = <Result KeyError('return_value')>.exit_code\n\ntests/test_main.py: AssertionError\n---------------------------- Captured stderr setup -----------------------------\nINFO:     Started server process [56874]\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56874]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-config-L112-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:112, a condition was inverted: 'isinstance(connect, UnsetType)' became 'not isinstance(connect, UnsetType)'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "isinstance(connect, UnsetType)", "mutated": "not isinstance(connect, UnsetType)", "line_num": 112}, "source": "discovered", "category": "config", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_timeout_all_parameters_set\n\nError: ValueError: httpx.Timeout must either include a default, or set all four parameters explicitly.\n\nTraceback:\n_______________________ test_timeout_all_parameters_set ________________________\n\n    def test_timeout_all_parameters_set():\n>       timeout = httpx.Timeout(connect=5.0, read=5.0, write=5.0, pool=5.0)\n\ntests/test_config.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <[AttributeError(\"'Timeout' object has no attribute 'connect'\") raised in repr()] Timeout object at 0x118462c90>\ntimeout = <httpx._config.UnsetType object at 0x105ac8590>\n\n    def __init__(\n        self,\n        timeout: TimeoutTypes | UnsetType = UNSET,\n        *,\n        connect: None | float | UnsetType = UNSET,\n        read: None | float | UnsetType = UNSET,\n        write: None | float | UnsetType = UNSET,\n        pool: None | float | UnsetType = UNSET,\n    ) -> None:\n        if isinstance(timeout, Timeout):\n            # Passed as a single explicit Timeout.\n            assert connect is UNSET\n            assert read is UNSET\n            assert write is UNSET\n    ..."}
{"task_id": "httpx-content-L129-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:129, a condition was inverted: 'elif isinstance(content, AsyncIterable):' became 'elif not isinstance(content, AsyncIterable):'. The branch now triggers in the opposite case.", "vague_description": "A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "elif isinstance(content, AsyncIterable):", "mutated": "elif not isinstance(content, AsyncIterable):", "line_num": 129}, "source": "discovered", "category": "content", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_async_bytesio_content[asyncio]\n\nError: TypeError: Unexpected type for 'content', <class 'tests.test_content.test_async_bytesio_content.<locals>.AsyncBytesIO'>\n\nTraceback:\n_____________________ test_async_bytesio_content[asyncio] ______________________\n\n    @pytest.mark.anyio\n    async def test_async_bytesio_content():\n        class AsyncBytesIO:\n            def __init__(self, content: bytes) -> None:\n                self._idx = 0\n                self._content = content\n    \n            async def aread(self, chunk_size: int) -> bytes:\n                chunk = self._content[self._idx : self._idx + chunk_size]\n                self._idx = self._idx + chunk_size\n                return chunk\n    \n            async def __aiter__(self):\n                yield self._content  # pragma: no cover\n    \n>       request = httpx.Request(method, url, content=AsyncBytesIO(b\"Hello, world!\"))\n\ntests/test_content.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_models.py: in __init__\n    headers, stream = encode_request(\nhttpx/_content.py: in encode_request\n    return encode_content(content)\n    ..."}
{"task_id": "httpx-decoders-L195-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:195, a condition was inverted: 'if not self.seen_data:' became 'if self.seen_data:'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "if not self.seen_data:", "mutated": "if self.seen_data:", "line_num": 195}, "source": "discovered", "category": "decoders", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_zstd_empty\n\nError: httpx.DecodingError: Zstandard data is incomplete\n\nTraceback:\n_______________________________ test_zstd_empty ________________________________\n\n    def test_zstd_empty():\n        headers = [(b\"Content-Encoding\", b\"zstd\")]\n>       response = httpx.Response(200, headers=headers, content=b\"\")\n\ntests/test_decoders.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_models.py: in __init__\n    self.read()\nhttpx/_models.py: in read\n    self._content = b\"\".join(self.iter_bytes())\nhttpx/_models.py: in iter_bytes\n    decoded = decoder.flush()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx._decoders.ZStandardDecoder object at 0x1056cffd0>\n\n    def flush(self) -> bytes:\n        if self.seen_data:\n            return b\"\"\n        ret = self.decompressor.flush()  # note: this is a no-op\n        if not self.decompressor.eof:\n>           raise DecodingError(\"Zstandard data is incomplete\")  # pragma: no cover\nE           httpx.DecodingError: Zstandard data is incomplete\n    ..."}
{"task_id": "httpx-multipart-L39-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:39, a constant was changed: 'return _HTML5_FORM_ENCODING_REPLACEMENTS[match.group(0)]' became 'return _HTML5_FORM_ENCODING_REPLACEMENTS[match.group(1)]'. This shifts a boundary or default.", "vague_description": "A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "return _HTML5_FORM_ENCODING_REPLACEMENTS[match.group(0)]", "mutated": "return _HTML5_FORM_ENCODING_REPLACEMENTS[match.group(1)]", "line_num": 39}, "source": "discovered", "category": "multipart", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: TestHeaderParamHTML5Formatting.test_unicode_escape\n\nError: IndexError: no such group\n\nTraceback:\n______________ TestHeaderParamHTML5Formatting.test_unicode_escape ______________\n\nself = <tests.test_multipart.TestHeaderParamHTML5Formatting object at 0x11041be90>\n\n    def test_unicode_escape(self):\n        filename = \"hello\\\\world\\u0022\"\n        expected = b'filename=\"hello\\\\\\\\world%22\"'\n        files = {\"upload\": (filename, b\"<file content>\")}\n>       request = httpx.Request(\"GET\", \"https://www.example.com\", files=files)\n\ntests/test_multipart.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_models.py: in __init__\n    headers, stream = encode_request(\nhttpx/_content.py: in encode_request\n    return encode_multipart_data(data or {}, files, boundary)\nhttpx/_content.py: in encode_multipart_data\n    headers = multipart.get_headers()\nhttpx/_multipart.py: in get_headers\n    content_length = self.get_content_length()\nhttpx/_multipart.py: in get_content_length\n    field_length = field.get_length()\nhttpx/_multipart.py: in get_length\n    headers = self.render_headers()\nhttpx/_multipart.py: in render_headers\n    ..."}
{"task_id": "httpx-asgi-L41-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:41, a value was swapped: 'return False' became 'return True'.", "vague_description": "Two values appear to be swapped. The system uses value A where it should use value B, and value B where it should use value A.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "return False", "mutated": "return True", "line_num": 41}, "source": "discovered", "category": "transports", "mutation_type": "value_swap", "dev_report_description": "Test failure: test_asgi_disconnect_after_response_complete[asyncio]\n\nError: RuntimeError: Task got bad yield: <class 'trio._core._traps.CancelShieldedCheckpoint'>\n\nTraceback:\n____________ test_asgi_disconnect_after_response_complete[asyncio] _____________\n\n    @pytest.mark.anyio\n    async def test_asgi_disconnect_after_response_complete():\n        disconnect = False\n    \n        async def read_body(scope, receive, send):\n            nonlocal disconnect\n    \n            status = 200\n            headers = [(b\"content-type\", \"text/plain\")]\n    \n            await send(\n                {\"type\": \"http.response.start\", \"status\": status, \"headers\": headers}\n            )\n            more_body = True\n            while more_body:\n                message = await receive()\n                more_body = message.get(\"more_body\", False)\n    \n            await send({\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False})\n    \n            # The ASGI spec says of the Disconnect message:\n            # \"Sent to the application when a HTTP connection is closed or if receive is\n            # called after a response has been sent.\"\n    ..."}
{"task_id": "httpx-utils-L202-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:202, a value was swapped: 'return False' became 'return True'.", "vague_description": "Two related values are mixed up. The system applies the wrong one of two options depending on context.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "return False", "mutated": "return True", "line_num": 202}, "source": "discovered", "category": "utils", "mutation_type": "value_swap", "dev_report_description": "Test failure: test_url_matches[http://example.com:123-http://example.com:456-False]\n\nError: AssertionError: assert True == False\n\nTraceback:\n____ test_url_matches[http://example.com:123-http://example.com:456-False] _____\n\npattern = <httpx._utils.URLPattern object at 0x104db1510>\nurl = 'http://example.com:456', expected = False\n\n    @pytest.mark.parametrize(\n        [\"pattern\", \"url\", \"expected\"],\n        [\n            (\"http://example.com\", \"http://example.com\", True),\n            (\"http://example.com\", \"https://example.com\", False),\n            (\"http://example.com\", \"http://other.com\", False),\n            (\"http://example.com:123\", \"http://example.com:123\", True),\n            (\"http://example.com:123\", \"http://example.com:456\", False),\n            (\"http://example.com:123\", \"http://example.com\", False),\n            (\"all://example.com\", \"http://example.com\", True),\n            (\"all://example.com\", \"https://example.com\", True),\n            (\"http://\", \"http://example.com\", True),\n            (\"http://\", \"https://example.com\", False),\n            (\"all://\", \"https://example.com:123\", True),\n            (\"\", \"https://example.com:123\", True),\n        ],\n    )\n    def test_url_matches(pattern, url, expected):\n        pattern = URLPattern(pattern)\n>       assert pattern.matches(httpx.URL(url)) == expected\n    ..."}
{"task_id": "httpx-main-L265-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:265, a boolean operator was swapped: 'total=int(content_length or 0),' became 'total=int(content_length and 0),'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "total=int(content_length or 0),", "mutated": "total=int(content_length and 0),", "line_num": 265}, "source": "discovered", "category": "cli", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: test_download\n\nError: AssertionError: assert False\n\nTraceback:\n________________________________ test_download _________________________________\n\nserver = <tests.conftest.TestServer object at 0x1055e9790>\n\n    def test_download(server):\n        url = str(server.url)\n        runner = CliRunner()\n        with runner.isolated_filesystem():\n            runner.invoke(httpx.main, [url, \"--download\", \"index.txt\"])\n>           assert os.path.exists(\"index.txt\")\nE           AssertionError: assert False\nE            +  where False = <function exists at 0x10292f600>('index.txt')\nE            +    where <function exists at 0x10292f600> = <module 'posixpath' (frozen)>.exists\nE            +      where <module 'posixpath' (frozen)> = os.path\n\ntests/test_main.py: AssertionError\n----------------------------- Captured stdout call -----------------------------\nINFO:     127.0.0.1:58063 - \"GET / HTTP/1.1\" 200 OK\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56908]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-config-L36-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:36, a boolean operator was swapped: 'elif trust_env and os.environ.get(\"SSL_CERT_DIR\"):  # pragma: nocover' became 'elif trust_env or os.environ.get(\"SSL_CERT_DIR\"):  # pragma: nocover'. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "elif trust_env and os.environ.get(\"SSL_CERT_DIR\"):  # pragma: nocover", "mutated": "elif trust_env or os.environ.get(\"SSL_CERT_DIR\"):  # pragma: nocover", "line_num": 36}, "source": "discovered", "category": "config", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: test_load_ssl_config\n\nError: KeyError: 'SSL_CERT_DIR'\n\nTraceback:\n_____________________________ test_load_ssl_config _____________________________\n\n    def test_load_ssl_config():\n>       context = httpx.create_ssl_context()\n\ntests/test_config.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_config.py: in create_ssl_context\n    ctx = ssl.create_default_context(capath=os.environ[\"SSL_CERT_DIR\"])\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    self = environ({...})\nkey = 'SSL_CERT_DIR'\n\n>   ???\nE   KeyError: 'SSL_CERT_DIR'\n\n<frozen os>: KeyError\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-content-L79-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:79, a value was swapped: 'self._is_stream_consumed = True' became 'self._is_stream_consumed = False'.", "vague_description": "Two related values are mixed up. The system applies the wrong one of two options depending on context.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "self._is_stream_consumed = True", "mutated": "self._is_stream_consumed = False", "line_num": 79}, "source": "discovered", "category": "content", "mutation_type": "value_swap", "dev_report_description": "Test failure: test_aiterator_content[asyncio]\n\nError: Failed: DID NOT RAISE <class 'httpx.StreamConsumed'>\n\nTraceback:\n_______________________ test_aiterator_content[asyncio] ________________________\n\n    @pytest.mark.anyio\n    async def test_aiterator_content():\n        async def hello_world() -> typing.AsyncIterator[bytes]:\n            yield b\"Hello, \"\n            yield b\"world!\"\n    \n        request = httpx.Request(method, url, content=hello_world())\n        assert not isinstance(request.stream, typing.Iterable)\n        assert isinstance(request.stream, typing.AsyncIterable)\n    \n        content = b\"\".join([part async for part in request.stream])\n    \n        assert request.headers == {\n            \"Host\": \"www.example.com\",\n            \"Transfer-Encoding\": \"chunked\",\n        }\n        assert content == b\"Hello, world!\"\n    \n>       with pytest.raises(httpx.StreamConsumed):\nE       Failed: DID NOT RAISE <class 'httpx.StreamConsumed'>\n\ntests/test_content.py: Failed\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-decoders-L119-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:119, a None check was inverted: 'if brotli is None:  # pragma: no cover' became 'if brotli is not None:  # pragma: no cover'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "if brotli is None:  # pragma: no cover", "mutated": "if brotli is not None:  # pragma: no cover", "line_num": 119}, "source": "discovered", "category": "decoders", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_brotli\n\nError: ImportError: Using 'BrotliDecoder', but neither of the 'brotlicffi' or 'brotli' packages have been installed. Make sure to install httpx using `pip install httpx[brotli]`.\n\nTraceback:\n_________________________________ test_brotli __________________________________\n\n    def test_brotli():\n        body = b\"test 123\"\n        compressed_body = b\"\\x8b\\x03\\x80test 123\\x03\"\n    \n        headers = [(b\"Content-Encoding\", b\"br\")]\n>       response = httpx.Response(\n            200,\n            headers=headers,\n            content=compressed_body,\n        )\n\ntests/test_decoders.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_models.py: in __init__\n    self.read()\nhttpx/_models.py: in read\n    self._content = b\"\".join(self.iter_bytes())\nhttpx/_models.py: in iter_bytes\n    decoder = self._get_content_decoder()\nhttpx/_models.py: in _get_content_decoder\n    decoders.append(decoder_cls())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    ..."}
{"task_id": "httpx-multipart-L52-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:52, a boolean operator was swapped: 'return mimetypes.guess_type(filename)[0] or \"application/octet-stream\"' became 'return mimetypes.guess_type(filename)[0] and \"application/octet-stream\"'. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "return mimetypes.guess_type(filename)[0] or \"application/octet-stream\"", "mutated": "return mimetypes.guess_type(filename)[0] and \"application/octet-stream\"", "line_num": 52}, "source": "discovered", "category": "multipart", "mutation_type": "boolean_flip", "dev_report_description": "Test failure: test_multipart[abc-abc0]\n\nError: AssertionError: assert b'--41157e850...edb994a--\\r\\n' == b'--41157e850...edb994a--\\r\\n'\n\nTraceback:\n___________________________ test_multipart[abc-abc0] ___________________________\n\nvalue = 'abc', output = b'abc'\n\n    @pytest.mark.parametrize((\"value,output\"), ((\"abc\", b\"abc\"), (b\"abc\", b\"abc\")))\n    def test_multipart(value, output):\n        client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n    \n        # Test with a single-value 'data' argument, and a plain file 'files' argument.\n        data = {\"text\": value}\n        files = {\"file\": io.BytesIO(b\"<file content>\")}\n        response = client.post(\"http://127.0.0.1:8000/\", data=data, files=files)\n        boundary = response.request.headers[\"Content-Type\"].split(\"boundary=\")[-1]\n        boundary_bytes = boundary.encode(\"ascii\")\n    \n        assert response.status_code == 200\n>       assert response.content == b\"\".join(\n            [\n                b\"--\" + boundary_bytes + b\"\\r\\n\",\n                b'Content-Disposition: form-data; name=\"text\"\\r\\n',\n                b\"\\r\\n\",\n                b\"abc\\r\\n\",\n                b\"--\" + boundary_bytes + b\"\\r\\n\",\n                b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n',\n                b\"Content-Type: application/octet-stream\\r\\n\",\n    ..."}
{"task_id": "httpx-asgi-L151-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:151, the comparison operator was changed: 'if message[\"type\"] == \"http.response.start\":' became 'if message[\"type\"] != \"http.response.start\":'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "if message[\"type\"] == \"http.response.start\":", "mutated": "if message[\"type\"] != \"http.response.start\":", "line_num": 151}, "source": "discovered", "category": "transports", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_asgi_transport[asyncio]\n\nError: KeyError: 'status'\n\nTraceback:\n_________________________ test_asgi_transport[asyncio] _________________________\n\n    @pytest.mark.anyio\n    async def test_asgi_transport():\n        async with httpx.ASGITransport(app=hello_world) as transport:\n            request = httpx.Request(\"GET\", \"http://www.example.com/\")\n>           response = await transport.handle_async_request(request)\n\ntests/test_asgi.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_transports/asgi.py: in handle_async_request\n    await self.app(scope, receive, send)\ntests/test_asgi.py: in hello_world\n    await send({\"type\": \"http.response.body\", \"body\": output})\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmessage = {'body': b'Hello, World!', 'type': 'http.response.body'}\n\n    async def send(message: typing.MutableMapping[str, typing.Any]) -> None:\n        nonlocal status_code, response_headers, response_started\n    \n        if message[\"type\"] != \"http.response.start\":\n            assert not response_started\n    \n>           status_code = message[\"status\"]\n    ..."}
{"task_id": "httpx-utils-L212-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:212, a None check was inverted: 'port_priority = 0 if self.port is not None else 1' became 'port_priority = 0 if self.port is None else 1'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "port_priority = 0 if self.port is not None else 1", "mutated": "port_priority = 0 if self.port is None else 1", "line_num": 212}, "source": "discovered", "category": "utils", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_pattern_priority\n\nError: AssertionError: assert [<httpx._util... 0x106167c10>] == [<httpx._util... 0x106167a10>]\n\nTraceback:\n____________________________ test_pattern_priority _____________________________\n\n    def test_pattern_priority():\n        matchers = [\n            URLPattern(\"all://\"),\n            URLPattern(\"http://\"),\n            URLPattern(\"http://example.com\"),\n            URLPattern(\"http://example.com:123\"),\n        ]\n        random.shuffle(matchers)\n>       assert sorted(matchers) == [\n            URLPattern(\"http://example.com:123\"),\n            URLPattern(\"http://example.com\"),\n            URLPattern(\"http://\"),\n            URLPattern(\"all://\"),\n        ]\nE       assert [<httpx._util... 0x106167c10>] == [<httpx._util... 0x106167a10>]\nE         \nE         At index 0 diff: <httpx._utils.URLPattern object at 0x106167a90> != <httpx._utils.URLPattern object at 0x106167e10>\nE         Use -v to get more diff\n\ntests/test_utils.py: AssertionError\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56914]\n    ..."}
{"task_id": "httpx-main-L174-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:174, the comparison operator was changed: 'if lexer_name.lower() == \"json\":' became 'if lexer_name.lower() != \"json\":'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "if lexer_name.lower() == \"json\":", "mutated": "if lexer_name.lower() != \"json\":", "line_num": 174}, "source": "discovered", "category": "cli", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_json\n\nError: AssertionError: assert ['HTTP/1.1 20...\": \"world!\"}'] == ['HTTP/1.1 20... '', '{', ...]\n\nTraceback:\n__________________________________ test_json ___________________________________\n\nserver = <tests.conftest.TestServer object at 0x1109695d0>\n\n    def test_json(server):\n        url = str(server.url.copy_with(path=\"/json\"))\n        runner = CliRunner()\n        result = runner.invoke(httpx.main, [url])\n        assert result.exit_code == 0\n>       assert remove_date_header(splitlines(result.output)) == [\n            \"HTTP/1.1 200 OK\",\n            \"server: uvicorn\",\n            \"content-type: application/json\",\n            \"Transfer-Encoding: chunked\",\n            \"\",\n            \"{\",\n            '\"Hello\": \"world!\"',\n            \"}\",\n        ]\nE       assert ['HTTP/1.1 20...\": \"world!\"}'] == ['HTTP/1.1 20... '', '{', ...]\nE         \nE         At index 5 diff: '{\"Hello\": \"world!\"}' != '{'\nE         Right contains 2 more items, first extra item: '\"Hello\": \"world!\"'\nE         Use -v to get more diff\n\n    ..."}
{"task_id": "httpx-config-L146-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:146, the comparison operator was changed: 'and self.pool == other.pool' became 'and self.pool != other.pool'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "and self.pool == other.pool", "mutated": "and self.pool != other.pool", "line_num": 146}, "source": "discovered", "category": "config", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_timeout_eq\n\nError: AssertionError: assert Timeout(timeout=5.0) == Timeout(timeout=5.0)\n\nTraceback:\n_______________________________ test_timeout_eq ________________________________\n\n    def test_timeout_eq():\n        timeout = httpx.Timeout(timeout=5.0)\n>       assert timeout == httpx.Timeout(timeout=5.0)\nE       AssertionError: assert Timeout(timeout=5.0) == Timeout(timeout=5.0)\nE        +  where Timeout(timeout=5.0) = <class 'httpx.Timeout'>(timeout=5.0)\nE        +    where <class 'httpx.Timeout'> = httpx.Timeout\n\ntests/test_config.py: AssertionError\n--------------------------- Captured stderr teardown ---------------------------\nINFO:     Shutting down\nINFO:     Finished server process [56916]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-content-L231-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:231, a None check was inverted: 'if content is not None:' became 'if content is None:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "if content is not None:", "mutated": "if content is None:", "line_num": 231}, "source": "discovered", "category": "content", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_response_empty_content[asyncio]\n\nError: TypeError: Unexpected type for 'content', <class 'NoneType'>\n\nTraceback:\n_____________________ test_response_empty_content[asyncio] _____________________\n\n    @pytest.mark.anyio\n    async def test_response_empty_content():\n>       response = httpx.Response(200)\n\ntests/test_content.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_models.py: in __init__\n    headers, stream = encode_response(content, text, html, json)\nhttpx/_content.py: in encode_response\n    return encode_content(content)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncontent = None\n\n    def encode_content(\n        content: str | bytes | Iterable[bytes] | AsyncIterable[bytes],\n    ) -> tuple[dict[str, str], SyncByteStream | AsyncByteStream]:\n        if isinstance(content, (bytes, str)):\n            body = content.encode(\"utf-8\") if isinstance(content, str) else content\n            content_length = len(body)\n            headers = {\"Content-Length\": str(content_length)} if body else {}\n            return headers, ByteStream(body)\n    \n    ..."}
{"task_id": "httpx-decoders-L277-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:277, a None check was inverted: 'if self._chunk_size is None:' became 'if self._chunk_size is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "if self._chunk_size is None:", "mutated": "if self._chunk_size is not None:", "line_num": 277}, "source": "discovered", "category": "decoders", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_text_decoder_with_autodetect[asyncio-data0-ascii]\n\nError: TypeError: '>=' not supported between instances of 'int' and 'NoneType'\n\nTraceback:\n____________ test_text_decoder_with_autodetect[asyncio-data0-ascii] ____________\n\ndata = (b'Hello,', b' world!'), encoding = 'ascii'\n\n    @pytest.mark.parametrize(\n        [\"data\", \"encoding\"],\n        [\n            ((b\"Hello,\", b\" world!\"), \"ascii\"),\n            ((b\"\\xe3\\x83\", b\"\\x88\\xe3\\x83\\xa9\", b\"\\xe3\", b\"\\x83\\x99\\xe3\\x83\\xab\"), \"utf-8\"),\n            ((b\"Euro character: \\x88! abcdefghijklmnopqrstuvwxyz\", b\"\"), \"cp1252\"),\n            ((b\"Accented: \\xd6sterreich abcdefghijklmnopqrstuvwxyz\", b\"\"), \"iso-8859-1\"),\n        ],\n    )\n    @pytest.mark.anyio\n    async def test_text_decoder_with_autodetect(data, encoding):\n        async def iterator() -> typing.AsyncIterator[bytes]:\n            nonlocal data\n            for chunk in data:\n                yield chunk\n    \n        def autodetect(content):\n            return chardet.detect(content).get(\"encoding\")\n    \n        # Accessing `.text` on a read response.\n        response = httpx.Response(200, content=iterator(), default_encoding=autodetect)\n    ..."}
{"task_id": "httpx-multipart-L158-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:158, a condition was inverted: 'if isinstance(fileobj, io.StringIO):' became 'if not isinstance(fileobj, io.StringIO):'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "if isinstance(fileobj, io.StringIO):", "mutated": "if not isinstance(fileobj, io.StringIO):", "line_num": 158}, "source": "discovered", "category": "multipart", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_multipart[abc-abc0]\n\nError: TypeError: Multipart file uploads require 'io.BytesIO', not 'io.StringIO'.\n\nTraceback:\n___________________________ test_multipart[abc-abc0] ___________________________\n\nvalue = 'abc', output = b'abc'\n\n    @pytest.mark.parametrize((\"value,output\"), ((\"abc\", b\"abc\"), (b\"abc\", b\"abc\")))\n    def test_multipart(value, output):\n        client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n    \n        # Test with a single-value 'data' argument, and a plain file 'files' argument.\n        data = {\"text\": value}\n        files = {\"file\": io.BytesIO(b\"<file content>\")}\n>       response = client.post(\"http://127.0.0.1:8000/\", data=data, files=files)\n\ntests/test_multipart.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_client.py: in post\n    return self.request(\nhttpx/_client.py: in request\n    request = self.build_request(\nhttpx/_client.py: in build_request\n    return Request(\nhttpx/_models.py: in __init__\n    headers, stream = encode_request(\nhttpx/_content.py: in encode_request\n    return encode_multipart_data(data or {}, files, boundary)\n    ..."}
{"task_id": "httpx-utils-L51-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:51, the comparison operator was changed: 'if hostname == \"*\":' became 'if hostname != \"*\":'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "if hostname == \"*\":", "mutated": "if hostname != \"*\":", "line_num": 51}, "source": "discovered", "category": "utils", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_get_environment_proxies[environment1-proxies1]\n\nError: AssertionError: assert {} == {'http://': '...://127.0.0.1'}\n\nTraceback:\n_____________ test_get_environment_proxies[environment1-proxies1] ______________\n\nenvironment = {'HTTP_PROXY': 'http://127.0.0.1'}\nproxies = {'http://': 'http://127.0.0.1'}\n\n    @pytest.mark.parametrize(\n        [\"environment\", \"proxies\"],\n        [\n            ({}, {}),\n            ({\"HTTP_PROXY\": \"http://127.0.0.1\"}, {\"http://\": \"http://127.0.0.1\"}),\n            (\n                {\"https_proxy\": \"http://127.0.0.1\", \"HTTP_PROXY\": \"https://127.0.0.1\"},\n                {\"https://\": \"http://127.0.0.1\", \"http://\": \"https://127.0.0.1\"},\n            ),\n            ({\"all_proxy\": \"http://127.0.0.1\"}, {\"all://\": \"http://127.0.0.1\"}),\n            ({\"TRAVIS_APT_PROXY\": \"http://127.0.0.1\"}, {}),\n            ({\"no_proxy\": \"127.0.0.1\"}, {\"all://127.0.0.1\": None}),\n            ({\"no_proxy\": \"192.168.0.0/16\"}, {\"all://192.168.0.0/16\": None}),\n            ({\"no_proxy\": \"::1\"}, {\"all://[::1]\": None}),\n            ({\"no_proxy\": \"localhost\"}, {\"all://localhost\": None}),\n            ({\"no_proxy\": \"github.com\"}, {\"all://*github.com\": None}),\n            ({\"no_proxy\": \".github.com\"}, {\"all://*.github.com\": None}),\n            ({\"no_proxy\": \"http://github.com\"}, {\"http://github.com\": None}),\n        ],\n    )\n    ..."}
{"task_id": "httpx-config-L122-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:122, a condition was inverted: 'if isinstance(timeout, UnsetType):' became 'if not isinstance(timeout, UnsetType):'. The branch now triggers in the opposite case.", "vague_description": "A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "if isinstance(timeout, UnsetType):", "mutated": "if not isinstance(timeout, UnsetType):", "line_num": 122}, "source": "discovered", "category": "config", "mutation_type": "condition_inversion", "dev_report_description": "Test failure when running: python -m pytest tests/test_config.py -x\n\nError: ValueError: httpx.Timeout must either include a default, or set all four parameters explicitly.\n\nTraceback:\nTraceback (most recent call last):\n  File \"<frozen runpy>\", in _run_module_as_main\n  File \"<frozen runpy>\", in _run_code\n  File \"__main__.py\", in <module>\n    raise SystemExit(pytest.console_main())\n                     ^^^^^^^^^^^^^^^^^^^^^\n  File \"__init__.py\", in console_main\n    code = main()\n           ^^^^^^\n  File \"__init__.py\", in main\n    config = _prepareconfig(args, plugins)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"__init__.py\", in _prepareconfig\n    config = pluginmanager.hook.pytest_cmdline_parse(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"_hooks.py\", in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"_manager.py\", in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"_callers.py\", in _multicall\n    raise exception.with_traceback(exception.__traceback__)\n  File \"_callers.py\", in _multicall\n    teardown.throw(exception)  # type: ignore[union-attr]\n    ..."}
{"task_id": "httpx-content-L233-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:233, a None check was inverted: 'elif text is not None:' became 'elif text is None:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "elif text is not None:", "mutated": "elif text is None:", "line_num": 233}, "source": "discovered", "category": "content", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_response_empty_content[asyncio]\n\nError: AttributeError: 'NoneType' object has no attribute 'encode'\n\nTraceback:\n_____________________ test_response_empty_content[asyncio] _____________________\n\n    @pytest.mark.anyio\n    async def test_response_empty_content():\n>       response = httpx.Response(200)\n\ntests/test_content.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_models.py: in __init__\n    headers, stream = encode_response(content, text, html, json)\nhttpx/_content.py: in encode_response\n    return encode_text(text)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntext = None\n\n    def encode_text(text: str) -> tuple[dict[str, str], ByteStream]:\n>       body = text.encode(\"utf-8\")\nE       AttributeError: 'NoneType' object has no attribute 'encode'\n\nhttpx/_content.py: AttributeError\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-multipart-L187-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:187, a condition was inverted: 'if not hasattr(self, \"_headers\"):' became 'if hasattr(self, \"_headers\"):'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "if not hasattr(self, \"_headers\"):", "mutated": "if hasattr(self, \"_headers\"):", "line_num": 187}, "source": "discovered", "category": "multipart", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_multipart[abc-abc0]\n\nError: AttributeError: 'FileField' object has no attribute '_headers'\n\nTraceback:\n___________________________ test_multipart[abc-abc0] ___________________________\n\nvalue = 'abc', output = b'abc'\n\n    @pytest.mark.parametrize((\"value,output\"), ((\"abc\", b\"abc\"), (b\"abc\", b\"abc\")))\n    def test_multipart(value, output):\n        client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n    \n        # Test with a single-value 'data' argument, and a plain file 'files' argument.\n        data = {\"text\": value}\n        files = {\"file\": io.BytesIO(b\"<file content>\")}\n>       response = client.post(\"http://127.0.0.1:8000/\", data=data, files=files)\n\ntests/test_multipart.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_client.py: in post\n    return self.request(\nhttpx/_client.py: in request\n    request = self.build_request(\nhttpx/_client.py: in build_request\n    return Request(\nhttpx/_models.py: in __init__\n    headers, stream = encode_request(\nhttpx/_content.py: in encode_request\n    return encode_multipart_data(data or {}, files, boundary)\n    ..."}
{"task_id": "httpx-asgi-L114-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:114, a constant was changed: '\"raw_path\": request.url.raw_path.split(b\"?\")[0],' became '\"raw_path\": request.url.raw_path.split(b\"?\")[1],'. This shifts a boundary or default.", "vague_description": "A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "\"raw_path\": request.url.raw_path.split(b\"?\")[0],", "mutated": "\"raw_path\": request.url.raw_path.split(b\"?\")[1],", "line_num": 114}, "source": "discovered", "category": "transports", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: test_asgi_transport[asyncio]\n\nError: IndexError: list index out of range\n\nTraceback:\n_________________________ test_asgi_transport[asyncio] _________________________\n\n    @pytest.mark.anyio\n    async def test_asgi_transport():\n        async with httpx.ASGITransport(app=hello_world) as transport:\n            request = httpx.Request(\"GET\", \"http://www.example.com/\")\n>           response = await transport.handle_async_request(request)\n\ntests/test_asgi.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx.ASGITransport object at 0x105204c90>\nrequest = <Request('GET', 'http://www.example.com/')>\n\n    async def handle_async_request(\n        self,\n        request: Request,\n    ) -> Response:\n        assert isinstance(request.stream, AsyncByteStream)\n    \n        # ASGI scope.\n        scope = {\n            \"type\": \"http\",\n            \"asgi\": {\"version\": \"3.0\"},\n            \"http_version\": \"1.1\",\n    ..."}
{"task_id": "httpx-utils-L193-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:193, the comparison operator was changed: 'if self.scheme and self.scheme != other.scheme:' became 'if self.scheme and self.scheme == other.scheme:'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "if self.scheme and self.scheme != other.scheme:", "mutated": "if self.scheme and self.scheme == other.scheme:", "line_num": 193}, "source": "discovered", "category": "utils", "mutation_type": "comparison_swap", "dev_report_description": "Test failure: test_url_matches[http://example.com-http://example.com-True]\n\nError: AssertionError: assert False == True\n\nTraceback:\n_________ test_url_matches[http://example.com-http://example.com-True] _________\n\npattern = <httpx._utils.URLPattern object at 0x106595690>\nurl = 'http://example.com', expected = True\n\n    @pytest.mark.parametrize(\n        [\"pattern\", \"url\", \"expected\"],\n        [\n            (\"http://example.com\", \"http://example.com\", True),\n            (\"http://example.com\", \"https://example.com\", False),\n            (\"http://example.com\", \"http://other.com\", False),\n            (\"http://example.com:123\", \"http://example.com:123\", True),\n            (\"http://example.com:123\", \"http://example.com:456\", False),\n            (\"http://example.com:123\", \"http://example.com\", False),\n            (\"all://example.com\", \"http://example.com\", True),\n            (\"all://example.com\", \"https://example.com\", True),\n            (\"http://\", \"http://example.com\", True),\n            (\"http://\", \"https://example.com\", False),\n            (\"all://\", \"https://example.com:123\", True),\n            (\"\", \"https://example.com:123\", True),\n        ],\n    )\n    def test_url_matches(pattern, url, expected):\n        pattern = URLPattern(pattern)\n>       assert pattern.matches(httpx.URL(url)) == expected\n    ..."}
{"task_id": "httpx-asgi-L129-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:129, a value was swapped: 'response_started = False' became 'response_started = True'.", "vague_description": "An assignment or return value is wrong — it returns the first argument where it should return the second, or similar.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "response_started = False", "mutated": "response_started = True", "line_num": 129}, "source": "discovered", "category": "transports", "mutation_type": "value_swap", "dev_report_description": "Test failure: test_asgi_transport[asyncio]\n\nError: AssertionError: AssertionError\n\nTraceback:\n_________________________ test_asgi_transport[asyncio] _________________________\n\n    @pytest.mark.anyio\n    async def test_asgi_transport():\n        async with httpx.ASGITransport(app=hello_world) as transport:\n            request = httpx.Request(\"GET\", \"http://www.example.com/\")\n>           response = await transport.handle_async_request(request)\n\ntests/test_asgi.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_transports/asgi.py: in handle_async_request\n    await self.app(scope, receive, send)\ntests/test_asgi.py: in hello_world\n    await send({\"type\": \"http.response.start\", \"status\": status, \"headers\": headers})\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmessage = {'headers': [(b'content-type', 'text/plain'), (b'content-length', '13')], 'status': 200, 'type': 'http.response.start'}\n\n    async def send(message: typing.MutableMapping[str, typing.Any]) -> None:\n        nonlocal status_code, response_headers, response_started\n    \n        if message[\"type\"] == \"http.response.start\":\n>           assert not response_started\nE           AssertionError\n\n    ..."}
{"task_id": "httpx-asgi-L182-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:182, a None check was inverted: 'assert status_code is not None' became 'assert status_code is None'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "assert status_code is not None", "mutated": "assert status_code is None", "line_num": 182}, "source": "discovered", "category": "transports", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_asgi_transport[asyncio]\n\nError: AssertionError: AssertionError\n\nTraceback:\n_________________________ test_asgi_transport[asyncio] _________________________\n\n    @pytest.mark.anyio\n    async def test_asgi_transport():\n        async with httpx.ASGITransport(app=hello_world) as transport:\n            request = httpx.Request(\"GET\", \"http://www.example.com/\")\n>           response = await transport.handle_async_request(request)\n\ntests/test_asgi.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx.ASGITransport object at 0x107b75090>\nrequest = <Request('GET', 'http://www.example.com/')>\n\n    async def handle_async_request(\n        self,\n        request: Request,\n    ) -> Response:\n        assert isinstance(request.stream, AsyncByteStream)\n    \n        # ASGI scope.\n        scope = {\n            \"type\": \"http\",\n            \"asgi\": {\"version\": \"3.0\"},\n            \"http_version\": \"1.1\",\n    ..."}
{"task_id": "httpx-asgi-L145-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:145, a value was swapped: 'return {\"type\": \"http.request\", \"body\": b\"\", \"more_body\": False}' became 'return {\"type\": \"http.request\", \"body\": b\"\", \"more_body\": True}'.", "vague_description": "Two related values are mixed up. The system applies the wrong one of two options depending on context.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "return {\"type\": \"http.request\", \"body\": b\"\", \"more_body\": False}", "mutated": "return {\"type\": \"http.request\", \"body\": b\"\", \"more_body\": True}", "line_num": 145}, "source": "discovered", "category": "transports", "mutation_type": "value_swap", "dev_report_description": "Test failure when running: python -m pytest tests/test_asgi.py -x\n\nError: Test execution timed out."}
{"task_id": "httpx-asgi-L177-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:177, a constant was changed: 'status_code = 500' became 'status_code = 501'. This shifts a boundary or default.", "vague_description": "A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "status_code = 500", "mutated": "status_code = 501", "line_num": 177}, "source": "discovered", "category": "transports", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: test_asgi_exc_no_raise[asyncio]\n\nError: AssertionError: assert 501 == 500\n\nTraceback:\n_______________________ test_asgi_exc_no_raise[asyncio] ________________________\n\n    @pytest.mark.anyio\n    async def test_asgi_exc_no_raise():\n        transport = httpx.ASGITransport(app=raise_exc, raise_app_exceptions=False)\n        async with httpx.AsyncClient(transport=transport) as client:\n            response = await client.get(\"http://www.example.org/\")\n    \n>           assert response.status_code == 500\nE           assert 501 == 500\nE            +  where 501 = <Response [501 Not Implemented]>.status_code\n\ntests/test_asgi.py: AssertionError\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-asgi-L103-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:103, a condition was inverted: 'assert isinstance(request.stream, AsyncByteStream)' became 'assert not isinstance(request.stream, AsyncByteStream)'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "assert isinstance(request.stream, AsyncByteStream)", "mutated": "assert not isinstance(request.stream, AsyncByteStream)", "line_num": 103}, "source": "discovered", "category": "transports", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_asgi_transport[asyncio]\n\nError: AssertionError: AssertionError\n\nTraceback:\n_________________________ test_asgi_transport[asyncio] _________________________\n\n    @pytest.mark.anyio\n    async def test_asgi_transport():\n        async with httpx.ASGITransport(app=hello_world) as transport:\n            request = httpx.Request(\"GET\", \"http://www.example.com/\")\n>           response = await transport.handle_async_request(request)\n\ntests/test_asgi.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx.ASGITransport object at 0x1083b4a90>\nrequest = <Request('GET', 'http://www.example.com/')>\n\n    async def handle_async_request(\n        self,\n        request: Request,\n    ) -> Response:\n>       assert not isinstance(request.stream, AsyncByteStream)\nE       AssertionError\n\nhttpx/_transports/asgi.py: AssertionError\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!"}
{"task_id": "httpx-wsgi-L27-return_value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In wsgi.py:27, the code was changed from 'return []' to 'return [None]' (return_value_swap).", "vague_description": "A return value is incorrect. The function returns True when it should return False, or an empty result instead of a populated one.", "test_cmd": "python -m pytest tests/test_wsgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/wsgi.py", "original": "return []", "mutated": "return [None]", "line_num": 27}, "source": "discovered", "category": "transports", "mutation_type": "return_value_swap", "dev_report_description": "Test failure: test_wsgi_generator_empty\n\nError: TypeError: object of type 'NoneType' has no len()\n\nTraceback:\n__________________________ test_wsgi_generator_empty ___________________________\n\n    def test_wsgi_generator_empty():\n        output = [b\"\", b\"\", b\"\", b\"\"]\n        transport = httpx.WSGITransport(app=application_factory(output))\n        client = httpx.Client(transport=transport)\n>       response = client.get(\"http://www.example.org/\")\n\ntests/test_wsgi.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_client.py: in get\n    return self.request(\nhttpx/_client.py: in request\n    return self.send(request, auth=auth, follow_redirects=follow_redirects)\nhttpx/_client.py: in send\n    raise exc\nhttpx/_client.py: in send\n    response.read()\nhttpx/_models.py: in read\n    self._content = b\"\".join(self.iter_bytes())\nhttpx/_models.py: in iter_bytes\n    for raw_bytes in self.iter_raw():\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Response [200 OK]>, chunk_size = None\n    ..."}
{"task_id": "httpx-wsgi-L143-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In wsgi.py:143, a constant was changed: 'status_code = int(seen_status.split()[0])' became 'status_code = int(seen_status.split()[1])'. This shifts a boundary or default.", "vague_description": "A hardcoded value is slightly off. Behavior at specific boundaries doesn't match expectations — like an off-by-one in a limit.", "test_cmd": "python -m pytest tests/test_wsgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/wsgi.py", "original": "status_code = int(seen_status.split()[0])", "mutated": "status_code = int(seen_status.split()[1])", "line_num": 143}, "source": "discovered", "category": "transports", "mutation_type": "constant_mutation", "dev_report_description": "Test failure: test_wsgi\n\nError: ValueError: invalid literal for int() with base 10: 'OK'\n\nTraceback:\n__________________________________ test_wsgi ___________________________________\n\n    def test_wsgi():\n        transport = httpx.WSGITransport(app=application_factory([b\"Hello, World!\"]))\n        client = httpx.Client(transport=transport)\n>       response = client.get(\"http://www.example.org/\")\n\ntests/test_wsgi.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_client.py: in get\n    return self.request(\nhttpx/_client.py: in request\n    return self.send(request, auth=auth, follow_redirects=follow_redirects)\nhttpx/_client.py: in send\n    response = self._send_handling_auth(\nhttpx/_client.py: in _send_handling_auth\n    response = self._send_handling_redirects(\nhttpx/_client.py: in _send_handling_redirects\n    response = self._send_single_request(request)\nhttpx/_client.py: in _send_single_request\n    response = transport.handle_request(request)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx.WSGITransport object at 0x1060acd10>\nrequest = <Request('GET', 'http://www.example.org/')>\n    ..."}
{"task_id": "httpx-asgi-L144-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:144, a value was swapped: 'request_complete = True' became 'request_complete = False'.", "vague_description": "An assignment or return value is wrong — it returns the first argument where it should return the second, or similar.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "request_complete = True", "mutated": "request_complete = False", "line_num": 144}, "source": "discovered", "category": "transports", "mutation_type": "value_swap", "dev_report_description": "Test failure: test_asgi_disconnect_after_response_complete[asyncio]\n\nError: AssertionError: assert False\n\nTraceback:\n____________ test_asgi_disconnect_after_response_complete[asyncio] _____________\n\n    @pytest.mark.anyio\n    async def test_asgi_disconnect_after_response_complete():\n        disconnect = False\n    \n        async def read_body(scope, receive, send):\n            nonlocal disconnect\n    \n            status = 200\n            headers = [(b\"content-type\", \"text/plain\")]\n    \n            await send(\n                {\"type\": \"http.response.start\", \"status\": status, \"headers\": headers}\n            )\n            more_body = True\n            while more_body:\n                message = await receive()\n                more_body = message.get(\"more_body\", False)\n    \n            await send({\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False})\n    \n            # The ASGI spec says of the Disconnect message:\n            # \"Sent to the application when a HTTP connection is closed or if receive is\n            # called after a response has been sent.\"\n    ..."}
{"task_id": "httpx-wsgi-L139-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In wsgi.py:139, a None check was inverted: 'assert seen_response_headers is not None' became 'assert seen_response_headers is None'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_wsgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/wsgi.py", "original": "assert seen_response_headers is not None", "mutated": "assert seen_response_headers is None", "line_num": 139}, "source": "discovered", "category": "transports", "mutation_type": "none_check_swap", "dev_report_description": "Test failure: test_wsgi\n\nError: AssertionError: AssertionError\n\nTraceback:\n__________________________________ test_wsgi ___________________________________\n\n    def test_wsgi():\n        transport = httpx.WSGITransport(app=application_factory([b\"Hello, World!\"]))\n        client = httpx.Client(transport=transport)\n>       response = client.get(\"http://www.example.org/\")\n\ntests/test_wsgi.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_client.py: in get\n    return self.request(\nhttpx/_client.py: in request\n    return self.send(request, auth=auth, follow_redirects=follow_redirects)\nhttpx/_client.py: in send\n    response = self._send_handling_auth(\nhttpx/_client.py: in _send_handling_auth\n    response = self._send_handling_redirects(\nhttpx/_client.py: in _send_handling_redirects\n    response = self._send_single_request(request)\nhttpx/_client.py: in _send_single_request\n    response = transport.handle_request(request)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx.WSGITransport object at 0x1080c2e50>\nrequest = <Request('GET', 'http://www.example.org/')>\n    ..."}
{"task_id": "httpx-mock-L25-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In mock.py:25, a condition was inverted: 'if not isinstance(response, Response):  # pragma: no cover' became 'if isinstance(response, Response):  # pragma: no cover'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/client/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/mock.py", "original": "if not isinstance(response, Response):  # pragma: no cover", "mutated": "if isinstance(response, Response):  # pragma: no cover", "line_num": 25}, "source": "discovered", "category": "transports", "mutation_type": "condition_inversion", "dev_report_description": "Test failure: test_netrc_auth_credentials_exist\n\nError: TypeError: Cannot use an async handler in a sync Client\n\nTraceback:\n______________________ test_netrc_auth_credentials_exist _______________________\n\n    def test_netrc_auth_credentials_exist() -> None:\n        \"\"\"\n        When netrc auth is being used and a request is made to a host that is\n        in the netrc file, then the relevant credentials should be applied.\n        \"\"\"\n        netrc_file = str(FIXTURES_DIR / \".netrc\")\n        url = \"http://netrcexample.org\"\n        app = App()\n        auth = httpx.NetRCAuth(netrc_file)\n    \n        with httpx.Client(transport=httpx.MockTransport(app), auth=auth) as client:\n>           response = client.get(url)\n\ntests/client/test_auth.py: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nhttpx/_client.py: in get\n    return self.request(\nhttpx/_client.py: in request\n    return self.send(request, auth=auth, follow_redirects=follow_redirects)\nhttpx/_client.py: in send\n    response = self._send_handling_auth(\nhttpx/_client.py: in _send_handling_auth\n    response = self._send_handling_redirects(\n    ..."}
