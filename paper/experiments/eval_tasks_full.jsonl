{"task_id":"usage-total-tokens-math","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"UsageBase.total_tokens subtracts output tokens instead of adding them, making the total_tokens property return wrong values.","vague_description":"Token usage tracking seems off. The total token count is always lower than expected, even lower than the input tokens alone.","test_cmd":"python -m pytest tests/test_usage_limits.py::test_total_token_limit -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"return self.input_tokens + self.output_tokens","mutated":"return self.input_tokens - self.output_tokens","line_num":66},"source":"handcrafted","category":"usage"}
{"task_id":"usage-request-limit-off-by-one","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"UsageLimits.check_before_request uses > instead of >= for the request limit check, allowing one extra request beyond the limit.","vague_description":"Setting request_limit=1 still allows 2 requests before stopping. The limit is off by one.","test_cmd":"python -m pytest tests/test_usage_limits.py::test_retry_limit -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"if request_limit is not None and usage.requests >= request_limit:","mutated":"if request_limit is not None and usage.requests > request_limit:","line_num":369},"source":"handcrafted","category":"usage"}
{"task_id":"usage-check-tokens-output-inverted","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"check_tokens uses 'is None' instead of 'is not None' for output_tokens_limit, so the limit is never enforced.","vague_description":"Output token limits are completely ignored. The agent generates unlimited output tokens even with output_tokens_limit set.","test_cmd":"python -m pytest tests/test_usage_limits.py::test_response_token_limit -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"if self.output_tokens_limit is not None and output_tokens > self.output_tokens_limit:","mutated":"if self.output_tokens_limit is None and output_tokens > self.output_tokens_limit:","line_num":391},"source":"handcrafted","category":"usage"}
{"task_id":"usage-incr-tokens-wrong-op","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"_incr_usage_tokens subtracts input_tokens instead of adding, causing RunUsage.incr() to produce negative token counts.","vague_description":"After multiple agent runs, the cumulative usage stats show negative input token counts. Something is wrong with the usage accumulation.","test_cmd":"python -m pytest tests/test_usage_limits.py::test_add_usages -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"slf.input_tokens += incr_usage.input_tokens","mutated":"slf.input_tokens -= incr_usage.input_tokens","line_num":231},"source":"handcrafted","category":"usage"}
{"task_id":"usage-tool-calls-limit-comparison","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"check_before_tool_call raises UsageLimitExceeded when tool calls are BELOW the limit instead of above it, blocking tools prematurely.","vague_description":"Tool calls are being rejected immediately even though the tool call limit hasn't been reached. The limit enforcement seems inverted.","test_cmd":"python -m pytest tests/test_usage_limits.py::test_tool_call_limit -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"if tool_calls_limit is not None and tool_calls > tool_calls_limit:","mutated":"if tool_calls_limit is not None and tool_calls < tool_calls_limit:","line_num":404},"source":"handcrafted","category":"usage"}
{"task_id":"ssrf-cloud-metadata-inverted","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"is_cloud_metadata_ip returns True for non-metadata IPs and False for actual cloud metadata endpoints \u2014 the check is inverted.","vague_description":"URL downloads to public websites are being blocked as 'cloud metadata', but requests to 169.254.169.254 go through unchecked.","test_cmd":"python -m pytest tests/test_ssrf.py::TestIsCloudMetadataIp -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"return ip_str in _CLOUD_METADATA_IPS","mutated":"return ip_str not in _CLOUD_METADATA_IPS","line_num":79},"source":"handcrafted","category":"ssrf"}
{"task_id":"ssrf-protocol-validation","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"validate_url_protocol rejects HTTPS URLs, only allowing plain HTTP \u2014 breaking all secure downloads.","vague_description":"All HTTPS URL downloads fail with a protocol error. Only plain HTTP URLs work, which defeats the security purpose.","test_cmd":"python -m pytest tests/test_ssrf.py::TestValidateUrlProtocol -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"if scheme not in ('http', 'https'):","mutated":"if scheme not in ('http',):","line_num":145},"source":"handcrafted","category":"ssrf"}
{"task_id":"ssrf-default-port-swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"extract_host_and_port swaps default ports \u2014 HTTPS gets port 80 and HTTP gets port 443, breaking URL resolution.","vague_description":"URL downloads fail silently. HTTPS connections seem to be going to the wrong port.","test_cmd":"python -m pytest tests/test_ssrf.py::TestExtractHostAndPort -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"default_port = 443 if is_https else 80","mutated":"default_port = 80 if is_https else 443","line_num":169},"source":"handcrafted","category":"ssrf"}
{"task_id":"ssrf-private-ip-allow-local-inverted","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"The allow_local guard is inverted \u2014 private IPs are blocked when allow_local=True and allowed when allow_local=False.","vague_description":"Setting allow_local=True blocks local network requests, and removing it allows them. The flag seems to do the opposite of what it should.","test_cmd":"python -m pytest tests/test_ssrf.py::TestValidateAndResolveUrl::test_private_ip_blocked_by_default -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"if not allow_local and is_private_ip(ip):","mutated":"if allow_local and is_private_ip(ip):","line_num":241},"source":"handcrafted","category":"ssrf"}
{"task_id":"tool-retry-isinstance-inverted","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"ToolRetryError._format_error_details inverts the isinstance check, passing string content to dict-processing code and crashing.","vague_description":"Tool retry errors crash with a TypeError when the tool returns a simple string error message. Only structured errors work.","test_cmd":"python -m pytest tests/test_exceptions.py::test_tool_retry_error_str_with_string_content -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/exceptions.py","original":"if isinstance(tool_retry.content, str)","mutated":"if not isinstance(tool_retry.content, str)","line_num":205},"source":"handcrafted","category":"exceptions"}
{"task_id":"tool-retry-error-format","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"ToolRetryError pluralization is inverted \u2014 says 'errors' for 1 error and 'error' for multiple.","vague_description":"Tool retry error messages have wrong grammar. A single validation error says 'errors' plural.","test_cmd":"python -m pytest tests/test_exceptions.py::test_tool_retry_error_str_with_error_details -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/exceptions.py","original":"f'{error_count} validation error{\"\" if error_count == 1 else \"s\"}{f\" for {tool_name!r}\" if tool_name else \"\"}'","mutated":"f'{error_count} validation error{\"s\" if error_count == 1 else \"\"}{f\" for {tool_name!r}\" if tool_name else \"\"}'","line_num":221},"source":"handcrafted","category":"exceptions"}
{"task_id":"settings-merge-priority","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"merge_model_settings gives base settings priority over overrides instead of the other way around, ignoring per-run settings.","vague_description":"Model settings passed to agent.run() are silently ignored. The agent always uses the settings from initialization.","test_cmd":"python -m pytest tests/test_agent.py::test_model_settings_override -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/settings.py","original":"return base | overrides","mutated":"return overrides | base","line_num":192},"source":"handcrafted","category":"settings"}
{"task_id":"ssrf-ipv4-mapped-ipv6-skip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"is_private_ip skips IPv4-mapped IPv6 unwrapping for actual mapped addresses, failing to detect private IPs in IPv6 form.","vague_description":"Private IP addresses wrapped in IPv6 notation bypass the SSRF protection. For example ::ffff:192.168.1.1 is not blocked.","test_cmd":"python -m pytest tests/test_ssrf.py::TestIsPrivateIp::test_ipv4_mapped_ipv6_private -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"if isinstance(ip, ipaddress.IPv6Address) and ip.ipv4_mapped:","mutated":"if isinstance(ip, ipaddress.IPv6Address) and not ip.ipv4_mapped:","line_num":91},"source":"handcrafted","category":"ssrf"}
{"task_id":"ssrf-max-redirects-zero","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"_MAX_REDIRECTS is set to 0, preventing any HTTP redirects from being followed during safe downloads.","vague_description":"URL downloads that involve redirects always fail. The downloader seems unable to follow even a single redirect.","test_cmd":"python -m pytest tests/test_ssrf.py::TestSafeDownload::test_redirect_followed -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"_MAX_REDIRECTS = 10","mutated":"_MAX_REDIRECTS = 0","line_num":50},"source":"handcrafted","category":"ssrf"}
{"task_id":"d-builtin_tools-L74-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In builtin_tools.py:74, a condition was inverted: 'if cls is not AbstractBuiltinTool:' became 'if cls is AbstractBuiltinTool:'. The branch now triggers in the opposite case.","vague_description":"A guard clause or check does the opposite of what it should. The happy path and error path are swapped.","test_cmd":"python -m pytest tests/test_builtin_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/builtin_tools.py","original":"if cls is not AbstractBuiltinTool:","mutated":"if cls is AbstractBuiltinTool:","line_num":74},"source":"discovered","category":"builtin_tools","mutation_type":"condition_inversion"}
{"task_id":"d-concurrency-L290-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In concurrency.py:290, a None check was inverted: 'if limit is None:' became 'if limit is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.","test_cmd":"python -m pytest tests/test_concurrency.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/concurrency.py","original":"if limit is None:","mutated":"if limit is not None:","line_num":290},"source":"discovered","category":"concurrency","mutation_type":"none_check_swap"}
{"task_id":"d-direct-L316-value_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In direct.py:316, a value was swapped: 'while True:' became 'while False:'.","vague_description":"Two related values are mixed up. The system applies the wrong one of two options depending on context.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/direct.py","original":"while True:","mutated":"while False:","line_num":316},"source":"discovered","category":"direct_api","mutation_type":"value_swap"}
{"task_id":"d-json_schema-L128-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _json_schema.py:128, a None check was inverted: 'if (additional_properties := schema.get('additionalProperties')) is not None:' became 'if (additional_properties := schema.get('additionalProperties')) is None:'. This reverses when the value is considered present vs absent.","vague_description":"Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.","test_cmd":"python -m pytest tests/test_json_schema.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_json_schema.py","original":"if (additional_properties := schema.get('additionalProperties')) is not None:","mutated":"if (additional_properties := schema.get('additionalProperties')) is None:","line_num":128},"source":"discovered","category":"json_schema","mutation_type":"none_check_swap"}
{"task_id":"d-instrumented-L68-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In instrumented.py:68, a boolean operator was swapped: 'if instrument and not isinstance(model, InstrumentedModel):' became 'if instrument or not isinstance(model, InstrumentedModel):'. This changes the logical condition.","vague_description":"A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/models/instrumented.py","original":"if instrument and not isinstance(model, InstrumentedModel):","mutated":"if instrument or not isinstance(model, InstrumentedModel):","line_num":68},"source":"discovered","category":"models","mutation_type":"boolean_flip"}
{"task_id":"d-parts_manager-L211-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _parts_manager.py:211, a None check was inverted: 'if vendor_part_id is None:' became 'if vendor_part_id is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.","test_cmd":"python -m pytest tests/test_parts_manager.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_parts_manager.py","original":"if vendor_part_id is None:","mutated":"if vendor_part_id is not None:","line_num":211},"source":"discovered","category":"parts_manager","mutation_type":"none_check_swap"}
{"task_id":"d-retries-L369-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In retries.py:369, a condition was inverted: 'assert isinstance(retry_time, datetime)' became 'assert not isinstance(retry_time, datetime)'. The branch now triggers in the opposite case.","vague_description":"Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.","test_cmd":"python -m pytest tests/test_tenacity.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/retries.py","original":"assert isinstance(retry_time, datetime)","mutated":"assert not isinstance(retry_time, datetime)","line_num":369},"source":"discovered","category":"retries","mutation_type":"condition_inversion"}
{"task_id":"d-ssrf-L201-comparison_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _ssrf.py:201, the comparison operator was changed: 'if resolved.port != default_port:' became 'if resolved.port == default_port:'. This alters the boundary condition.","vague_description":"A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.","test_cmd":"python -m pytest tests/test_ssrf.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"if resolved.port != default_port:","mutated":"if resolved.port == default_port:","line_num":201},"source":"discovered","category":"ssrf","mutation_type":"comparison_swap"}
{"task_id":"d-thinking_part-L22-arithmetic_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _thinking_part.py:22, an arithmetic operator was changed: 'think_content, content = content[:end_index], content[end_index + len(end_tag) :]' became 'think_content, content = content[:end_index], content[end_index - len(end_tag) :]'. This produces wrong numeric results.","vague_description":"Computed values are consistently wrong. The computation seems to use subtraction where it should add, or vice versa.","test_cmd":"python -m pytest tests/test_thinking_part.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_thinking_part.py","original":"think_content, content = content[:end_index], content[end_index + len(end_tag) :]","mutated":"think_content, content = content[:end_index], content[end_index - len(end_tag) :]","line_num":22},"source":"discovered","category":"thinking","mutation_type":"arithmetic_swap"}
{"task_id":"d-tools-L251-value_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In tools.py:251, a value was swapped: 'json_schema['additionalProperties'] = False' became 'json_schema['additionalProperties'] = True'.","vague_description":"An assignment or return value is wrong \u2014 it returns the first argument where it should return the second, or similar.","test_cmd":"python -m pytest tests/test_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/tools.py","original":"json_schema['additionalProperties'] = False","mutated":"json_schema['additionalProperties'] = True","line_num":251},"source":"discovered","category":"tools","mutation_type":"value_swap"}
{"task_id":"d-app-L89-constant_mutation","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In app.py:89, a constant was changed: 'url_hash = hashlib.sha256(html_source.encode()).hexdigest()[:16]' became 'url_hash = hashlib.sha256(html_source.encode()).hexdigest()[:17]'. This shifts a boundary or default.","vague_description":"A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.","test_cmd":"python -m pytest tests/test_ui_web.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/ui/_web/app.py","original":"url_hash = hashlib.sha256(html_source.encode()).hexdigest()[:16]","mutated":"url_hash = hashlib.sha256(html_source.encode()).hexdigest()[:17]","line_num":89},"source":"discovered","category":"ui","mutation_type":"constant_mutation"}
{"task_id":"d-usage-L240-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In usage.py:240, a condition was inverted: 'if isinstance(value, (int, float)):' became 'if not isinstance(value, (int, float)):'. The branch now triggers in the opposite case.","vague_description":"A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.","test_cmd":"python -m pytest tests/test_usage_limits.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"if isinstance(value, (int, float)):","mutated":"if not isinstance(value, (int, float)):","line_num":240},"source":"discovered","category":"usage","mutation_type":"condition_inversion"}
{"task_id":"d-utils-L243-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _utils.py:243, a None check was inverted: 'if group_start_time is None:' became 'if group_start_time is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.","test_cmd":"python -m pytest tests/test_utils.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_utils.py","original":"if group_start_time is None:","mutated":"if group_start_time is not None:","line_num":243},"source":"discovered","category":"utils","mutation_type":"none_check_swap"}
{"task_id":"d-builtin_tools-L469-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In builtin_tools.py:469, a condition was inverted: 'if isinstance(tool_data, dict):' became 'if not isinstance(tool_data, dict):'. The branch now triggers in the opposite case.","vague_description":"A guard clause or check does the opposite of what it should. The happy path and error path are swapped.","test_cmd":"python -m pytest tests/test_builtin_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/builtin_tools.py","original":"if isinstance(tool_data, dict):","mutated":"if not isinstance(tool_data, dict):","line_num":469},"source":"discovered","category":"builtin_tools","mutation_type":"condition_inversion"}
{"task_id":"d-concurrency-L130-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In concurrency.py:130, a condition was inverted: 'if isinstance(limit, int):' became 'if not isinstance(limit, int):'. The branch now triggers in the opposite case.","vague_description":"A guard clause or check does the opposite of what it should. The happy path and error path are swapped.","test_cmd":"python -m pytest tests/test_concurrency.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/concurrency.py","original":"if isinstance(limit, int):","mutated":"if not isinstance(limit, int):","line_num":130},"source":"discovered","category":"concurrency","mutation_type":"condition_inversion"}
{"task_id":"d-direct-L343-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In direct.py:343, a None check was inverted: 'if self._stream_response is None:' became 'if self._stream_response is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/direct.py","original":"if self._stream_response is None:","mutated":"if self._stream_response is not None:","line_num":343},"source":"discovered","category":"direct_api","mutation_type":"none_check_swap"}
{"task_id":"d-parts_manager-L223-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _parts_manager.py:223, a None check was inverted: 'if existing_thinking_part_and_index is None:' became 'if existing_thinking_part_and_index is not None:'. This reverses when the value is considered present vs absent.","vague_description":"A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.","test_cmd":"python -m pytest tests/test_parts_manager.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_parts_manager.py","original":"if existing_thinking_part_and_index is None:","mutated":"if existing_thinking_part_and_index is not None:","line_num":223},"source":"discovered","category":"parts_manager","mutation_type":"none_check_swap"}
{"task_id":"d-retries-L354-constant_mutation","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In retries.py:354, a constant was changed: 'fallback_strategy = wait_exponential(multiplier=1, max=60)' became 'fallback_strategy = wait_exponential(multiplier=0, max=60)'. This shifts a boundary or default.","vague_description":"A hardcoded value is slightly off. Behavior at specific boundaries doesn't match expectations \u2014 like an off-by-one in a limit.","test_cmd":"python -m pytest tests/test_tenacity.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/retries.py","original":"fallback_strategy = wait_exponential(multiplier=1, max=60)","mutated":"fallback_strategy = wait_exponential(multiplier=0, max=60)","line_num":354},"source":"discovered","category":"retries","mutation_type":"constant_mutation"}
{"task_id":"d-ssrf-L166-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _ssrf.py:166, a condition was inverted: 'if not hostname:' became 'if hostname:'. The branch now triggers in the opposite case.","vague_description":"A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.","test_cmd":"python -m pytest tests/test_ssrf.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"if not hostname:","mutated":"if hostname:","line_num":166},"source":"discovered","category":"ssrf","mutation_type":"condition_inversion"}
{"task_id":"d-thinking_part-L17-arithmetic_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _thinking_part.py:17, an arithmetic operator was changed: 'before_think, content = content[:start_index], content[start_index + len(start_tag) :]' became 'before_think, content = content[:start_index], content[start_index - len(start_tag) :]'. This produces wrong numeric results.","vague_description":"An accumulator or counter is going in the wrong direction. Values that should increase are decreasing, or the formula uses the wrong operator.","test_cmd":"python -m pytest tests/test_thinking_part.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_thinking_part.py","original":"before_think, content = content[:start_index], content[start_index + len(start_tag) :]","mutated":"before_think, content = content[:start_index], content[start_index - len(start_tag) :]","line_num":17},"source":"discovered","category":"thinking","mutation_type":"arithmetic_swap"}
{"task_id":"d-tools-L377-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In tools.py:377, a boolean operator was swapped: 'self.name = name or function.__name__' became 'self.name = name and function.__name__'. This changes the logical condition.","vague_description":"A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.","test_cmd":"python -m pytest tests/test_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/tools.py","original":"self.name = name or function.__name__","mutated":"self.name = name and function.__name__","line_num":377},"source":"discovered","category":"tools","mutation_type":"boolean_flip"}
{"task_id":"d-app-L80-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In app.py:80, a condition was inverted: 'if isinstance(html_source, Path):' became 'if not isinstance(html_source, Path):'. The branch now triggers in the opposite case.","vague_description":"A guard clause or check does the opposite of what it should. The happy path and error path are swapped.","test_cmd":"python -m pytest tests/test_ui_web.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/ui/_web/app.py","original":"if isinstance(html_source, Path):","mutated":"if not isinstance(html_source, Path):","line_num":80},"source":"discovered","category":"ui","mutation_type":"condition_inversion"}
{"task_id":"d-usage-L373-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In usage.py:373, a None check was inverted: 'if self.input_tokens_limit is not None and input_tokens > self.input_tokens_limit:' became 'if self.input_tokens_limit is None and input_tokens > self.input_tokens_limit:'. This reverses when the value is considered present vs absent.","vague_description":"Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.","test_cmd":"python -m pytest tests/test_usage_limits.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"if self.input_tokens_limit is not None and input_tokens > self.input_tokens_limit:","mutated":"if self.input_tokens_limit is None and input_tokens > self.input_tokens_limit:","line_num":373},"source":"discovered","category":"usage","mutation_type":"none_check_swap"}
{"task_id":"d-utils-L212-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _utils.py:212, a None check was inverted: 'if group_start_time is None:' became 'if group_start_time is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.","test_cmd":"python -m pytest tests/test_utils.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_utils.py","original":"if group_start_time is None:","mutated":"if group_start_time is not None:","line_num":212},"source":"discovered","category":"utils","mutation_type":"none_check_swap"}
{"task_id":"d-concurrency-L222-constant_mutation","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In concurrency.py:222, a constant was changed: 'self._waiting_count -= 1' became 'self._waiting_count -= 0'. This shifts a boundary or default.","vague_description":"A hardcoded value is slightly off. Behavior at specific boundaries doesn't match expectations \u2014 like an off-by-one in a limit.","test_cmd":"python -m pytest tests/test_concurrency.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/concurrency.py","original":"self._waiting_count -= 1","mutated":"self._waiting_count -= 0","line_num":222},"source":"discovered","category":"concurrency","mutation_type":"constant_mutation"}
{"task_id":"d-direct-L320-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In direct.py:320, a condition was inverted: 'elif isinstance(item, Exception):' became 'elif not isinstance(item, Exception):'. The branch now triggers in the opposite case.","vague_description":"A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/direct.py","original":"elif isinstance(item, Exception):","mutated":"elif not isinstance(item, Exception):","line_num":320},"source":"discovered","category":"direct_api","mutation_type":"condition_inversion"}
{"task_id":"d-exceptions-L147-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In exceptions.py:147, a None check was inverted: 'if body is None:' became 'if body is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.","test_cmd":"python -m pytest tests/test_exceptions.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/exceptions.py","original":"if body is None:","mutated":"if body is not None:","line_num":147},"source":"discovered","category":"exceptions","mutation_type":"none_check_swap"}
{"task_id":"d-json_schema-L109-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _json_schema.py:109, a None check was inverted: 'elif type_ is None:' became 'elif type_ is not None:'. This reverses when the value is considered present vs absent.","vague_description":"A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.","test_cmd":"python -m pytest tests/test_json_schema.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_json_schema.py","original":"elif type_ is None:","mutated":"elif type_ is not None:","line_num":109},"source":"discovered","category":"json_schema","mutation_type":"none_check_swap"}
{"task_id":"d-messages-L165-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In messages.py:165, a condition was inverted: 'if isinstance(identifier, str):' became 'if not isinstance(identifier, str):'. The branch now triggers in the opposite case.","vague_description":"Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.","test_cmd":"python -m pytest tests/test_messages.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/messages.py","original":"if isinstance(identifier, str):","mutated":"if not isinstance(identifier, str):","line_num":165},"source":"discovered","category":"messages","mutation_type":"condition_inversion"}
{"task_id":"d-parts_manager-L135-comparison_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _parts_manager.py:135, the comparison operator was changed: 'if content == thinking_tags[1]:' became 'if content != thinking_tags[1]:'. This alters the boundary condition.","vague_description":"Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.","test_cmd":"python -m pytest tests/test_parts_manager.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_parts_manager.py","original":"if content == thinking_tags[1]:","mutated":"if content != thinking_tags[1]:","line_num":135},"source":"discovered","category":"parts_manager","mutation_type":"comparison_swap"}
{"task_id":"d-retries-L165-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In retries.py:165, a boolean operator was swapped: 'self.wrapped = wrapped or HTTPTransport()' became 'self.wrapped = wrapped and HTTPTransport()'. This changes the logical condition.","vague_description":"A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.","test_cmd":"python -m pytest tests/test_tenacity.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/retries.py","original":"self.wrapped = wrapped or HTTPTransport()","mutated":"self.wrapped = wrapped and HTTPTransport()","line_num":165},"source":"discovered","category":"retries","mutation_type":"boolean_flip"}
{"task_id":"d-ssrf-L94-membership_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _ssrf.py:94, a membership test was inverted: 'return any(ip in network for network in _PRIVATE_NETWORKS)' became 'return any(ip not in network for network in _PRIVATE_NETWORKS)'. This reverses which values pass the check.","vague_description":"A filter or validation check accepts the wrong set of values. Things that should match don't, and things that shouldn't match do.","test_cmd":"python -m pytest tests/test_ssrf.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"return any(ip in network for network in _PRIVATE_NETWORKS)","mutated":"return any(ip not in network for network in _PRIVATE_NETWORKS)","line_num":94},"source":"discovered","category":"ssrf","mutation_type":"membership_swap"}
{"task_id":"d-tools-L247-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In tools.py:247, a boolean operator was swapped: 'json_schema['additionalProperties'] = self.generate_inner(extras_schema) or True' became 'json_schema['additionalProperties'] = self.generate_inner(extras_schema) and True'. This changes the logical condition.","vague_description":"An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.","test_cmd":"python -m pytest tests/test_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/tools.py","original":"json_schema['additionalProperties'] = self.generate_inner(extras_schema) or True","mutated":"json_schema['additionalProperties'] = self.generate_inner(extras_schema) and True","line_num":247},"source":"discovered","category":"tools","mutation_type":"boolean_flip"}
{"task_id":"d-utils-L133-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _utils.py:133, a boolean operator was swapped: 'return any(isinstance(item, dict | list) and _contains_ref(item) for item in items)  # pyright: ignore[reportUnknownArgumentType]' became 'return any(isinstance(item, dict | list) or _contains_ref(item) for item in items)  # pyright: ignore[reportUnknownArgumentType]'. This changes the logical condition.","vague_description":"A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.","test_cmd":"python -m pytest tests/test_utils.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_utils.py","original":"return any(isinstance(item, dict | list) and _contains_ref(item) for item in items)  # pyright: ignore[reportUnknownArgumentType]","mutated":"return any(isinstance(item, dict | list) or _contains_ref(item) for item in items)  # pyright: ignore[reportUnknownArgumentType]","line_num":133},"source":"discovered","category":"utils","mutation_type":"boolean_flip"}
{"task_id":"d-builtin_tools-L78-comparison_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In builtin_tools.py:78, the comparison operator was changed: 'if len(tools) == 1:  # pragma: no cover' became 'if len(tools) != 1:  # pragma: no cover'. This alters the boundary condition.","vague_description":"A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.","test_cmd":"python -m pytest tests/test_builtin_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/builtin_tools.py","original":"if len(tools) == 1:  # pragma: no cover","mutated":"if len(tools) != 1:  # pragma: no cover","line_num":78},"source":"discovered","category":"builtin_tools","mutation_type":"comparison_swap"}
{"task_id":"d-concurrency-L73-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In concurrency.py:73, a condition was inverted: 'if isinstance(limiter, AbstractConcurrencyLimiter):' became 'if not isinstance(limiter, AbstractConcurrencyLimiter):'. The branch now triggers in the opposite case.","vague_description":"A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.","test_cmd":"python -m pytest tests/test_concurrency.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/models/concurrency.py","original":"if isinstance(limiter, AbstractConcurrencyLimiter):","mutated":"if not isinstance(limiter, AbstractConcurrencyLimiter):","line_num":73},"source":"discovered","category":"concurrency","mutation_type":"condition_inversion"}
{"task_id":"d-direct-L300-value_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In direct.py:300, a value was swapped: 'self._context_entered = True' became 'self._context_entered = False'.","vague_description":"Two values appear to be swapped. The system uses value A where it should use value B, and value B where it should use value A.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/direct.py","original":"self._context_entered = True","mutated":"self._context_entered = False","line_num":300},"source":"discovered","category":"direct_api","mutation_type":"value_swap"}
{"task_id":"d-parts_manager-L83-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _parts_manager.py:83, a None check was inverted: 'if part_index is not None:' became 'if part_index is None:'. This reverses when the value is considered present vs absent.","vague_description":"Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.","test_cmd":"python -m pytest tests/test_parts_manager.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_parts_manager.py","original":"if part_index is not None:","mutated":"if part_index is None:","line_num":83},"source":"discovered","category":"parts_manager","mutation_type":"none_check_swap"}
{"task_id":"d-retries-L358-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In retries.py:358, a condition was inverted: 'if isinstance(exc, HTTPStatusError):' became 'if not isinstance(exc, HTTPStatusError):'. The branch now triggers in the opposite case.","vague_description":"A guard clause or check does the opposite of what it should. The happy path and error path are swapped.","test_cmd":"python -m pytest tests/test_tenacity.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/retries.py","original":"if isinstance(exc, HTTPStatusError):","mutated":"if not isinstance(exc, HTTPStatusError):","line_num":358},"source":"discovered","category":"retries","mutation_type":"condition_inversion"}
{"task_id":"d-ssrf-L193-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _ssrf.py:193, a condition was inverted: 'if isinstance(ip_obj, ipaddress.IPv6Address):' became 'if not isinstance(ip_obj, ipaddress.IPv6Address):'. The branch now triggers in the opposite case.","vague_description":"A guard clause or check does the opposite of what it should. The happy path and error path are swapped.","test_cmd":"python -m pytest tests/test_ssrf.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"if isinstance(ip_obj, ipaddress.IPv6Address):","mutated":"if not isinstance(ip_obj, ipaddress.IPv6Address):","line_num":193},"source":"discovered","category":"ssrf","mutation_type":"condition_inversion"}
{"task_id":"d-tools-L190-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In tools.py:190, a condition was inverted: 'if isinstance(x, dict):' became 'if not isinstance(x, dict):'. The branch now triggers in the opposite case.","vague_description":"A guard clause or check does the opposite of what it should. The happy path and error path are swapped.","test_cmd":"python -m pytest tests/test_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/tools.py","original":"if isinstance(x, dict):","mutated":"if not isinstance(x, dict):","line_num":190},"source":"discovered","category":"tools","mutation_type":"condition_inversion"}
{"task_id":"d-app-L64-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In app.py:64, a None check was inverted: 'if html_source is None:' became 'if html_source is not None:'. This reverses when the value is considered present vs absent.","vague_description":"A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.","test_cmd":"python -m pytest tests/test_ui_web.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/ui/_web/app.py","original":"if html_source is None:","mutated":"if html_source is not None:","line_num":64},"source":"discovered","category":"ui","mutation_type":"none_check_swap"}
{"task_id":"d-utils-L115-comparison_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _utils.py:115, the comparison operator was changed: 'and resolved.get('type') == 'object'' became 'and resolved.get('type') != 'object''. This alters the boundary condition.","vague_description":"Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.","test_cmd":"python -m pytest tests/test_utils.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_utils.py","original":"and resolved.get('type') == 'object'","mutated":"and resolved.get('type') != 'object'","line_num":115},"source":"discovered","category":"utils","mutation_type":"comparison_swap"}
{"task_id":"d-concurrency-L271-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In concurrency.py:271, a None check was inverted: 'if limiter is None:' became 'if limiter is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.","test_cmd":"python -m pytest tests/test_concurrency.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/concurrency.py","original":"if limiter is None:","mutated":"if limiter is not None:","line_num":271},"source":"discovered","category":"concurrency","mutation_type":"none_check_swap"}
{"task_id":"d-direct-L276-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In direct.py:276, a None check was inverted: 'if instrument is None:' became 'if instrument is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/direct.py","original":"if instrument is None:","mutated":"if instrument is not None:","line_num":276},"source":"discovered","category":"direct_api","mutation_type":"none_check_swap"}
{"task_id":"d-json_schema-L177-comparison_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _json_schema.py:177, the comparison operator was changed: '(item for item in cases if item != {'type': 'null'}),' became '(item for item in cases if item == {'type': 'null'}),'. This alters the boundary condition.","vague_description":"A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.","test_cmd":"python -m pytest tests/test_json_schema.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_json_schema.py","original":"(item for item in cases if item != {'type': 'null'}),","mutated":"(item for item in cases if item == {'type': 'null'}),","line_num":177},"source":"discovered","category":"json_schema","mutation_type":"comparison_swap"}
{"task_id":"d-instrumented-L149-comparison_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In instrumented.py:149, the comparison operator was changed: 'if event_mode == 'logs' and version != 1:' became 'if event_mode != 'logs' and version != 1:'. This alters the boundary condition.","vague_description":"A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/models/instrumented.py","original":"if event_mode == 'logs' and version != 1:","mutated":"if event_mode != 'logs' and version != 1:","line_num":149},"source":"discovered","category":"models","mutation_type":"comparison_swap"}
{"task_id":"d-parts_manager-L246-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _parts_manager.py:246, a None check was inverted: 'if content is None and signature is None and provider_name is None and provider_details is None:' became 'if content is not None and signature is None and provider_name is None and provider_details is None:'. This reverses when the value is considered present vs absent.","vague_description":"Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.","test_cmd":"python -m pytest tests/test_parts_manager.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_parts_manager.py","original":"if content is None and signature is None and provider_name is None and provider_details is None:","mutated":"if content is not None and signature is None and provider_name is None and provider_details is None:","line_num":246},"source":"discovered","category":"parts_manager","mutation_type":"none_check_swap"}
{"task_id":"d-retries-L371-arithmetic_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In retries.py:371, an arithmetic operator was changed: 'wait_seconds = (retry_time - now).total_seconds()' became 'wait_seconds = (retry_time + now).total_seconds()'. This produces wrong numeric results.","vague_description":"Computed values are consistently wrong. The computation seems to use subtraction where it should add, or vice versa.","test_cmd":"python -m pytest tests/test_tenacity.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/retries.py","original":"wait_seconds = (retry_time - now).total_seconds()","mutated":"wait_seconds = (retry_time + now).total_seconds()","line_num":371},"source":"discovered","category":"retries","mutation_type":"arithmetic_swap"}
{"task_id":"d-ssrf-L249-constant_mutation","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _ssrf.py:249, a constant was changed: 'resolved_ip=ips[0],' became 'resolved_ip=ips[1],'. This shifts a boundary or default.","vague_description":"A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.","test_cmd":"python -m pytest tests/test_ssrf.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"resolved_ip=ips[0],","mutated":"resolved_ip=ips[1],","line_num":249},"source":"discovered","category":"ssrf","mutation_type":"constant_mutation"}
{"task_id":"d-tools-L250-comparison_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In tools.py:250, the comparison operator was changed: 'elif extra == 'forbid':' became 'elif extra != 'forbid':'. This alters the boundary condition.","vague_description":"A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.","test_cmd":"python -m pytest tests/test_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/tools.py","original":"elif extra == 'forbid':","mutated":"elif extra != 'forbid':","line_num":250},"source":"discovered","category":"tools","mutation_type":"comparison_swap"}
{"task_id":"d-usage-L241-arithmetic_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In usage.py:241, an arithmetic operator was changed: 'slf.details[key] = slf.details.get(key, 0) + value' became 'slf.details[key] = slf.details.get(key, 0) - value'. This produces wrong numeric results.","vague_description":"Computed values are consistently wrong. The computation seems to use subtraction where it should add, or vice versa.","test_cmd":"python -m pytest tests/test_usage_limits.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"slf.details[key] = slf.details.get(key, 0) + value","mutated":"slf.details[key] = slf.details.get(key, 0) - value","line_num":241},"source":"discovered","category":"usage","mutation_type":"arithmetic_swap"}
{"task_id":"d-utils-L191-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _utils.py:191, a None check was inverted: 'if soft_max_interval is None:' became 'if soft_max_interval is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.","test_cmd":"python -m pytest tests/test_utils.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_utils.py","original":"if soft_max_interval is None:","mutated":"if soft_max_interval is not None:","line_num":191},"source":"discovered","category":"utils","mutation_type":"none_check_swap"}
{"task_id":"d-concurrency-L292-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In concurrency.py:292, a condition was inverted: 'elif isinstance(limit, AbstractConcurrencyLimiter):' became 'elif not isinstance(limit, AbstractConcurrencyLimiter):'. The branch now triggers in the opposite case.","vague_description":"A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.","test_cmd":"python -m pytest tests/test_concurrency.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/concurrency.py","original":"elif isinstance(limit, AbstractConcurrencyLimiter):","mutated":"elif not isinstance(limit, AbstractConcurrencyLimiter):","line_num":292},"source":"discovered","category":"concurrency","mutation_type":"condition_inversion"}
{"task_id":"d-direct-L334-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In direct.py:334, a condition was inverted: 'if not self._context_entered:' became 'if self._context_entered:'. The branch now triggers in the opposite case.","vague_description":"Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/direct.py","original":"if not self._context_entered:","mutated":"if self._context_entered:","line_num":334},"source":"discovered","category":"direct_api","mutation_type":"condition_inversion"}
{"task_id":"d-json_schema-L174-comparison_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _json_schema.py:174, the comparison operator was changed: 'if len(cases) == 2 and {'type': 'null'} in cases:' became 'if len(cases) != 2 and {'type': 'null'} in cases:'. This alters the boundary condition.","vague_description":"A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.","test_cmd":"python -m pytest tests/test_json_schema.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_json_schema.py","original":"if len(cases) == 2 and {'type': 'null'} in cases:","mutated":"if len(cases) != 2 and {'type': 'null'} in cases:","line_num":174},"source":"discovered","category":"json_schema","mutation_type":"comparison_swap"}
{"task_id":"d-messages-L167-constant_mutation","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In messages.py:167, a constant was changed: 'return hashlib.sha1(identifier).hexdigest()[:6]' became 'return hashlib.sha1(identifier).hexdigest()[:7]'. This shifts a boundary or default.","vague_description":"A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.","test_cmd":"python -m pytest tests/test_messages.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/messages.py","original":"return hashlib.sha1(identifier).hexdigest()[:6]","mutated":"return hashlib.sha1(identifier).hexdigest()[:7]","line_num":167},"source":"discovered","category":"messages","mutation_type":"constant_mutation"}
{"task_id":"d-parts_manager-L124-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _parts_manager.py:124, a None check was inverted: 'if vendor_part_id is None:' became 'if vendor_part_id is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.","test_cmd":"python -m pytest tests/test_parts_manager.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_parts_manager.py","original":"if vendor_part_id is None:","mutated":"if vendor_part_id is not None:","line_num":124},"source":"discovered","category":"parts_manager","mutation_type":"none_check_swap"}
{"task_id":"d-retries-L353-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In retries.py:353, a None check was inverted: 'if fallback_strategy is None:' became 'if fallback_strategy is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.","test_cmd":"python -m pytest tests/test_tenacity.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/retries.py","original":"if fallback_strategy is None:","mutated":"if fallback_strategy is not None:","line_num":353},"source":"discovered","category":"retries","mutation_type":"none_check_swap"}
{"task_id":"d-ssrf-L170-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _ssrf.py:170, a boolean operator was swapped: 'port = parsed.port or default_port' became 'port = parsed.port and default_port'. This changes the logical condition.","vague_description":"An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.","test_cmd":"python -m pytest tests/test_ssrf.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"port = parsed.port or default_port","mutated":"port = parsed.port and default_port","line_num":170},"source":"discovered","category":"ssrf","mutation_type":"boolean_flip"}
{"task_id":"d-tools-L378-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In tools.py:378, a boolean operator was swapped: 'self.description = description or self.function_schema.description' became 'self.description = description and self.function_schema.description'. This changes the logical condition.","vague_description":"A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.","test_cmd":"python -m pytest tests/test_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/tools.py","original":"self.description = description or self.function_schema.description","mutated":"self.description = description and self.function_schema.description","line_num":378},"source":"discovered","category":"tools","mutation_type":"boolean_flip"}
{"task_id":"d-usage-L209-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In usage.py:209, a condition was inverted: 'if isinstance(incr_usage, RunUsage):' became 'if not isinstance(incr_usage, RunUsage):'. The branch now triggers in the opposite case.","vague_description":"A guard clause or check does the opposite of what it should. The happy path and error path are swapped.","test_cmd":"python -m pytest tests/test_usage_limits.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"if isinstance(incr_usage, RunUsage):","mutated":"if not isinstance(incr_usage, RunUsage):","line_num":209},"source":"discovered","category":"usage","mutation_type":"condition_inversion"}
{"task_id":"d-utils-L206-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _utils.py:206, a None check was inverted: 'assert soft_max_interval is not None and soft_max_interval >= 0, 'soft_max_interval must be a positive number'' became 'assert soft_max_interval is None and soft_max_interval >= 0, 'soft_max_interval must be a positive number''. This reverses when the value is considered present vs absent.","vague_description":"Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.","test_cmd":"python -m pytest tests/test_utils.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_utils.py","original":"assert soft_max_interval is not None and soft_max_interval >= 0, 'soft_max_interval must be a positive number'","mutated":"assert soft_max_interval is None and soft_max_interval >= 0, 'soft_max_interval must be a positive number'","line_num":206},"source":"discovered","category":"utils","mutation_type":"none_check_swap"}
{"task_id":"d-concurrency-L138-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In concurrency.py:138, a None check was inverted: 'if normalized_limiter is None:' became 'if normalized_limiter is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.","test_cmd":"python -m pytest tests/test_concurrency.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/models/concurrency.py","original":"if normalized_limiter is None:","mutated":"if normalized_limiter is not None:","line_num":138},"source":"discovered","category":"concurrency","mutation_type":"none_check_swap"}
{"task_id":"d-direct-L202-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In direct.py:202, a boolean operator was swapped: 'model_request_parameters or models.ModelRequestParameters(),' became 'model_request_parameters and models.ModelRequestParameters(),'. This changes the logical condition.","vague_description":"A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/direct.py","original":"model_request_parameters or models.ModelRequestParameters(),","mutated":"model_request_parameters and models.ModelRequestParameters(),","line_num":202},"source":"discovered","category":"direct_api","mutation_type":"boolean_flip"}
{"task_id":"d-json_schema-L164-constant_mutation","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _json_schema.py:164, a constant was changed: 'return handled[0] | schema' became 'return handled[1] | schema'. This shifts a boundary or default.","vague_description":"A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.","test_cmd":"python -m pytest tests/test_json_schema.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_json_schema.py","original":"return handled[0] | schema","mutated":"return handled[1] | schema","line_num":164},"source":"discovered","category":"json_schema","mutation_type":"constant_mutation"}
{"task_id":"d-messages-L596-membership_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In messages.py:596, a membership test was inverted: 'return self.media_type in _document_format_lookup' became 'return self.media_type not in _document_format_lookup'. This reverses which values pass the check.","vague_description":"A filter or validation check accepts the wrong set of values. Things that should match don't, and things that shouldn't match do.","test_cmd":"python -m pytest tests/test_messages.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/messages.py","original":"return self.media_type in _document_format_lookup","mutated":"return self.media_type not in _document_format_lookup","line_num":596},"source":"discovered","category":"messages","mutation_type":"membership_swap"}
{"task_id":"d-instrumented-L140-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In instrumented.py:140, a boolean operator was swapped: 'logger_provider = logger_provider or get_logger_provider()' became 'logger_provider = logger_provider and get_logger_provider()'. This changes the logical condition.","vague_description":"An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/models/instrumented.py","original":"logger_provider = logger_provider or get_logger_provider()","mutated":"logger_provider = logger_provider and get_logger_provider()","line_num":140},"source":"discovered","category":"models","mutation_type":"boolean_flip"}
{"task_id":"d-parts_manager-L133-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _parts_manager.py:133, a boolean operator was swapped: 'if thinking_tags and isinstance(existing_part, ThinkingPart):' became 'if thinking_tags or isinstance(existing_part, ThinkingPart):'. This changes the logical condition.","vague_description":"A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.","test_cmd":"python -m pytest tests/test_parts_manager.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_parts_manager.py","original":"if thinking_tags and isinstance(existing_part, ThinkingPart):","mutated":"if thinking_tags or isinstance(existing_part, ThinkingPart):","line_num":133},"source":"discovered","category":"parts_manager","mutation_type":"boolean_flip"}
{"task_id":"d-tools-L368-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In tools.py:368, a boolean operator was swapped: 'self.function_schema = function_schema or _function_schema.function_schema(' became 'self.function_schema = function_schema and _function_schema.function_schema('. This changes the logical condition.","vague_description":"An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.","test_cmd":"python -m pytest tests/test_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/tools.py","original":"self.function_schema = function_schema or _function_schema.function_schema(","mutated":"self.function_schema = function_schema and _function_schema.function_schema(","line_num":368},"source":"discovered","category":"tools","mutation_type":"boolean_flip"}
{"task_id":"d-usage-L349-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In usage.py:349, a None check was inverted: 'self.input_tokens_limit = input_tokens_limit if input_tokens_limit is not None else request_tokens_limit' became 'self.input_tokens_limit = input_tokens_limit if input_tokens_limit is None else request_tokens_limit'. This reverses when the value is considered present vs absent.","vague_description":"Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.","test_cmd":"python -m pytest tests/test_usage_limits.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"self.input_tokens_limit = input_tokens_limit if input_tokens_limit is not None else request_tokens_limit","mutated":"self.input_tokens_limit = input_tokens_limit if input_tokens_limit is None else request_tokens_limit","line_num":349},"source":"discovered","category":"usage","mutation_type":"none_check_swap"}
{"task_id":"d-utils-L107-comparison_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _utils.py:107, the comparison operator was changed: 'if schema.get('type') == 'object':' became 'if schema.get('type') != 'object':'. This alters the boundary condition.","vague_description":"A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.","test_cmd":"python -m pytest tests/test_utils.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_utils.py","original":"if schema.get('type') == 'object':","mutated":"if schema.get('type') != 'object':","line_num":107},"source":"discovered","category":"utils","mutation_type":"comparison_swap"}
{"task_id":"d-concurrency-L198-constant_mutation","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In concurrency.py:198, a constant was changed: 'self._waiting_count += 1' became 'self._waiting_count += 0'. This shifts a boundary or default.","vague_description":"A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.","test_cmd":"python -m pytest tests/test_concurrency.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/concurrency.py","original":"self._waiting_count += 1","mutated":"self._waiting_count += 0","line_num":198},"source":"discovered","category":"concurrency","mutation_type":"constant_mutation"}
{"task_id":"d-direct-L84-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In direct.py:84, a boolean operator was swapped: 'model_request_parameters or models.ModelRequestParameters(),' became 'model_request_parameters and models.ModelRequestParameters(),'. This changes the logical condition.","vague_description":"An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/direct.py","original":"model_request_parameters or models.ModelRequestParameters(),","mutated":"model_request_parameters and models.ModelRequestParameters(),","line_num":84},"source":"discovered","category":"direct_api","mutation_type":"boolean_flip"}
{"task_id":"d-messages-L394-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In messages.py:394, a None check was inverted: 'if mime_type is None:' became 'if mime_type is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.","test_cmd":"python -m pytest tests/test_messages.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/messages.py","original":"if mime_type is None:","mutated":"if mime_type is not None:","line_num":394},"source":"discovered","category":"messages","mutation_type":"none_check_swap"}
{"task_id":"d-parts_manager-L299-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _parts_manager.py:299, a None check was inverted: 'if vendor_part_id is None:' became 'if vendor_part_id is not None:'. This reverses when the value is considered present vs absent.","vague_description":"A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.","test_cmd":"python -m pytest tests/test_parts_manager.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_parts_manager.py","original":"if vendor_part_id is None:","mutated":"if vendor_part_id is not None:","line_num":299},"source":"discovered","category":"parts_manager","mutation_type":"none_check_swap"}
{"task_id":"d-retries-L262-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In retries.py:262, a boolean operator was swapped: 'self.wrapped = wrapped or AsyncHTTPTransport()' became 'self.wrapped = wrapped and AsyncHTTPTransport()'. This changes the logical condition.","vague_description":"A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.","test_cmd":"python -m pytest tests/test_tenacity.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/retries.py","original":"self.wrapped = wrapped or AsyncHTTPTransport()","mutated":"self.wrapped = wrapped and AsyncHTTPTransport()","line_num":262},"source":"discovered","category":"retries","mutation_type":"boolean_flip"}
{"task_id":"d-ssrf-L173-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _ssrf.py:173, a boolean operator was swapped: 'path = parsed.path or '/'' became 'path = parsed.path and '/''. This changes the logical condition.","vague_description":"A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.","test_cmd":"python -m pytest tests/test_ssrf.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"path = parsed.path or '/'","mutated":"path = parsed.path and '/'","line_num":173},"source":"discovered","category":"ssrf","mutation_type":"boolean_flip"}
{"task_id":"d-tools-L244-comparison_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In tools.py:244, the comparison operator was changed: 'if extra == 'allow':' became 'if extra != 'allow':'. This alters the boundary condition.","vague_description":"A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.","test_cmd":"python -m pytest tests/test_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/tools.py","original":"if extra == 'allow':","mutated":"if extra != 'allow':","line_num":244},"source":"discovered","category":"tools","mutation_type":"comparison_swap"}
{"task_id":"d-usage-L92-arithmetic_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In usage.py:92, an arithmetic operator was changed: 'result[prefix + key] = value' became 'result[prefix - key] = value'. This produces wrong numeric results.","vague_description":"A numerical calculation gives wrong output. The math is off \u2014 values are larger or smaller than expected by a consistent amount.","test_cmd":"python -m pytest tests/test_usage_limits.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"result[prefix + key] = value","mutated":"result[prefix - key] = value","line_num":92},"source":"discovered","category":"usage","mutation_type":"arithmetic_swap"}
{"task_id":"d-utils-L220-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _utils.py:220, a None check was inverted: 'if task is None:' became 'if task is not None:'. This reverses when the value is considered present vs absent.","vague_description":"A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.","test_cmd":"python -m pytest tests/test_utils.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_utils.py","original":"if task is None:","mutated":"if task is not None:","line_num":220},"source":"discovered","category":"utils","mutation_type":"none_check_swap"}
{"task_id":"d-concurrency-L190-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In concurrency.py:190, a None check was inverted: 'if self._max_queued is not None and self._waiting_count >= self._max_queued:' became 'if self._max_queued is None and self._waiting_count >= self._max_queued:'. This reverses when the value is considered present vs absent.","vague_description":"A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.","test_cmd":"python -m pytest tests/test_concurrency.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/concurrency.py","original":"if self._max_queued is not None and self._waiting_count >= self._max_queued:","mutated":"if self._max_queued is None and self._waiting_count >= self._max_queued:","line_num":190},"source":"discovered","category":"concurrency","mutation_type":"none_check_swap"}
{"task_id":"d-direct-L318-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In direct.py:318, a None check was inverted: 'if item is None:  # End of stream' became 'if item is not None:  # End of stream'. This reverses when the value is considered present vs absent.","vague_description":"Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/direct.py","original":"if item is None:  # End of stream","mutated":"if item is not None:  # End of stream","line_num":318},"source":"discovered","category":"direct_api","mutation_type":"none_check_swap"}
{"task_id":"d-json_schema-L134-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _json_schema.py:134, a None check was inverted: 'if (pattern_properties := schema.get('patternProperties')) is not None:' became 'if (pattern_properties := schema.get('patternProperties')) is None:'. This reverses when the value is considered present vs absent.","vague_description":"A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.","test_cmd":"python -m pytest tests/test_json_schema.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_json_schema.py","original":"if (pattern_properties := schema.get('patternProperties')) is not None:","mutated":"if (pattern_properties := schema.get('patternProperties')) is None:","line_num":134},"source":"discovered","category":"json_schema","mutation_type":"none_check_swap"}
{"task_id":"d-parts_manager-L224-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _parts_manager.py:224, a None check was inverted: 'if content is not None or signature is not None or provider_details is not None:' became 'if content is None or signature is not None or provider_details is not None:'. This reverses when the value is considered present vs absent.","vague_description":"A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.","test_cmd":"python -m pytest tests/test_parts_manager.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_parts_manager.py","original":"if content is not None or signature is not None or provider_details is not None:","mutated":"if content is None or signature is not None or provider_details is not None:","line_num":224},"source":"discovered","category":"parts_manager","mutation_type":"none_check_swap"}
{"task_id":"d-ssrf-L148-comparison_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _ssrf.py:148, the comparison operator was changed: 'return scheme, scheme == 'https'' became 'return scheme, scheme != 'https''. This alters the boundary condition.","vague_description":"A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.","test_cmd":"python -m pytest tests/test_ssrf.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"return scheme, scheme == 'https'","mutated":"return scheme, scheme != 'https'","line_num":148},"source":"discovered","category":"ssrf","mutation_type":"comparison_swap"}
{"task_id":"d-tools-L246-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In tools.py:246, a None check was inverted: 'if extras_schema is not None:' became 'if extras_schema is None:'. This reverses when the value is considered present vs absent.","vague_description":"A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.","test_cmd":"python -m pytest tests/test_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/tools.py","original":"if extras_schema is not None:","mutated":"if extras_schema is None:","line_num":246},"source":"discovered","category":"tools","mutation_type":"none_check_swap"}
{"task_id":"d-usage-L350-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In usage.py:350, a None check was inverted: 'self.output_tokens_limit = output_tokens_limit if output_tokens_limit is not None else response_tokens_limit' became 'self.output_tokens_limit = output_tokens_limit if output_tokens_limit is None else response_tokens_limit'. This reverses when the value is considered present vs absent.","vague_description":"Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.","test_cmd":"python -m pytest tests/test_usage_limits.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"self.output_tokens_limit = output_tokens_limit if output_tokens_limit is not None else response_tokens_limit","mutated":"self.output_tokens_limit = output_tokens_limit if output_tokens_limit is None else response_tokens_limit","line_num":350},"source":"discovered","category":"usage","mutation_type":"none_check_swap"}
{"task_id":"d-utils-L116-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _utils.py:116, a boolean operator was swapped: 'and not _contains_ref(resolved)' became 'or not _contains_ref(resolved)'. This changes the logical condition.","vague_description":"A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.","test_cmd":"python -m pytest tests/test_utils.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_utils.py","original":"and not _contains_ref(resolved)","mutated":"or not _contains_ref(resolved)","line_num":116},"source":"discovered","category":"utils","mutation_type":"boolean_flip"}
{"task_id":"d-messages-L566-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In messages.py:566, a boolean operator was swapped: 'return self._identifier or _multi_modal_content_identifier(self.data)' became 'return self._identifier and _multi_modal_content_identifier(self.data)'. This changes the logical condition.","vague_description":"A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.","test_cmd":"python -m pytest tests/test_messages.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/messages.py","original":"return self._identifier or _multi_modal_content_identifier(self.data)","mutated":"return self._identifier and _multi_modal_content_identifier(self.data)","line_num":566},"source":"discovered","category":"messages","mutation_type":"boolean_flip"}
{"task_id":"d-instrumented-L139-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In instrumented.py:139, a boolean operator was swapped: 'meter_provider = meter_provider or get_meter_provider()' became 'meter_provider = meter_provider and get_meter_provider()'. This changes the logical condition.","vague_description":"A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/models/instrumented.py","original":"meter_provider = meter_provider or get_meter_provider()","mutated":"meter_provider = meter_provider and get_meter_provider()","line_num":139},"source":"discovered","category":"models","mutation_type":"boolean_flip"}
{"task_id":"d-parts_manager-L143-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _parts_manager.py:143, a condition was inverted: 'elif isinstance(existing_part, TextPart):' became 'elif not isinstance(existing_part, TextPart):'. The branch now triggers in the opposite case.","vague_description":"Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.","test_cmd":"python -m pytest tests/test_parts_manager.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_parts_manager.py","original":"elif isinstance(existing_part, TextPart):","mutated":"elif not isinstance(existing_part, TextPart):","line_num":143},"source":"discovered","category":"parts_manager","mutation_type":"condition_inversion"}
{"task_id":"d-ssrf-L293-constant_mutation","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _ssrf.py:293, a constant was changed: 'base_path = parsed_current.path.rsplit('/', 1)[0]' became 'base_path = parsed_current.path.rsplit('/', 0)[0]'. This shifts a boundary or default.","vague_description":"A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.","test_cmd":"python -m pytest tests/test_ssrf.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"base_path = parsed_current.path.rsplit('/', 1)[0]","mutated":"base_path = parsed_current.path.rsplit('/', 0)[0]","line_num":293},"source":"discovered","category":"ssrf","mutation_type":"constant_mutation"}
{"task_id":"d-tools-L243-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In tools.py:243, a boolean operator was swapped: 'extra = schema.get('extra_behavior') or schema.get('config', {}).get('extra_fields_behavior')' became 'extra = schema.get('extra_behavior') and schema.get('config', {}).get('extra_fields_behavior')'. This changes the logical condition.","vague_description":"A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.","test_cmd":"python -m pytest tests/test_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/tools.py","original":"extra = schema.get('extra_behavior') or schema.get('config', {}).get('extra_fields_behavior')","mutated":"extra = schema.get('extra_behavior') and schema.get('config', {}).get('extra_fields_behavior')","line_num":243},"source":"discovered","category":"tools","mutation_type":"boolean_flip"}
{"task_id":"d-usage-L114-constant_mutation","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In usage.py:114, a constant was changed: 'return 1' became 'return 0'. This shifts a boundary or default.","vague_description":"A default value or configuration constant seems wrong. The system uses a different threshold or limit than what's documented.","test_cmd":"python -m pytest tests/test_usage_limits.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"return 1","mutated":"return 0","line_num":114},"source":"discovered","category":"usage","mutation_type":"constant_mutation"}
{"task_id":"d-utils-L129-value_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _utils.py:129, a value was swapped: 'return True' became 'return False'.","vague_description":"Two related values are mixed up. The system applies the wrong one of two options depending on context.","test_cmd":"python -m pytest tests/test_utils.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_utils.py","original":"return True","mutated":"return False","line_num":129},"source":"discovered","category":"utils","mutation_type":"value_swap"}
{"task_id":"d-json_schema-L162-comparison_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _json_schema.py:162, the comparison operator was changed: 'if len(handled) == 1:' became 'if len(handled) != 1:'. This alters the boundary condition.","vague_description":"Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.","test_cmd":"python -m pytest tests/test_json_schema.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_json_schema.py","original":"if len(handled) == 1:","mutated":"if len(handled) != 1:","line_num":162},"source":"discovered","category":"json_schema","mutation_type":"comparison_swap"}
{"task_id":"d-instrumented-L138-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In instrumented.py:138, a boolean operator was swapped: 'tracer_provider = tracer_provider or get_tracer_provider()' became 'tracer_provider = tracer_provider and get_tracer_provider()'. This changes the logical condition.","vague_description":"A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/models/instrumented.py","original":"tracer_provider = tracer_provider or get_tracer_provider()","mutated":"tracer_provider = tracer_provider and get_tracer_provider()","line_num":138},"source":"discovered","category":"models","mutation_type":"boolean_flip"}
{"task_id":"d-parts_manager-L230-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _parts_manager.py:230, a boolean operator was swapped: 'content=content or '',' became 'content=content and '','. This changes the logical condition.","vague_description":"A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.","test_cmd":"python -m pytest tests/test_parts_manager.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_parts_manager.py","original":"content=content or '',","mutated":"content=content and '',","line_num":230},"source":"discovered","category":"parts_manager","mutation_type":"boolean_flip"}
{"task_id":"d-ssrf-L97-value_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _ssrf.py:97, a value was swapped: 'return True' became 'return False'.","vague_description":"Two values appear to be swapped. The system uses value A where it should use value B, and value B where it should use value A.","test_cmd":"python -m pytest tests/test_ssrf.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"return True","mutated":"return False","line_num":97},"source":"discovered","category":"ssrf","mutation_type":"value_swap"}
{"task_id":"d-usage-L158-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In usage.py:158, a boolean operator was swapped: 'details = details or {}' became 'details = details and {}'. This changes the logical condition.","vague_description":"A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.","test_cmd":"python -m pytest tests/test_usage_limits.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"details = details or {}","mutated":"details = details and {}","line_num":158},"source":"discovered","category":"usage","mutation_type":"boolean_flip"}
{"task_id":"d-json_schema-L183-value_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _json_schema.py:183, a value was swapped: 'new_schema['nullable'] = True' became 'new_schema['nullable'] = False'.","vague_description":"Two values appear to be swapped. The system uses value A where it should use value B, and value B where it should use value A.","test_cmd":"python -m pytest tests/test_json_schema.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_json_schema.py","original":"new_schema['nullable'] = True","mutated":"new_schema['nullable'] = False","line_num":183},"source":"discovered","category":"json_schema","mutation_type":"value_swap"}
{"task_id":"d-messages-L641-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In messages.py:641, a condition was inverted: 'if not self.is_image:' became 'if self.is_image:'. The branch now triggers in the opposite case.","vague_description":"Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.","test_cmd":"python -m pytest tests/test_messages.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/messages.py","original":"if not self.is_image:","mutated":"if self.is_image:","line_num":641},"source":"discovered","category":"messages","mutation_type":"condition_inversion"}
{"task_id":"d-parts_manager-L219-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _parts_manager.py:219, a condition was inverted: 'if not isinstance(existing_part, ThinkingPart):' became 'if isinstance(existing_part, ThinkingPart):'. The branch now triggers in the opposite case.","vague_description":"Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.","test_cmd":"python -m pytest tests/test_parts_manager.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_parts_manager.py","original":"if not isinstance(existing_part, ThinkingPart):","mutated":"if isinstance(existing_part, ThinkingPart):","line_num":219},"source":"discovered","category":"parts_manager","mutation_type":"condition_inversion"}
{"task_id":"d-ssrf-L123-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _ssrf.py:123, a condition was inverted: 'if not ips:' became 'if ips:'. The branch now triggers in the opposite case.","vague_description":"Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.","test_cmd":"python -m pytest tests/test_ssrf.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"if not ips:","mutated":"if ips:","line_num":123},"source":"discovered","category":"ssrf","mutation_type":"condition_inversion"}
{"task_id":"d-utils-L127-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _utils.py:127, a condition was inverted: 'if isinstance(obj, dict):' became 'if not isinstance(obj, dict):'. The branch now triggers in the opposite case.","vague_description":"A guard clause or check does the opposite of what it should. The happy path and error path are swapped.","test_cmd":"python -m pytest tests/test_utils.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_utils.py","original":"if isinstance(obj, dict):","mutated":"if not isinstance(obj, dict):","line_num":127},"source":"discovered","category":"utils","mutation_type":"condition_inversion"}
{"task_id":"d-json_schema-L64-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _json_schema.py:64, a boolean operator was swapped: 'if not self.prefer_inlined_defs and self.defs:' became 'if not self.prefer_inlined_defs or self.defs:'. This changes the logical condition.","vague_description":"A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.","test_cmd":"python -m pytest tests/test_json_schema.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_json_schema.py","original":"if not self.prefer_inlined_defs and self.defs:","mutated":"if not self.prefer_inlined_defs or self.defs:","line_num":64},"source":"discovered","category":"json_schema","mutation_type":"boolean_flip"}
{"task_id":"d-messages-L224-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In messages.py:224, a boolean operator was swapped: 'return self._media_type or self._infer_media_type()' became 'return self._media_type and self._infer_media_type()'. This changes the logical condition.","vague_description":"An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.","test_cmd":"python -m pytest tests/test_messages.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/messages.py","original":"return self._media_type or self._infer_media_type()","mutated":"return self._media_type and self._infer_media_type()","line_num":224},"source":"discovered","category":"messages","mutation_type":"boolean_flip"}
{"task_id":"d-ssrf-L119-constant_mutation","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _ssrf.py:119, a constant was changed: 'ip = str(result[4][0])' became 'ip = str(result[5][0])'. This shifts a boundary or default.","vague_description":"A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.","test_cmd":"python -m pytest tests/test_ssrf.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"ip = str(result[4][0])","mutated":"ip = str(result[5][0])","line_num":119},"source":"discovered","category":"ssrf","mutation_type":"constant_mutation"}
{"task_id":"d-utils-L114-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _utils.py:114, a boolean operator was swapped: 'and (resolved := schema.get('$defs', {}).get(ref[len(prefix) :]))' became 'or (resolved := schema.get('$defs', {}).get(ref[len(prefix) :]))'. This changes the logical condition.","vague_description":"An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.","test_cmd":"python -m pytest tests/test_utils.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_utils.py","original":"and (resolved := schema.get('$defs', {}).get(ref[len(prefix) :]))","mutated":"or (resolved := schema.get('$defs', {}).get(ref[len(prefix) :]))","line_num":114},"source":"discovered","category":"utils","mutation_type":"boolean_flip"}
{"task_id":"d-messages-L241-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In messages.py:241, a boolean operator was swapped: 'return self._identifier or _multi_modal_content_identifier(self.url)' became 'return self._identifier and _multi_modal_content_identifier(self.url)'. This changes the logical condition.","vague_description":"A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.","test_cmd":"python -m pytest tests/test_messages.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/messages.py","original":"return self._identifier or _multi_modal_content_identifier(self.url)","mutated":"return self._identifier and _multi_modal_content_identifier(self.url)","line_num":241},"source":"discovered","category":"messages","mutation_type":"boolean_flip"}
{"task_id":"d-ssrf-L188-constant_mutation","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _ssrf.py:188, a constant was changed: 'default_port = 443 if resolved.is_https else 80' became 'default_port = 444 if resolved.is_https else 80'. This shifts a boundary or default.","vague_description":"A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.","test_cmd":"python -m pytest tests/test_ssrf.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"default_port = 443 if resolved.is_https else 80","mutated":"default_port = 444 if resolved.is_https else 80","line_num":188},"source":"discovered","category":"ssrf","mutation_type":"constant_mutation"}
{"task_id":"d-utils-L211-value_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _utils.py:211, a value was swapped: 'while True:' became 'while False:'.","vague_description":"An assignment or return value is wrong \u2014 it returns the first argument where it should return the second, or similar.","test_cmd":"python -m pytest tests/test_utils.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_utils.py","original":"while True:","mutated":"while False:","line_num":211},"source":"discovered","category":"utils","mutation_type":"value_swap"}
{"task_id":"d-messages-L543-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In messages.py:543, a condition was inverted: 'if not path.exists():' became 'if path.exists():'. The branch now triggers in the opposite case.","vague_description":"Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.","test_cmd":"python -m pytest tests/test_messages.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/messages.py","original":"if not path.exists():","mutated":"if path.exists():","line_num":543},"source":"discovered","category":"messages","mutation_type":"condition_inversion"}
{"task_id": "httpx-auth-L272-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:272, a constant was changed: 'self._nonce_count += 1' became 'self._nonce_count += 0'. This shifts a boundary or default.", "vague_description": "A default value or configuration constant seems wrong. The system uses a different threshold or limit than what's documented.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "self._nonce_count += 1", "mutated": "self._nonce_count += 0", "line_num": 272}, "source": "discovered", "category": "auth", "mutation_type": "constant_mutation"}
{"task_id": "httpx-main-L235-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:235, the comparison operator was changed: 'elif name == \"http11.send_request_headers.started\" and verbose:' became 'elif name != \"http11.send_request_headers.started\" and verbose:'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "elif name == \"http11.send_request_headers.started\" and verbose:", "mutated": "elif name != \"http11.send_request_headers.started\" and verbose:", "line_num": 235}, "source": "discovered", "category": "cli", "mutation_type": "comparison_swap"}
{"task_id": "httpx-client-L228-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _client.py:228, the comparison operator was changed: 'return self._state == ClientState.CLOSED' became 'return self._state != ClientState.CLOSED'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/client/test_client.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_client.py", "original": "return self._state == ClientState.CLOSED", "mutated": "return self._state != ClientState.CLOSED", "line_num": 228}, "source": "discovered", "category": "client", "mutation_type": "comparison_swap"}
{"task_id": "httpx-config-L108-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:108, a constant was changed: 'self.read = timeout[1]' became 'self.read = timeout[0]'. This shifts a boundary or default.", "vague_description": "A hardcoded value is slightly off. Behavior at specific boundaries doesn't match expectations \u2014 like an off-by-one in a limit.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "self.read = timeout[1]", "mutated": "self.read = timeout[0]", "line_num": 108}, "source": "discovered", "category": "config", "mutation_type": "constant_mutation"}
{"task_id": "httpx-decoders-L224-arithmetic_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:224, an arithmetic operator was changed: 'data = child.decode(data) + child.flush()' became 'data = child.decode(data) - child.flush()'. This produces wrong numeric results.", "vague_description": "A numerical calculation gives wrong output. The math is off \u2014 values are larger or smaller than expected by a consistent amount.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "data = child.decode(data) + child.flush()", "mutated": "data = child.decode(data) - child.flush()", "line_num": 224}, "source": "discovered", "category": "decoders", "mutation_type": "arithmetic_swap"}
{"task_id": "httpx-exceptions-L98-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _exceptions.py:98, a None check was inverted: 'if self._request is None:' became 'if self._request is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_exceptions.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_exceptions.py", "original": "if self._request is None:", "mutated": "if self._request is not None:", "line_num": 98}, "source": "discovered", "category": "exceptions", "mutation_type": "none_check_swap"}
{"task_id": "httpx-multipart-L80-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:80, a None check was inverted: 'if value is not None and not isinstance(value, (str, bytes, int, float)):' became 'if value is None and not isinstance(value, (str, bytes, int, float)):'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "if value is not None and not isinstance(value, (str, bytes, int, float)):", "mutated": "if value is None and not isinstance(value, (str, bytes, int, float)):", "line_num": 80}, "source": "discovered", "category": "multipart", "mutation_type": "none_check_swap"}
{"task_id": "httpx-urlparse-L311-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _urlparse.py:311, a boolean operator was swapped: 'userinfo = kwargs.get(\"userinfo\", authority_dict[\"userinfo\"]) or \"\"' became 'userinfo = kwargs.get(\"userinfo\", authority_dict[\"userinfo\"]) and \"\"'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/models/test_whatwg.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_urlparse.py", "original": "userinfo = kwargs.get(\"userinfo\", authority_dict[\"userinfo\"]) or \"\"", "mutated": "userinfo = kwargs.get(\"userinfo\", authority_dict[\"userinfo\"]) and \"\"", "line_num": 311}, "source": "discovered", "category": "url_parsing", "mutation_type": "boolean_flip"}
{"task_id": "httpx-main-L223-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:223, the comparison operator was changed: 'elif name == \"connection.start_tls.complete\" and verbose:  # pragma: no cover' became 'elif name != \"connection.start_tls.complete\" and verbose:  # pragma: no cover'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "elif name == \"connection.start_tls.complete\" and verbose:  # pragma: no cover", "mutated": "elif name != \"connection.start_tls.complete\" and verbose:  # pragma: no cover", "line_num": 223}, "source": "discovered", "category": "cli", "mutation_type": "comparison_swap"}
{"task_id": "httpx-config-L41-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:41, a value was swapped: 'elif verify is False:' became 'elif verify is True:'.", "vague_description": "An assignment or return value is wrong \u2014 it returns the first argument where it should return the second, or similar.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "elif verify is False:", "mutated": "elif verify is True:", "line_num": 41}, "source": "discovered", "category": "config", "mutation_type": "value_swap"}
{"task_id": "httpx-decoders-L69-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:69, a value was swapped: 'self.first_attempt = False' became 'self.first_attempt = True'.", "vague_description": "An assignment or return value is wrong \u2014 it returns the first argument where it should return the second, or similar.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "self.first_attempt = False", "mutated": "self.first_attempt = True", "line_num": 69}, "source": "discovered", "category": "decoders", "mutation_type": "value_swap"}
{"task_id": "httpx-multipart-L134-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:134, a condition was inverted: 'if isinstance(value, tuple):' became 'if not isinstance(value, tuple):'. The branch now triggers in the opposite case.", "vague_description": "A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "if isinstance(value, tuple):", "mutated": "if not isinstance(value, tuple):", "line_num": 134}, "source": "discovered", "category": "multipart", "mutation_type": "condition_inversion"}
{"task_id": "httpx-urlparse-L299-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _urlparse.py:299, a boolean operator was swapped: 'authority = kwargs.get(\"authority\", url_dict[\"authority\"]) or \"\"' became 'authority = kwargs.get(\"authority\", url_dict[\"authority\"]) and \"\"'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/models/test_whatwg.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_urlparse.py", "original": "authority = kwargs.get(\"authority\", url_dict[\"authority\"]) or \"\"", "mutated": "authority = kwargs.get(\"authority\", url_dict[\"authority\"]) and \"\"", "line_num": 299}, "source": "discovered", "category": "url_parsing", "mutation_type": "boolean_flip"}
{"task_id": "httpx-utils-L200-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:200, a value was swapped: 'return False' became 'return True'.", "vague_description": "Two related values are mixed up. The system applies the wrong one of two options depending on context.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "return False", "mutated": "return True", "line_num": 200}, "source": "discovered", "category": "utils", "mutation_type": "value_swap"}
{"task_id": "httpx-main-L237-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:237, a value was swapped: 'print_request_headers(request, http2=False)' became 'print_request_headers(request, http2=True)'.", "vague_description": "Two values appear to be swapped. The system uses value A where it should use value B, and value B where it should use value A.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "print_request_headers(request, http2=False)", "mutated": "print_request_headers(request, http2=True)", "line_num": 237}, "source": "discovered", "category": "cli", "mutation_type": "value_swap"}
{"task_id": "httpx-client-L204-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _client.py:204, a None check was inverted: 'event_hooks = {} if event_hooks is None else event_hooks' became 'event_hooks = {} if event_hooks is not None else event_hooks'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/client/test_client.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_client.py", "original": "event_hooks = {} if event_hooks is None else event_hooks", "mutated": "event_hooks = {} if event_hooks is not None else event_hooks", "line_num": 204}, "source": "discovered", "category": "client", "mutation_type": "none_check_swap"}
{"task_id": "httpx-config-L110-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:110, the comparison operator was changed: 'self.pool = None if len(timeout) < 4 else timeout[3]' became 'self.pool = None if len(timeout) <= 4 else timeout[3]'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "self.pool = None if len(timeout) < 4 else timeout[3]", "mutated": "self.pool = None if len(timeout) <= 4 else timeout[3]", "line_num": 110}, "source": "discovered", "category": "config", "mutation_type": "comparison_swap"}
{"task_id": "httpx-content-L110-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:110, a condition was inverted: 'if isinstance(content, (bytes, str)):' became 'if not isinstance(content, (bytes, str)):'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "if isinstance(content, (bytes, str)):", "mutated": "if not isinstance(content, (bytes, str)):", "line_num": 110}, "source": "discovered", "category": "content", "mutation_type": "condition_inversion"}
{"task_id": "httpx-decoders-L171-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:171, a None check was inverted: 'if zstandard is None:  # pragma: no cover' became 'if zstandard is not None:  # pragma: no cover'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "if zstandard is None:  # pragma: no cover", "mutated": "if zstandard is not None:  # pragma: no cover", "line_num": 171}, "source": "discovered", "category": "decoders", "mutation_type": "none_check_swap"}
{"task_id": "httpx-asgi-L159-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:159, a condition was inverted: 'assert not response_complete.is_set()' became 'assert response_complete.is_set()'. The branch now triggers in the opposite case.", "vague_description": "A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "assert not response_complete.is_set()", "mutated": "assert response_complete.is_set()", "line_num": 159}, "source": "discovered", "category": "transports", "mutation_type": "condition_inversion"}
{"task_id": "httpx-urlparse-L290-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _urlparse.py:290, a None check was inverted: 'assert url_match is not None' became 'assert url_match is None'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/models/test_whatwg.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_urlparse.py", "original": "assert url_match is not None", "mutated": "assert url_match is None", "line_num": 290}, "source": "discovered", "category": "url_parsing", "mutation_type": "none_check_swap"}
{"task_id": "httpx-auth-L279-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:279, a None check was inverted: 'if qop is None:' became 'if qop is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "if qop is None:", "mutated": "if qop is not None:", "line_num": 279}, "source": "discovered", "category": "auth", "mutation_type": "none_check_swap"}
{"task_id": "httpx-main-L216-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:216, the comparison operator was changed: 'if name == \"connection.connect_tcp.started\" and verbose:' became 'if name != \"connection.connect_tcp.started\" and verbose:'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "if name == \"connection.connect_tcp.started\" and verbose:", "mutated": "if name != \"connection.connect_tcp.started\" and verbose:", "line_num": 216}, "source": "discovered", "category": "cli", "mutation_type": "comparison_swap"}
{"task_id": "httpx-client-L237-arithmetic_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _client.py:237, an arithmetic operator was changed: 'return url.copy_with(raw_path=url.raw_path + b\"/\")' became 'return url.copy_with(raw_path=url.raw_path - b\"/\")'. This produces wrong numeric results.", "vague_description": "A numerical calculation gives wrong output. The math is off \u2014 values are larger or smaller than expected by a consistent amount.", "test_cmd": "python -m pytest tests/client/test_client.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_client.py", "original": "return url.copy_with(raw_path=url.raw_path + b\"/\")", "mutated": "return url.copy_with(raw_path=url.raw_path - b\"/\")", "line_num": 237}, "source": "discovered", "category": "client", "mutation_type": "arithmetic_swap"}
{"task_id": "httpx-config-L130-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:130, a condition was inverted: 'self.pool = timeout if isinstance(pool, UnsetType) else pool' became 'self.pool = timeout if not isinstance(pool, UnsetType) else pool'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "self.pool = timeout if isinstance(pool, UnsetType) else pool", "mutated": "self.pool = timeout if not isinstance(pool, UnsetType) else pool", "line_num": 130}, "source": "discovered", "category": "config", "mutation_type": "condition_inversion"}
{"task_id": "httpx-multipart-L181-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:181, a None check was inverted: 'if file_length is None:' became 'if file_length is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "if file_length is None:", "mutated": "if file_length is not None:", "line_num": 181}, "source": "discovered", "category": "multipart", "mutation_type": "none_check_swap"}
{"task_id": "httpx-wsgi-L40-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In wsgi.py:40, a None check was inverted: 'if self._close is not None:' became 'if self._close is None:'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_wsgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/wsgi.py", "original": "if self._close is not None:", "mutated": "if self._close is None:", "line_num": 40}, "source": "discovered", "category": "transports", "mutation_type": "none_check_swap"}
{"task_id": "httpx-urlparse-L306-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _urlparse.py:306, a None check was inverted: 'assert authority_match is not None' became 'assert authority_match is None'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/models/test_whatwg.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_urlparse.py", "original": "assert authority_match is not None", "mutated": "assert authority_match is None", "line_num": 306}, "source": "discovered", "category": "url_parsing", "mutation_type": "none_check_swap"}
{"task_id": "httpx-utils-L197-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:197, a None check was inverted: 'and self.host_regex is not None' became 'and self.host_regex is None'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "and self.host_regex is not None", "mutated": "and self.host_regex is None", "line_num": 197}, "source": "discovered", "category": "utils", "mutation_type": "none_check_swap"}
{"task_id": "httpx-auth-L318-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:318, the comparison operator was changed: 'if i > 0:' became 'if i >= 0:'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "if i > 0:", "mutated": "if i >= 0:", "line_num": 318}, "source": "discovered", "category": "auth", "mutation_type": "comparison_swap"}
{"task_id": "httpx-config-L129-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:129, a condition was inverted: 'self.write = timeout if isinstance(write, UnsetType) else write' became 'self.write = timeout if not isinstance(write, UnsetType) else write'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "self.write = timeout if isinstance(write, UnsetType) else write", "mutated": "self.write = timeout if not isinstance(write, UnsetType) else write", "line_num": 129}, "source": "discovered", "category": "config", "mutation_type": "condition_inversion"}
{"task_id": "httpx-content-L111-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:111, a condition was inverted: 'body = content.encode(\"utf-8\") if isinstance(content, str) else content' became 'body = content.encode(\"utf-8\") if not isinstance(content, str) else content'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "body = content.encode(\"utf-8\") if isinstance(content, str) else content", "mutated": "body = content.encode(\"utf-8\") if not isinstance(content, str) else content", "line_num": 111}, "source": "discovered", "category": "content", "mutation_type": "condition_inversion"}
{"task_id": "httpx-asgi-L152-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:152, a condition was inverted: 'assert not response_started' became 'assert response_started'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "assert not response_started", "mutated": "assert response_started", "line_num": 152}, "source": "discovered", "category": "transports", "mutation_type": "condition_inversion"}
{"task_id": "httpx-urlparse-L312-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _urlparse.py:312, a boolean operator was swapped: 'host = kwargs.get(\"host\", authority_dict[\"host\"]) or \"\"' became 'host = kwargs.get(\"host\", authority_dict[\"host\"]) and \"\"'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/models/test_whatwg.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_urlparse.py", "original": "host = kwargs.get(\"host\", authority_dict[\"host\"]) or \"\"", "mutated": "host = kwargs.get(\"host\", authority_dict[\"host\"]) and \"\"", "line_num": 312}, "source": "discovered", "category": "url_parsing", "mutation_type": "boolean_flip"}
{"task_id": "httpx-utils-L177-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:177, the comparison operator was changed: 'if not url.host or url.host == \"*\":' became 'if not url.host or url.host != \"*\":'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "if not url.host or url.host == \"*\":", "mutated": "if not url.host or url.host != \"*\":", "line_num": 177}, "source": "discovered", "category": "utils", "mutation_type": "comparison_swap"}
{"task_id": "httpx-auth-L239-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:239, a constant was changed: 'key, value = field.strip().split(\"=\", 1)' became 'key, value = field.strip().split(\"=\", 0)'. This shifts a boundary or default.", "vague_description": "A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "key, value = field.strip().split(\"=\", 1)", "mutated": "key, value = field.strip().split(\"=\", 0)", "line_num": 239}, "source": "discovered", "category": "auth", "mutation_type": "constant_mutation"}
{"task_id": "httpx-main-L238-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:238, the comparison operator was changed: 'elif name == \"http2.send_request_headers.started\" and verbose:  # pragma: no cover' became 'elif name != \"http2.send_request_headers.started\" and verbose:  # pragma: no cover'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "elif name == \"http2.send_request_headers.started\" and verbose:  # pragma: no cover", "mutated": "elif name != \"http2.send_request_headers.started\" and verbose:  # pragma: no cover", "line_num": 238}, "source": "discovered", "category": "cli", "mutation_type": "comparison_swap"}
{"task_id": "httpx-client-L248-return_value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _client.py:248, the code was changed from 'return {}' to 'return {\"_\": None}' (return_value_swap).", "vague_description": "The return value from a function doesn't match its contract. Callers get unexpected results.", "test_cmd": "python -m pytest tests/client/test_client.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_client.py", "original": "return {}", "mutated": "return {\"_\": None}", "line_num": 248}, "source": "discovered", "category": "client", "mutation_type": "return_value_swap"}
{"task_id": "httpx-config-L143-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:143, the comparison operator was changed: 'and self.connect == other.connect' became 'and self.connect != other.connect'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "and self.connect == other.connect", "mutated": "and self.connect != other.connect", "line_num": 143}, "source": "discovered", "category": "config", "mutation_type": "comparison_swap"}
{"task_id": "httpx-content-L235-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:235, a None check was inverted: 'elif html is not None:' became 'elif html is None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "elif html is not None:", "mutated": "elif html is None:", "line_num": 235}, "source": "discovered", "category": "content", "mutation_type": "none_check_swap"}
{"task_id": "httpx-decoders-L238-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:238, a None check was inverted: 'if self._chunk_size is None:' became 'if self._chunk_size is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "if self._chunk_size is None:", "mutated": "if self._chunk_size is not None:", "line_num": 238}, "source": "discovered", "category": "decoders", "mutation_type": "none_check_swap"}
{"task_id": "httpx-multipart-L210-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:210, a constant was changed: 'self.file.seek(0)' became 'self.file.seek(1)'. This shifts a boundary or default.", "vague_description": "A default value or configuration constant seems wrong. The system uses a different threshold or limit than what's documented.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "self.file.seek(0)", "mutated": "self.file.seek(1)", "line_num": 210}, "source": "discovered", "category": "multipart", "mutation_type": "constant_mutation"}
{"task_id": "httpx-wsgi-L140-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In wsgi.py:140, a boolean operator was swapped: 'if seen_exc_info and seen_exc_info[0] and self.raise_app_exceptions:' became 'if seen_exc_info or seen_exc_info[0] and self.raise_app_exceptions:'. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/test_wsgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/wsgi.py", "original": "if seen_exc_info and seen_exc_info[0] and self.raise_app_exceptions:", "mutated": "if seen_exc_info or seen_exc_info[0] and self.raise_app_exceptions:", "line_num": 140}, "source": "discovered", "category": "transports", "mutation_type": "boolean_flip"}
{"task_id": "httpx-urlparse-L300-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _urlparse.py:300, a boolean operator was swapped: 'path = kwargs.get(\"path\", url_dict[\"path\"]) or \"\"' became 'path = kwargs.get(\"path\", url_dict[\"path\"]) and \"\"'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/models/test_whatwg.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_urlparse.py", "original": "path = kwargs.get(\"path\", url_dict[\"path\"]) or \"\"", "mutated": "path = kwargs.get(\"path\", url_dict[\"path\"]) and \"\"", "line_num": 300}, "source": "discovered", "category": "url_parsing", "mutation_type": "boolean_flip"}
{"task_id": "httpx-utils-L201-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:201, a None check was inverted: 'if self.port is not None and self.port != other.port:' became 'if self.port is None and self.port != other.port:'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "if self.port is not None and self.port != other.port:", "mutated": "if self.port is None and self.port != other.port:", "line_num": 201}, "source": "discovered", "category": "utils", "mutation_type": "none_check_swap"}
{"task_id": "httpx-auth-L330-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:330, a None check was inverted: 'if qop is None:' became 'if qop is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "if qop is None:", "mutated": "if qop is not None:", "line_num": 330}, "source": "discovered", "category": "auth", "mutation_type": "none_check_swap"}
{"task_id": "httpx-main-L105-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:105, a None check was inverted: 'if content_type is not None:' became 'if content_type is None:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "if content_type is not None:", "mutated": "if content_type is None:", "line_num": 105}, "source": "discovered", "category": "cli", "mutation_type": "none_check_swap"}
{"task_id": "httpx-client-L370-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _client.py:370, a None check was inverted: 'extensions = {} if extensions is None else extensions' became 'extensions = {} if extensions is not None else extensions'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/client/test_client.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_client.py", "original": "extensions = {} if extensions is None else extensions", "mutated": "extensions = {} if extensions is not None else extensions", "line_num": 370}, "source": "discovered", "category": "client", "mutation_type": "none_check_swap"}
{"task_id": "httpx-config-L34-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:34, a boolean operator was swapped: 'if trust_env and os.environ.get(\"SSL_CERT_FILE\"):  # pragma: nocover' became 'if trust_env or os.environ.get(\"SSL_CERT_FILE\"):  # pragma: nocover'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "if trust_env and os.environ.get(\"SSL_CERT_FILE\"):  # pragma: nocover", "mutated": "if trust_env or os.environ.get(\"SSL_CERT_FILE\"):  # pragma: nocover", "line_num": 34}, "source": "discovered", "category": "config", "mutation_type": "boolean_flip"}
{"task_id": "httpx-content-L51-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:51, a boolean operator was swapped: 'if self._is_stream_consumed and self._is_generator:' became 'if self._is_stream_consumed or self._is_generator:'. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "if self._is_stream_consumed and self._is_generator:", "mutated": "if self._is_stream_consumed or self._is_generator:", "line_num": 51}, "source": "discovered", "category": "content", "mutation_type": "boolean_flip"}
{"task_id": "httpx-multipart-L152-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:152, a None check was inverted: 'if content_type is not None and not has_content_type_header:' became 'if content_type is None and not has_content_type_header:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "if content_type is not None and not has_content_type_header:", "mutated": "if content_type is None and not has_content_type_header:", "line_num": 152}, "source": "discovered", "category": "multipart", "mutation_type": "none_check_swap"}
{"task_id": "httpx-asgi-L146-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:146, a value was swapped: 'return {\"type\": \"http.request\", \"body\": body, \"more_body\": True}' became 'return {\"type\": \"http.request\", \"body\": body, \"more_body\": False}'.", "vague_description": "Two related values are mixed up. The system applies the wrong one of two options depending on context.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "return {\"type\": \"http.request\", \"body\": body, \"more_body\": True}", "mutated": "return {\"type\": \"http.request\", \"body\": body, \"more_body\": False}", "line_num": 146}, "source": "discovered", "category": "transports", "mutation_type": "value_swap"}
{"task_id": "httpx-urlparse-L223-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _urlparse.py:223, a boolean operator was swapped: 'if any(char.isascii() and not char.isprintable() for char in url):' became 'if any(char.isascii() or not char.isprintable() for char in url):'. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/models/test_whatwg.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_urlparse.py", "original": "if any(char.isascii() and not char.isprintable() for char in url):", "mutated": "if any(char.isascii() or not char.isprintable() for char in url):", "line_num": 223}, "source": "discovered", "category": "url_parsing", "mutation_type": "boolean_flip"}
{"task_id": "httpx-utils-L174-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:174, the comparison operator was changed: 'self.scheme = \"\" if url.scheme == \"all\" else url.scheme' became 'self.scheme = \"\" if url.scheme != \"all\" else url.scheme'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "self.scheme = \"\" if url.scheme == \"all\" else url.scheme", "mutated": "self.scheme = \"\" if url.scheme != \"all\" else url.scheme", "line_num": 174}, "source": "discovered", "category": "utils", "mutation_type": "comparison_swap"}
{"task_id": "httpx-auth-L215-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:215, a constant was changed: 'self._nonce_count = 1' became 'self._nonce_count = 0'. This shifts a boundary or default.", "vague_description": "A hardcoded value is slightly off. Behavior at specific boundaries doesn't match expectations \u2014 like an off-by-one in a limit.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "self._nonce_count = 1", "mutated": "self._nonce_count = 0", "line_num": 215}, "source": "discovered", "category": "auth", "mutation_type": "constant_mutation"}
{"task_id": "httpx-config-L144-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:144, the comparison operator was changed: 'and self.read == other.read' became 'and self.read != other.read'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "and self.read == other.read", "mutated": "and self.read != other.read", "line_num": 144}, "source": "discovered", "category": "config", "mutation_type": "comparison_swap"}
{"task_id": "httpx-content-L212-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:212, a boolean operator was swapped: 'return encode_multipart_data(data or {}, files, boundary)' became 'return encode_multipart_data(data and {}, files, boundary)'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "return encode_multipart_data(data or {}, files, boundary)", "mutated": "return encode_multipart_data(data and {}, files, boundary)", "line_num": 212}, "source": "discovered", "category": "content", "mutation_type": "boolean_flip"}
{"task_id": "httpx-decoders-L137-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:137, a condition was inverted: 'if not data:' became 'if data:'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "if not data:", "mutated": "if data:", "line_num": 137}, "source": "discovered", "category": "decoders", "mutation_type": "condition_inversion"}
{"task_id": "httpx-multipart-L87-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:87, a condition was inverted: 'value if isinstance(value, bytes) else primitive_value_to_str(value)' became 'value if not isinstance(value, bytes) else primitive_value_to_str(value)'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "value if isinstance(value, bytes) else primitive_value_to_str(value)", "mutated": "value if not isinstance(value, bytes) else primitive_value_to_str(value)", "line_num": 87}, "source": "discovered", "category": "multipart", "mutation_type": "condition_inversion"}
{"task_id": "httpx-utils-L198-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:198, a boolean operator was swapped: 'and not self.host_regex.match(other.host)' became 'or not self.host_regex.match(other.host)'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "and not self.host_regex.match(other.host)", "mutated": "or not self.host_regex.match(other.host)", "line_num": 198}, "source": "discovered", "category": "utils", "mutation_type": "boolean_flip"}
{"task_id": "httpx-auth-L235-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:235, the comparison operator was changed: 'assert scheme.lower() == \"digest\"' became 'assert scheme.lower() != \"digest\"'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "assert scheme.lower() == \"digest\"", "mutated": "assert scheme.lower() != \"digest\"", "line_num": 235}, "source": "discovered", "category": "auth", "mutation_type": "comparison_swap"}
{"task_id": "httpx-main-L241-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:241, the comparison operator was changed: 'elif name == \"http11.receive_response_headers.complete\":' became 'elif name != \"http11.receive_response_headers.complete\":'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "elif name == \"http11.receive_response_headers.complete\":", "mutated": "elif name != \"http11.receive_response_headers.complete\":", "line_num": 241}, "source": "discovered", "category": "cli", "mutation_type": "comparison_swap"}
{"task_id": "httpx-config-L43-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:43, a value was swapped: 'ctx.check_hostname = False' became 'ctx.check_hostname = True'.", "vague_description": "An assignment or return value is wrong \u2014 it returns the first argument where it should return the second, or similar.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "ctx.check_hostname = False", "mutated": "ctx.check_hostname = True", "line_num": 43}, "source": "discovered", "category": "config", "mutation_type": "value_swap"}
{"task_id": "httpx-content-L197-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:197, a None check was inverted: 'if data is not None and not isinstance(data, Mapping):' became 'if data is None and not isinstance(data, Mapping):'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "if data is not None and not isinstance(data, Mapping):", "mutated": "if data is None and not isinstance(data, Mapping):", "line_num": 197}, "source": "discovered", "category": "content", "mutation_type": "none_check_swap"}
{"task_id": "httpx-decoders-L186-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:186, a boolean operator was swapped: 'while self.decompressor.eof and self.decompressor.unused_data:' became 'while self.decompressor.eof or self.decompressor.unused_data:'. This changes the logical condition.", "vague_description": "A feature flag or boolean check seems inverted. Enabling something disables it, or the logic short-circuits in the wrong direction.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "while self.decompressor.eof and self.decompressor.unused_data:", "mutated": "while self.decompressor.eof or self.decompressor.unused_data:", "line_num": 186}, "source": "discovered", "category": "decoders", "mutation_type": "boolean_flip"}
{"task_id": "httpx-multipart-L108-arithmetic_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:108, an arithmetic operator was changed: 'return len(headers) + len(data)' became 'return len(headers) - len(data)'. This produces wrong numeric results.", "vague_description": "A numerical calculation gives wrong output. The math is off \u2014 values are larger or smaller than expected by a consistent amount.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "return len(headers) + len(data)", "mutated": "return len(headers) - len(data)", "line_num": 108}, "source": "discovered", "category": "multipart", "mutation_type": "arithmetic_swap"}
{"task_id": "httpx-urlparse-L298-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _urlparse.py:298, a boolean operator was swapped: 'scheme = kwargs.get(\"scheme\", url_dict[\"scheme\"]) or \"\"' became 'scheme = kwargs.get(\"scheme\", url_dict[\"scheme\"]) and \"\"'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/models/test_whatwg.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_urlparse.py", "original": "scheme = kwargs.get(\"scheme\", url_dict[\"scheme\"]) or \"\"", "mutated": "scheme = kwargs.get(\"scheme\", url_dict[\"scheme\"]) and \"\"", "line_num": 298}, "source": "discovered", "category": "url_parsing", "mutation_type": "boolean_flip"}
{"task_id": "httpx-utils-L71-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:71, the comparison operator was changed: 'elif hostname.lower() == \"localhost\":' became 'elif hostname.lower() != \"localhost\":'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "elif hostname.lower() == \"localhost\":", "mutated": "elif hostname.lower() != \"localhost\":", "line_num": 71}, "source": "discovered", "category": "utils", "mutation_type": "comparison_swap"}
{"task_id": "httpx-auth-L77-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:77, a value was swapped: 'while True:' became 'while False:'.", "vague_description": "An assignment or return value is wrong \u2014 it returns the first argument where it should return the second, or similar.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "while True:", "mutated": "while False:", "line_num": 77}, "source": "discovered", "category": "auth", "mutation_type": "value_swap"}
{"task_id": "httpx-config-L45-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:45, a condition was inverted: 'elif isinstance(verify, str):  # pragma: nocover' became 'elif not isinstance(verify, str):  # pragma: nocover'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "elif isinstance(verify, str):  # pragma: nocover", "mutated": "elif not isinstance(verify, str):  # pragma: nocover", "line_num": 45}, "source": "discovered", "category": "config", "mutation_type": "condition_inversion"}
{"task_id": "httpx-decoders-L198-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:198, a condition was inverted: 'if not self.decompressor.eof:' became 'if self.decompressor.eof:'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "if not self.decompressor.eof:", "mutated": "if self.decompressor.eof:", "line_num": 198}, "source": "discovered", "category": "decoders", "mutation_type": "condition_inversion"}
{"task_id": "httpx-multipart-L59-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:59, a boolean operator was swapped: 'if not content_type or not content_type.startswith(b\"multipart/form-data\"):' became 'if not content_type and not content_type.startswith(b\"multipart/form-data\"):'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "if not content_type or not content_type.startswith(b\"multipart/form-data\"):", "mutated": "if not content_type and not content_type.startswith(b\"multipart/form-data\"):", "line_num": 59}, "source": "discovered", "category": "multipart", "mutation_type": "boolean_flip"}
{"task_id": "httpx-asgi-L176-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:176, a None check was inverted: 'if status_code is None:' became 'if status_code is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "if status_code is None:", "mutated": "if status_code is not None:", "line_num": 176}, "source": "discovered", "category": "transports", "mutation_type": "none_check_swap"}
{"task_id": "httpx-utils-L175-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:175, the comparison operator was changed: 'self.host = \"\" if url.host == \"*\" else url.host' became 'self.host = \"\" if url.host != \"*\" else url.host'. This alters the boundary condition.", "vague_description": "A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "self.host = \"\" if url.host == \"*\" else url.host", "mutated": "self.host = \"\" if url.host != \"*\" else url.host", "line_num": 175}, "source": "discovered", "category": "utils", "mutation_type": "comparison_swap"}
{"task_id": "httpx-auth-L201-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _auth.py:201, the comparison operator was changed: 'if response.status_code != 401 or \"www-authenticate\" not in response.headers:' became 'if response.status_code == 401 or \"www-authenticate\" not in response.headers:'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_auth.py", "original": "if response.status_code != 401 or \"www-authenticate\" not in response.headers:", "mutated": "if response.status_code == 401 or \"www-authenticate\" not in response.headers:", "line_num": 201}, "source": "discovered", "category": "auth", "mutation_type": "comparison_swap"}
{"task_id": "httpx-main-L219-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:219, the comparison operator was changed: 'elif name == \"connection.connect_tcp.complete\" and verbose:' became 'elif name != \"connection.connect_tcp.complete\" and verbose:'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "elif name == \"connection.connect_tcp.complete\" and verbose:", "mutated": "elif name != \"connection.connect_tcp.complete\" and verbose:", "line_num": 219}, "source": "discovered", "category": "cli", "mutation_type": "comparison_swap"}
{"task_id": "httpx-config-L186-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:186, a condition was inverted: 'isinstance(other, self.__class__)' became 'not isinstance(other, self.__class__)'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "isinstance(other, self.__class__)", "mutated": "not isinstance(other, self.__class__)", "line_num": 186}, "source": "discovered", "category": "config", "mutation_type": "condition_inversion"}
{"task_id": "httpx-content-L123-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:123, a None check was inverted: 'if content_length_or_none is None:' became 'if content_length_or_none is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "if content_length_or_none is None:", "mutated": "if content_length_or_none is not None:", "line_num": 123}, "source": "discovered", "category": "content", "mutation_type": "none_check_swap"}
{"task_id": "httpx-decoders-L181-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:181, a None check was inverted: 'assert zstandard is not None' became 'assert zstandard is None'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "assert zstandard is not None", "mutated": "assert zstandard is None", "line_num": 181}, "source": "discovered", "category": "decoders", "mutation_type": "none_check_swap"}
{"task_id": "httpx-multipart-L175-arithmetic_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:175, an arithmetic operator was changed: 'return len(headers) + len(to_bytes(self.file))' became 'return len(headers) - len(to_bytes(self.file))'. This produces wrong numeric results.", "vague_description": "A numerical calculation gives wrong output. The math is off \u2014 values are larger or smaller than expected by a consistent amount.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "return len(headers) + len(to_bytes(self.file))", "mutated": "return len(headers) - len(to_bytes(self.file))", "line_num": 175}, "source": "discovered", "category": "multipart", "mutation_type": "arithmetic_swap"}
{"task_id": "httpx-mock-L40-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In mock.py:40, a condition was inverted: 'if not isinstance(response, Response):' became 'if isinstance(response, Response):'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/client/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/mock.py", "original": "if not isinstance(response, Response):", "mutated": "if isinstance(response, Response):", "line_num": 40}, "source": "discovered", "category": "transports", "mutation_type": "condition_inversion"}
{"task_id": "httpx-utils-L194-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:194, a value was swapped: 'return False' became 'return True'.", "vague_description": "Two related values are mixed up. The system applies the wrong one of two options depending on context.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "return False", "mutated": "return True", "line_num": 194}, "source": "discovered", "category": "utils", "mutation_type": "value_swap"}
{"task_id": "httpx-main-L244-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:244, the comparison operator was changed: 'elif name == \"http2.receive_response_headers.complete\":  # pragma: no cover' became 'elif name != \"http2.receive_response_headers.complete\":  # pragma: no cover'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "elif name == \"http2.receive_response_headers.complete\":  # pragma: no cover", "mutated": "elif name != \"http2.receive_response_headers.complete\":  # pragma: no cover", "line_num": 244}, "source": "discovered", "category": "cli", "mutation_type": "comparison_swap"}
{"task_id": "httpx-config-L112-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:112, a condition was inverted: 'isinstance(connect, UnsetType)' became 'not isinstance(connect, UnsetType)'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "isinstance(connect, UnsetType)", "mutated": "not isinstance(connect, UnsetType)", "line_num": 112}, "source": "discovered", "category": "config", "mutation_type": "condition_inversion"}
{"task_id": "httpx-content-L129-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:129, a condition was inverted: 'elif isinstance(content, AsyncIterable):' became 'elif not isinstance(content, AsyncIterable):'. The branch now triggers in the opposite case.", "vague_description": "A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "elif isinstance(content, AsyncIterable):", "mutated": "elif not isinstance(content, AsyncIterable):", "line_num": 129}, "source": "discovered", "category": "content", "mutation_type": "condition_inversion"}
{"task_id": "httpx-decoders-L195-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:195, a condition was inverted: 'if not self.seen_data:' became 'if self.seen_data:'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "if not self.seen_data:", "mutated": "if self.seen_data:", "line_num": 195}, "source": "discovered", "category": "decoders", "mutation_type": "condition_inversion"}
{"task_id": "httpx-multipart-L39-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:39, a constant was changed: 'return _HTML5_FORM_ENCODING_REPLACEMENTS[match.group(0)]' became 'return _HTML5_FORM_ENCODING_REPLACEMENTS[match.group(1)]'. This shifts a boundary or default.", "vague_description": "A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "return _HTML5_FORM_ENCODING_REPLACEMENTS[match.group(0)]", "mutated": "return _HTML5_FORM_ENCODING_REPLACEMENTS[match.group(1)]", "line_num": 39}, "source": "discovered", "category": "multipart", "mutation_type": "constant_mutation"}
{"task_id": "httpx-asgi-L41-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:41, a value was swapped: 'return False' became 'return True'.", "vague_description": "Two values appear to be swapped. The system uses value A where it should use value B, and value B where it should use value A.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "return False", "mutated": "return True", "line_num": 41}, "source": "discovered", "category": "transports", "mutation_type": "value_swap"}
{"task_id": "httpx-utils-L202-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:202, a value was swapped: 'return False' became 'return True'.", "vague_description": "Two related values are mixed up. The system applies the wrong one of two options depending on context.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "return False", "mutated": "return True", "line_num": 202}, "source": "discovered", "category": "utils", "mutation_type": "value_swap"}
{"task_id": "httpx-main-L265-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:265, a boolean operator was swapped: 'total=int(content_length or 0),' became 'total=int(content_length and 0),'. This changes the logical condition.", "vague_description": "A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "total=int(content_length or 0),", "mutated": "total=int(content_length and 0),", "line_num": 265}, "source": "discovered", "category": "cli", "mutation_type": "boolean_flip"}
{"task_id": "httpx-config-L36-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:36, a boolean operator was swapped: 'elif trust_env and os.environ.get(\"SSL_CERT_DIR\"):  # pragma: nocover' became 'elif trust_env or os.environ.get(\"SSL_CERT_DIR\"):  # pragma: nocover'. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "elif trust_env and os.environ.get(\"SSL_CERT_DIR\"):  # pragma: nocover", "mutated": "elif trust_env or os.environ.get(\"SSL_CERT_DIR\"):  # pragma: nocover", "line_num": 36}, "source": "discovered", "category": "config", "mutation_type": "boolean_flip"}
{"task_id": "httpx-content-L79-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:79, a value was swapped: 'self._is_stream_consumed = True' became 'self._is_stream_consumed = False'.", "vague_description": "Two related values are mixed up. The system applies the wrong one of two options depending on context.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "self._is_stream_consumed = True", "mutated": "self._is_stream_consumed = False", "line_num": 79}, "source": "discovered", "category": "content", "mutation_type": "value_swap"}
{"task_id": "httpx-decoders-L119-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:119, a None check was inverted: 'if brotli is None:  # pragma: no cover' became 'if brotli is not None:  # pragma: no cover'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "if brotli is None:  # pragma: no cover", "mutated": "if brotli is not None:  # pragma: no cover", "line_num": 119}, "source": "discovered", "category": "decoders", "mutation_type": "none_check_swap"}
{"task_id": "httpx-multipart-L52-boolean_flip", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:52, a boolean operator was swapped: 'return mimetypes.guess_type(filename)[0] or \"application/octet-stream\"' became 'return mimetypes.guess_type(filename)[0] and \"application/octet-stream\"'. This changes the logical condition.", "vague_description": "An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "return mimetypes.guess_type(filename)[0] or \"application/octet-stream\"", "mutated": "return mimetypes.guess_type(filename)[0] and \"application/octet-stream\"", "line_num": 52}, "source": "discovered", "category": "multipart", "mutation_type": "boolean_flip"}
{"task_id": "httpx-asgi-L151-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:151, the comparison operator was changed: 'if message[\"type\"] == \"http.response.start\":' became 'if message[\"type\"] != \"http.response.start\":'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "if message[\"type\"] == \"http.response.start\":", "mutated": "if message[\"type\"] != \"http.response.start\":", "line_num": 151}, "source": "discovered", "category": "transports", "mutation_type": "comparison_swap"}
{"task_id": "httpx-utils-L212-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:212, a None check was inverted: 'port_priority = 0 if self.port is not None else 1' became 'port_priority = 0 if self.port is None else 1'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "port_priority = 0 if self.port is not None else 1", "mutated": "port_priority = 0 if self.port is None else 1", "line_num": 212}, "source": "discovered", "category": "utils", "mutation_type": "none_check_swap"}
{"task_id": "httpx-main-L174-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _main.py:174, the comparison operator was changed: 'if lexer_name.lower() == \"json\":' became 'if lexer_name.lower() != \"json\":'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_main.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_main.py", "original": "if lexer_name.lower() == \"json\":", "mutated": "if lexer_name.lower() != \"json\":", "line_num": 174}, "source": "discovered", "category": "cli", "mutation_type": "comparison_swap"}
{"task_id": "httpx-config-L146-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:146, the comparison operator was changed: 'and self.pool == other.pool' became 'and self.pool != other.pool'. This alters the boundary condition.", "vague_description": "Something that should be caught at an exact limit slips through, or triggers too early. The comparison logic seems wrong.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "and self.pool == other.pool", "mutated": "and self.pool != other.pool", "line_num": 146}, "source": "discovered", "category": "config", "mutation_type": "comparison_swap"}
{"task_id": "httpx-content-L231-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:231, a None check was inverted: 'if content is not None:' became 'if content is None:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "if content is not None:", "mutated": "if content is None:", "line_num": 231}, "source": "discovered", "category": "content", "mutation_type": "none_check_swap"}
{"task_id": "httpx-decoders-L277-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _decoders.py:277, a None check was inverted: 'if self._chunk_size is None:' became 'if self._chunk_size is not None:'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_decoders.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_decoders.py", "original": "if self._chunk_size is None:", "mutated": "if self._chunk_size is not None:", "line_num": 277}, "source": "discovered", "category": "decoders", "mutation_type": "none_check_swap"}
{"task_id": "httpx-multipart-L158-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:158, a condition was inverted: 'if isinstance(fileobj, io.StringIO):' became 'if not isinstance(fileobj, io.StringIO):'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "if isinstance(fileobj, io.StringIO):", "mutated": "if not isinstance(fileobj, io.StringIO):", "line_num": 158}, "source": "discovered", "category": "multipart", "mutation_type": "condition_inversion"}
{"task_id": "httpx-utils-L51-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:51, the comparison operator was changed: 'if hostname == \"*\":' became 'if hostname != \"*\":'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "if hostname == \"*\":", "mutated": "if hostname != \"*\":", "line_num": 51}, "source": "discovered", "category": "utils", "mutation_type": "comparison_swap"}
{"task_id": "httpx-config-L122-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _config.py:122, a condition was inverted: 'if isinstance(timeout, UnsetType):' became 'if not isinstance(timeout, UnsetType):'. The branch now triggers in the opposite case.", "vague_description": "A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.", "test_cmd": "python -m pytest tests/test_config.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_config.py", "original": "if isinstance(timeout, UnsetType):", "mutated": "if not isinstance(timeout, UnsetType):", "line_num": 122}, "source": "discovered", "category": "config", "mutation_type": "condition_inversion"}
{"task_id": "httpx-content-L233-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _content.py:233, a None check was inverted: 'elif text is not None:' became 'elif text is None:'. This reverses when the value is considered present vs absent.", "vague_description": "Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.", "test_cmd": "python -m pytest tests/test_content.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_content.py", "original": "elif text is not None:", "mutated": "elif text is None:", "line_num": 233}, "source": "discovered", "category": "content", "mutation_type": "none_check_swap"}
{"task_id": "httpx-multipart-L187-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _multipart.py:187, a condition was inverted: 'if not hasattr(self, \"_headers\"):' became 'if hasattr(self, \"_headers\"):'. The branch now triggers in the opposite case.", "vague_description": "Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.", "test_cmd": "python -m pytest tests/test_multipart.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_multipart.py", "original": "if not hasattr(self, \"_headers\"):", "mutated": "if hasattr(self, \"_headers\"):", "line_num": 187}, "source": "discovered", "category": "multipart", "mutation_type": "condition_inversion"}
{"task_id": "httpx-asgi-L114-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:114, a constant was changed: '\"raw_path\": request.url.raw_path.split(b\"?\")[0],' became '\"raw_path\": request.url.raw_path.split(b\"?\")[1],'. This shifts a boundary or default.", "vague_description": "A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "\"raw_path\": request.url.raw_path.split(b\"?\")[0],", "mutated": "\"raw_path\": request.url.raw_path.split(b\"?\")[1],", "line_num": 114}, "source": "discovered", "category": "transports", "mutation_type": "constant_mutation"}
{"task_id": "httpx-utils-L193-comparison_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In _utils.py:193, the comparison operator was changed: 'if self.scheme and self.scheme != other.scheme:' became 'if self.scheme and self.scheme == other.scheme:'. This alters the boundary condition.", "vague_description": "A threshold or limit check seems to trigger at the wrong value. The boundary is off by one or uses the wrong comparison direction.", "test_cmd": "python -m pytest tests/test_utils.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_utils.py", "original": "if self.scheme and self.scheme != other.scheme:", "mutated": "if self.scheme and self.scheme == other.scheme:", "line_num": 193}, "source": "discovered", "category": "utils", "mutation_type": "comparison_swap"}
{"task_id": "httpx-asgi-L129-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:129, a value was swapped: 'response_started = False' became 'response_started = True'.", "vague_description": "An assignment or return value is wrong \u2014 it returns the first argument where it should return the second, or similar.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "response_started = False", "mutated": "response_started = True", "line_num": 129}, "source": "discovered", "category": "transports", "mutation_type": "value_swap"}
{"task_id": "httpx-asgi-L182-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:182, a None check was inverted: 'assert status_code is not None' became 'assert status_code is None'. This reverses when the value is considered present vs absent.", "vague_description": "Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "assert status_code is not None", "mutated": "assert status_code is None", "line_num": 182}, "source": "discovered", "category": "transports", "mutation_type": "none_check_swap"}
{"task_id": "httpx-asgi-L145-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:145, a value was swapped: 'return {\"type\": \"http.request\", \"body\": b\"\", \"more_body\": False}' became 'return {\"type\": \"http.request\", \"body\": b\"\", \"more_body\": True}'.", "vague_description": "Two related values are mixed up. The system applies the wrong one of two options depending on context.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "return {\"type\": \"http.request\", \"body\": b\"\", \"more_body\": False}", "mutated": "return {\"type\": \"http.request\", \"body\": b\"\", \"more_body\": True}", "line_num": 145}, "source": "discovered", "category": "transports", "mutation_type": "value_swap"}
{"task_id": "httpx-asgi-L177-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:177, a constant was changed: 'status_code = 500' became 'status_code = 501'. This shifts a boundary or default.", "vague_description": "A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "status_code = 500", "mutated": "status_code = 501", "line_num": 177}, "source": "discovered", "category": "transports", "mutation_type": "constant_mutation"}
{"task_id": "httpx-asgi-L103-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:103, a condition was inverted: 'assert isinstance(request.stream, AsyncByteStream)' became 'assert not isinstance(request.stream, AsyncByteStream)'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "assert isinstance(request.stream, AsyncByteStream)", "mutated": "assert not isinstance(request.stream, AsyncByteStream)", "line_num": 103}, "source": "discovered", "category": "transports", "mutation_type": "condition_inversion"}
{"task_id": "httpx-wsgi-L27-return_value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In wsgi.py:27, the code was changed from 'return []' to 'return [None]' (return_value_swap).", "vague_description": "A return value is incorrect. The function returns True when it should return False, or an empty result instead of a populated one.", "test_cmd": "python -m pytest tests/test_wsgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/wsgi.py", "original": "return []", "mutated": "return [None]", "line_num": 27}, "source": "discovered", "category": "transports", "mutation_type": "return_value_swap"}
{"task_id": "httpx-wsgi-L143-constant_mutation", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In wsgi.py:143, a constant was changed: 'status_code = int(seen_status.split()[0])' became 'status_code = int(seen_status.split()[1])'. This shifts a boundary or default.", "vague_description": "A hardcoded value is slightly off. Behavior at specific boundaries doesn't match expectations \u2014 like an off-by-one in a limit.", "test_cmd": "python -m pytest tests/test_wsgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/wsgi.py", "original": "status_code = int(seen_status.split()[0])", "mutated": "status_code = int(seen_status.split()[1])", "line_num": 143}, "source": "discovered", "category": "transports", "mutation_type": "constant_mutation"}
{"task_id": "httpx-asgi-L144-value_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In asgi.py:144, a value was swapped: 'request_complete = True' became 'request_complete = False'.", "vague_description": "An assignment or return value is wrong \u2014 it returns the first argument where it should return the second, or similar.", "test_cmd": "python -m pytest tests/test_asgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/asgi.py", "original": "request_complete = True", "mutated": "request_complete = False", "line_num": 144}, "source": "discovered", "category": "transports", "mutation_type": "value_swap"}
{"task_id": "httpx-wsgi-L139-none_check_swap", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In wsgi.py:139, a None check was inverted: 'assert seen_response_headers is not None' became 'assert seen_response_headers is None'. This reverses when the value is considered present vs absent.", "vague_description": "A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.", "test_cmd": "python -m pytest tests/test_wsgi.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/wsgi.py", "original": "assert seen_response_headers is not None", "mutated": "assert seen_response_headers is None", "line_num": 139}, "source": "discovered", "category": "transports", "mutation_type": "none_check_swap"}
{"task_id": "httpx-mock-L25-condition_inversion", "repo_path": "/Users/akshankrithick/projects/httpx", "repo_url": "https://github.com/encode/httpx", "commit": "ae1b9f66238f75ced3ced5e4485408435de10768", "setup_cmd": "pip install -e '.[brotli,zstd,cli,http2,socks]' && pip install pytest uvicorn trio trustme chardet", "description": "In mock.py:25, a condition was inverted: 'if not isinstance(response, Response):  # pragma: no cover' became 'if isinstance(response, Response):  # pragma: no cover'. The branch now triggers in the opposite case.", "vague_description": "A guard clause or check does the opposite of what it should. The happy path and error path are swapped.", "test_cmd": "python -m pytest tests/client/test_auth.py -x", "in_place": true, "timeout": 60, "mutation": {"file": "httpx/_transports/mock.py", "original": "if not isinstance(response, Response):  # pragma: no cover", "mutated": "if isinstance(response, Response):  # pragma: no cover", "line_num": 25}, "source": "discovered", "category": "transports", "mutation_type": "condition_inversion"}
