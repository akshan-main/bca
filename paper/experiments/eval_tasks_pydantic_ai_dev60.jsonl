{"task_id":"usage-total-tokens-math","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"UsageBase.total_tokens subtracts output tokens instead of adding them, making the total_tokens property return wrong values.","vague_description":"Token usage tracking seems off. The total token count is always lower than expected, even lower than the input tokens alone.","test_cmd":"python -m pytest tests/test_usage_limits.py::test_total_token_limit -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"return self.input_tokens + self.output_tokens","mutated":"return self.input_tokens - self.output_tokens","line_num":66},"source":"handcrafted","category":"usage"}
{"task_id":"usage-request-limit-off-by-one","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"UsageLimits.check_before_request uses > instead of >= for the request limit check, allowing one extra request beyond the limit.","vague_description":"Setting request_limit=1 still allows 2 requests before stopping. The limit is off by one.","test_cmd":"python -m pytest tests/test_usage_limits.py::test_retry_limit -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"if request_limit is not None and usage.requests >= request_limit:","mutated":"if request_limit is not None and usage.requests > request_limit:","line_num":369},"source":"handcrafted","category":"usage"}
{"task_id":"usage-check-tokens-output-inverted","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"check_tokens uses 'is None' instead of 'is not None' for output_tokens_limit, so the limit is never enforced.","vague_description":"Output token limits are completely ignored. The agent generates unlimited output tokens even with output_tokens_limit set.","test_cmd":"python -m pytest tests/test_usage_limits.py::test_response_token_limit -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"if self.output_tokens_limit is not None and output_tokens > self.output_tokens_limit:","mutated":"if self.output_tokens_limit is None and output_tokens > self.output_tokens_limit:","line_num":391},"source":"handcrafted","category":"usage"}
{"task_id":"usage-incr-tokens-wrong-op","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"_incr_usage_tokens subtracts input_tokens instead of adding, causing RunUsage.incr() to produce negative token counts.","vague_description":"After multiple agent runs, the cumulative usage stats show negative input token counts. Something is wrong with the usage accumulation.","test_cmd":"python -m pytest tests/test_usage_limits.py::test_add_usages -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"slf.input_tokens += incr_usage.input_tokens","mutated":"slf.input_tokens -= incr_usage.input_tokens","line_num":231},"source":"handcrafted","category":"usage"}
{"task_id":"usage-tool-calls-limit-comparison","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"check_before_tool_call raises UsageLimitExceeded when tool calls are BELOW the limit instead of above it, blocking tools prematurely.","vague_description":"Tool calls are being rejected immediately even though the tool call limit hasn't been reached. The limit enforcement seems inverted.","test_cmd":"python -m pytest tests/test_usage_limits.py::test_tool_call_limit -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"if tool_calls_limit is not None and tool_calls > tool_calls_limit:","mutated":"if tool_calls_limit is not None and tool_calls < tool_calls_limit:","line_num":404},"source":"handcrafted","category":"usage"}
{"task_id":"ssrf-cloud-metadata-inverted","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"is_cloud_metadata_ip returns True for non-metadata IPs and False for actual cloud metadata endpoints \u2014 the check is inverted.","vague_description":"URL downloads to public websites are being blocked as 'cloud metadata', but requests to 169.254.169.254 go through unchecked.","test_cmd":"python -m pytest tests/test_ssrf.py::TestIsCloudMetadataIp -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"return ip_str in _CLOUD_METADATA_IPS","mutated":"return ip_str not in _CLOUD_METADATA_IPS","line_num":79},"source":"handcrafted","category":"ssrf"}
{"task_id":"ssrf-protocol-validation","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"validate_url_protocol rejects HTTPS URLs, only allowing plain HTTP \u2014 breaking all secure downloads.","vague_description":"All HTTPS URL downloads fail with a protocol error. Only plain HTTP URLs work, which defeats the security purpose.","test_cmd":"python -m pytest tests/test_ssrf.py::TestValidateUrlProtocol -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"if scheme not in ('http', 'https'):","mutated":"if scheme not in ('http',):","line_num":145},"source":"handcrafted","category":"ssrf"}
{"task_id":"ssrf-default-port-swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"extract_host_and_port swaps default ports \u2014 HTTPS gets port 80 and HTTP gets port 443, breaking URL resolution.","vague_description":"URL downloads fail silently. HTTPS connections seem to be going to the wrong port.","test_cmd":"python -m pytest tests/test_ssrf.py::TestExtractHostAndPort -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"default_port = 443 if is_https else 80","mutated":"default_port = 80 if is_https else 443","line_num":169},"source":"handcrafted","category":"ssrf"}
{"task_id":"ssrf-private-ip-allow-local-inverted","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"The allow_local guard is inverted \u2014 private IPs are blocked when allow_local=True and allowed when allow_local=False.","vague_description":"Setting allow_local=True blocks local network requests, and removing it allows them. The flag seems to do the opposite of what it should.","test_cmd":"python -m pytest tests/test_ssrf.py::TestValidateAndResolveUrl::test_private_ip_blocked_by_default -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"if not allow_local and is_private_ip(ip):","mutated":"if allow_local and is_private_ip(ip):","line_num":241},"source":"handcrafted","category":"ssrf"}
{"task_id":"tool-retry-isinstance-inverted","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"ToolRetryError._format_error_details inverts the isinstance check, passing string content to dict-processing code and crashing.","vague_description":"Tool retry errors crash with a TypeError when the tool returns a simple string error message. Only structured errors work.","test_cmd":"python -m pytest tests/test_exceptions.py::test_tool_retry_error_str_with_string_content -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/exceptions.py","original":"if isinstance(tool_retry.content, str)","mutated":"if not isinstance(tool_retry.content, str)","line_num":205},"source":"handcrafted","category":"exceptions"}
{"task_id":"tool-retry-error-format","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"ToolRetryError pluralization is inverted \u2014 says 'errors' for 1 error and 'error' for multiple.","vague_description":"Tool retry error messages have wrong grammar. A single validation error says 'errors' plural.","test_cmd":"python -m pytest tests/test_exceptions.py::test_tool_retry_error_str_with_error_details -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/exceptions.py","original":"f'{error_count} validation error{\"\" if error_count == 1 else \"s\"}{f\" for {tool_name!r}\" if tool_name else \"\"}'","mutated":"f'{error_count} validation error{\"s\" if error_count == 1 else \"\"}{f\" for {tool_name!r}\" if tool_name else \"\"}'","line_num":221},"source":"handcrafted","category":"exceptions"}
{"task_id":"settings-merge-priority","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"merge_model_settings gives base settings priority over overrides instead of the other way around, ignoring per-run settings.","vague_description":"Model settings passed to agent.run() are silently ignored. The agent always uses the settings from initialization.","test_cmd":"python -m pytest tests/test_agent.py::test_model_settings_override -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/settings.py","original":"return base | overrides","mutated":"return overrides | base","line_num":192},"source":"handcrafted","category":"settings"}
{"task_id":"ssrf-ipv4-mapped-ipv6-skip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"is_private_ip skips IPv4-mapped IPv6 unwrapping for actual mapped addresses, failing to detect private IPs in IPv6 form.","vague_description":"Private IP addresses wrapped in IPv6 notation bypass the SSRF protection. For example ::ffff:192.168.1.1 is not blocked.","test_cmd":"python -m pytest tests/test_ssrf.py::TestIsPrivateIp::test_ipv4_mapped_ipv6_private -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"if isinstance(ip, ipaddress.IPv6Address) and ip.ipv4_mapped:","mutated":"if isinstance(ip, ipaddress.IPv6Address) and not ip.ipv4_mapped:","line_num":91},"source":"handcrafted","category":"ssrf"}
{"task_id":"ssrf-max-redirects-zero","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"_MAX_REDIRECTS is set to 0, preventing any HTTP redirects from being followed during safe downloads.","vague_description":"URL downloads that involve redirects always fail. The downloader seems unable to follow even a single redirect.","test_cmd":"python -m pytest tests/test_ssrf.py::TestSafeDownload::test_redirect_followed -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"_MAX_REDIRECTS = 10","mutated":"_MAX_REDIRECTS = 0","line_num":50},"source":"handcrafted","category":"ssrf"}
{"task_id":"d-builtin_tools-L74-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In builtin_tools.py:74, a condition was inverted: 'if cls is not AbstractBuiltinTool:' became 'if cls is AbstractBuiltinTool:'. The branch now triggers in the opposite case.","vague_description":"A guard clause or check does the opposite of what it should. The happy path and error path are swapped.","test_cmd":"python -m pytest tests/test_builtin_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/builtin_tools.py","original":"if cls is not AbstractBuiltinTool:","mutated":"if cls is AbstractBuiltinTool:","line_num":74},"source":"discovered","category":"builtin_tools","mutation_type":"condition_inversion"}
{"task_id":"d-concurrency-L290-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In concurrency.py:290, a None check was inverted: 'if limit is None:' became 'if limit is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.","test_cmd":"python -m pytest tests/test_concurrency.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/concurrency.py","original":"if limit is None:","mutated":"if limit is not None:","line_num":290},"source":"discovered","category":"concurrency","mutation_type":"none_check_swap"}
{"task_id":"d-direct-L316-value_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In direct.py:316, a value was swapped: 'while True:' became 'while False:'.","vague_description":"An assignment or return value is wrong \u2014 it returns the first argument where it should return the second, or similar.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/direct.py","original":"while True:","mutated":"while False:","line_num":316},"source":"discovered","category":"direct_api","mutation_type":"value_swap"}
{"task_id":"d-json_schema-L128-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _json_schema.py:128, a None check was inverted: 'if (additional_properties := schema.get('additionalProperties')) is not None:' became 'if (additional_properties := schema.get('additionalProperties')) is None:'. This reverses when the value is considered present vs absent.","vague_description":"A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.","test_cmd":"python -m pytest tests/test_json_schema.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_json_schema.py","original":"if (additional_properties := schema.get('additionalProperties')) is not None:","mutated":"if (additional_properties := schema.get('additionalProperties')) is None:","line_num":128},"source":"discovered","category":"json_schema","mutation_type":"none_check_swap"}
{"task_id":"d-instrumented-L68-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In instrumented.py:68, a boolean operator was swapped: 'if instrument and not isinstance(model, InstrumentedModel):' became 'if instrument or not isinstance(model, InstrumentedModel):'. This changes the logical condition.","vague_description":"An 'or' that should be 'and' (or vice versa) is causing wrong behavior. The boolean logic combines conditions incorrectly.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/models/instrumented.py","original":"if instrument and not isinstance(model, InstrumentedModel):","mutated":"if instrument or not isinstance(model, InstrumentedModel):","line_num":68},"source":"discovered","category":"models","mutation_type":"boolean_flip"}
{"task_id":"d-parts_manager-L211-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _parts_manager.py:211, a None check was inverted: 'if vendor_part_id is None:' became 'if vendor_part_id is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.","test_cmd":"python -m pytest tests/test_parts_manager.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_parts_manager.py","original":"if vendor_part_id is None:","mutated":"if vendor_part_id is not None:","line_num":211},"source":"discovered","category":"parts_manager","mutation_type":"none_check_swap"}
{"task_id":"d-retries-L369-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In retries.py:369, a condition was inverted: 'assert isinstance(retry_time, datetime)' became 'assert not isinstance(retry_time, datetime)'. The branch now triggers in the opposite case.","vague_description":"Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.","test_cmd":"python -m pytest tests/test_tenacity.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/retries.py","original":"assert isinstance(retry_time, datetime)","mutated":"assert not isinstance(retry_time, datetime)","line_num":369},"source":"discovered","category":"retries","mutation_type":"condition_inversion"}
{"task_id":"d-ssrf-L201-comparison_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _ssrf.py:201, the comparison operator was changed: 'if resolved.port != default_port:' became 'if resolved.port == default_port:'. This alters the boundary condition.","vague_description":"A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.","test_cmd":"python -m pytest tests/test_ssrf.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"if resolved.port != default_port:","mutated":"if resolved.port == default_port:","line_num":201},"source":"discovered","category":"ssrf","mutation_type":"comparison_swap"}
{"task_id":"d-thinking_part-L22-arithmetic_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _thinking_part.py:22, an arithmetic operator was changed: 'think_content, content = content[:end_index], content[end_index + len(end_tag) :]' became 'think_content, content = content[:end_index], content[end_index - len(end_tag) :]'. This produces wrong numeric results.","vague_description":"A numerical calculation gives wrong output. The math is off \u2014 values are larger or smaller than expected by a consistent amount.","test_cmd":"python -m pytest tests/test_thinking_part.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_thinking_part.py","original":"think_content, content = content[:end_index], content[end_index + len(end_tag) :]","mutated":"think_content, content = content[:end_index], content[end_index - len(end_tag) :]","line_num":22},"source":"discovered","category":"thinking","mutation_type":"arithmetic_swap"}
{"task_id":"d-tools-L251-value_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In tools.py:251, a value was swapped: 'json_schema['additionalProperties'] = False' became 'json_schema['additionalProperties'] = True'.","vague_description":"Two related values are mixed up. The system applies the wrong one of two options depending on context.","test_cmd":"python -m pytest tests/test_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/tools.py","original":"json_schema['additionalProperties'] = False","mutated":"json_schema['additionalProperties'] = True","line_num":251},"source":"discovered","category":"tools","mutation_type":"value_swap"}
{"task_id":"d-app-L89-constant_mutation","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In app.py:89, a constant was changed: 'url_hash = hashlib.sha256(html_source.encode()).hexdigest()[:16]' became 'url_hash = hashlib.sha256(html_source.encode()).hexdigest()[:17]'. This shifts a boundary or default.","vague_description":"A numeric constant or default parameter has the wrong value. The system behaves as if configured with a different setting than intended.","test_cmd":"python -m pytest tests/test_ui_web.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/ui/_web/app.py","original":"url_hash = hashlib.sha256(html_source.encode()).hexdigest()[:16]","mutated":"url_hash = hashlib.sha256(html_source.encode()).hexdigest()[:17]","line_num":89},"source":"discovered","category":"ui","mutation_type":"constant_mutation"}
{"task_id":"d-usage-L240-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In usage.py:240, a condition was inverted: 'if isinstance(value, (int, float)):' became 'if not isinstance(value, (int, float)):'. The branch now triggers in the opposite case.","vague_description":"A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.","test_cmd":"python -m pytest tests/test_usage_limits.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"if isinstance(value, (int, float)):","mutated":"if not isinstance(value, (int, float)):","line_num":240},"source":"discovered","category":"usage","mutation_type":"condition_inversion"}
{"task_id":"d-utils-L243-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _utils.py:243, a None check was inverted: 'if group_start_time is None:' became 'if group_start_time is not None:'. This reverses when the value is considered present vs absent.","vague_description":"A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.","test_cmd":"python -m pytest tests/test_utils.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_utils.py","original":"if group_start_time is None:","mutated":"if group_start_time is not None:","line_num":243},"source":"discovered","category":"utils","mutation_type":"none_check_swap"}
{"task_id":"d-builtin_tools-L469-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In builtin_tools.py:469, a condition was inverted: 'if isinstance(tool_data, dict):' became 'if not isinstance(tool_data, dict):'. The branch now triggers in the opposite case.","vague_description":"Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.","test_cmd":"python -m pytest tests/test_builtin_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/builtin_tools.py","original":"if isinstance(tool_data, dict):","mutated":"if not isinstance(tool_data, dict):","line_num":469},"source":"discovered","category":"builtin_tools","mutation_type":"condition_inversion"}
{"task_id":"d-concurrency-L130-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In concurrency.py:130, a condition was inverted: 'if isinstance(limit, int):' became 'if not isinstance(limit, int):'. The branch now triggers in the opposite case.","vague_description":"Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.","test_cmd":"python -m pytest tests/test_concurrency.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/concurrency.py","original":"if isinstance(limit, int):","mutated":"if not isinstance(limit, int):","line_num":130},"source":"discovered","category":"concurrency","mutation_type":"condition_inversion"}
{"task_id":"d-direct-L343-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In direct.py:343, a None check was inverted: 'if self._stream_response is None:' became 'if self._stream_response is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/direct.py","original":"if self._stream_response is None:","mutated":"if self._stream_response is not None:","line_num":343},"source":"discovered","category":"direct_api","mutation_type":"none_check_swap"}
{"task_id":"d-parts_manager-L223-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _parts_manager.py:223, a None check was inverted: 'if existing_thinking_part_and_index is None:' became 'if existing_thinking_part_and_index is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.","test_cmd":"python -m pytest tests/test_parts_manager.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_parts_manager.py","original":"if existing_thinking_part_and_index is None:","mutated":"if existing_thinking_part_and_index is not None:","line_num":223},"source":"discovered","category":"parts_manager","mutation_type":"none_check_swap"}
{"task_id":"d-retries-L354-constant_mutation","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In retries.py:354, a constant was changed: 'fallback_strategy = wait_exponential(multiplier=1, max=60)' became 'fallback_strategy = wait_exponential(multiplier=0, max=60)'. This shifts a boundary or default.","vague_description":"A default value or configuration constant seems wrong. The system uses a different threshold or limit than what's documented.","test_cmd":"python -m pytest tests/test_tenacity.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/retries.py","original":"fallback_strategy = wait_exponential(multiplier=1, max=60)","mutated":"fallback_strategy = wait_exponential(multiplier=0, max=60)","line_num":354},"source":"discovered","category":"retries","mutation_type":"constant_mutation"}
{"task_id":"d-ssrf-L166-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _ssrf.py:166, a condition was inverted: 'if not hostname:' became 'if hostname:'. The branch now triggers in the opposite case.","vague_description":"A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.","test_cmd":"python -m pytest tests/test_ssrf.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_ssrf.py","original":"if not hostname:","mutated":"if hostname:","line_num":166},"source":"discovered","category":"ssrf","mutation_type":"condition_inversion"}
{"task_id":"d-thinking_part-L17-arithmetic_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _thinking_part.py:17, an arithmetic operator was changed: 'before_think, content = content[:start_index], content[start_index + len(start_tag) :]' became 'before_think, content = content[:start_index], content[start_index - len(start_tag) :]'. This produces wrong numeric results.","vague_description":"Computed values are consistently wrong. The computation seems to use subtraction where it should add, or vice versa.","test_cmd":"python -m pytest tests/test_thinking_part.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_thinking_part.py","original":"before_think, content = content[:start_index], content[start_index + len(start_tag) :]","mutated":"before_think, content = content[:start_index], content[start_index - len(start_tag) :]","line_num":17},"source":"discovered","category":"thinking","mutation_type":"arithmetic_swap"}
{"task_id":"d-tools-L377-boolean_flip","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In tools.py:377, a boolean operator was swapped: 'self.name = name or function.__name__' became 'self.name = name and function.__name__'. This changes the logical condition.","vague_description":"A logical condition evaluates to the opposite of what it should. The system does the wrong thing when a condition is true vs false.","test_cmd":"python -m pytest tests/test_tools.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/tools.py","original":"self.name = name or function.__name__","mutated":"self.name = name and function.__name__","line_num":377},"source":"discovered","category":"tools","mutation_type":"boolean_flip"}
{"task_id":"d-app-L80-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In app.py:80, a condition was inverted: 'if isinstance(html_source, Path):' became 'if not isinstance(html_source, Path):'. The branch now triggers in the opposite case.","vague_description":"Logic seems backwards. An operation that should run only in certain cases runs in the opposite cases instead.","test_cmd":"python -m pytest tests/test_ui_web.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/ui/_web/app.py","original":"if isinstance(html_source, Path):","mutated":"if not isinstance(html_source, Path):","line_num":80},"source":"discovered","category":"ui","mutation_type":"condition_inversion"}
{"task_id":"d-usage-L373-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In usage.py:373, a None check was inverted: 'if self.input_tokens_limit is not None and input_tokens > self.input_tokens_limit:' became 'if self.input_tokens_limit is None and input_tokens > self.input_tokens_limit:'. This reverses when the value is considered present vs absent.","vague_description":"Optional configuration is being ignored. When I explicitly set a value, the system behaves as if it's not set, and when I don't set it, the system acts like it is.","test_cmd":"python -m pytest tests/test_usage_limits.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/usage.py","original":"if self.input_tokens_limit is not None and input_tokens > self.input_tokens_limit:","mutated":"if self.input_tokens_limit is None and input_tokens > self.input_tokens_limit:","line_num":373},"source":"discovered","category":"usage","mutation_type":"none_check_swap"}
{"task_id":"d-utils-L212-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _utils.py:212, a None check was inverted: 'if group_start_time is None:' became 'if group_start_time is not None:'. This reverses when the value is considered present vs absent.","vague_description":"A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.","test_cmd":"python -m pytest tests/test_utils.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_utils.py","original":"if group_start_time is None:","mutated":"if group_start_time is not None:","line_num":212},"source":"discovered","category":"utils","mutation_type":"none_check_swap"}
{"task_id":"d-concurrency-L222-constant_mutation","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In concurrency.py:222, a constant was changed: 'self._waiting_count -= 1' became 'self._waiting_count -= 0'. This shifts a boundary or default.","vague_description":"A default value or configuration constant seems wrong. The system uses a different threshold or limit than what's documented.","test_cmd":"python -m pytest tests/test_concurrency.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/concurrency.py","original":"self._waiting_count -= 1","mutated":"self._waiting_count -= 0","line_num":222},"source":"discovered","category":"concurrency","mutation_type":"constant_mutation"}
{"task_id":"d-direct-L320-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In direct.py:320, a condition was inverted: 'elif isinstance(item, Exception):' became 'elif not isinstance(item, Exception):'. The branch now triggers in the opposite case.","vague_description":"A guard clause or check does the opposite of what it should. The happy path and error path are swapped.","test_cmd":"python -m pytest tests/test_direct.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/direct.py","original":"elif isinstance(item, Exception):","mutated":"elif not isinstance(item, Exception):","line_num":320},"source":"discovered","category":"direct_api","mutation_type":"condition_inversion"}
{"task_id":"d-exceptions-L147-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In exceptions.py:147, a None check was inverted: 'if body is None:' became 'if body is not None:'. This reverses when the value is considered present vs absent.","vague_description":"Setting a value to None should disable something, but it has no effect. Or leaving it unset activates behavior that shouldn't be there.","test_cmd":"python -m pytest tests/test_exceptions.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/exceptions.py","original":"if body is None:","mutated":"if body is not None:","line_num":147},"source":"discovered","category":"exceptions","mutation_type":"none_check_swap"}
{"task_id":"d-json_schema-L109-none_check_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _json_schema.py:109, a None check was inverted: 'elif type_ is None:' became 'elif type_ is not None:'. This reverses when the value is considered present vs absent.","vague_description":"A feature that should be disabled when not configured is always active, or vice versa. The None/not-None check seems inverted.","test_cmd":"python -m pytest tests/test_json_schema.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_json_schema.py","original":"elif type_ is None:","mutated":"elif type_ is not None:","line_num":109},"source":"discovered","category":"json_schema","mutation_type":"none_check_swap"}
{"task_id":"d-messages-L165-condition_inversion","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In messages.py:165, a condition was inverted: 'if isinstance(identifier, str):' became 'if not isinstance(identifier, str):'. The branch now triggers in the opposite case.","vague_description":"A conditional branch is inverted. The code takes the 'if' path when it should take the 'else' path, and vice versa.","test_cmd":"python -m pytest tests/test_messages.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/messages.py","original":"if isinstance(identifier, str):","mutated":"if not isinstance(identifier, str):","line_num":165},"source":"discovered","category":"messages","mutation_type":"condition_inversion"}
{"task_id":"d-parts_manager-L135-comparison_swap","repo_path":"/Users/akshankrithick/projects/pydantic-ai","repo_url":"https://github.com/pydantic/pydantic-ai","commit":"69a578a1e1012e0241d15321e45ab978962ed0d7","setup_cmd":"pip install -e pydantic_graph && pip install -e 'pydantic_ai_slim[test]' && pip install inline-snapshot","description":"In _parts_manager.py:135, the comparison operator was changed: 'if content == thinking_tags[1]:' became 'if content != thinking_tags[1]:'. This alters the boundary condition.","vague_description":"A numeric check is behaving unexpectedly at the boundary. Values exactly at the threshold are handled incorrectly.","test_cmd":"python -m pytest tests/test_parts_manager.py -x","in_place":true,"timeout":60,"mutation":{"file":"pydantic_ai_slim/pydantic_ai/_parts_manager.py","original":"if content == thinking_tags[1]:","mutated":"if content != thinking_tags[1]:","line_num":135},"source":"discovered","category":"parts_manager","mutation_type":"comparison_swap"}
