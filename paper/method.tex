% Budgeted Context Assembly: Method Section
% Standalone compilable fragment â€” include in your main paper via \input{method}

\section{Method}\label{sec:method}

We formalize the problem of assembling LLM context from a code knowledge graph
under a token budget and dependency constraints, then present a greedy algorithm
with a bounded approximation ratio.

% --------------------------------------------------------------------------
\subsection{Problem Formulation}\label{sec:formulation}

Let $G = (V, E)$ be a directed code knowledge graph where each node $v \in V$
represents a code symbol (function, class, method, constant) and each edge
$(u, v, k) \in E$ carries a type $k \in \mathcal{K}$ (e.g., \textsc{calls},
\textsc{inherits}, \textsc{imports}, \textsc{contains}).

Given:
\begin{itemize}
  \item A natural-language task description $\tau$,
  \item A seed set $S \subseteq V$ extracted from $\tau$ via entity recognition,
  \item A token cost function $c : V \to \mathbb{Z}^+$ (lines $\times$ chars-per-token),
  \item A token budget $B \in \mathbb{Z}^+$,
\end{itemize}

\noindent we seek a subset $X \subseteq V$ that maximizes a utility function
$f(X)$ subject to budget and dependency constraints:

\begin{equation}\label{eq:objective}
  \max_{X \subseteq V} \; f(X) = \sum_{v \in X} u(v \mid X)
  \quad \text{s.t.} \quad
  \begin{cases}
    \displaystyle\sum_{v \in X} c(v) \leq B & \text{(budget)} \\[4pt]
    v \in X \implies D(v) \subseteq X & \text{(closure)}
  \end{cases}
\end{equation}

% --------------------------------------------------------------------------
\subsection{Utility Function}\label{sec:utility}

The per-symbol utility decomposes as:

\begin{equation}\label{eq:utility}
  u(v \mid X) = \underbrace{r(v, S)}_{\text{relevance}}
  \cdot \underbrace{w_{\text{kind}}(v)}_{\text{kind weight}}
  \cdot \underbrace{\phi(v, X)}_{\text{coverage}}
\end{equation}

\paragraph{Relevance $r(v, S)$.}
Computed via weighted BFS from the seed set $S$.  For a seed $s \in S$ with
initial score $\sigma_s$, relevance propagates along edge $(u, v, k)$ as:
\begin{equation}
  r(v) = \max_{(u,v,k) \in E} \; r(u) \cdot \alpha_k \cdot w_{\text{kind}}(v)
\end{equation}
where $\alpha_k \in [0, 1]$ is the decay weight for edge type $k$.  Backward
(caller) edges use a reduced decay $0.7 \cdot \alpha_k$.  BFS depth is bounded
by the strategy parameter (1 for \textsc{precise}, 3 for \textsc{smart}, 5 for
\textsc{thorough}).

An alternative expansion uses \emph{personalized PageRank} (PPR) with the seed
set as the personalization vector.  PPR gives a global relevance score that
accounts for the full graph structure, not just local neighborhoods.  Both
expansion methods are available as ablation variants.

\paragraph{Edge weight learning.}
The default edge-type weights $\alpha_k$ are hand-tuned.  Optionally, they can
be learned from the repository's git history: for each edge type $k$, we
estimate $\alpha_k = P(\text{co-change} \mid \text{edge of type } k)$ from the
fraction of edges whose endpoints were modified in the same commit.  We smooth
the learned weight toward the prior via a confidence ramp:
$\hat{\alpha}_k = \min(n_k/50, 1) \cdot \alpha_k^{\text{git}} + (1 -
\min(n_k/50, 1)) \cdot \alpha_k^{\text{prior}}$, where $n_k$ is the number of
sampled edges of type $k$.

\paragraph{Kind weights $w_{\text{kind}}$.}
Fixed multipliers per symbol kind: classes and functions receive $1.0$; methods
$0.9$; interfaces $0.8$; constants $0.5$; imports $0.1$.  These can be disabled
for ablation.

\paragraph{Submodular coverage $\phi(v, X)$.}
Measures the fraction of edges incident to $v$ not yet covered.  We maintain a
set of covered edges $\mathcal{C} \subseteq E$; when a symbol is selected, all
its incident edges are added to $\mathcal{C}$.  Then:
\begin{equation}\label{eq:coverage}
  \phi(v, \mathcal{C}) = \frac{|\{e \in \delta(v) : e \notin \mathcal{C}\}|}
                              {|\delta(v)|}
\end{equation}
where $\delta(v) = \{(v, w) \in E\} \cup \{(w, v) \in E\}$ is the set of
edges incident to $v$ (restricted to symbol-typed endpoints).

This makes $f$ submodular: as more symbols are selected and their edges added
to $\mathcal{C}$, each additional symbol covers fewer new edges.

% --------------------------------------------------------------------------
\subsection{Dependency Closure}\label{sec:closure}

Define the \emph{hard dependency set} $D(v) \subseteq V$ as the transitive
closure of $v$ over edges of type \textsc{inherits} and \textsc{implements},
plus upward \textsc{contains} edges (method $\to$ parent class):

\begin{equation}
  D(v) = \{w \in V : v \rightsquigarrow w \text{ via } \textsc{inherits} \cup
  \textsc{implements} \cup \textsc{contains}^{-1}\}
\end{equation}

The closure constraint $v \in X \implies D(v) \subseteq X$ ensures that
selected symbols are self-contained: a method's parent class and its base
types are always co-included.  This directly affects downstream LLM
correctness---without closure, the model may see a method referencing an
undefined base class.

% --------------------------------------------------------------------------
\subsection{Algorithm}\label{sec:algorithm}

Algorithm~\ref{alg:bca} describes the full pipeline.

\begin{algorithm}[t]
\caption{Budgeted Context Assembly (BCA)}\label{alg:bca}
\begin{algorithmic}[1]
\Require Task $\tau$, graph $G = (V, E)$, budget $B$
\Ensure Selected set $X$ with $\sum_{v \in X} c(v) \leq B$ and $D(v) \subseteq X \;\forall v \in X$

\State $S \gets \textsc{ExtractEntities}(\tau)$ \Comment{regex: CamelCase, snake\_case, paths}
\State $\text{seeds} \gets \textsc{FindSeeds}(S, G)$ \Comment{match entities to graph nodes}
\State $C \gets \textsc{WeightedBFS}(\text{seeds}, G)$ \Comment{expand candidates with relevance scores}
\State $D(\cdot) \gets \textsc{ComputeClosures}(C, G)$ \Comment{transitive hard deps}

\State $X \gets \emptyset$, $\text{covered} \gets \emptyset$

\For{$v \in C$ sorted by $u(v) / c_{\text{eff}}(v)$ descending}
  \State $c_{\text{eff}}(v) \gets c(v) + \sum_{d \in D(v) \setminus X} c(d)$
  \Comment{effective cost includes unselected deps}
  \If{$c_{\text{eff}}(v) > B - \sum_{x \in X} c(x)$}
    \State \textbf{continue}
  \EndIf
  \If{$\phi(v, X) < \epsilon$ \textbf{and} $\text{depth}(v) > 1$}
    \State \textbf{continue} \Comment{skip low-marginal-gain symbols}
  \EndIf
  \State $X \gets X \cup \{v\} \cup D(v)$
  \State $\text{covered} \gets \text{covered} \cup \text{edges}(v)$
\EndFor

\State $X \gets \textsc{TopoSort}(X, G)$ \Comment{definitions before usage}
\State \Return $X$
\end{algorithmic}
\end{algorithm}

\paragraph{Cycle handling.}
If the dependency subgraph contains cycles (e.g., mutual inheritance in legacy
code), we compute strongly connected components (SCCs), condense them into a
DAG, topologically sort the DAG, and order nodes within each SCC by relevance
score.

% --------------------------------------------------------------------------
\subsection{Approximation Guarantee}\label{sec:guarantee}

The coverage function $\phi$ makes the overall utility $f$ submodular
(Proposition~\ref{prop:submodular}).  Under a single knapsack constraint with
submodular objective, the greedy algorithm that selects items by marginal
value-to-cost ratio achieves a $(1 - 1/e) \approx 0.632$ approximation
ratio~\cite{nemhauser1978analysis}.

\begin{proposition}\label{prop:submodular}
$f(X) = \sum_{v \in X} r(v) \cdot w_{\text{kind}}(v) \cdot \phi(v, X)$ is
monotone submodular in $X$.
\end{proposition}

\begin{proof}[Proof sketch]
$\phi(v, X)$ is non-increasing in $|X|$ for fixed $v$: each new element in $X$
can only increase the number of covered edges, reducing $\phi$.  The sum of
non-negative, non-increasing marginal contributions is submodular
by~\cite{krause2014submodular}.
\end{proof}

The dependency closure constraint couples variables (selecting $v$ forces
$D(v)$).  Following~\cite{wolsey1982analysis}, we handle this via effective
cost: $c_{\text{eff}}(v) = c(v) + \sum_{d \in D(v) \setminus X} c(d)$.  This
preserves the greedy ratio when closures are chain-structured
(Corollary 3 in~\cite{wolsey1982analysis}); for general DAG closures, the
bound degrades to $(1 - 1/e) / \max_v |D(v)|$ in the worst case, though
empirically closures are small ($|D(v)| \leq 3$ on average).

% --------------------------------------------------------------------------
\subsection{Complexity}\label{sec:complexity}

Let $n = |V|$, $m = |E|$, $s = |S|$, $d_{\max}$ be the BFS depth bound.

\begin{itemize}
  \item \textbf{Entity extraction}: $O(|\tau|)$ via regex.
  \item \textbf{Seed identification}: $O(s \cdot n)$ via linear scan over graph
    nodes.
  \item \textbf{Weighted BFS}: $O(n + m)$ per depth level, bounded by
    $d_{\max}$.
  \item \textbf{Closure computation}: $O(|C| \cdot m)$ worst case, where $|C|$
    is the candidate set size.  In practice, $|D(v)|$ is small and closure
    computation is fast.
  \item \textbf{Greedy selection}: $O(|C| \log |C|)$ for sorting, $O(|C|
    \cdot \bar{d})$ for coverage updates where $\bar{d}$ is average degree.
  \item \textbf{Topological sort}: $O(|X| + m_X)$ where $m_X$ is the edge
    count in the selected subgraph.
\end{itemize}

Total: $O(|C| \cdot m)$, dominated by closure computation.  With optional C++
acceleration (pybind11), BFS and closure are $2$--$5\times$ faster.

% --------------------------------------------------------------------------
\subsection{Ablation Controls}\label{sec:ablation}

Each scoring component can be independently toggled via an
\texttt{AblationConfig}:

\begin{center}
\begin{tabular}{ll}
\toprule
\textbf{Component} & \textbf{What it controls} \\
\midrule
\texttt{dependency\_closure} & Enforce $D(v) \subseteq X$ constraint \\
\texttt{submodular\_coverage} & Diminishing returns via $\phi(v, X)$ \\
\texttt{centrality\_scoring} & Degree-based importance boost \\
\texttt{file\_proximity} & Bonus for symbols co-located with seeds \\
\texttt{kind\_weights} & Symbol-type multipliers $w_{\text{kind}}$ \\
\texttt{dependency\_ordering} & Topological sort of output \\
\texttt{learned\_weights} & Git-history edge weight learning \\
\texttt{use\_pagerank} & Personalized PageRank expansion \\
\bottomrule
\end{tabular}
\end{center}

Disabling all components reduces BCA to relevance-only greedy knapsack.
