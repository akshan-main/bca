\section{Introduction}\label{sec:introduction}

Code-generation models operate within a finite context window.  When a
developer asks an LLM to fix a bug or add a feature, the model must receive
enough source code to understand the task, but not so much that it exceeds its
token budget or drowns the relevant symbols in noise.  Selecting which code to
include is currently left to ad-hoc heuristics: grep for keywords, concatenate
matching files, and truncate at the limit.

This paper formalizes the problem of \emph{budgeted context assembly}: given a
code knowledge graph, a natural-language task, and a token budget, select a
subset of code symbols that maximizes relevance while respecting the budget and
ensuring that selected symbols are self-contained (dependency closure).  We
cast this as constrained submodular maximization and present a greedy algorithm
with a bounded approximation ratio.

The key constraints that distinguish budgeted context assembly from standard
retrieval are:

\begin{enumerate}
  \item \textbf{Token budget.}  The total cost of selected symbols must not
    exceed a fixed limit.  Violating this constraint means the context cannot
    be sent to the model.
  \item \textbf{Dependency closure.}  If a method is selected, its parent
    class and base types must also be included.  Without this, the model sees
    references to undefined symbols and cannot reason about the code.
  \item \textbf{Diminishing returns.}  Selecting many symbols from the same
    module adds less information than covering diverse parts of the codebase.
\end{enumerate}

We implement this algorithm in \textsc{CeGraph}, a tool that builds a
multi-language code knowledge graph (via tree-sitter parsing) and assembles
context for LLM coding tasks.  On infrastructure metrics across 12 coding
tasks at 4 budget levels:

\begin{itemize}
  \item BCA enforces the token budget on all tasks (0 violations), while
    graph traversal without closure violates the budget on 92\% of tasks.
  \item Dependency closure is the single most impactful component: disabling it
    alone causes systematic budget overruns.
\end{itemize}

We also provide an end-to-end benchmark harness with 8 mutation-based
bug-fixing tasks: the harness assembles context, calls an LLM, applies the
generated patch, and runs tests.  The harness and all evaluation code are
released for reproducibility.

The contribution is the formalization, implementation, and evaluation
infrastructure---not a claim of superior retrieval quality over lexical
methods.  BCA provides a principled framework for token-constrained code
selection with formal guarantees on budget adherence and dependency
completeness.
