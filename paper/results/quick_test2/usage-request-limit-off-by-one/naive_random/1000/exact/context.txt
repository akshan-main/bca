# pydantic_ai_slim/pydantic_ai/embeddings/wrapper.py:5-5
from typing import TYPE_CHECKING

# examples/pydantic_ai_examples/flight_booking.py:14-21
from pydantic_ai import (
    Agent,
    ModelMessage,
    ModelRetry,
    RunContext,
    RunUsage,
    UsageLimits,
)

# pydantic_ai_slim/pydantic_ai/output.py:3-3
from collections.abc import Awaitable, Callable, Sequence

# tests/test_prefect.py:1003-1003
dynamic_agent = Agent(name='dynamic_agent', model=test_model, deps_type=ToggleableDeps)

# pydantic_evals/pydantic_evals/otel/span_tree.py:172-176
    def find_descendants(
        self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None
    ) -> list[SpanNode]:
        """Return all descendant nodes that satisfy the given predicate in DFS order."""
        return list(self._filter_descendants(predicate, stop_recursing_when))

# pydantic_ai_slim/pydantic_ai/models/groq.py:14-14
from .._output import DEFAULT_OUTPUT_TOOL_NAME, OutputObjectDefinition

# pydantic_graph/pydantic_graph/beta/graph_builder.py:20-20
from pydantic_graph._utils import UNSET, Unset

# pydantic_ai_slim/pydantic_ai/providers/gateway.py:114-114
UpstreamProvider = ModelProvider | APIFlavor

# tests/graph/beta/test_graph_builder.py:255-271
async def test_duplicate_node_ids_error():
    """Test that duplicate node IDs raise a ValueError."""
    g = GraphBuilder(state_type=SimpleState, output_type=int)

    @g.step(node_id='duplicate_id')
    async def step_one(ctx: StepContext[SimpleState, None, None]) -> int:
        return 1  # pragma: no cover

    @g.step(node_id='duplicate_id')
    async def step_two(ctx: StepContext[SimpleState, None, None]) -> int:
        return 2  # pragma: no cover

    with pytest.raises(GraphBuildingError, match='All nodes must have unique node IDs'):
        g.add(
            g.edge_from(g.start_node).to(step_one),
            g.edge_from(g.start_node).to(step_two),
        )

# pydantic_ai_slim/pydantic_ai/output.py:76-133
class ToolOutput(Generic[OutputDataT]):
    """Marker class to use a tool for output and optionally customize the tool.

    Example:
    ```python {title="tool_output.py"}
    from pydantic import BaseModel

    from pydantic_ai import Agent, ToolOutput


    class Fruit(BaseModel):
        name: str
        color: str


    class Vehicle(BaseModel):
        name: str
        wheels: int


    agent = Agent(
        'openai:gpt-5.2',
        output_type=[
            ToolOutput(Fruit, name='return_fruit'),
            ToolOutput(Vehicle, name='return_vehicle'),
        ],
    )
    result = agent.run_sync('What is a banana?')
    print(repr(result.output))
    #> Fruit(name='banana', color='yellow')
    ```
    """

    output: OutputTypeOrFunction[OutputDataT]
    """An output type or function."""
    name: str | None
    """The name of the tool that will be passed to the model. If not specified and only one output is provided, `final_result` will be used. If multiple outputs are provided, the name of the output type or function will be added to the tool name."""
    description: str | None
    """The description of the tool that will be passed to the model. If not specified, the docstring of the output type or function will be used."""
    max_retries: int | None
    """The maximum number of retries for the tool."""
    strict: bool | None
    """Whether to use strict mode for the tool."""

    def __init__(
        self,
        type_: OutputTypeOrFunction[OutputDataT],
        *,
        name: str | None = None,
        description: str | None = None,
        max_retries: int | None = None,
        strict: bool | None = None,
    ):
        self.output = type_
        self.name = name
        self.description = description
        self.max_retries = max_retries
        self.strict = strict

# pydantic_ai_slim/pydantic_ai/agent/__init__.py:151-151
    _output_schema: _output.OutputSchema[OutputDataT] = dataclasses.field(repr=False)

# pydantic_ai_slim/pydantic_ai/models/huggingface.py:528-530
    def timestamp(self) -> datetime:
        """Get the timestamp of the response."""
        return self._timestamp

# tests/graph/beta/test_edge_cases.py:5-5
from dataclasses import dataclass, field

# pydantic_ai_slim/pydantic_ai/_agent_graph.py:834-834
    final_result: result.FinalResult[NodeRunEndT]