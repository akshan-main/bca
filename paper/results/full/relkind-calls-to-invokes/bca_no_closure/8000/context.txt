# Codebase Context for: Function call edges in the graph use kind 'invokes' instead of 'calls'. The RelKind.CALLS enum value was changed, so all call graph queries (who_calls, what_calls) return empty results.
# 123 symbols from 24 files (~8,697 tokens, 109% of budget)

## src/cegraph/cli.py
# Included because: graph expansion (depth 2); graph expansion (depth 1); matches 'who_calls'

# [function] _get_project_root (relevance: 1.18, depth: 1)
  28 | def _get_project_root(path: str | None = None) -> Path:
  29 |     """Find the project root or error."""
  30 |     if path:
  31 |         root = Path(path).resolve()
  32 |         if not root.exists():
  33 |             console.error(f"Path does not exist: {path}")
  34 |             sys.exit(1)
  35 |         return root
  36 | 
  37 |     root = find_project_root()
  38 |     if root is None:
  39 |         console.error(
  40 |             "No CeGraph project found. Run 'cegraph init' first, "
  41 |             "or specify a path with --path."
  42 |         )
  43 |         sys.exit(1)
  44 |     return root

# [function] _load_graph (relevance: 1.16, depth: 1)
  47 | def _load_graph(root: Path):
  48 |     """Load the knowledge graph and related objects."""
  49 |     from cegraph.graph.store import GraphStore
  50 | 
  51 |     db_path = get_cegraph_dir(root) / GRAPH_DB_FILE
  52 |     store = GraphStore(db_path)
  53 |     graph = store.load()
  54 |     if graph is None:
  55 |         console.error("No index found. Run 'cegraph init' or 'cegraph reindex' first.")
  56 |         sys.exit(1)
  57 |     return graph, store

# [function] main (relevance: 0.20, depth: 2)
  62 | def main():
  63 |     """CeGraph - AI that actually understands your entire codebase."""
  64 |     pass

# [function] reindex (relevance: 0.61, depth: 2)
 100 | def reindex(path: str | None):
 101 |     """Rebuild the knowledge graph from scratch."""
 102 |     root = _get_project_root(path)
 103 |     config = load_config(root)
 104 |     _do_index(root, config)

# [function] who_calls (relevance: 1.32, depth: 0)
 202 | def who_calls(symbol_name: str, path: str | None, depth: int):
 203 |     """Find all callers of a function or method."""
 204 |     root = _get_project_root(path)
 205 |     graph, store = _load_graph(root)
 206 | 
 207 |     from cegraph.graph.query import GraphQuery
 208 | 
 209 |     query = GraphQuery(graph, store)
 210 |     callers = query.who_calls(symbol_name, max_depth=depth)
 211 | 
 212 |     if callers:
 213 |         console.info(f"Callers of '{symbol_name}':")
 214 |         console.show_callers(callers, symbol_name)
 215 |     else:
 216 |         console.warning(f"No callers found for '{symbol_name}'")
 217 | 
 218 |     store.close()

# [function] impact (relevance: 0.67, depth: 2)
 224 | def impact(symbol_name: str, path: str | None):
 225 |     """Analyze the blast radius of changing a symbol."""
 226 |     root = _get_project_root(path)
 227 |     graph, store = _load_graph(root)
 228 | 
 229 |     from cegraph.graph.query import GraphQuery
 230 | 
 231 |     query = GraphQuery(graph, store)
 232 |     result = query.impact_of(symbol_name)
 233 |     console.show_impact(result)
 234 | 
 235 |     store.close()

# [function] ask (relevance: 0.63, depth: 2)
 504 | def ask(question: str, path: str | None):
 505 |     """Ask a question about the codebase (uses LLM + knowledge graph)."""
 506 |     root = _get_project_root(path)
 507 |     config = load_config(root)
 508 |     graph, store = _load_graph(root)
 509 | 
 510 |     _run_agent(root, config, graph, store, question, agent_mode=False)

# [function] agent (relevance: 0.63, depth: 2)
 517 | def agent(task: str, path: str | None, auto: bool):
 518 |     """Run an agentic task (coding, debugging, refactoring)."""
 519 |     root = _get_project_root(path)
 520 |     config = load_config(root)
 521 |     graph, store = _load_graph(root)
 522 | 
 523 |     _run_agent(root, config, graph, store, task, agent_mode=True, auto_approve=auto)

## src/cegraph/context/_native.py
# Included because: graph expansion (depth 3)

# [method] NativeCAG.is_available (relevance: 0.30, depth: 3)
 160 |     def is_available() -> bool:
 161 |         """Check if the native C++ library is available."""
 162 |         return _load_library() is not None

# [method] NativeGraph.add_edge (relevance: 0.60, depth: 3)
 229 |     def add_edge(self, src: int, dst: int, weight: float) -> None:
 230 |         self._lib.cag_graph_add_edge(self._handle, src, dst, weight)

# [method] NativeGraph.set_node_weight (relevance: 0.29, depth: 3)
 232 |     def set_node_weight(self, node: int, weight: float) -> None:
 233 |         self._lib.cag_graph_set_node_weight(self._handle, node, weight)

# [method] NativeGraph.set_lines (relevance: 0.29, depth: 3)
 235 |     def set_lines(self, node: int, start: int, end: int) -> None:
 236 |         self._lib.cag_graph_set_lines(self._handle, node, start, end)

## src/cegraph/context/engine.py
# Included because: graph expansion (depth 2)

# [method] ContextAssembler._token_cost (relevance: 0.40, depth: 2)
 898 |     def _token_cost(self, symbol_id: str, cand: dict | None = None) -> int:
 899 |         """Compute token cost c(v) for a symbol."""
 900 |         data = self.graph.nodes.get(symbol_id, {})
 901 |         line_start = data.get("line_start", 0)
 902 |         line_end = data.get("line_end", 0)
 903 |         line_count = max(1, line_end - line_start + 1)
 904 |         return TokenEstimator.estimate_lines(line_count)

## src/cegraph/context/models.py
# Included because: graph expansion (depth 3)

# [method] TokenEstimator.estimate (relevance: 0.47, depth: 3)
 166 |     def estimate(cls, text: str) -> int:
 167 |         """Estimate token count for a string."""
 168 |         return max(1, int(len(text) / cls.CHARS_PER_TOKEN))

# [method] TokenEstimator.estimate_lines (relevance: 0.39, depth: 3)
 171 |     def estimate_lines(cls, line_count: int, avg_line_length: int = 40) -> int:
 172 |         """Estimate tokens for a given number of lines."""
 173 |         return max(1, int(line_count * avg_line_length / cls.CHARS_PER_TOKEN))

## src/cegraph/github/diff_parser.py
# Included because: graph expansion (depth 2)

# [function] get_pr_diff (relevance: 0.51, depth: 2)
 205 | def get_pr_diff(root: Path) -> str:
 206 |     """Get the diff for the current PR (GitHub Actions context)."""
 207 |     import os
 208 |     base_ref = os.environ.get("GITHUB_BASE_REF", "main")
 209 |     return get_git_diff(root, base=f"origin/{base_ref}")

## src/cegraph/github/renderer.py
# Included because: graph expansion (depth 3)

# [function] _footer (relevance: 0.32, depth: 3)
 192 | def _footer() -> str:
 193 |     return (
 194 |         "---\n"
 195 |         "*Powered by [CeGraph](https://github.com/cegraph-ai/cegraph) "
 196 |         "— CAG-driven code intelligence*"
 197 |     )

## src/cegraph/graph/query.py
# Included because: matches 'what_calls'; graph expansion (depth 2); graph expansion (depth 1); matches 'who_calls'

# [method] GraphQuery.__init__ (relevance: 0.35, depth: 2)
  38 |     def __init__(self, graph: nx.DiGraph, store: GraphStore | None = None) -> None:
  39 |         self.graph = graph
  40 |         self.store = store
  41 |         self._name_index: dict[str, list[str]] = {}
  42 |         self._build_index()

# [method] GraphQuery.find_symbol (relevance: 1.00, depth: 1)
  56 |     def find_symbol(self, name: str) -> list[str]:
  57 |         """Find symbol node IDs matching a name (exact or qualified)."""
  58 |         results = self._name_index.get(name, [])
  59 |         if not results:
  60 |             # Try partial match
  61 |             for key, ids in self._name_index.items():
  62 |                 if name.lower() in key.lower():
  63 |                     results.extend(ids)
  64 |         return list(set(results))

# [method] GraphQuery.who_calls (relevance: 1.04, depth: 0)
 122 |     def who_calls(self, name: str, max_depth: int = 1) -> list[dict]:
 123 |         """Find all callers of a symbol, optionally going N levels deep.
 124 | 
 125 |         Returns list of {symbol_id, name, file_path, line, depth}
 126 |         """
 127 |         symbol_ids = self.find_symbol(name)
 128 |         if not symbol_ids:
 129 |             return []
 130 | 
 131 |         results = []
 132 |         visited = set()
 133 | 
 134 |         def _traverse(node_id: str, depth: int) -> None:
 135 |             if depth > max_depth or node_id in visited:
 136 |                 return
 137 |             visited.add(node_id)
 138 | 
 139 |             for pred in self.graph.predecessors(node_id):
 140 |                 edge_data = self.graph.edges[pred, node_id]
 141 |                 if edge_data.get("kind") != "calls":
 142 |                     continue
 143 |                 pred_data = self.graph.nodes.get(pred, {})
 144 |                 if pred_data.get("type") != "symbol":
 145 |                     continue
 146 | 
 147 |                 results.append({
 148 |                     "symbol_id": pred,
 149 |                     "name": pred_data.get("qualified_name", pred_data.get("name", "")),
 150 |                     "kind": pred_data.get("kind", ""),
 151 |                     "file_path": pred_data.get("file_path", ""),
 152 |                     "line": pred_data.get("line_start", 0),
 153 |                     "depth": depth,
 154 |                 })
 155 |                 _traverse(pred, depth + 1)
 156 | 
 157 |         for sid in symbol_ids:
 158 |             _traverse(sid, 1)
 159 | 
 160 |         return results

# [method] GraphQuery.what_calls (relevance: 1.06, depth: 0)
 162 |     def what_calls(self, name: str) -> list[dict]:
 163 |         """Find all symbols called by the given symbol."""
 164 |         symbol_ids = self.find_symbol(name)
 165 |         results = []
 166 | 
 167 |         for sid in symbol_ids:
 168 |             for succ in self.graph.successors(sid):
 169 |                 edge_data = self.graph.edges[sid, succ]
 170 |                 if edge_data.get("kind") != "calls":
 171 |                     continue
 172 |                 succ_data = self.graph.nodes.get(succ, {})
 173 |                 if succ_data.get("type") != "symbol":
 174 |                     continue
 175 |                 results.append({
 176 |                     "symbol_id": succ,
 177 |                     "name": succ_data.get("qualified_name", succ_data.get("name", "")),
 178 |                     "kind": succ_data.get("kind", ""),
 179 |                     "file_path": succ_data.get("file_path", ""),
 180 |                     "line": succ_data.get("line_start", 0),
 181 |                 })
 182 | 
 183 |         return results

## src/cegraph/graph/store.py
# Included because: graph expansion (depth 1); graph expansion (depth 3)

# [method] GraphStore.__init__ (relevance: 0.25, depth: 3)
  24 |     def __init__(self, db_path: str | Path) -> None:
  25 |         self.db_path = Path(db_path)
  26 |         self._conn: sqlite3.Connection | None = None

# [method] GraphStore._get_conn (relevance: 0.68, depth: 3)
  28 |     def _get_conn(self) -> sqlite3.Connection:
  29 |         if self._conn is None:
  30 |             self.db_path.parent.mkdir(parents=True, exist_ok=True)
  31 |             self._conn = sqlite3.connect(str(self.db_path))
  32 |             self._conn.row_factory = sqlite3.Row
  33 |             self._conn.execute("PRAGMA journal_mode=WAL")
  34 |             self._create_tables()
  35 |         return self._conn

# [method] GraphStore.get_metadata (relevance: 0.47, depth: 3)
 491 |     def get_metadata(self, key: str) -> str | None:
 492 |         """Get a metadata value."""
 493 |         conn = self._get_conn()
 494 |         row = conn.execute("SELECT value FROM metadata WHERE key = ?", (key,)).fetchone()
 495 |         if row:
 496 |             return json.loads(row["value"])
 497 |         return None

# [method] GraphStore.close (relevance: 0.91, depth: 1)
 499 |     def close(self) -> None:
 500 |         """Close the database connection."""
 501 |         if self._conn:
 502 |             self._conn.close()
 503 |             self._conn = None

## src/cegraph/llm/base.py
# Included because: matches 'calls'

# [method] LLMResponse.has_tool_calls (relevance: 0.78, depth: 0)
  55 |     def has_tool_calls(self) -> bool:
  56 |         return len(self.tool_calls) > 0

## src/cegraph/map/app.py
# Included because: graph expansion (depth 3)

# [function] launch_map (relevance: 0.42, depth: 3)
 397 | def launch_map(root: Path, graph, query) -> None:
 398 |     """Launch the Live Code Map TUI."""
 399 |     check_textual()
 400 |     app = CodeMapApp(root=root, graph=graph, query=query)
 401 |     app.run()

## src/cegraph/mcp/server.py
# Included because: graph expansion (depth 1); graph expansion (depth 2); graph expansion (depth 3); matches 'calls'

# [method] MCPServer._tool_who_calls (relevance: 0.86, depth: 0)
 269 |     def _tool_who_calls(self, args: dict) -> str:
 270 |         self._ensure_graph()
 271 |         callers = self._query.who_calls(
 272 |             args["symbol"], max_depth=args.get("max_depth", 3)
 273 |         )
 274 |         if not callers:
 275 |             return f"No callers found for '{args['symbol']}'"
 276 | 
 277 |         lines = [f"Callers of '{args['symbol']}':"]
 278 |         for c in callers:
 279 |             indent = "  " * c.get("depth", 1)
 280 |             lines.append(f"{indent}{c['name']} ({c['kind']}) at {c['file_path']}:{c['line']}")
 281 |         return "\n".join(lines)

# [method] MCPServer._tool_get_structure (relevance: 0.42, depth: 2)
 308 |     def _tool_get_structure(self, _args: dict) -> str:
 309 |         self._ensure_graph()
 310 |         structure = self._query.get_structure()
 311 | 
 312 |         lines = ["Codebase structure:"]
 313 |         self._render_structure(structure, lines, indent=1)
 314 |         return "\n".join(lines)

# [method] MCPServer._write_message (relevance: 0.39, depth: 3)
 396 |     async def _write_message(self, writer: asyncio.StreamWriter, message: dict) -> None:
 397 |         """Write a JSON-RPC response with Content-Length header."""
 398 |         body = json.dumps(message).encode("utf-8")
 399 |         header = f"Content-Length: {len(body)}\r\n\r\n".encode("utf-8")
 400 |         writer.write(header + body)
 401 |         await writer.drain()

# [method] MCPServer._handle_notification (relevance: 0.53, depth: 2)
 424 |     def _handle_notification(self, method: str, params: dict) -> None:
 425 |         """Handle a notification (no response needed)."""
 426 |         if method == "notifications/initialized":
 427 |             logger.info("Client initialized")
 428 |         elif method == "notifications/cancelled":
 429 |             logger.info(f"Request cancelled: {params.get('requestId')}")

# [method] MCPServer._dispatch (relevance: 0.86, depth: 1)
 431 |     def _dispatch(self, method: str, params: dict) -> Any:
 432 |         """Dispatch a JSON-RPC method to its handler."""
 433 |         if method == "initialize":
 434 |             return self._rpc_initialize(params)
 435 |         elif method == "tools/list":
 436 |             return self._rpc_tools_list(params)
 437 |         elif method == "tools/call":
 438 |             return self._rpc_tools_call(params)
 439 |         elif method == "resources/list":
 440 |             return self._rpc_resources_list(params)
 441 |         elif method == "resources/read":
 442 |             return self._rpc_resources_read(params)
 443 |         elif method == "ping":
 444 |             return {}
 445 |         else:
 446 |             raise ValueError(f"Unknown method: {method}")

# [method] MCPServer._rpc_tools_list (relevance: 0.49, depth: 2)
 462 |     def _rpc_tools_list(self, params: dict) -> dict:
 463 |         """List available tools."""
 464 |         return {"tools": self._tools}

# [method] MCPServer.generate_claude_config (relevance: 0.48, depth: 3)
 528 |     def generate_claude_config(project_path: str | None = None) -> dict:
 529 |         """Generate MCP config for Claude Code (~/.claude/mcp_servers.json)."""
 530 |         return {
 531 |             "cegraph": {
 532 |                 "command": "cegraph",
 533 |                 "args": ["serve", "--transport", "stdio"],
 534 |                 "cwd": project_path or ".",
 535 |             }
 536 |         }

## src/cegraph/parser/models.py
# Included because: matches 'RelKind'; graph expansion (depth 2)

# [class] RelKind (relevance: 1.21, depth: 0)
  25 | class RelKind(str, Enum):
  26 |     """Types of relationships between symbols."""
  27 | 
  28 |     CALLS = "invokes"
  29 |     IMPORTS = "imports"
  30 |     INHERITS = "inherits"
  31 |     IMPLEMENTS = "implements"
  32 |     USES = "uses"
  33 |     CONTAINS = "contains"
  34 |     OVERRIDES = "overrides"
  35 |     DECORATES = "decorates"
  36 |     TYPE_OF = "type_of"

# [function] detect_language (relevance: 0.49, depth: 2)
 100 | def detect_language(file_path: str) -> str | None:
 101 |     """Detect programming language from file extension."""
 102 |     from pathlib import Path
 103 | 
 104 |     ext = Path(file_path).suffix.lower()
 105 |     return EXTENSION_LANGUAGE_MAP.get(ext)

## src/cegraph/parser/python_parser.py
# Included because: graph expansion (depth 1); matches 'calls'

# [function] parse_python_file (relevance: 0.93, depth: 1)
  17 | def parse_python_file(file_path: str, source: str | None = None) -> FileSymbols:
  18 |     """Parse a Python file and extract symbols and relationships."""
  19 |     if source is None:
  20 |         source = Path(file_path).read_text(encoding="utf-8", errors="replace")
  21 | 
  22 |     result = FileSymbols(file_path=file_path, language="python")
  23 | 
  24 |     try:
  25 |         tree = ast.parse(source, filename=file_path)
  26 |     except SyntaxError as e:
  27 |         result.errors.append(f"SyntaxError: {e}")
  28 |         return result
  29 | 
  30 |     lines = source.splitlines()
  31 |     _extract_from_module(tree, file_path, lines, result)
  32 |     return result

# [function] _extract_calls (relevance: 0.90, depth: 0)
 286 | def _extract_calls(
 287 |     node: ast.AST, file_path: str, caller_id: str, result: FileSymbols
 288 | ) -> None:
 289 |     """Walk a function body and extract all function calls."""
 290 |     for child in ast.walk(node):
 291 |         if isinstance(child, ast.Call):
 292 |             callee = _node_to_name(child.func)
 293 |             if callee:
 294 |                 result.relationships.append(
 295 |                     Relationship(
 296 |                         source=caller_id,
 297 |                         target=callee,
 298 |                         kind=RelKind.CALLS,
 299 |                         file_path=file_path,
 300 |                         line=child.lineno if hasattr(child, "lineno") else 0,
 301 |                     )
 302 |                 )

# [function] _node_to_name (relevance: 0.82, depth: 1)
 305 | def _node_to_name(node: ast.AST) -> str:
 306 |     """Convert an AST node to a dotted name string."""
 307 |     if isinstance(node, ast.Name):
 308 |         return node.id
 309 |     elif isinstance(node, ast.Attribute):
 310 |         parent = _node_to_name(node.value)
 311 |         if parent:
 312 |             return f"{parent}.{node.attr}"
 313 |         return node.attr
 314 |     elif isinstance(node, ast.Subscript):
 315 |         return _node_to_name(node.value)
 316 |     return ""

## src/cegraph/parser/tree_sitter_parser.py
# Included because: graph expansion (depth 2); matches 'calls'

# [function] _extract_ts_calls (relevance: 0.92, depth: 0)
 220 | def _extract_ts_calls(
 221 |     node, file_path: str, language: str, source: bytes,
 222 |     caller_id: str, call_types: list[str], result: FileSymbols
 223 | ) -> None:
 224 |     """Extract function calls from a tree-sitter node."""
 225 |     if node.type in call_types:
 226 |         # Get the function being called
 227 |         func_node = node.child_by_field_name("function")
 228 |         if func_node is None and node.children:
 229 |             func_node = node.children[0]
 230 |         if func_node:
 231 |             callee = func_node.text.decode("utf-8")
 232 |             # Clean up multiline callees
 233 |             callee = callee.split("(")[0].strip()
 234 |             if callee and len(callee) < 100:
 235 |                 result.relationships.append(
 236 |                     Relationship(
 237 |                         source=caller_id,
 238 |                         target=callee,
 239 |                         kind=RelKind.CALLS,
 240 |                         file_path=file_path,
 241 |                         line=node.start_point[0] + 1,
 242 |                     )
 243 |                 )
 244 |         return
 245 | 
 246 |     for child in node.children:
 247 |         _extract_ts_calls(child, file_path, language, source, caller_id, call_types, result)

# [function] _extract_ts_import (relevance: 0.45, depth: 2)
 250 | def _extract_ts_import(node, file_path: str, source: bytes, result: FileSymbols) -> None:
 251 |     """Extract import information from a tree-sitter node."""
 252 |     text = node.text.decode("utf-8")
 253 |     result.imports.append(text)

## src/cegraph/tools/definitions.py
# Included because: matches 'what_calls'; graph expansion (depth 3); matches 'who_calls'; graph expansion (depth 2)

# [method] CeGraphTools.who_calls (relevance: 1.02, depth: 0)
  77 |     def who_calls(self, symbol_name: str, max_depth: int = 2) -> str:
  78 |         """Find all callers of a function/method."""
  79 |         results = self.query.who_calls(symbol_name, max_depth=max_depth)
  80 |         if not results:
  81 |             return f"No callers found for '{symbol_name}'"
  82 | 
  83 |         output = [f"Callers of `{symbol_name}`:"]
  84 |         for r in results:
  85 |             indent = "  " * r["depth"]
  86 |             output.append(
  87 |                 f"{indent}← **{r['name']}** ({r['kind']}) at {r['file_path']}:{r['line']}"
  88 |             )
  89 |         return "\n".join(output)

# [method] CeGraphTools.what_calls (relevance: 1.02, depth: 0)
  91 |     def what_calls(self, symbol_name: str) -> str:
  92 |         """Find all symbols called by a function/method."""
  93 |         results = self.query.what_calls(symbol_name)
  94 |         if not results:
  95 |             return f"No callees found for '{symbol_name}'"
  96 | 
  97 |         output = [f"`{symbol_name}` calls:"]
  98 |         for r in results:
  99 |             output.append(
 100 |                 f"→ **{r['name']}** ({r['kind']}) at {r['file_path']}:{r['line']}"
 101 |             )
 102 |         return "\n".join(output)

# [method] CeGraphTools.get_structure (relevance: 0.38, depth: 3)
 220 |     def get_structure(self, path: str = "") -> str:
 221 |         """Get the project structure with symbol counts."""
 222 |         structure = self.query.get_structure(path)
 223 |         return json.dumps(structure, indent=2) if structure else "No structure data"

# [function] get_tool_definitions (relevance: 0.18, depth: 2)
 468 | def get_tool_definitions() -> list[ToolDefinition]:
 469 |     """Get all built-in tool definitions."""
 470 |     return _TOOL_DEFINITIONS.copy()

## src/cegraph/tools/registry.py
# Included because: graph expansion (depth 2); graph expansion (depth 1); graph expansion (depth 3)

# [method] ToolRegistry.__init__ (relevance: 0.21, depth: 3)
  17 |     def __init__(self) -> None:
  18 |         self._tools: dict[str, Callable] = {}
  19 |         self._definitions: dict[str, ToolDefinition] = {}

# [method] ToolRegistry.register (relevance: 0.31, depth: 3)
  21 |     def register(self, func: Callable, definition: ToolDefinition) -> None:
  22 |         """Register a tool function with its definition."""
  23 |         self._tools[definition.name] = func
  24 |         self._definitions[definition.name] = definition

# [method] ToolRegistry.get (relevance: 0.85, depth: 1)
  26 |     def get(self, name: str) -> Callable | None:
  27 |         """Get a tool function by name."""
  28 |         return self._tools.get(name)

# [method] ToolRegistry.get_definition (relevance: 0.35, depth: 2)
  30 |     def get_definition(self, name: str) -> ToolDefinition | None:
  31 |         """Get a tool definition by name."""
  32 |         return self._definitions.get(name)

# [method] ToolRegistry.list_tools (relevance: 0.29, depth: 3)
  34 |     def list_tools(self) -> list[str]:
  35 |         """List all registered tool names."""
  36 |         return list(self._tools.keys())

# [method] ToolRegistry.get_definitions (relevance: 0.23, depth: 3)
  38 |     def get_definitions(self) -> list[ToolDefinition]:
  39 |         """Get all tool definitions (for passing to LLM)."""
  40 |         return list(self._definitions.values())

## src/cegraph/ui/console.py
# Included because: graph expansion (depth 2); graph expansion (depth 1); graph expansion (depth 3)

# [method] Console.__init__ (relevance: 0.25, depth: 3)
  19 |     def __init__(self) -> None:
  20 |         self.console = RichConsole()

# [method] Console.success (relevance: 0.43, depth: 3)
  33 |     def success(self, message: str) -> None:
  34 |         self.console.print(f"[green]✓[/green] {message}")

# [method] Console.error (relevance: 0.78, depth: 2)
  36 |     def error(self, message: str) -> None:
  37 |         self.console.print(f"[red]✗[/red] {message}")

# [method] Console.warning (relevance: 0.75, depth: 1)
  39 |     def warning(self, message: str) -> None:
  40 |         self.console.print(f"[yellow]![/yellow] {message}")

# [method] Console.info (relevance: 0.83, depth: 1)
  42 |     def info(self, message: str) -> None:
  43 |         self.console.print(f"[blue]i[/blue] {message}")

# [method] Console.markdown (relevance: 0.25, depth: 3)
  45 |     def markdown(self, text: str) -> None:
  46 |         """Render markdown text."""
  47 |         self.console.print(Markdown(text))

# [method] Console.code (relevance: 0.25, depth: 3)
  49 |     def code(self, text: str, language: str = "python") -> None:
  50 |         """Render syntax-highlighted code."""
  51 |         self.console.print(Syntax(text, language, theme="monokai", line_numbers=True))

# [method] Console.confirm (relevance: 0.23, depth: 3)
 174 |     def confirm(self, message: str) -> bool:
 175 |         """Ask for user confirmation."""
 176 |         response = self.console.input(f"\n{message} [y/N] ")
 177 |         return response.lower().strip() in ("y", "yes")

## tests/test_cli.py
# Included because: graph expansion (depth 2); matches 'calls'

# [function] runner (relevance: 0.18, depth: 2)
  14 | def runner():
  15 |     return CliRunner()

# [class] TestCLIWhoCalls (relevance: 0.88, depth: 0)
  70 | class TestCLIWhoCalls:
  71 |     def test_who_calls(self, runner: CliRunner, indexed_project: Path):
  72 |         result = runner.invoke(
  73 |             main, ["who-calls", "helper_function", "--path", str(indexed_project)]
  74 |         )
  75 |         assert result.exit_code == 0
  76 | 
  77 |     def test_who_calls_not_found(self, runner: CliRunner, indexed_project: Path):
  78 |         result = runner.invoke(
  79 |             main, ["who-calls", "nonexistent_func", "--path", str(indexed_project)]
  80 |         )
  81 |         assert result.exit_code == 0
  82 |         assert "No callers" in result.output

# [method] TestCLIWhoCalls.test_who_calls (relevance: 0.78, depth: 0)
  71 |     def test_who_calls(self, runner: CliRunner, indexed_project: Path):
  72 |         result = runner.invoke(
  73 |             main, ["who-calls", "helper_function", "--path", str(indexed_project)]
  74 |         )
  75 |         assert result.exit_code == 0

# [method] TestCLIWhoCalls.test_who_calls_not_found (relevance: 0.78, depth: 0)
  77 |     def test_who_calls_not_found(self, runner: CliRunner, indexed_project: Path):
  78 |         result = runner.invoke(
  79 |             main, ["who-calls", "nonexistent_func", "--path", str(indexed_project)]
  80 |         )
  81 |         assert result.exit_code == 0
  82 |         assert "No callers" in result.output

## tests/test_context.py
# Included because: graph expansion (depth 3)

# [function] cag_engine (relevance: 0.32, depth: 3)
  21 | def cag_engine(tmp_project: Path):
  22 |     """Create a context assembler with a built graph."""
  23 |     builder = GraphBuilder()
  24 |     graph = builder.build_from_directory(tmp_project)
  25 |     query = GraphQuery(graph)
  26 |     return ContextAssembler(tmp_project, graph, query)

## tests/test_graph.py
# Included because: graph expansion (depth 2); graph expansion (depth 1); graph expansion (depth 3); matches 'calls'

# [method] TestGraphBuilder.test_build_from_directory (relevance: 0.33, depth: 3)
  16 |     def test_build_from_directory(self, tmp_project: Path):
  17 |         builder = GraphBuilder()
  18 |         graph = builder.build_from_directory(tmp_project)
  19 | 
  20 |         assert graph.number_of_nodes() > 0
  21 |         assert graph.number_of_edges() > 0

# [method] TestGraphBuilder.test_call_edges_exist (relevance: 0.48, depth: 2)
  57 |     def test_call_edges_exist(self, tmp_project: Path):
  58 |         builder = GraphBuilder()
  59 |         graph = builder.build_from_directory(tmp_project)
  60 | 
  61 |         call_edges = [
  62 |             (u, v) for u, v, d in graph.edges(data=True) if d.get("kind") == "calls"
  63 |         ]
  64 |         assert len(call_edges) > 0

# [method] TestGraphBuilder.test_contains_edges_exist (relevance: 0.48, depth: 2)
  66 |     def test_contains_edges_exist(self, tmp_project: Path):
  67 |         builder = GraphBuilder()
  68 |         graph = builder.build_from_directory(tmp_project)
  69 | 
  70 |         contains_edges = [
  71 |             (u, v) for u, v, d in graph.edges(data=True) if d.get("kind") == "contains"
  72 |         ]
  73 |         assert len(contains_edges) > 0

# [method] TestGraphStore.test_metadata (relevance: 0.59, depth: 2)
 142 |     def test_metadata(self, tmp_project: Path, tmp_path: Path):
 143 |         builder = GraphBuilder()
 144 |         graph = builder.build_from_directory(tmp_project)
 145 | 
 146 |         db_path = tmp_path / "test.db"
 147 |         store = GraphStore(db_path)
 148 |         store.save(graph, metadata={"version": "1.0"})
 149 | 
 150 |         assert store.get_metadata("version") == "1.0"
 151 |         store.close()

# [method] TestGraphQuery._build_query (relevance: 0.86, depth: 1)
 155 |     def _build_query(self, tmp_project: Path) -> GraphQuery:
 156 |         builder = GraphBuilder()
 157 |         graph = builder.build_from_directory(tmp_project)
 158 |         return GraphQuery(graph)

# [method] TestGraphQuery.test_find_symbol (relevance: 0.46, depth: 2)
 160 |     def test_find_symbol(self, tmp_project: Path):
 161 |         query = self._build_query(tmp_project)
 162 |         results = query.find_symbol("main")
 163 |         assert len(results) > 0

# [method] TestGraphQuery.test_find_symbol_partial (relevance: 0.46, depth: 2)
 165 |     def test_find_symbol_partial(self, tmp_project: Path):
 166 |         query = self._build_query(tmp_project)
 167 |         results = query.find_symbol("helper")
 168 |         assert len(results) > 0

# [method] TestGraphQuery.test_who_calls (relevance: 0.82, depth: 0)
 170 |     def test_who_calls(self, tmp_project: Path):
 171 |         query = self._build_query(tmp_project)
 172 |         callers = query.who_calls("helper_function")
 173 |         # main() calls helper_function()
 174 |         caller_names = [c["name"] for c in callers]
 175 |         assert any("main" in name for name in caller_names)

# [method] TestGraphQuery.test_what_calls (relevance: 0.82, depth: 0)
 177 |     def test_what_calls(self, tmp_project: Path):
 178 |         query = self._build_query(tmp_project)
 179 |         callees = query.what_calls("main")
 180 |         callee_names = [c["name"] for c in callees]
 181 |         # main() should call several functions
 182 |         assert len(callees) > 0

# [method] TestGraphQuery.test_impact_of (relevance: 0.38, depth: 2)
 184 |     def test_impact_of(self, tmp_project: Path):
 185 |         query = self._build_query(tmp_project)
 186 |         impact = query.impact_of("calculate_total")
 187 |         assert impact["found"] is True
 188 |         assert len(impact["affected_files"]) > 0
 189 |         assert impact["risk_score"] >= 0

# [method] TestGraphQuery.test_impact_not_found (relevance: 0.38, depth: 2)
 191 |     def test_impact_not_found(self, tmp_project: Path):
 192 |         query = self._build_query(tmp_project)
 193 |         impact = query.impact_of("nonexistent_function")
 194 |         assert impact["found"] is False

# [method] TestGraphQuery.test_get_file_symbols (relevance: 0.38, depth: 2)
 196 |     def test_get_file_symbols(self, tmp_project: Path):
 197 |         query = self._build_query(tmp_project)
 198 |         symbols = query.get_file_symbols("main.py")
 199 |         assert len(symbols) > 0
 200 |         names = [s["name"] for s in symbols]
 201 |         assert "main" in names

# [method] TestGraphQuery.test_get_structure (relevance: 0.38, depth: 2)
 203 |     def test_get_structure(self, tmp_project: Path):
 204 |         query = self._build_query(tmp_project)
 205 |         structure = query.get_structure()
 206 |         assert "main.py" in structure or len(structure) > 0

# [method] TestGraphQuery.test_find_related (relevance: 0.38, depth: 2)
 208 |     def test_find_related(self, tmp_project: Path):
 209 |         query = self._build_query(tmp_project)
 210 |         related = query.find_related("calculate_total")
 211 |         assert len(related) > 0

## tests/test_mcp.py
# Included because: graph expansion (depth 2); matches 'calls'

# [method] TestMCPProtocol.test_ping (relevance: 0.36, depth: 2)
  73 |     def test_ping(self, mcp_server: MCPServer):
  74 |         """Test ping response."""
  75 |         result = mcp_server._dispatch("ping", {})
  76 |         assert result == {}

# [method] TestMCPTools.test_search_code (relevance: 0.46, depth: 2)
  93 |     def test_search_code(self, mcp_server: MCPServer):
  94 |         """Test the search_code tool."""
  95 |         result = mcp_server._dispatch("tools/call", {
  96 |             "name": "search_code",
  97 |             "arguments": {"query": "main"},
  98 |         })
  99 |         assert not result.get("isError")
 100 |         content = result["content"][0]["text"]
 101 |         assert "main" in content

# [method] TestMCPTools.test_who_calls (relevance: 0.82, depth: 0)
 103 |     def test_who_calls(self, mcp_server: MCPServer):
 104 |         """Test the who_calls tool."""
 105 |         result = mcp_server._dispatch("tools/call", {
 106 |             "name": "who_calls",
 107 |             "arguments": {"symbol": "helper_function"},
 108 |         })
 109 |         assert not result.get("isError")

# [method] TestMCPTools.test_find_related (relevance: 0.46, depth: 2)
 131 |     def test_find_related(self, mcp_server: MCPServer):
 132 |         """Test the find_related tool."""
 133 |         result = mcp_server._dispatch("tools/call", {
 134 |             "name": "find_related",
 135 |             "arguments": {"symbol": "main"},
 136 |         })
 137 |         assert not result.get("isError")

# [method] TestMCPTools.test_unknown_tool (relevance: 0.46, depth: 2)
 139 |     def test_unknown_tool(self, mcp_server: MCPServer):
 140 |         """Test calling an unknown tool."""
 141 |         result = mcp_server._dispatch("tools/call", {
 142 |             "name": "nonexistent_tool",
 143 |             "arguments": {},
 144 |         })
 145 |         assert result.get("isError")

# [method] TestMCPTools.test_search_no_results (relevance: 0.46, depth: 2)
 147 |     def test_search_no_results(self, mcp_server: MCPServer):
 148 |         """Test search with no results."""
 149 |         result = mcp_server._dispatch("tools/call", {
 150 |             "name": "search_code",
 151 |             "arguments": {"query": "zzz_nonexistent_symbol_zzz"},
 152 |         })
 153 |         assert not result.get("isError")
 154 |         content = result["content"][0]["text"]
 155 |         assert "No symbols found" in content

# [method] TestMCPSecurity.test_resources_read_path_traversal (relevance: 0.46, depth: 2)
 171 |     def test_resources_read_path_traversal(self, mcp_server: MCPServer):
 172 |         """Regression: reading files outside the project root must be denied."""
 173 |         result = mcp_server._dispatch("resources/read", {
 174 |             "uri": "file://../../../../etc/hosts",
 175 |         })
 176 |         text = result["contents"][0].get("text", "")
 177 |         assert "Access denied" in text
 178 |         assert "localhost" not in text

# [method] TestMCPSecurity.test_resources_read_valid_file (relevance: 0.46, depth: 2)
 180 |     def test_resources_read_valid_file(self, mcp_server: MCPServer):
 181 |         """Reading a file inside the project root should work."""
 182 |         result = mcp_server._dispatch("resources/read", {
 183 |             "uri": "file://main.py",
 184 |         })
 185 |         text = result["contents"][0].get("text", "")
 186 |         assert "Access denied" not in text

## tests/test_parser.py
# Included because: graph expansion (depth 2); matches 'calls'

# [method] TestPythonParser.test_parse_imports (relevance: 0.40, depth: 2)
  71 |     def test_parse_imports(self, sample_python_source: str):
  72 |         result = parse_python_file("sample.py", sample_python_source)
  73 |         assert "os" in result.imports
  74 |         assert "typing.List" in result.imports
  75 |         assert "pathlib.Path" in result.imports

# [method] TestPythonParser.test_parse_constants (relevance: 0.40, depth: 2)
  77 |     def test_parse_constants(self, sample_python_source: str):
  78 |         result = parse_python_file("sample.py", sample_python_source)
  79 |         constants = [
  80 |             s for s in result.symbols if s.kind == SymbolKind.CONSTANT
  81 |         ]
  82 |         assert any(c.name == "CONSTANT_VALUE" for c in constants)

# [method] TestPythonParser.test_parse_inheritance (relevance: 0.40, depth: 2)
  84 |     def test_parse_inheritance(self, sample_python_source: str):
  85 |         result = parse_python_file("sample.py", sample_python_source)
  86 |         inherits = [
  87 |             r for r in result.relationships if r.kind == RelKind.INHERITS
  88 |         ]
  89 |         assert any("AdvancedProcessor" in r.source and "BaseProcessor" in r.target for r in inherits)

# [method] TestPythonParser.test_parse_calls (relevance: 0.80, depth: 0)
  91 |     def test_parse_calls(self, sample_python_source: str):
  92 |         result = parse_python_file("sample.py", sample_python_source)
  93 |         calls = [r for r in result.relationships if r.kind == RelKind.CALLS]
  94 |         # run_pipeline calls create_processor
  95 |         assert any(
  96 |             "run_pipeline" in r.source and "create_processor" in r.target
  97 |             for r in calls
  98 |         )

# [method] TestPythonParser.test_parse_docstrings (relevance: 0.40, depth: 2)
 100 |     def test_parse_docstrings(self, sample_python_source: str):
 101 |         result = parse_python_file("sample.py", sample_python_source)
 102 |         funcs = {s.name: s for s in result.symbols if s.kind in (SymbolKind.FUNCTION, SymbolKind.METHOD)}
 103 |         assert "Factory function" in funcs["create_processor"].docstring
 104 |         assert "Transform a single item" in funcs["_transform"].docstring

# [method] TestPythonParser.test_parse_contains_relationships (relevance: 0.40, depth: 2)
 106 |     def test_parse_contains_relationships(self, sample_python_source: str):
 107 |         result = parse_python_file("sample.py", sample_python_source)
 108 |         contains = [r for r in result.relationships if r.kind == RelKind.CONTAINS]
 109 |         # BaseProcessor should contain process, _transform, __init__
 110 |         assert any("BaseProcessor" in r.source and "process" in r.target for r in contains)

# [method] TestPythonParser.test_syntax_error_handling (relevance: 0.40, depth: 2)
 112 |     def test_syntax_error_handling(self):
 113 |         result = parse_python_file("bad.py", "def broken(:\n  pass")
 114 |         assert len(result.errors) > 0

# [method] TestPythonParser.test_empty_file (relevance: 0.40, depth: 2)
 116 |     def test_empty_file(self):
 117 |         result = parse_python_file("empty.py", "")
 118 |         assert result.language == "python"
 119 |         assert len(result.symbols) == 0

## tests/test_search.py
# Included because: graph expansion (depth 3)

# [method] TestLexicalSearch._build_search (relevance: 0.46, depth: 3)
  15 |     def _build_search(self, tmp_project: Path) -> LexicalSearch:
  16 |         builder = GraphBuilder()
  17 |         graph = builder.build_from_directory(tmp_project)
  18 |         return LexicalSearch(tmp_project, graph)

# [method] TestLexicalSearch.test_search_basic (relevance: 0.30, depth: 3)
  20 |     def test_search_basic(self, tmp_project: Path):
  21 |         search = self._build_search(tmp_project)
  22 |         results = search.search("calculate_total")
  23 |         assert len(results) > 0
  24 |         assert any("calculate_total" in r.line_content for r in results)

# [method] TestLexicalSearch.test_search_with_file_pattern (relevance: 0.30, depth: 3)
  26 |     def test_search_with_file_pattern(self, tmp_project: Path):
  27 |         search = self._build_search(tmp_project)
  28 |         results = search.search("def ", file_pattern="*.py")
  29 |         assert len(results) > 0
  30 |         assert all(r.file_path.endswith(".py") for r in results)

# [method] TestLexicalSearch.test_search_context_lines (relevance: 0.30, depth: 3)
  32 |     def test_search_context_lines(self, tmp_project: Path):
  33 |         search = self._build_search(tmp_project)
  34 |         results = search.search("calculate_total", context_lines=3)
  35 |         if results:
  36 |             # Should have context
  37 |             assert len(results[0].context_before) > 0 or len(results[0].context_after) > 0

# [method] TestLexicalSearch.test_search_regex (relevance: 0.30, depth: 3)
  39 |     def test_search_regex(self, tmp_project: Path):
  40 |         search = self._build_search(tmp_project)
  41 |         results = search.search(r"def \w+\(self", regex=True)
  42 |         assert len(results) > 0

# [method] TestLexicalSearch.test_search_no_results (relevance: 0.30, depth: 3)
  44 |     def test_search_no_results(self, tmp_project: Path):
  45 |         search = self._build_search(tmp_project)
  46 |         results = search.search("xyznonexistent123")
  47 |         assert len(results) == 0

# [method] TestLexicalSearch.test_search_symbols (relevance: 0.28, depth: 3)
  49 |     def test_search_symbols(self, tmp_project: Path):
  50 |         search = self._build_search(tmp_project)
  51 |         results = search.search_symbols("User")
  52 |         assert len(results) > 0
  53 |         assert any(r["name"] == "User" for r in results)

# [method] TestLexicalSearch.test_search_symbols_by_kind (relevance: 0.28, depth: 3)
  55 |     def test_search_symbols_by_kind(self, tmp_project: Path):
  56 |         search = self._build_search(tmp_project)
  57 |         results = search.search_symbols("", kind="function")
  58 |         assert len(results) > 0
  59 |         assert all(r["kind"] == "function" for r in results)

## tests/test_tools.py
# Included because: graph expansion (depth 2); graph expansion (depth 1); matches 'calls'

# [method] TestCeGraphTools._build_tools (relevance: 0.86, depth: 1)
  16 |     def _build_tools(self, tmp_project: Path) -> CeGraphTools:
  17 |         builder = GraphBuilder()
  18 |         graph = builder.build_from_directory(tmp_project)
  19 |         query = GraphQuery(graph)
  20 |         search = HybridSearch(tmp_project, graph)
  21 |         return CeGraphTools(tmp_project, graph, query, search)

# [method] TestCeGraphTools.test_search_code (relevance: 0.38, depth: 2)
  23 |     def test_search_code(self, tmp_project: Path):
  24 |         tools = self._build_tools(tmp_project)
  25 |         result = tools.search_code("calculate_total")
  26 |         assert "calculate_total" in result
  27 |         assert "No results" not in result

# [method] TestCeGraphTools.test_search_symbols (relevance: 0.38, depth: 2)
  29 |     def test_search_symbols(self, tmp_project: Path):
  30 |         tools = self._build_tools(tmp_project)
  31 |         result = tools.search_symbols("User")
  32 |         assert "User" in result
  33 |         assert "class" in result

# [method] TestCeGraphTools.test_who_calls (relevance: 0.82, depth: 0)
  35 |     def test_who_calls(self, tmp_project: Path):
  36 |         tools = self._build_tools(tmp_project)
  37 |         result = tools.who_calls("helper_function")
  38 |         assert "main" in result.lower() or "Callers" in result

# [method] TestCeGraphTools.test_what_calls (relevance: 0.82, depth: 0)
  40 |     def test_what_calls(self, tmp_project: Path):
  41 |         tools = self._build_tools(tmp_project)
  42 |         result = tools.what_calls("main")
  43 |         assert len(result) > 0

# [method] TestCeGraphTools.test_impact_of (relevance: 0.38, depth: 2)
  45 |     def test_impact_of(self, tmp_project: Path):
  46 |         tools = self._build_tools(tmp_project)
  47 |         result = tools.impact_of("calculate_total")
  48 |         assert "Risk score" in result or "Impact" in result

# [method] TestCeGraphTools.test_read_file (relevance: 0.38, depth: 2)
  50 |     def test_read_file(self, tmp_project: Path):
  51 |         tools = self._build_tools(tmp_project)
  52 |         result = tools.read_file("main.py")
  53 |         assert "def main" in result

# [method] TestCeGraphTools.test_read_file_with_lines (relevance: 0.38, depth: 2)
  55 |     def test_read_file_with_lines(self, tmp_project: Path):
  56 |         tools = self._build_tools(tmp_project)
  57 |         result = tools.read_file("main.py", start_line=1, end_line=5)
  58 |         assert "1" in result  # Line numbers
  59 |         lines = [l for l in result.splitlines() if l.strip()]
  60 |         assert len(lines) <= 5

# [method] TestCeGraphTools.test_read_file_not_found (relevance: 0.38, depth: 2)
  62 |     def test_read_file_not_found(self, tmp_project: Path):
  63 |         tools = self._build_tools(tmp_project)
  64 |         result = tools.read_file("nonexistent.py")
  65 |         assert "not found" in result.lower()

# [method] TestCeGraphTools.test_read_file_outside_root (relevance: 0.38, depth: 2)
  67 |     def test_read_file_outside_root(self, tmp_project: Path):
  68 |         tools = self._build_tools(tmp_project)
  69 |         result = tools.read_file("../../etc/passwd")
  70 |         assert "denied" in result.lower() or "not found" in result.lower()

# [method] TestCeGraphTools.test_edit_file_text_not_found (relevance: 0.38, depth: 2)
  87 |     def test_edit_file_text_not_found(self, tmp_project: Path):
  88 |         tools = self._build_tools(tmp_project)
  89 |         result = tools.edit_file("utils.py", "NONEXISTENT_TEXT", "replacement")
  90 |         assert "not found" in result.lower()

# [method] TestCeGraphTools.test_write_file (relevance: 0.40, depth: 2)
  92 |     def test_write_file(self, tmp_project: Path):
  93 |         tools = self._build_tools(tmp_project)
  94 |         result = tools.write_file("new_file.py", "# New file\nprint('hello')\n")
  95 |         assert "Successfully" in result
  96 | 
  97 |         content = tools.read_file("new_file.py")
  98 |         assert "New file" in content

# [method] TestCeGraphTools.test_list_files (relevance: 0.38, depth: 2)
 100 |     def test_list_files(self, tmp_project: Path):
 101 |         tools = self._build_tools(tmp_project)
 102 |         result = tools.list_files()
 103 |         assert "main.py" in result

# [method] TestCeGraphTools.test_list_files_pattern (relevance: 0.38, depth: 2)
 105 |     def test_list_files_pattern(self, tmp_project: Path):
 106 |         tools = self._build_tools(tmp_project)
 107 |         result = tools.list_files(pattern="*.py")
 108 |         assert "main.py" in result

# [method] TestCeGraphTools.test_get_context (relevance: 0.38, depth: 2)
 110 |     def test_get_context(self, tmp_project: Path):
 111 |         tools = self._build_tools(tmp_project)
 112 |         result = tools.get_context("User")
 113 |         assert "User" in result
 114 |         assert "class" in result.lower()

# [method] TestCeGraphTools.test_run_command_safe (relevance: 0.38, depth: 2)
 116 |     def test_run_command_safe(self, tmp_project: Path):
 117 |         tools = self._build_tools(tmp_project)
 118 |         result = tools.run_command("python --version")
 119 |         assert "Python" in result

# [method] TestCeGraphTools.test_run_command_blocked (relevance: 0.38, depth: 2)
 121 |     def test_run_command_blocked(self, tmp_project: Path):
 122 |         tools = self._build_tools(tmp_project)
 123 |         result = tools.run_command("rm -rf /")
 124 |         assert "not allowed" in result.lower()

# [method] TestCeGraphTools.test_run_command_injection_pipe (relevance: 0.38, depth: 2)
 135 |     def test_run_command_injection_pipe(self, tmp_project: Path):
 136 |         """Regression: pipes must not be interpreted."""
 137 |         tools = self._build_tools(tmp_p