# Codebase Context for: GraphQuery.get_file_symbols always returns an empty list â€” it cannot find any file nodes in the graph.
# 12 symbols from 4 files (~3,647 tokens, 91% of budget)

## src/cegraph/context/_native.py
# Included because: graph expansion (depth 1); matches 'graph'; graph expansion (depth 3)

# [class] NativeGraph (relevance: 0.56, depth: 0)
 220 | class NativeGraph:
 221 |     """Handle to a native C++ graph."""
 222 | 
 223 |     def __init__(self, lib, handle, num_nodes: int):
 224 |         self._lib = lib
 225 |         self._handle = handle
 226 |         self._num_nodes = num_nodes
 227 |         self._destroyed = False
 228 | 
 229 |     def add_edge(self, src: int, dst: int, weight: float) -> None:
 230 |         self._lib.cag_graph_add_edge(self._handle, src, dst, weight)
 231 | 
 232 |     def set_node_weight(self, node: int, weight: float) -> None:
 233 |         self._lib.cag_graph_set_node_weight(self._handle, node, weight)
 234 | 
 235 |     def set_lines(self, node: int, start: int, end: int) -> None:
 236 |         self._lib.cag_graph_set_lines(self._handle, node, start, end)
 237 | 
 238 |     def weighted_bfs(
 239 |         self,
 240 |         seed_nodes: list[int],
 241 |         seed_scores: list[float],
 242 |         max_depth: int = 3,
 243 |         min_score: float = 0.1,
 244 |         backward_decay: float = 0.7,
 245 |         max_results: int = 5000,
 246 |     ) -> list[dict]:
 247 |         """Run weighted BFS and return results."""
 248 |         n = len(seed_nodes)
 249 |         c_seeds = (ctypes.c_int32 * n)(*seed_nodes)
 250 |         c_scores = (ctypes.c_float * n)(*seed_scores)
 251 | 
 252 |         out_nodes = (ctypes.c_int32 * max_results)()
 253 |         out_scores = (ctypes.c_float * max_results)()
 254 |         out_depths = (ctypes.c_int32 * max_results)()
 255 | 
 256 |         count = self._lib.cag_weighted_bfs(
 257 |             self._handle,
 258 |             c_seeds, c_scores, n,
 259 |             max_depth, min_score, backward_decay,
 260 |             out_nodes, out_scores, out_depths,
 261 |             max_results,
 262 |         )
 263 | 
 264 |         return [
 265 |             {"node": out_nodes[i], "score": out_scores[i], "depth": out_depths[i]}
 266 |             for i in range(count)
 267 |         ]
 268 | 
 269 |     def topological_sort(self, nodes: list[int]) -> list[int]:
 270 |         """Topological sort a subset of nodes."""
 271 |         n = len(nodes)
 272 |         c_nodes = (ctypes.c_int32 * n)(*nodes)
 273 |         out_order = (ctypes.c_int32 * n)()
 274 | 
 275 |         count = self._lib.cag_topological_sort(self._handle, c_nodes, n, out_order)
 276 |         return [out_order[i] for i in range(count)]
 277 | 
 278 |     def destroy(self) -> None:
 279 |         """Free the native graph."""
 280 |         if not self._destroyed:
 281 |             self._lib.cag_graph_destroy(self._handle)
 282 |             self._destroyed = True
 283 | 
 284 |     def __del__(self):
 285 |         self.destroy()

# [method] NativeGraph.add_edge (relevance: 0.49, depth: 3)
 229 |     def add_edge(self, src: int, dst: int, weight: float) -> None:
 230 |         self._lib.cag_graph_add_edge(self._handle, src, dst, weight)

# [method] NativeGraph.set_node_weight (relevance: 0.35, depth: 3)
 232 |     def set_node_weight(self, node: int, weight: float) -> None:
 233 |         self._lib.cag_graph_set_node_weight(self._handle, node, weight)

# [method] NativeGraph.set_lines (relevance: 0.35, depth: 3)
 235 |     def set_lines(self, node: int, start: int, end: int) -> None:
 236 |         self._lib.cag_graph_set_lines(self._handle, node, start, end)

# [method] NativeGraph.__del__ (relevance: 0.29, depth: 1)
 284 |     def __del__(self):
 285 |         self.destroy()

## src/cegraph/exceptions.py
# Included because: graph expansion (depth 1); matches 'graph'

# [class] CeGraphError (relevance: 0.47, depth: 1)
   4 | class CeGraphError(Exception):
   5 |     """Base exception for all CeGraph errors."""

# [class] GraphError (relevance: 0.40, depth: 0)
  16 | class GraphError(CeGraphError):
  17 |     """Knowledge graph errors."""

## src/cegraph/github/diff_parser.py
# Included because: graph expansion (depth 2)

# [function] get_pr_diff (relevance: 0.41, depth: 2)
 205 | def get_pr_diff(root: Path) -> str:
 206 |     """Get the diff for the current PR (GitHub Actions context)."""
 207 |     import os
 208 |     base_ref = os.environ.get("GITHUB_BASE_REF", "main")
 209 |     return get_git_diff(root, base=f"origin/{base_ref}")

## src/cegraph/graph/query.py
# Included because: matches 'get_file_symbols'; graph expansion (depth 1); matches 'GraphQuery'

# [class] GraphQuery (relevance: 1.11, depth: 0)
  31 | class GraphQuery:
  32 |     """Query engine for the code knowledge graph.
  33 | 
  34 |     Provides high-level methods for common queries: who calls what,
  35 |     impact analysis, related symbols, etc.
  36 |     """
  37 | 
  38 |     def __init__(self, graph: nx.DiGraph, store: GraphStore | None = None) -> None:
  39 |         self.graph = graph
  40 |         self.store = store
  41 |         self._name_index: dict[str, list[str]] = {}
  42 |         self._build_index()
  43 | 
  44 |     def _build_index(self) -> None:
  45 |         """Build a name->node_id lookup index."""
  46 |         for node_id, data in self.graph.nodes(data=True):
  47 |             if data.get("type") != "symbol":
  48 |                 continue
  49 |             name = data.get("name", "")
  50 |             qname = data.get("qualified_name", "")
  51 |             if name:
  52 |                 self._name_index.setdefault(name, []).append(node_id)
  53 |             if qname and qname != name:
  54 |                 self._name_index.setdefault(qname, []).append(node_id)
  55 | 
  56 |     def find_symbol(self, name: str) -> list[str]:
  57 |         """Find symbol node IDs matching a name (exact or qualified)."""
  58 |         results = self._name_index.get(name, [])
  59 |         if not results:
  60 |             # Try partial match
  61 |             for key, ids in self._name_index.items():
  62 |                 if name.lower() in key.lower():
  63 |                     results.extend(ids)
  64 |         return list(set(results))
  65 | 
  66 |     def get_symbol_info(self, symbol_id: str) -> SymbolInfo | None:
  67 |         """Get detailed information about a symbol."""
  68 |         if not self.graph.has_node(symbol_id):
  69 |             return None
  70 | 
  71 |         data = self.graph.nodes[symbol_id]
  72 |         if data.get("type") != "symbol":
  73 |             return None
  74 | 
  75 |         # Get callers (reverse edges with kind=calls)
  76 |         callers = []
  77 |         for pred in self.graph.predecessors(symbol_id):
  78 |             edge_data = self.graph.edges[pred, symbol_id]
  79 |             if edge_data.get("kind") == "calls":
  80 |                 callers.append(pred)
  81 | 
  82 |         # Get callees (forward edges with kind=calls)
  83 |         callees = []
  84 |         for succ in self.graph.successors(symbol_id):
  85 |             edge_data = self.graph.edges[symbol_id, succ]
  86 |             if edge_data.get("kind") == "calls":
  87 |                 callees.append(succ)
  88 | 
  89 |         # Get children (contains edges)
  90 |         children = []
  91 |         for succ in self.graph.successors(symbol_id):
  92 |             edge_data = self.graph.edges[symbol_id, succ]
  93 |             if edge_data.get("kind") == "contains":
  94 |                 children.append(succ)
  95 | 
  96 |         # Get parent
  97 |         parent = ""
  98 |         for pred in self.graph.predecessors(symbol_id):
  99 |             edge_data = self.graph.edges[pred, symbol_id]
 100 |             if edge_data.get("kind") == "contains":
 101 |                 pred_data = self.graph.nodes.get(pred, {})
 102 |                 if pred_data.get("type") == "symbol":
 103 |                     parent = pred
 104 |                     break
 105 | 
 106 |         return SymbolInfo(
 107 |             id=symbol_id,
 108 |             name=data.get("name", ""),
 109 |             qualified_name=data.get("qualified_name", ""),
 110 |             kind=data.get("kind", ""),
 111 |             file_path=data.get("file_path", ""),
 112 |             line_start=data.get("line_start", 0),
 113 |             line_end=data.get("line_end", 0),
 114 |             signature=data.get("signature", ""),
 115 |             docstring=data.get("docstring", ""),
 116 |             callers=callers,
 117 |             callees=callees,
 118 |             children=children,
 119 |             parent=parent,
 120 |         )
 121 | 
 122 |     def who_calls(self, name: str, max_depth: int = 1) -> list[dict]:
 123 |         """Find all callers of a symbol, optionally going N levels deep.
 124 | 
 125 |         Returns list of {symbol_id, name, file_path, line, depth}
 126 |         """
 127 |         symbol_ids = self.find_symbol(name)
 128 |         if not symbol_ids:
 129 |             return []
 130 | 
 131 |         results = []
 132 |         visited = set()
 133 | 
 134 |         def _traverse(node_id: str, depth: int) -> None:
 135 |             if depth > max_depth or node_id in visited:
 136 |                 return
 137 |             visited.add(node_id)
 138 | 
 139 |             for pred in self.graph.predecessors(node_id):
 140 |                 edge_data = self.graph.edges[pred, node_id]
 141 |                 if edge_data.get("kind") != "calls":
 142 |                     continue
 143 |                 pred_data = self.graph.nodes.get(pred, {})
 144 |                 if pred_data.get("type") != "symbol":
 145 |                     continue
 146 | 
 147 |                 results.append({
 148 |                     "symbol_id": pred,
 149 |                     "name": pred_data.get("qualified_name", pred_data.get("name", "")),
 150 |                     "kind": pred_data.get("kind", ""),
 151 |                     "file_path": pred_data.get("file_path", ""),
 152 |                     "line": pred_data.get("line_start", 0),
 153 |                     "depth": depth,
 154 |                 })
 155 |                 _traverse(pred, depth + 1)
 156 | 
 157 |         for sid in symbol_ids:
 158 |             _traverse(sid, 1)
 159 | 
 160 |         return results
 161 | 
 162 |     def what_calls(self, name: str) -> list[dict]:
 163 |         """Find all symbols called by the given symbol."""
 164 |         symbol_ids = self.find_symbol(name)
 165 |         results = []
 166 | 
 167 |         for sid in symbol_ids:
 168 |             for succ in self.graph.successors(sid):
 169 |                 edge_data = self.graph.edges[sid, succ]
 170 |                 if edge_data.get("kind") != "calls":
 171 |                     continue
 172 |                 succ_data = self.graph.nodes.get(succ, {})
 173 |                 if succ_data.get("type") != "symbol":
 174 |                     continue
 175 |                 results.append({
 176 |                     "symbol_id": succ,
 177 |                     "name": succ_data.get("qualified_name", succ_data.get("name", "")),
 178 |                     "kind": succ_data.get("kind", ""),
 179 |                     "file_path": succ_data.get("file_path", ""),
 180 |                     "line": succ_data.get("line_start", 0),
 181 |                 })
 182 | 
 183 |         return results
 184 | 
 185 |     def impact_of(self, name: str, max_depth: int = 3) -> dict:
 186 |         """Analyze the impact of changing a symbol.
 187 | 
 188 |         Returns a dict with:
 189 |         - direct_callers: immediate callers
 190 |         - transitive_callers: all callers up to max_depth
 191 |         - affected_files: set of files that could be affected
 192 |         - risk_score: rough risk assessment (0-1)
 193 |         """
 194 |         symbol_ids = self.find_symbol(name)
 195 |         if not symbol_ids:
 196 |             return {
 197 |                 "symbol": name,
 198 |                 "found": False,
 199 |                 "direct_callers": [],
 200 |                 "transitive_callers": [],
 201 |                 "affected_files": [],
 202 |                 "risk_score": 0.0,
 203 |             }
 204 | 
 205 |         direct = self.who_calls(name, max_depth=1)
 206 |         transitive = self.who_calls(name, max_depth=max_depth)
 207 | 
 208 |         affected_files = set()
 209 |         for item in transitive:
 210 |             if item.get("file_path"):
 211 |                 affected_files.add(item["file_path"])
 212 |         # Also include the symbol's own file
 213 |         for sid in symbol_ids:
 214 |             data = self.graph.nodes.get(sid, {})
 215 |             if data.get("file_path"):
 216 |                 affected_files.add(data["file_path"])
 217 | 
 218 |         # Risk score based on impact breadth
 219 |         total_files = sum(1 for _, d in self.graph.nodes(data=True) if d.get("type") == "file")
 220 |         risk_score = min(len(affected_files) / max(total_files, 1), 1.0)
 221 | 
 222 |         return {
 223 |             "symbol": name,
 224 |             "found": True,
 225 |             "direct_callers": direct,
 226 |             "transitive_callers": transitive,
 227 |             "affected_files": sorted(affected_files),
 228 |             "risk_score": round(risk_score, 3),
 229 |         }
 230 | 
 231 |     def get_file_symbols(self, file_path: str) -> list[dict]:
 232 |         """Get all symbols defined in a file."""
 233 |         file_node = f"{file_path}"
 234 |         if not self.graph.has_node(file_node):
 235 |             return []
 236 | 
 237 |         symbols = []
 238 |         for succ in self.graph.successors(file_node):
 239 |             data = self.graph.nodes.get(succ, {})
 240 |             if data.get("type") == "symbol":
 241 |                 symbols.append({
 242 |                     "id": succ,
 243 |                     **{k: v for k, v in data.items() if k != "type"},
 244 |                 })
 245 | 
 246 |         return sorted(symbols, key=lambda s: s.get("line_start", 0))
 247 | 
 248 |     def get_structure(self, path_prefix: str = "") -> dict:
 249 |         """Get the directory/file structure with symbol counts."""
 250 |         structure: dict = {}
 251 | 
 252 |         for node_id, data in self.graph.nodes(data=True):
 253 |             if data.get("type") != "file":
 254 |                 continue
 255 |             file_path = data.get("path", "")
 256 |             if path_prefix and not file_path.startswith(path_prefix):
 257 |                 continue
 258 | 
 259 |             parts = file_path.split("/")
 260 |             current = structure
 261 |             for part in parts[:-1]:
 262 |                 current = current.setdefault(part, {})
 263 |             current[parts[-1]] = {
 264 |                 "_language": data.get("language", ""),
 265 |                 "_symbols": data.get("symbol_count", 0),
 266 |             }
 267 | 
 268 |         return structure
 269 | 
 270 |     def find_related(self, name: str, max_hops: int = 2) -> list[dict]:
 271 |         """Find symbols related to the given one within N hops."""
 272 |         symbol_ids = self.find_symbol(name)
 273 |         if not symbol_ids:
 274 |             return []
 275 | 
 276 |         related = set()
 277 |         visited = set()
 278 | 
 279 |         def _bfs(start: str, hops: int) -> None:
 280 |             if hops > max_hops or start in visited:
 281 |                 return
 282 |             visited.add(start)
 283 | 
 284 |             # Forward edges
 285 |             for succ in self.graph.successors(start):
 286 |                 succ_data = self.graph.nodes.get(succ, {})
 287 |                 if succ_data.get("type") == "symbol":
 288 |                     related.add(succ)
 289 |                     _bfs(succ, hops + 1)
 290 | 
 291 |             # Backward edges
 292 |             for pred in self.graph.predecessors(start):
 293 |                 pred_data = self.graph.nodes.get(pred, {})
 294 |                 if pred_data.get("type") == "symbol":
 295 |                     related.add(pred)
 296 |                     _bfs(pred, hops + 1)
 297 | 
 298 |         for sid in symbol_ids:
 299 |             _bfs(sid, 0)
 300 | 
 301 |         # Remove the original symbols
 302 |         related -= set(symbol_ids)
 303 | 
 304 |         results = []
 305 |         for node_id in related:
 306 |             data = self.graph.nodes.get(node_id, {})
 307 |             results.append({
 308 |                 "symbol_id": node_id,
 309 |                 "name": data.get("qualified_name", data.get("name", "")),
 310 |                 "kind": data.get("kind", ""),
 311 |                 "file_path": data.get("file_path", ""),
 312 |                 "line": data.get("line_start", 0),
 313 |             })
 314 | 
 315 |         return results

# [method] GraphQuery.__init__ (relevance: 0.80, depth: 1)
  38 |     def __init__(self, graph: nx.DiGraph, store: GraphStore | None = None) -> None:
  39 |         self.graph = graph
  40 |         self.store = store
  41 |         self._name_index: dict[str, list[str]] = {}
  42 |         self._build_index()

# [method] GraphQuery.find_symbol (relevance: 1.02, depth: 1)
  56 |     def find_symbol(self, name: str) -> list[str]:
  57 |         """Find symbol node IDs matching a name (exact or qualified)."""
  58 |         results = self._name_index.get(name, [])
  59 |         if not results:
  60 |             # Try partial match
  61 |             for key, ids in self._name_index.items():
  62 |                 if name.lower() in key.lower():
  63 |                     results.extend(ids)
  64 |         return list(set(results))

# [method] GraphQuery.get_file_symbols (relevance: 1.02, depth: 0)
 231 |     def get_file_symbols(self, file_path: str) -> list[dict]:
 232 |         """Get all symbols defined in a file."""
 233 |         file_node = f"{file_path}"
 234 |         if not self.graph.has_node(file_node):
 235 |             return []
 236 | 
 237 |         symbols = []
 238 |         for succ in self.graph.successors(file_node):
 239 |             data = self.graph.nodes.get(succ, {})
 240 |             if data.get("type") == "symbol":
 241 |                 symbols.append({
 242 |                     "id": succ,
 243 |                     **{k: v for k, v in data.items() if k != "type"},
 244 |                 })
 245 | 
 246 |         return sorted(symbols, key=lambda s: s.get("line_start", 0))
