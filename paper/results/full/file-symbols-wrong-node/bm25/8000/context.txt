# tests/test_graph.py:196-201
    def test_get_file_symbols(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        symbols = query.get_file_symbols("main.py")
        assert len(symbols) > 0
        names = [s["name"] for s in symbols]
        assert "main" in names

# src/cegraph/graph/query.py:231-246
    def get_file_symbols(self, file_path: str) -> list[dict]:
        """Get all symbols defined in a file."""
        file_node = f"{file_path}"
        if not self.graph.has_node(file_node):
            return []

        symbols = []
        for succ in self.graph.successors(file_node):
            data = self.graph.nodes.get(succ, {})
            if data.get("type") == "symbol":
                symbols.append({
                    "id": succ,
                    **{k: v for k, v in data.items() if k != "type"},
                })

        return sorted(symbols, key=lambda s: s.get("line_start", 0))

# src/cegraph/tools/definitions.py:195-218
    def list_files(self, path: str = "", pattern: str = "") -> str:
        """List files in the repository."""
        target = self.root / path if path else self.root
        if not target.exists():
            return f"Path not found: {path}"

        try:
            target.resolve().relative_to(self.root.resolve())
        except ValueError:
            return f"Access denied: {path} is outside the project root"

        files = []
        if pattern:
            import fnmatch

            for p in sorted(target.rglob("*")):
                if p.is_file() and fnmatch.fnmatch(p.name, pattern):
                    files.append(str(p.relative_to(self.root)))
        else:
            for p in sorted(target.iterdir()):
                prefix = "d " if p.is_dir() else "f "
                files.append(prefix + str(p.relative_to(self.root)))

        return "\n".join(files) if files else "No files found"

# tests/test_parser.py:116-119
    def test_empty_file(self):
        result = parse_python_file("empty.py", "")
        assert result.language == "python"
        assert len(result.symbols) == 0

# tests/test_tools.py:100-103
    def test_list_files(self, tmp_project: Path):
        tools = self._build_tools(tmp_project)
        result = tools.list_files()
        assert "main.py" in result

# tests/test_graph.py:34-44
    def test_file_nodes_present(self, tmp_project: Path):
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)

        file_nodes = [
            n for n, d in graph.nodes(data=True) if d.get("type") == "file"
        ]
        file_paths = [graph.nodes[n].get("path") for n in file_nodes]
        assert "main.py" in file_paths
        assert "utils.py" in file_paths
        assert "models.py" in file_paths

# tests/test_tools.py:105-108
    def test_list_files_pattern(self, tmp_project: Path):
        tools = self._build_tools(tmp_project)
        result = tools.list_files(pattern="*.py")
        assert "main.py" in result

# tests/test_graph.py:160-163
    def test_find_symbol(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        results = query.find_symbol("main")
        assert len(results) > 0

# tests/test_graph.py:208-211
    def test_find_related(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        related = query.find_related("calculate_total")
        assert len(related) > 0

# src/cegraph/graph/query.py:270-315
    def find_related(self, name: str, max_hops: int = 2) -> list[dict]:
        """Find symbols related to the given one within N hops."""
        symbol_ids = self.find_symbol(name)
        if not symbol_ids:
            return []

        related = set()
        visited = set()

        def _bfs(start: str, hops: int) -> None:
            if hops > max_hops or start in visited:
                return
            visited.add(start)

            # Forward edges
            for succ in self.graph.successors(start):
                succ_data = self.graph.nodes.get(succ, {})
                if succ_data.get("type") == "symbol":
                    related.add(succ)
                    _bfs(succ, hops + 1)

            # Backward edges
            for pred in self.graph.predecessors(start):
                pred_data = self.graph.nodes.get(pred, {})
                if pred_data.get("type") == "symbol":
                    related.add(pred)
                    _bfs(pred, hops + 1)

        for sid in symbol_ids:
            _bfs(sid, 0)

        # Remove the original symbols
        related -= set(symbol_ids)

        results = []
        for node_id in related:
            data = self.graph.nodes.get(node_id, {})
            results.append({
                "symbol_id": node_id,
                "name": data.get("qualified_name", data.get("name", "")),
                "kind": data.get("kind", ""),
                "file_path": data.get("file_path", ""),
                "line": data.get("line_start", 0),
            })

        return results

# src/cegraph/graph/query.py:122-160
    def who_calls(self, name: str, max_depth: int = 1) -> list[dict]:
        """Find all callers of a symbol, optionally going N levels deep.

        Returns list of {symbol_id, name, file_path, line, depth}
        """
        symbol_ids = self.find_symbol(name)
        if not symbol_ids:
            return []

        results = []
        visited = set()

        def _traverse(node_id: str, depth: int) -> None:
            if depth > max_depth or node_id in visited:
                return
            visited.add(node_id)

            for pred in self.graph.predecessors(node_id):
                edge_data = self.graph.edges[pred, node_id]
                if edge_data.get("kind") != "calls":
                    continue
                pred_data = self.graph.nodes.get(pred, {})
                if pred_data.get("type") != "symbol":
                    continue

                results.append({
                    "symbol_id": pred,
                    "name": pred_data.get("qualified_name", pred_data.get("name", "")),
                    "kind": pred_data.get("kind", ""),
                    "file_path": pred_data.get("file_path", ""),
                    "line": pred_data.get("line_start", 0),
                    "depth": depth,
                })
                _traverse(pred, depth + 1)

        for sid in symbol_ids:
            _traverse(sid, 1)

        return results

# examples/demo.py:10-10
from cegraph.graph.query import GraphQuery

# examples/demo.py:10-10
from cegraph.graph.query import GraphQuery

# examples/demo.py:10-10
from cegraph.graph.query import GraphQuery

# examples/demo.py:10-10
from cegraph.graph.query import GraphQuery

# examples/demo.py:10-10
from cegraph.graph.query import GraphQuery

# examples/demo.py:10-10
from cegraph.graph.query import GraphQuery

# examples/demo.py:10-10
from cegraph.graph.query import GraphQuery

# examples/demo.py:10-10
from cegraph.graph.query import GraphQuery

# examples/demo.py:10-10
from cegraph.graph.query import GraphQuery

# examples/demo.py:10-10
from cegraph.graph.query import GraphQuery

# examples/demo.py:10-10
from cegraph.graph.query import GraphQuery

# tests/test_graph.py:165-168
    def test_find_symbol_partial(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        results = query.find_symbol("helper")
        assert len(results) > 0

# src/cegraph/cli.py:14-22
from cegraph.config import (
    GRAPH_DB_FILE,
    ProjectConfig,
    find_project_root,
    get_cegraph_dir,
    load_config,
    save_config,
    set_config_value,
)

# src/cegraph/cli.py:14-22
from cegraph.config import (
    GRAPH_DB_FILE,
    ProjectConfig,
    find_project_root,
    get_cegraph_dir,
    load_config,
    save_config,
    set_config_value,
)

# src/cegraph/cli.py:14-22
from cegraph.config import (
    GRAPH_DB_FILE,
    ProjectConfig,
    find_project_root,
    get_cegraph_dir,
    load_config,
    save_config,
    set_config_value,
)

# tests/test_graph.py:154-226
class TestGraphQuery:
    def _build_query(self, tmp_project: Path) -> GraphQuery:
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)
        return GraphQuery(graph)

    def test_find_symbol(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        results = query.find_symbol("main")
        assert len(results) > 0

    def test_find_symbol_partial(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        results = query.find_symbol("helper")
        assert len(results) > 0

    def test_who_calls(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        callers = query.who_calls("helper_function")
        # main() calls helper_function()
        caller_names = [c["name"] for c in callers]
        assert any("main" in name for name in caller_names)

    def test_what_calls(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        callees = query.what_calls("main")
        callee_names = [c["name"] for c in callees]
        # main() should call several functions
        assert len(callees) > 0

    def test_impact_of(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        impact = query.impact_of("calculate_total")
        assert impact["found"] is True
        assert len(impact["affected_files"]) > 0
        assert impact["risk_score"] >= 0

    def test_impact_not_found(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        impact = query.impact_of("nonexistent_function")
        assert impact["found"] is False

    def test_get_file_symbols(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        symbols = query.get_file_symbols("main.py")
        assert len(symbols) > 0
        names = [s["name"] for s in symbols]
        assert "main" in names

    def test_get_structure(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        structure = query.get_structure()
        assert "main.py" in structure or len(structure) > 0

    def test_find_related(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        related = query.find_related("calculate_total")
        assert len(related) > 0

    def test_get_symbol_info(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        symbol_ids = query.find_symbol("User")
        assert len(symbol_ids) > 0
        # Find the class definition (not import)
        class_info = None
        for sid in symbol_ids:
            info = query.get_symbol_info(sid)
            if info and info.kind == "class":
                class_info = info
                break
        assert class_info is not None
        assert class_info.name == "User"
        assert class_info.kind == "class"

# src/cegraph/graph/builder.py:66-121
    def _add_file(self, fs: FileSymbols, root: Path) -> None:
        """Add a file and its symbols to the graph."""
        file_path = fs.file_path

        # Add file node
        self.graph.add_node(
            f"file::{file_path}",
            type="file",
            path=file_path,
            language=fs.language,
            symbol_count=len(fs.symbols),
            import_count=len(fs.imports),
        )

        # Compute file hash for change detection
        try:
            full_path = root / file_path
            content = full_path.read_bytes()
            self._file_hashes[file_path] = hashlib.sha256(content).hexdigest()[:16]
        except OSError:
            pass

        # Add symbol nodes
        for symbol in fs.symbols:
            attrs = {
                "type": "symbol",
                "name": symbol.name,
                "qualified_name": symbol.qualified_name,
                "kind": symbol.kind.value,
                "file_path": symbol.file_path,
                "line_start": symbol.line_start,
                "line_end": symbol.line_end,
                "signature": symbol.signature,
                "docstring": symbol.docstring,
            }
            self.graph.add_node(symbol.id, **attrs)

            # Link symbol to its file
            self.graph.add_edge(
                f"file::{file_path}",
                symbol.id,
                kind="contains",
            )

        # Add relationships
        for rel in fs.relationships:
            if rel.resolved or self._try_resolve(rel):
                self.graph.add_edge(
                    rel.source,
                    rel.target,
                    kind=rel.kind.value,
                    file_path=rel.file_path,
                    line=rel.line,
                )
            else:
                self._unresolved.append(rel)

# src/cegraph/graph/query.py:56-64
    def find_symbol(self, name: str) -> list[str]:
        """Find symbol node IDs matching a name (exact or qualified)."""
        results = self._name_index.get(name, [])
        if not results:
            # Try partial match
            for key, ids in self._name_index.items():
                if name.lower() in key.lower():
                    results.extend(ids)
        return list(set(results))

# src/cegraph/graph/query.py:162-183
    def what_calls(self, name: str) -> list[dict]:
        """Find all symbols called by the given symbol."""
        symbol_ids = self.find_symbol(name)
        results = []

        for sid in symbol_ids:
            for succ in self.graph.successors(sid):
                edge_data = self.graph.edges[sid, succ]
                if edge_data.get("kind") != "calls":
                    continue
                succ_data = self.graph.nodes.get(succ, {})
                if succ_data.get("type") != "symbol":
                    continue
                results.append({
                    "symbol_id": succ,
                    "name": succ_data.get("qualified_name", succ_data.get("name", "")),
                    "kind": succ_data.get("kind", ""),
                    "file_path": succ_data.get("file_path", ""),
                    "line": succ_data.get("line_start", 0),
                })

        return results

# tests/test_impact_bot.py:108-110
    def test_parse_empty(self):
        diffs = parse_diff("")
        assert diffs == []

# tests/test_context.py:65-72
    def test_render_empty(self):
        pkg = ContextPackage(
            task="test task",
            strategy=ContextStrategy.SMART,
            token_budget=8000,
        )
        rendered = pkg.render()
        assert "test task" in rendered

# src/cegraph/tools/definitions.py:119-156
    def read_file(self, file_path: str, start_line: int = 0, end_line: int = 0) -> str:
        """Read a file from the repository."""
        full_path = self.root / file_path
        if not full_path.exists():
            return f"File not found: {file_path}"
        if not full_path.is_file():
            return f"Not a file: {file_path}"

        # Security: ensure we're within the project root
        try:
            full_path.resolve().relative_to(self.root.resolve())
        except ValueError:
            return f"Access denied: {file_path} is outside the project root"

        try:
            content = full_path.read_text(encoding="utf-8", errors="replace")
        except OSError as e:
            return f"Error reading file: {e}"

        lines = content.splitlines()
        if start_line or end_line:
            start = max(0, start_line - 1)
            end = end_line if end_line else len(lines)
            lines = lines[start:end]
            # Add line numbers
            numbered = [
                f"{i + start + 1:4d} | {line}" for i, line in enumerate(lines)
            ]
            return "\n".join(numbered)

        # If file is too long, truncate with message
        if len(lines) > 200:
            numbered = [f"{i + 1:4d} | {line}" for i, line in enumerate(lines[:200])]
            numbered.append(f"\n... ({len(lines) - 200} more lines)")
            return "\n".join(numbered)

        numbered = [f"{i + 1:4d} | {line}" for i, line in enumerate(lines)]
        return "\n".join(numbered)

# tests/test_context.py:56-63
    def test_empty_package(self):
        pkg = ContextPackage(
            task="test task",
            strategy=ContextStrategy.SMART,
            token_budget=8000,
        )
        assert pkg.symbols_included == 0
        assert pkg.total_tokens == 0

# tests/test_context.py:35-36
    def test_estimate_empty(self):
        assert TokenEstimator.estimate("") == 1

# tests/test_impact_bot.py:162-165
    def test_render_empty_comment(self):
        comment = render_impact_comment([], [])
        assert "CeGraph Impact Analysis" in comment
        assert "No code symbols" in comment

# examples/demo.py:9-9
from cegraph.graph.builder import GraphBuilder

# src/cegraph/graph/query.py:248-268
    def get_structure(self, path_prefix: str = "") -> dict:
        """Get the directory/file structure with symbol counts."""
        structure: dict = {}

        for node_id, data in self.graph.nodes(data=True):
            if data.get("type") != "file":
                continue
            file_path = data.get("path", "")
            if path_prefix and not file_path.startswith(path_prefix):
                continue

            parts = file_path.split("/")
            current = structure
            for part in parts[:-1]:
                current = current.setdefault(part, {})
            current[parts[-1]] = {
                "_language": data.get("language", ""),
                "_symbols": data.get("symbol_count", 0),
            }

        return structure

# src/cegraph/context/engine.py:349-427
    def _find_seeds(
        self, entities: list[dict], focus_files: list[str] | None = None
    ) -> list[dict]:
        """Find seed symbols in the graph matching extracted entities."""
        seeds: list[dict] = []
        seen_ids = set()

        for entity in entities:
            name = entity["name"]
            confidence = entity["confidence"]

            if entity["type"] == "file":
                file_node = f"file::{name}"
                if self.graph.has_node(file_node):
                    for succ in self.graph.successors(file_node):
                        data = self.graph.nodes.get(succ, {})
                        if data.get("type") == "symbol" and succ not in seen_ids:
                            kind_w = _KIND_WEIGHTS.get(data.get("kind", ""), 0.5)
                            seeds.append({
                                "symbol_id": succ,
                                "score": confidence * kind_w,
                                "reason": f"in file '{name}'",
                            })
                            seen_ids.add(succ)
            else:
                matches = self.query.find_symbol(name)
                for sid in matches:
                    if sid in seen_ids:
                        continue
                    data = self.graph.nodes.get(sid, {})
                    if data.get("type") != "symbol":
                        continue
                    kind = data.get("kind", "")
                    sym_name = data.get("name", "")

                    if sym_name.lower() == name.lower():
                        match_score = 1.0
                    elif name.lower() in sym_name.lower():
                        match_score = 0.7
                    else:
                        match_score = 0.4

                    kind_w = _KIND_WEIGHTS.get(kind, 0.5)
                    score = confidence * match_score * kind_w

                    if kind == "import" and score < 0.3:
                        continue

                    seeds.append({
                        "symbol_id": sid,
                        "score": score,
                        "reason": f"matches '{name}'",
                    })
                    seen_ids.add(sid)

        if focus_files:
            for fp in focus_files:
                file_node = f"file::{fp}"
                if self.graph.has_node(file_node):
                    for succ in self.graph.successors(file_node):
                        data = self.graph.nodes.get(succ, {})
                        if data.get("type") == "symbol" and succ not in seen_ids:
                            kind_w = _KIND_WEIGHTS.get(data.get("kind", ""), 0.5)
                            seeds.append({
                                "symbol_id": succ,
                                "score": 0.8 * kind_w,
                                "reason": f"in focus file '{fp}'",
                            })
                            seen_ids.add(succ)

        seeds.sort(key=lambda x: x["score"], reverse=True)

        # Cap low-confidence keyword seeds to avoid noise explosion.
        # Keep all high-confidence seeds (>= 0.5), but limit keywords to 5.
        high = [s for s in seeds if s["score"] >= 0.5]
        low = [s for s in seeds if s["score"] < 0.5]
        seeds = high + low[:5]

        return seeds

# src/cegraph/mcp/server.py:483-499
    def _rpc_resources_list(self, params: dict) -> dict:
        """List available resources (codebase files)."""
        resources = []
        try:
            self._ensure_graph()
            for node_id, data in self._graph.nodes(data=True):
                if data.get("type") == "file":
                    fp = data.get("path", "")
                    resources.append({
                        "uri": f"file://{fp}",
                        "name": fp,
                        "mimeType": "text/plain",
                    })
        except Exception:
            pass

        return {"resources": resources}

# src/cegraph/github/renderer.py:151-166
def _render_file_tree(files: list[str]) -> list[str]:
    """Render a list of file paths as an ASCII tree."""
    if not files:
        return []

    # Build tree structure
    tree: dict = {}
    for fp in sorted(files):
        parts = fp.split("/")
        node = tree
        for part in parts:
            node = node.setdefault(part, {})

    lines: list[str] = []
    _render_tree_recursive(tree, "", lines, is_last=True, is_root=True)
    return lines

# src/cegraph/search/lexical.py:157-183
    def _get_searchable_files(self, file_pattern: str) -> list[str]:
        """Get list of files to search."""
        files = []
        if self.graph:
            for node_id, data in self.graph.nodes(data=True):
                if data.get("type") == "file":
                    path = data.get("path", "")
                    if file_pattern:
                        from fnmatch import fnmatch

                        if not fnmatch(path, file_pattern):
                            continue
                    files.append(path)
        else:
            # Scan directory
            import os

            for dirpath, _, filenames in os.walk(self.root):
                for filename in filenames:
                    rel_path = str(Path(dirpath, filename).relative_to(self.root))
                    if file_pattern:
                        from fnmatch import fnmatch

                        if not fnmatch(rel_path, file_pattern):
                            continue
                    files.append(rel_path)
        return sorted(files)

# tests/test_tools.py:50-53
    def test_read_file(self, tmp_project: Path):
        tools = self._build_tools(tmp_project)
        result = tools.read_file("main.py")
        assert "def main" in result

# tests/test_tools.py:72-85
    def test_edit_file(self, tmp_project: Path):
        tools = self._build_tools(tmp_project)

        # Read original
        original = tools.read_file("utils.py")
        assert "TAX_RATE = 0.08" in original

        # Edit
        result = tools.edit_file("utils.py", "TAX_RATE = 0.08", "TAX_RATE = 0.10")
        assert "Successfully" in result

        # Verify edit
        updated = tools.read_file("utils.py")
        assert "TAX_RATE = 0.10" in updated

# tests/test_graph.py:46-55
    def test_symbol_nodes_have_attributes(self, tmp_project: Path):
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)

        for node_id, data in graph.nodes(data=True):
            if data.get("type") == "symbol":
                assert "name" in data
                assert "kind" in data
                assert "file_path" in data
                assert "line_start" in data

# src/cegraph/agent/loop.py:14-14
from typing import Any, AsyncIterator, Callable

# src/cegraph/agent/loop.py:14-14
from typing import Any, AsyncIterator, Callable