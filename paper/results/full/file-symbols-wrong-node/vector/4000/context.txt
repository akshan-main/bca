# src/cegraph/graph/query.py:231-246
    def get_file_symbols(self, file_path: str) -> list[dict]:
        """Get all symbols defined in a file."""
        file_node = f"{file_path}"
        if not self.graph.has_node(file_node):
            return []

        symbols = []
        for succ in self.graph.successors(file_node):
            data = self.graph.nodes.get(succ, {})
            if data.get("type") == "symbol":
                symbols.append({
                    "id": succ,
                    **{k: v for k, v in data.items() if k != "type"},
                })

        return sorted(symbols, key=lambda s: s.get("line_start", 0))

# src/cegraph/agent/loop.py:14-14
from typing import Any, AsyncIterator, Callable

# src/cegraph/config.py:8-8
from typing import Any

# src/cegraph/context/_native.py:20-20
from typing import Any

# src/cegraph/context/models.py:6-6
from typing import Any

# src/cegraph/github/diff_parser.py:14-14
from typing import Any

# src/cegraph/github/impact_bot.py:24-24
from typing import Any

# src/cegraph/github/renderer.py:13-13
from typing import Any

# src/cegraph/llm/anthropic_provider.py:6-6
from typing import Any, AsyncIterator

# src/cegraph/llm/base.py:6-6
from typing import Any, AsyncIterator

# src/cegraph/llm/openai_provider.py:6-6
from typing import Any, AsyncIterator

# src/cegraph/map/app.py:14-14
from typing import Any

# src/cegraph/mcp/server.py:22-22
from typing import Any

# src/cegraph/tools/definitions.py:9-9
from typing import Any

# src/cegraph/tools/registry.py:6-6
from typing import Any, Callable

# examples/demo.py:10-10
from cegraph.graph.query import GraphQuery

# paper/experiments/ablation.py:23-23
from cegraph.graph.query import GraphQuery

# paper/experiments/baselines.py:30-30
from cegraph.graph.query import GraphQuery

# paper/experiments/benchmark.py:57-57
from cegraph.graph.query import GraphQuery

# src/cegraph/context/engine.py:49-49
from cegraph.graph.query import GraphQuery

# src/cegraph/graph/__init__.py:5-5
from cegraph.graph.query import GraphQuery

# src/cegraph/tools/definitions.py:13-13
from cegraph.graph.query import GraphQuery

# tests/test_context.py:17-17
from cegraph.graph.query import GraphQuery

# tests/test_graph.py:11-11
from cegraph.graph.query import GraphQuery

# tests/test_mcp.py:11-11
from cegraph.graph.query import GraphQuery

# tests/test_tools.py:10-10
from cegraph.graph.query import GraphQuery

# src/cegraph/graph/builder.py:15-213
class GraphBuilder:
    """Builds and maintains a code knowledge graph.

    The graph has two types of nodes:
    - File nodes: represent source files
    - Symbol nodes: represent code symbols (functions, classes, etc.)

    Edges represent relationships (calls, imports, inherits, contains, etc.)
    """

    def __init__(self) -> None:
        self.graph = nx.DiGraph()
        self._file_hashes: dict[str, str] = {}
        self._unresolved: list[Relationship] = []

    def build_from_directory(
        self,
        root: str | Path,
        config: ProjectConfig | None = None,
        progress_callback: callable | None = None,
    ) -> nx.DiGraph:
        """Build the full knowledge graph from a directory.

        Args:
            root: Root directory to index.
            config: Project configuration.
            progress_callback: Optional callback(file_path, current, total).

        Returns:
            The constructed NetworkX directed graph.
        """
        root = Path(root).resolve()
        indexer_config = config.indexer if config else IndexerConfig()

        # Reset state so reusing a builder doesn't accumulate stale data
        # self.graph = nx.DiGraph()
        # self._file_hashes = {}
        # self._unresolved = []

        # Parse all files
        all_parsed = parse_directory(root, indexer_config, progress_callback)

        # Build graph from parsed results
        for file_symbols in all_parsed:
            self._add_file(file_symbols, root)

        # Resolve cross-file references
        self._resolve_references()

        return self.graph

    def _add_file(self, fs: FileSymbols, root: Path) -> None:
        """Add a file and its symbols to the graph."""
        file_path = fs.file_path

        # Add file node
        self.graph.add_node(
            f"file::{file_path}",
            type="file",
            path=file_path,
            language=fs.language,
            symbol_count=len(fs.symbols),
            import_count=len(fs.imports),
        )

        # Compute file hash for change detection
        try:
            full_path = root / file_path
            content = full_path.read_bytes()
            self._file_hashes[file_path] = hashlib.sha256(content).hexdigest()[:16]
        except OSError:
            pass

        # Add symbol nodes
        for symbol in fs.symbols:
            attrs = {
                "type": "symbol",
                "name": symbol.name,
                "qualified_name": symbol.qualified_name,
                "kind": symbol.kind.value,
                "file_path": symbol.file_path,
                "line_start": symbol.line_start,
                "line_end": symbol.line_end,
                "signature": symbol.signature,
                "docstring": symbol.docstring,
            }
            self.graph.add_node(symbol.id, **attrs)

            # Link symbol to its file
            self.graph.add_edge(
                f"file::{file_path}",
                symbol.id,
                kind="contains",
            )

        # Add relationships
        for rel in fs.relationships:
            if rel.resolved or self._try_resolve(rel):
                self.graph.add_edge(
                    rel.source,
                    rel.target,
                    kind=rel.kind.value,
                    file_path=rel.file_path,
                    line=rel.line,
                )
            else:
                self._unresolved.append(rel)

    def _try_resolve(self, rel: Relationship) -> bool:
        """Try to resolve a relationship's target to an existing node."""
        target = rel.target

        # Direct match
        if self.graph.has_node(target):
            return True

        # Try finding by name across all files
        for node_id, data in self.graph.nodes(data=True):
            if data.get("type") != "symbol":
                continue
            if data.get("name") == target or data.get("qualified_name") == target:
                rel.target = node_id
                rel.resolved = True
                return True

        return False

    def _resolve_references(self) -> None:
        """Try to resolve all unresolved references after the full graph is built."""
        still_unresolved = []

        # Build a lookup index: name -> [node_ids]
        name_index: dict[str, list[str]] = {}
        for node_id, data in self.graph.nodes(data=True):
            if data.get("type") != "symbol":
                continue
            name = data.get("name", "")
            qname = data.get("qualified_name", "")
            if name:
                name_index.setdefault(name, []).append(node_id)
            if qname and qname != name:
                name_index.setdefault(qname, []).append(node_id)

        for rel in self._unresolved:
            target = rel.target
            # Try exact match by name
            candidates = name_index.get(target, [])

            # Try dotted parts (e.g., "module.func" -> "func")
            if not candidates and "." in target:
                parts = target.split(".")
                candidates = name_index.get(parts[-1], [])

            if candidates:
                # Pick the best candidate (same file first, then any)
                best = None
                for c in candidates:
                    c_data = self.graph.nodes[c]
                    if c_data.get("file_path") == rel.file_path:
                        best = c
                        break
                if best is None:
                    best = candidates[0]

                self.graph.add_edge(
                    rel.source,
                    best,
                    kind=rel.kind.value,
                    file_path=rel.file_path,
                    line=rel.line,
                )
            else:
                still_unresolved.append(rel)

        self._unresolved = still_unresolved

    def get_stats(self) -> dict:
        """Get graph statistics."""
        node_types: dict[str, int] = {}
        edge_types: dict[str, int] = {}

        for _, data in self.graph.nodes(data=True):
            kind = data.get("kind", data.get("type", "unknown"))
            node_types[kind] = node_types.get(kind, 0) + 1

        for _, _, data in self.graph.edges(data=True):
            kind = data.get("kind", "unknown")
            edge_types[kind] = edge_types.get(kind, 0) + 1

        return {
            "total_nodes": self.graph.number_of_nodes(),
            "total_edges": self.graph.number_of_edges(),
            "node_types": node_types,
            "edge_types": edge_types,
            "files": node_types.get("file", 0),
            "functions": node_types.get("function", 0) + node_types.get("method", 0),
            "classes": node_types.get("class", 0),
            "unresolved_refs": len(self._unresolved),
        }

# src/cegraph/github/diff_parser.py:116-177
def get_changed_symbols(
    root: Path, graph, file_diffs: list[FileDiff]
) -> list[ChangedSymbol]:
    """Map diff hunks to symbols using the knowledge graph.

    For each changed line range, find which symbols in the graph
    overlap with those lines.
    """
    changed: list[ChangedSymbol] = []
    seen = set()

    for fd in file_diffs:
        if fd.status == "deleted":
            # All symbols in deleted file are affected
            for node_id, data in graph.nodes(data=True):
                if data.get("type") == "symbol" and data.get("file_path") == fd.path:
                    key = (data.get("name"), fd.path)
                    if key not in seen:
                        changed.append(ChangedSymbol(
                            name=data.get("name", ""),
                            qualified_name=data.get("qualified_name", ""),
                            kind=data.get("kind", ""),
                            file_path=fd.path,
                            line_start=data.get("line_start", 0),
                            line_end=data.get("line_end", 0),
                            change_type="deleted",
                        ))
                        seen.add(key)
            continue

        # For modified/added files, find overlapping symbols
        ranges = fd.changed_line_ranges
        for node_id, data in graph.nodes(data=True):
            if data.get("type") != "symbol":
                continue
            if data.get("file_path") != fd.path:
                continue

            sym_start = data.get("line_start", 0)
            sym_end = data.get("line_end", 0)

            # Check if any hunk overlaps with this symbol
            for r_start, r_end in ranges:
                if sym_start <= r_end and sym_end >= r_start:
                    key = (data.get("name"), fd.path)
                    if key not in seen:
                        overlap = min(sym_end, r_end) - max(sym_start, r_start)
                        change_type = "added" if fd.status == "added" else "modified"
                        changed.append(ChangedSymbol(
                            name=data.get("name", ""),
                            qualified_name=data.get("qualified_name", ""),
                            kind=data.get("kind", ""),
                            file_path=fd.path,
                            line_start=sym_start,
                            line_end=sym_end,
                            change_type=change_type,
                            lines_changed=max(0, overlap),
                        ))
                        seen.add(key)
                    break

    return changed

# src/cegraph/context/engine.py:349-427
    def _find_seeds(
        self, entities: list[dict], focus_files: list[str] | None = None
    ) -> list[dict]:
        """Find seed symbols in the graph matching extracted entities."""
        seeds: list[dict] = []
        seen_ids = set()

        for entity in entities:
            name = entity["name"]
            confidence = entity["confidence"]

            if entity["type"] == "file":
                file_node = f"file::{name}"
                if self.graph.has_node(file_node):
                    for succ in self.graph.successors(file_node):
                        data = self.graph.nodes.get(succ, {})
                        if data.get("type") == "symbol" and succ not in seen_ids:
                            kind_w = _KIND_WEIGHTS.get(data.get("kind", ""), 0.5)
                            seeds.append({
                                "symbol_id": succ,
                                "score": confidence * kind_w,
                                "reason": f"in file '{name}'",
                            })
                            seen_ids.add(succ)
            else:
                matches = self.query.find_symbol(name)
                for sid in matches:
                    if sid in seen_ids:
                        continue
                    data = self.graph.nodes.get(sid, {})
                    if data.get("type") != "symbol":
                        continue
                    kind = data.get("kind", "")
                    sym_name = data.get("name", "")

                    if sym_name.lower() == name.lower():
                        match_score = 1.0
                    elif name.lower() in sym_name.lower():
                        match_score = 0.7
                    else:
                        match_score = 0.4

                    kind_w = _KIND_WEIGHTS.get(kind, 0.5)
                    score = confidence * match_score * kind_w

                    if kind == "import" and score < 0.3:
                        continue

                    seeds.append({
                        "symbol_id": sid,
                        "score": score,
                        "reason": f"matches '{name}'",
                    })
                    seen_ids.add(sid)

        if focus_files:
            for fp in focus_files:
                file_node = f"file::{fp}"
                if self.graph.has_node(file_node):
                    for succ in self.graph.successors(file_node):
                        data = self.graph.nodes.get(succ, {})
                        if data.get("type") == "symbol" and succ not in seen_ids:
                            kind_w = _KIND_WEIGHTS.get(data.get("kind", ""), 0.5)
                            seeds.append({
                                "symbol_id": succ,
                                "score": 0.8 * kind_w,
                                "reason": f"in focus file '{fp}'",
                            })
                            seen_ids.add(succ)

        seeds.sort(key=lambda x: x["score"], reverse=True)

        # Cap low-confidence keyword seeds to avoid noise explosion.
        # Keep all high-confidence seeds (>= 0.5), but limit keywords to 5.
        high = [s for s in seeds if s["score"] >= 0.5]
        low = [s for s in seeds if s["score"] < 0.5]
        seeds = high + low[:5]

        return seeds

# src/cegraph/context/_native.py:269-276
    def topological_sort(self, nodes: list[int]) -> list[int]:
        """Topological sort a subset of nodes."""
        n = len(nodes)
        c_nodes = (ctypes.c_int32 * n)(*nodes)
        out_order = (ctypes.c_int32 * n)()

        count = self._lib.cag_topological_sort(self._handle, c_nodes, n, out_order)
        return [out_order[i] for i in range(count)]

# src/cegraph/github/diff_parser.py:38-43
    def changed_line_ranges(self) -> list[tuple[int, int]]:
        """Get ranges of changed lines in the new file."""
        ranges = []
        for hunk in self.hunks:
            ranges.append((hunk.new_start, hunk.new_start + hunk.new_count))
        return ranges

# src/cegraph/graph/query.py:38-42
    def __init__(self, graph: nx.DiGraph, store: GraphStore | None = None) -> None:
        self.graph = graph
        self.store = store
        self._name_index: dict[str, list[str]] = {}
        self._build_index()