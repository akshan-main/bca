# src/cegraph/graph/query.py:56-64
    def find_symbol(self, name: str) -> list[str]:
        """Find symbol node IDs matching a name (exact or qualified)."""
        results = self._name_index.get(name, [])
        if not results:
            # Try partial match
            for key, ids in self._name_index.items():
                if name.lower() == key.lower():
                    results.extend(ids)
        return list(set(results))

# tests/test_graph.py:165-168
    def test_find_symbol_partial(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        results = query.find_symbol("helper")
        assert len(results) > 0

# tests/test_graph.py:160-163
    def test_find_symbol(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        results = query.find_symbol("main")
        assert len(results) > 0

# src/cegraph/parser/core.py:5-5
import fnmatch

# src/cegraph/parser/core.py:133-144
def _should_exclude(path: str, patterns: list[str]) -> bool:
    """Check if a path matches any exclusion pattern."""
    path_parts = Path(path).parts
    for pattern in patterns:
        # Check against full path
        if fnmatch.fnmatch(path, pattern):
            return True
        # Check against any path component
        for part in path_parts:
            if fnmatch.fnmatch(part, pattern):
                return True
    return False

# src/cegraph/search/lexical.py:185-209
    def _score_match(self, query: str, line: str, file_path: str) -> float:
        """Score a match based on quality heuristics."""
        score = 1.0

        # Exact case match bonus
        if query in line:
            score += 0.5

        # Definition bonus (line starts with def, class, function, etc.)
        stripped = line.strip()
        if any(
            stripped.startswith(kw)
            for kw in ("def ", "class ", "function ", "const ", "let ", "var ", "fn ", "func ", "pub ")
        ):
            score += 1.0

        # Shorter lines are usually more relevant
        if len(stripped) < 80:
            score += 0.3

        # Test files penalty
        if "test" in file_path.lower():
            score -= 0.3

        return score

# tests/test_graph.py:196-201
    def test_get_file_symbols(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        symbols = query.get_file_symbols("main.py")
        assert len(symbols) > 0
        names = [s["name"] for s in symbols]
        assert "main" in names

# src/cegraph/graph/query.py:231-246
    def get_file_symbols(self, file_path: str) -> list[dict]:
        """Get all symbols defined in a file."""
        file_node = f"file::{file_path}"
        if not self.graph.has_node(file_node):
            return []

        symbols = []
        for succ in self.graph.successors(file_node):
            data = self.graph.nodes.get(succ, {})
            if data.get("type") == "symbol":
                symbols.append({
                    "id": succ,
                    **{k: v for k, v in data.items() if k != "type"},
                })

        return sorted(symbols, key=lambda s: s.get("line_start", 0))

# src/cegraph/mcp/server.py:37-37
    SERVER_NAME = "cegraph"

# src/cegraph/graph/query.py:44-54
    def _build_index(self) -> None:
        """Build a name->node_id lookup index."""
        for node_id, data in self.graph.nodes(data=True):
            if data.get("type") != "symbol":
                continue
            name = data.get("name", "")
            qname = data.get("qualified_name", "")
            if name:
                self._name_index.setdefault(name, []).append(node_id)
            if qname and qname != name:
                self._name_index.setdefault(qname, []).append(node_id)

# src/cegraph/parser/tree_sitter_parser.py:207-217
def _extract_name(node, language: str) -> str:
    """Extract the name of a symbol from its tree-sitter node."""
    # Look for a name/identifier child
    for child in node.children:
        if child.type in ("identifier", "name", "type_identifier", "property_identifier"):
            return child.text.decode("utf-8")
    # For some languages, try named children
    name_child = node.child_by_field_name("name")
    if name_child:
        return name_child.text.decode("utf-8")
    return ""