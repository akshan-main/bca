# src/cegraph/graph/query.py:56-64
    def find_symbol(self, name: str) -> list[str]:
        """Find symbol node IDs matching a name (exact or qualified)."""
        results = self._name_index.get(name, [])
        if not results:
            # Try partial match
            for key, ids in self._name_index.items():
                if name.lower() == key.lower():
                    results.extend(ids)
        return list(set(results))

# tests/test_graph.py:165-168
    def test_find_symbol_partial(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        results = query.find_symbol("helper")
        assert len(results) > 0

# src/cegraph/graph/query.py:162-183
    def what_calls(self, name: str) -> list[dict]:
        """Find all symbols called by the given symbol."""
        symbol_ids = self.find_symbol(name)
        results = []

        for sid in symbol_ids:
            for succ in self.graph.successors(sid):
                edge_data = self.graph.edges[sid, succ]
                if edge_data.get("kind") != "calls":
                    continue
                succ_data = self.graph.nodes.get(succ, {})
                if succ_data.get("type") != "symbol":
                    continue
                results.append({
                    "symbol_id": succ,
                    "name": succ_data.get("qualified_name", succ_data.get("name", "")),
                    "kind": succ_data.get("kind", ""),
                    "file_path": succ_data.get("file_path", ""),
                    "line": succ_data.get("line_start", 0),
                })

        return results

# src/cegraph/graph/store.py:410-445
    def search_symbols(
        self,
        query: str = "",
        kind: str = "",
        file_path: str = "",
        limit: int = 50,
    ) -> list[dict]:
        """Search symbols using the indexed SQLite tables."""
        conn = self._get_conn()
        conditions = ["n.node_type = 'symbol'"]
        params: list = []

        if query:
            conditions.append("(n.name LIKE ? OR n.qualified_name LIKE ? OR n.signature LIKE ?)")
            like = f"%{query}%"
            params.extend([like, like, like])
        if kind:
            conditions.append("n.kind = ?")
            params.append(kind)
        if file_path:
            conditions.append("p.path LIKE ?")
            params.append(f"%{file_path}%")

        where = " AND ".join(conditions)
        rows = conn.execute(
            f"""SELECT (p.path || '::' || n.qualified_name) as id,
                       n.name, n.qualified_name, n.kind,
                       p.path as file_path, n.line_start, n.line_end,
                       n.signature, n.docstring
                FROM nodes n
                JOIN path_map p ON p.pid = n.path_id
                WHERE {where} LIMIT ?""",
            params + [limit],
        ).fetchall()

        return [dict(row) for row in rows]

# src/cegraph/search/lexical.py:105-155
    def search_symbols(
        self, query: str, kind: str = "", max_results: int = 20
    ) -> list[dict]:
        """Search through symbol definitions in the knowledge graph."""
        if not self.graph:
            return []

        results = []
        query_lower = query.lower()

        for node_id, data in self.graph.nodes(data=True):
            if data.get("type") != "symbol":
                continue

            name = data.get("name", "")
            qname = data.get("qualified_name", "")
            sig = data.get("signature", "")
            doc = data.get("docstring", "")
            sym_kind = data.get("kind", "")

            if kind and sym_kind != kind:
                continue

            # Score based on match quality
            score = 0.0
            if query_lower == name.lower():
                score = 1.0
            elif query_lower in name.lower():
                score = 0.8
            elif query_lower in qname.lower():
                score = 0.6
            elif query_lower in sig.lower():
                score = 0.4
            elif query_lower in doc.lower():
                score = 0.3
            else:
                continue

            results.append({
                "id": node_id,
                "name": name,
                "qualified_name": qname,
                "kind": sym_kind,
                "file_path": data.get("file_path", ""),
                "line": data.get("line_start", 0),
                "signature": sig,
                "score": score,
            })

        results.sort(key=lambda r: r["score"], reverse=True)
        return results[:max_results]

# tests/test_graph.py:160-163
    def test_find_symbol(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        results = query.find_symbol("main")
        assert len(results) > 0

# src/cegraph/tools/definitions.py:62-75
    def search_symbols(self, query: str, kind: str = "", max_results: int = 10) -> str:
        """Search for symbol definitions (functions, classes, etc.)."""
        results = self.search.search_symbols(query, kind, max_results)
        if not results:
            return f"No symbols found matching '{query}'"

        output = []
        for r in results:
            output.append(
                f"- **{r['qualified_name']}** ({r['kind']}) at {r['file_path']}:{r['line']}"
            )
            if r.get("signature"):
                output.append(f"  `{r['signature']}`")
        return "\n".join(output)

# src/cegraph/search/hybrid.py:49-51
    def search_symbols(self, query: str, kind: str = "", max_results: int = 20) -> list[dict]:
        """Search symbols using lexical + optional semantic."""
        return self.lexical.search_symbols(query, kind, max_results)

# src/cegraph/graph/query.py:66-120
    def get_symbol_info(self, symbol_id: str) -> SymbolInfo | None:
        """Get detailed information about a symbol."""
        if not self.graph.has_node(symbol_id):
            return None

        data = self.graph.nodes[symbol_id]
        if data.get("type") != "symbol":
            return None

        # Get callers (reverse edges with kind=calls)
        callers = []
        for pred in self.graph.predecessors(symbol_id):
            edge_data = self.graph.edges[pred, symbol_id]
            if edge_data.get("kind") == "calls":
                callers.append(pred)

        # Get callees (forward edges with kind=calls)
        callees = []
        for succ in self.graph.successors(symbol_id):
            edge_data = self.graph.edges[symbol_id, succ]
            if edge_data.get("kind") == "calls":
                callees.append(succ)

        # Get children (contains edges)
        children = []
        for succ in self.graph.successors(symbol_id):
            edge_data = self.graph.edges[symbol_id, succ]
            if edge_data.get("kind") == "contains":
                children.append(succ)

        # Get parent
        parent = ""
        for pred in self.graph.predecessors(symbol_id):
            edge_data = self.graph.edges[pred, symbol_id]
            if edge_data.get("kind") == "contains":
                pred_data = self.graph.nodes.get(pred, {})
                if pred_data.get("type") == "symbol":
                    parent = pred
                    break

        return SymbolInfo(
            id=symbol_id,
            name=data.get("name", ""),
            qualified_name=data.get("qualified_name", ""),
            kind=data.get("kind", ""),
            file_path=data.get("file_path", ""),
            line_start=data.get("line_start", 0),
            line_end=data.get("line_end", 0),
            signature=data.get("signature", ""),
            docstring=data.get("docstring", ""),
            callers=callers,
            callees=callees,
            children=children,
            parent=parent,
        )

# tests/test_context.py:17-17
from cegraph.graph.query import GraphQuery

# paper/experiments/ablation.py:23-23
from cegraph.graph.query import GraphQuery