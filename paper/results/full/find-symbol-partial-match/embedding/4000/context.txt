# src/cegraph/graph/query.py:56-64
    def find_symbol(self, name: str) -> list[str]:
        """Find symbol node IDs matching a name (exact or qualified)."""
        results = self._name_index.get(name, [])
        if not results:
            # Try partial match
            for key, ids in self._name_index.items():
                if name.lower() == key.lower():
                    results.extend(ids)
        return list(set(results))

# tests/test_graph.py:165-168
    def test_find_symbol_partial(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        results = query.find_symbol("helper")
        assert len(results) > 0

# src/cegraph/graph/query.py:162-183
    def what_calls(self, name: str) -> list[dict]:
        """Find all symbols called by the given symbol."""
        symbol_ids = self.find_symbol(name)
        results = []

        for sid in symbol_ids:
            for succ in self.graph.successors(sid):
                edge_data = self.graph.edges[sid, succ]
                if edge_data.get("kind") != "calls":
                    continue
                succ_data = self.graph.nodes.get(succ, {})
                if succ_data.get("type") != "symbol":
                    continue
                results.append({
                    "symbol_id": succ,
                    "name": succ_data.get("qualified_name", succ_data.get("name", "")),
                    "kind": succ_data.get("kind", ""),
                    "file_path": succ_data.get("file_path", ""),
                    "line": succ_data.get("line_start", 0),
                })

        return results

# src/cegraph/graph/store.py:410-445
    def search_symbols(
        self,
        query: str = "",
        kind: str = "",
        file_path: str = "",
        limit: int = 50,
    ) -> list[dict]:
        """Search symbols using the indexed SQLite tables."""
        conn = self._get_conn()
        conditions = ["n.node_type = 'symbol'"]
        params: list = []

        if query:
            conditions.append("(n.name LIKE ? OR n.qualified_name LIKE ? OR n.signature LIKE ?)")
            like = f"%{query}%"
            params.extend([like, like, like])
        if kind:
            conditions.append("n.kind = ?")
            params.append(kind)
        if file_path:
            conditions.append("p.path LIKE ?")
            params.append(f"%{file_path}%")

        where = " AND ".join(conditions)
        rows = conn.execute(
            f"""SELECT (p.path || '::' || n.qualified_name) as id,
                       n.name, n.qualified_name, n.kind,
                       p.path as file_path, n.line_start, n.line_end,
                       n.signature, n.docstring
                FROM nodes n
                JOIN path_map p ON p.pid = n.path_id
                WHERE {where} LIMIT ?""",
            params + [limit],
        ).fetchall()

        return [dict(row) for row in rows]

# src/cegraph/search/lexical.py:105-155
    def search_symbols(
        self, query: str, kind: str = "", max_results: int = 20
    ) -> list[dict]:
        """Search through symbol definitions in the knowledge graph."""
        if not self.graph:
            return []

        results = []
        query_lower = query.lower()

        for node_id, data in self.graph.nodes(data=True):
            if data.get("type") != "symbol":
                continue

            name = data.get("name", "")
            qname = data.get("qualified_name", "")
            sig = data.get("signature", "")
            doc = data.get("docstring", "")
            sym_kind = data.get("kind", "")

            if kind and sym_kind != kind:
                continue

            # Score based on match quality
            score = 0.0
            if query_lower == name.lower():
                score = 1.0
            elif query_lower in name.lower():
                score = 0.8
            elif query_lower in qname.lower():
                score = 0.6
            elif query_lower in sig.lower():
                score = 0.4
            elif query_lower in doc.lower():
                score = 0.3
            else:
                continue

            results.append({
                "id": node_id,
                "name": name,
                "qualified_name": qname,
                "kind": sym_kind,
                "file_path": data.get("file_path", ""),
                "line": data.get("line_start", 0),
                "signature": sig,
                "score": score,
            })

        results.sort(key=lambda r: r["score"], reverse=True)
        return results[:max_results]

# tests/test_graph.py:160-163
    def test_find_symbol(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        results = query.find_symbol("main")
        assert len(results) > 0

# src/cegraph/tools/definitions.py:62-75
    def search_symbols(self, query: str, kind: str = "", max_results: int = 10) -> str:
        """Search for symbol definitions (functions, classes, etc.)."""
        results = self.search.search_symbols(query, kind, max_results)
        if not results:
            return f"No symbols found matching '{query}'"

        output = []
        for r in results:
            output.append(
                f"- **{r['qualified_name']}** ({r['kind']}) at {r['file_path']}:{r['line']}"
            )
            if r.get("signature"):
                output.append(f"  `{r['signature']}`")
        return "\n".join(output)

# src/cegraph/search/hybrid.py:49-51
    def search_symbols(self, query: str, kind: str = "", max_results: int = 20) -> list[dict]:
        """Search symbols using lexical + optional semantic."""
        return self.lexical.search_symbols(query, kind, max_results)

# src/cegraph/graph/query.py:66-120
    def get_symbol_info(self, symbol_id: str) -> SymbolInfo | None:
        """Get detailed information about a symbol."""
        if not self.graph.has_node(symbol_id):
            return None

        data = self.graph.nodes[symbol_id]
        if data.get("type") != "symbol":
            return None

        # Get callers (reverse edges with kind=calls)
        callers = []
        for pred in self.graph.predecessors(symbol_id):
            edge_data = self.graph.edges[pred, symbol_id]
            if edge_data.get("kind") == "calls":
                callers.append(pred)

        # Get callees (forward edges with kind=calls)
        callees = []
        for succ in self.graph.successors(symbol_id):
            edge_data = self.graph.edges[symbol_id, succ]
            if edge_data.get("kind") == "calls":
                callees.append(succ)

        # Get children (contains edges)
        children = []
        for succ in self.graph.successors(symbol_id):
            edge_data = self.graph.edges[symbol_id, succ]
            if edge_data.get("kind") == "contains":
                children.append(succ)

        # Get parent
        parent = ""
        for pred in self.graph.predecessors(symbol_id):
            edge_data = self.graph.edges[pred, symbol_id]
            if edge_data.get("kind") == "contains":
                pred_data = self.graph.nodes.get(pred, {})
                if pred_data.get("type") == "symbol":
                    parent = pred
                    break

        return SymbolInfo(
            id=symbol_id,
            name=data.get("name", ""),
            qualified_name=data.get("qualified_name", ""),
            kind=data.get("kind", ""),
            file_path=data.get("file_path", ""),
            line_start=data.get("line_start", 0),
            line_end=data.get("line_end", 0),
            signature=data.get("signature", ""),
            docstring=data.get("docstring", ""),
            callers=callers,
            callees=callees,
            children=children,
            parent=parent,
        )

# tests/test_cli.py:55-60
    def test_search_symbol(self, runner: CliRunner, indexed_project: Path):
        result = runner.invoke(
            main, ["search", "User", "--path", str(indexed_project)]
        )
        assert result.exit_code == 0
        assert "User" in result.output

# tests/test_graph.py:213-226
    def test_get_symbol_info(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        symbol_ids = query.find_symbol("User")
        assert len(symbol_ids) > 0
        # Find the class definition (not import)
        class_info = None
        for sid in symbol_ids:
            info = query.get_symbol_info(sid)
            if info and info.kind == "class":
                class_info = info
                break
        assert class_info is not None
        assert class_info.name == "User"
        assert class_info.kind == "class"

# tests/test_context.py:17-17
from cegraph.graph.query import GraphQuery

# examples/demo.py:10-10
from cegraph.graph.query import GraphQuery

# paper/experiments/ablation.py:23-23
from cegraph.graph.query import GraphQuery

# src/cegraph/context/engine.py:49-49
from cegraph.graph.query import GraphQuery

# src/cegraph/graph/__init__.py:5-5
from cegraph.graph.query import GraphQuery

# src/cegraph/tools/definitions.py:13-13
from cegraph.graph.query import GraphQuery

# tests/test_graph.py:11-11
from cegraph.graph.query import GraphQuery

# tests/test_mcp.py:11-11
from cegraph.graph.query import GraphQuery

# tests/test_tools.py:10-10
from cegraph.graph.query import GraphQuery

# paper/experiments/benchmark.py:57-57
from cegraph.graph.query import GraphQuery

# paper/experiments/baselines.py:30-30
from cegraph.graph.query import GraphQuery

# src/cegraph/tools/definitions.py:91-102
    def what_calls(self, symbol_name: str) -> str:
        """Find all symbols called by a function/method."""
        results = self.query.what_calls(symbol_name)
        if not results:
            return f"No callees found for '{symbol_name}'"

        output = [f"`{symbol_name}` calls:"]
        for r in results:
            output.append(
                f"â†’ **{r['name']}** ({r['kind']}) at {r['file_path']}:{r['line']}"
            )
        return "\n".join(output)

# src/cegraph/cli.py:168-195
def search(query: str, path: str | None, kind: str):
    """Search for code or symbols in the repository."""
    root = _get_project_root(path)
    graph, store = _load_graph(root)

    from cegraph.search.hybrid import HybridSearch

    search_engine = HybridSearch(root, graph)

    # Try symbol search first
    symbol_results = search_engine.search_symbols(query, kind=kind)
    if symbol_results:
        console.info(f"Found {len(symbol_results)} symbol(s) matching '{query}':")
        console.show_search_results(symbol_results)
    else:
        console.info(f"No symbol definitions found for '{query}', searching code...")
        code_results = search_engine.search(query)
        if code_results:
            for r in code_results:
                console.console.print(
                    f"  [cyan]{r.file_path}:{r.line_number}[/cyan] {r.line_content.strip()}"
                )
                if r.symbol_name:
                    console.console.print(f"    [dim]in {r.symbol_name}[/dim]")
        else:
            console.warning(f"No results found for '{query}'")

    store.close()

# src/cegraph/graph/query.py:270-315
    def find_related(self, name: str, max_hops: int = 2) -> list[dict]:
        """Find symbols related to the given one within N hops."""
        symbol_ids = self.find_symbol(name)
        if not symbol_ids:
            return []

        related = set()
        visited = set()

        def _bfs(start: str, hops: int) -> None:
            if hops > max_hops or start in visited:
                return
            visited.add(start)

            # Forward edges
            for succ in self.graph.successors(start):
                succ_data = self.graph.nodes.get(succ, {})
                if succ_data.get("type") == "symbol":
                    related.add(succ)
                    _bfs(succ, hops + 1)

            # Backward edges
            for pred in self.graph.predecessors(start):
                pred_data = self.graph.nodes.get(pred, {})
                if pred_data.get("type") == "symbol":
                    related.add(pred)
                    _bfs(pred, hops + 1)

        for sid in symbol_ids:
            _bfs(sid, 0)

        # Remove the original symbols
        related -= set(symbol_ids)

        results = []
        for node_id in related:
            data = self.graph.nodes.get(node_id, {})
            results.append({
                "symbol_id": node_id,
                "name": data.get("qualified_name", data.get("name", "")),
                "kind": data.get("kind", ""),
                "file_path": data.get("file_path", ""),
                "line": data.get("line_start", 0),
            })

        return results

# src/cegraph/github/impact_bot.py:26-33
from cegraph.github.diff_parser import (
    ChangedSymbol,
    FileDiff,
    get_changed_symbols,
    get_git_diff,
    get_pr_diff,
    parse_diff,
)

# tests/test_impact_bot.py:9-15
from cegraph.github.diff_parser import (
    DiffHunk,
    FileDiff,
    ChangedSymbol,
    get_changed_symbols,
    parse_diff,
)

# src/cegraph/github/renderer.py:15-15
from cegraph.github.diff_parser import ChangedSymbol

# src/cegraph/github/diff_parser.py:116-177
def get_changed_symbols(
    root: Path, graph, file_diffs: list[FileDiff]
) -> list[ChangedSymbol]:
    """Map diff hunks to symbols using the knowledge graph.

    For each changed line range, find which symbols in the graph
    overlap with those lines.
    """
    changed: list[ChangedSymbol] = []
    seen = set()

    for fd in file_diffs:
        if fd.status == "deleted":
            # All symbols in deleted file are affected
            for node_id, data in graph.nodes(data=True):
                if data.get("type") == "symbol" and data.get("file_path") == fd.path:
                    key = (data.get("name"), fd.path)
                    if key not in seen:
                        changed.append(ChangedSymbol(
                            name=data.get("name", ""),
                            qualified_name=data.get("qualified_name", ""),
                            kind=data.get("kind", ""),
                            file_path=fd.path,
                            line_start=data.get("line_start", 0),
                            line_end=data.get("line_end", 0),
                            change_type="deleted",
                        ))
                        seen.add(key)
            continue

        # For modified/added files, find overlapping symbols
        ranges = fd.changed_line_ranges
        for node_id, data in graph.nodes(data=True):
            if data.get("type") != "symbol":
                continue
            if data.get("file_path") != fd.path:
                continue

            sym_start = data.get("line_start", 0)
            sym_end = data.get("line_end", 0)

            # Check if any hunk overlaps with this symbol
            for r_start, r_end in ranges:
                if sym_start <= r_end and sym_end >= r_start:
                    key = (data.get("name"), fd.path)
                    if key not in seen:
                        overlap = min(sym_end, r_end) - max(sym_start, r_start)
                        change_type = "added" if fd.status == "added" else "modified"
                        changed.append(ChangedSymbol(
                            name=data.get("name", ""),
                            qualified_name=data.get("qualified_name", ""),
                            kind=data.get("kind", ""),
                            file_path=fd.path,
                            line_start=sym_start,
                            line_end=sym_end,
                            change_type=change_type,
                            lines_changed=max(0, overlap),
                        ))
                        seen.add(key)
                    break

    return changed

# tests/test_graph.py:196-201
    def test_get_file_symbols(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        symbols = query.get_file_symbols("main.py")
        assert len(symbols) > 0
        names = [s["name"] for s in symbols]
        assert "main" in names

# tests/test_parser.py:7-7
from cegraph.parser.models import SymbolKind, RelKind, detect_language