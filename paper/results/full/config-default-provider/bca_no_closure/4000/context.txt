# Codebase Context for: Default LLM provider is set to openai instead of anthropic, breaking configurations that rely on the anthropic default.
# 44 symbols from 19 files (~3,949 tokens, 99% of budget)

## paper/experiments/baselines.py
# Included because: graph expansion (depth 3)

# [class] BaselineResult (relevance: 0.23, depth: 3)
  34 | class BaselineResult:
  35 |     """Result of a single baseline run."""
  36 | 
  37 |     method: str
  38 |     task: str
  39 |     budget: int
  40 |     tokens_used: int
  41 |     symbols_selected: int
  42 |     files_included: int
  43 |     assembly_time_ms: float
  44 |     selected_symbols: list[str] = field(default_factory=list)
  45 |     recall: float | None = None

## src/cegraph/cli.py
# Included because: graph expansion (depth 3)

# [function] _get_project_root (relevance: 0.41, depth: 3)
  28 | def _get_project_root(path: str | None = None) -> Path:
  29 |     """Find the project root or error."""
  30 |     if path:
  31 |         root = Path(path).resolve()
  32 |         if not root.exists():
  33 |             console.error(f"Path does not exist: {path}")
  34 |             sys.exit(1)
  35 |         return root
  36 | 
  37 |     root = find_project_root()
  38 |     if root is None:
  39 |         console.error(
  40 |             "No CeGraph project found. Run 'cegraph init' first, "
  41 |             "or specify a path with --path."
  42 |         )
  43 |         sys.exit(1)
  44 |     return root

# [function] _load_graph (relevance: 0.39, depth: 3)
  47 | def _load_graph(root: Path):
  48 |     """Load the knowledge graph and related objects."""
  49 |     from cegraph.graph.store import GraphStore
  50 | 
  51 |     db_path = get_cegraph_dir(root) / GRAPH_DB_FILE
  52 |     store = GraphStore(db_path)
  53 |     graph = store.load()
  54 |     if graph is None:
  55 |         console.error("No index found. Run 'cegraph init' or 'cegraph reindex' first.")
  56 |         sys.exit(1)
  57 |     return graph, store

## src/cegraph/config.py
# Included because: graph expansion (depth 2); matches 'set'

# [method] LLMConfig.api_key (relevance: 0.21, depth: 2)
  29 |     def api_key(self) -> str | None:
  30 |         if self.api_key_env:
  31 |             return os.environ.get(self.api_key_env)
  32 |         # Try common env vars
  33 |         env_map = {
  34 |             "openai": "OPENAI_API_KEY",
  35 |             "anthropic": "ANTHROPIC_API_KEY",
  36 |         }
  37 |         env_var = env_map.get(self.provider, "")
  38 |         return os.environ.get(env_var)

# [function] set_config_value (relevance: 0.40, depth: 0)
 125 | def set_config_value(config: ProjectConfig, key: str, value: Any) -> ProjectConfig:
 126 |     """Set a nested config value using dot notation (e.g., 'llm.provider')."""
 127 |     parts = key.split(".")
 128 |     data = config.model_dump()
 129 |     target = data
 130 |     for part in parts[:-1]:
 131 |         if part not in target or not isinstance(target[part], dict):
 132 |             raise KeyError(f"Invalid config key: {key}")
 133 |         target = target[part]
 134 |     if parts[-1] not in target:
 135 |         raise KeyError(f"Invalid config key: {key}")
 136 |     target[parts[-1]] = value
 137 |     return ProjectConfig(**data)

## src/cegraph/context/engine.py
# Included because: graph expansion (depth 2)

# [method] ContextAssembler._token_cost (relevance: 0.21, depth: 2)
 898 |     def _token_cost(self, symbol_id: str, cand: dict | None = None) -> int:
 899 |         """Compute token cost c(v) for a symbol."""
 900 |         data = self.graph.nodes.get(symbol_id, {})
 901 |         line_start = data.get("line_start", 0)
 902 |         line_end = data.get("line_end", 0)
 903 |         line_count = max(1, line_end - line_start + 1)
 904 |         return TokenEstimator.estimate_lines(line_count)

## src/cegraph/context/models.py
# Included because: graph expansion (depth 2)

# [method] TokenEstimator.estimate_lines (relevance: 0.27, depth: 2)
 171 |     def estimate_lines(cls, line_count: int, avg_line_length: int = 40) -> int:
 172 |         """Estimate tokens for a given number of lines."""
 173 |         return max(1, int(line_count * avg_line_length / cls.CHARS_PER_TOKEN))

## src/cegraph/exceptions.py
# Included because: graph expansion (depth 2); graph expansion (depth 3)

# [class] LLMError (relevance: 0.20, depth: 3)
  20 | class LLMError(CeGraphError):
  21 |     """LLM provider errors."""

# [class] ProviderNotAvailable (relevance: 0.25, depth: 2)
  32 | class ProviderNotAvailable(LLMError):
  33 |     """Raised when an LLM provider's SDK is not installed."""
  34 | 
  35 |     def __init__(self, provider: str, package: str):
  36 |         super().__init__(
  37 |             f"Provider '{provider}' requires the '{package}' package. "
  38 |             f"Install it with: pip install cegraph[{provider}]"
  39 |         )

## src/cegraph/github/diff_parser.py
# Included because: graph expansion (depth 2)

# [function] get_pr_diff (relevance: 0.21, depth: 2)
 205 | def get_pr_diff(root: Path) -> str:
 206 |     """Get the diff for the current PR (GitHub Actions context)."""
 207 |     import os
 208 |     base_ref = os.environ.get("GITHUB_BASE_REF", "main")
 209 |     return get_git_diff(root, base=f"origin/{base_ref}")

## src/cegraph/github/renderer.py
# Included because: graph expansion (depth 3)

# [function] _risk_badge (relevance: 0.23, depth: 3)
 137 | def _risk_badge(risk: float) -> tuple[str, str, str]:
 138 |     """Return (emoji, label, color) for a risk score."""
 139 |     if risk < 0.1:
 140 |         return ("ðŸŸ¢", "LOW", "green")
 141 |     elif risk < 0.2:
 142 |         return ("ðŸŸ¡", "LOW", "yellow")
 143 |     elif risk < 0.4:
 144 |         return ("ðŸŸ ", "MEDIUM", "orange")
 145 |     elif risk < 0.6:
 146 |         return ("ðŸ”´", "HIGH", "red")
 147 |     else:
 148 |         return ("â›”", "CRITICAL", "red")

# [function] _footer (relevance: 0.15, depth: 3)
 192 | def _footer() -> str:
 193 |     return (
 194 |         "---\n"
 195 |         "*Powered by [CeGraph](https://github.com/cegraph-ai/cegraph) "
 196 |         "â€” CAG-driven code intelligence*"
 197 |     )

## src/cegraph/graph/query.py
# Included because: graph expansion (depth 2)

# [method] GraphQuery._build_index (relevance: 0.20, depth: 2)
  44 |     def _build_index(self) -> None:
  45 |         """Build a name->node_id lookup index."""
  46 |         for node_id, data in self.graph.nodes(data=True):
  47 |             if data.get("type") != "symbol":
  48 |                 continue
  49 |             name = data.get("name", "")
  50 |             qname = data.get("qualified_name", "")
  51 |             if name:
  52 |                 self._name_index.setdefault(name, []).append(node_id)
  53 |             if qname and qname != name:
  54 |                 self._name_index.setdefault(qname, []).append(node_id)

# [method] GraphQuery.find_symbol (relevance: 0.40, depth: 2)
  56 |     def find_symbol(self, name: str) -> list[str]:
  57 |         """Find symbol node IDs matching a name (exact or qualified)."""
  58 |         results = self._name_index.get(name, [])
  59 |         if not results:
  60 |             # Try partial match
  61 |             for key, ids in self._name_index.items():
  62 |                 if name.lower() in key.lower():
  63 |                     results.extend(ids)
  64 |         return list(set(results))

## src/cegraph/llm/anthropic_provider.py
# Included because: graph expansion (depth 1)

# [method] AnthropicProvider.__init__ (relevance: 0.29, depth: 1)
  20 |     def __init__(
  21 |         self,
  22 |         model: str = "claude-sonnet-4-5-20250929",
  23 |         api_key: str | None = None,
  24 |         base_url: str | None = None,
  25 |     ) -> None:
  26 |         super().__init__(model, api_key, base_url)
  27 |         self._client = None

# [method] AnthropicProvider._get_client (relevance: 0.33, depth: 1)
  29 |     def _get_client(self):
  30 |         if self._client is None:
  31 |             try:
  32 |                 from anthropic import AsyncAnthropic
  33 |             except ImportError:
  34 |                 from cegraph.exceptions import ProviderNotAvailable
  35 |                 raise ProviderNotAvailable("anthropic", "anthropic")
  36 | 
  37 |             kwargs: dict[str, Any] = {}
  38 |             if self.api_key:
  39 |                 kwargs["api_key"] = self.api_key
  40 |             if self.base_url:
  41 |                 kwargs["base_url"] = self.base_url
  42 |             self._client = AsyncAnthropic(**kwargs)
  43 |         return self._client

# [method] AnthropicProvider._format_tools (relevance: 0.31, depth: 1)
  86 |     def _format_tools(self, tools: list[ToolDefinition]) -> list[dict]:
  87 |         """Convert tool definitions to Anthropic's format."""
  88 |         return [
  89 |             {
  90 |                 "name": tool.name,
  91 |                 "description": tool.description,
  92 |                 "input_schema": tool.parameters,
  93 |             }
  94 |             for tool in tools
  95 |         ]

## src/cegraph/llm/openai_provider.py
# Included because: graph expansion (depth 1)

# [method] OpenAIProvider.__init__ (relevance: 0.29, depth: 1)
  20 |     def __init__(
  21 |         self, model: str = "gpt-4o", api_key: str | None = None, base_url: str | None = None
  22 |     ) -> None:
  23 |         super().__init__(model, api_key, base_url)
  24 |         self._client = None
  25 |         self._async_client = None

# [method] OpenAIProvider._get_client (relevance: 0.33, depth: 1)
  27 |     def _get_client(self):
  28 |         if self._async_client is None:
  29 |             try:
  30 |                 from openai import AsyncOpenAI
  31 |             except ImportError:
  32 |                 from cegraph.exceptions import ProviderNotAvailable
  33 |                 raise ProviderNotAvailable("openai", "openai")
  34 | 
  35 |             kwargs: dict[str, Any] = {}
  36 |             if self.api_key:
  37 |                 kwargs["api_key"] = self.api_key
  38 |             if self.base_url:
  39 |                 kwargs["base_url"] = self.base_url
  40 |             self._async_client = AsyncOpenAI(**kwargs)
  41 |         return self._async_client

# [method] OpenAIProvider._format_tools (relevance: 0.31, depth: 1)
  76 |     def _format_tools(self, tools: list[ToolDefinition]) -> list[dict]:
  77 |         """Convert tool definitions to OpenAI's format."""
  78 |         return [
  79 |             {
  80 |                 "type": "function",
  81 |                 "function": {
  82 |                     "name": tool.name,
  83 |                     "description": tool.description,
  84 |                     "parameters": tool.parameters,
  85 |                 },
  86 |             }
  87 |             for tool in tools
  88 |         ]

## src/cegraph/mcp/server.py
# Included because: graph expansion (depth 2)

# [method] MCPServer._tool_who_calls (relevance: 0.23, depth: 2)
 269 |     def _tool_who_calls(self, args: dict) -> str:
 270 |         self._ensure_graph()
 271 |         callers = self._query.who_calls(
 272 |             args["symbol"], max_depth=args.get("max_depth", 3)
 273 |         )
 274 |         if not callers:
 275 |             return f"No callers found for '{args['symbol']}'"
 276 | 
 277 |         lines = [f"Callers of '{args['symbol']}':"]
 278 |         for c in callers:
 279 |             indent = "  " * c.get("depth", 1)
 280 |             lines.append(f"{indent}{c['name']} ({c['kind']}) at {c['file_path']}:{c['line']}")
 281 |         return "\n".join(lines)

# [method] MCPServer._tool_find_related (relevance: 0.23, depth: 2)
 333 |     def _tool_find_related(self, args: dict) -> str:
 334 |         self._ensure_graph()
 335 |         related = self._query.find_related(args["symbol"])
 336 |         if not related:
 337 |             return f"No related symbols found for '{args['symbol']}'"
 338 | 
 339 |         lines = [f"Related to '{args['symbol']}':"]
 340 |         for r in related:
 341 |             lines.append(f"  {r['name']} ({r['kind']}) â€” {r.get('relation', 'related')}")
 342 |         return "\n".join(lines)

# [method] MCPServer._handle_notification (relevance: 0.21, depth: 2)
 424 |     def _handle_notification(self, method: str, params: dict) -> None:
 425 |         """Handle a notification (no response needed)."""
 426 |         if method == "notifications/initialized":
 427 |             logger.info("Client initialized")
 428 |         elif method == "notifications/cancelled":
 429 |             logger.info(f"Request cancelled: {params.get('requestId')}")

## src/cegraph/parser/models.py
# Included because: graph expansion (depth 2)

# [function] detect_language (relevance: 0.19, depth: 2)
 100 | def detect_language(file_path: str) -> str | None:
 101 |     """Detect programming language from file extension."""
 102 |     from pathlib import Path
 103 | 
 104 |     ext = Path(file_path).suffix.lower()
 105 |     return EXTENSION_LANGUAGE_MAP.get(ext)

## src/cegraph/parser/tree_sitter_parser.py
# Included because: graph expansion (depth 2); graph expansion (depth 3)

# [function] _get_language (relevance: 0.19, depth: 2)
  94 | def _get_language(lang: str):
  95 |     """Get a tree-sitter Language object for the given language."""
  96 |     from tree_sitter import Language
  97 | 
  98 |     module_name = _TS_LANGUAGE_MODULES.get(lang)
  99 |     if not module_name:
 100 |         raise ValueError(f"No tree-sitter grammar for language: {lang}")
 101 | 
 102 |     module = __import__(module_name)
 103 |     return Language(module.language())

# [function] _extract_ts_import (relevance: 0.15, depth: 3)
 250 | def _extract_ts_import(node, file_path: str, source: bytes, result: FileSymbols) -> None:
 251 |     """Extract import information from a tree-sitter node."""
 252 |     text = node.text.decode("utf-8")
 253 |     result.imports.append(text)

## src/cegraph/tools/registry.py
# Included because: graph expansion (depth 2); graph expansion (depth 1)

# [method] ToolRegistry.get (relevance: 0.51, depth: 1)
  26 |     def get(self, name: str) -> Callable | None:
  27 |         """Get a tool function by name."""
  28 |         return self._tools.get(name)

# [method] ToolRegistry.get_definition (relevance: 0.17, depth: 2)
  30 |     def get_definition(self, name: str) -> ToolDefinition | None:
  31 |         """Get a tool definition by name."""
  32 |         return self._definitions.get(name)

# [method] ToolRegistry.execute (relevance: 0.41, depth: 2)
  42 |     async def execute(self, name: str, arguments: dict[str, Any]) -> str:
  43 |         """Execute a tool by name with the given arguments.
  44 | 
  45 |         Returns the result as a string.
  46 |         """
  47 |         func = self._tools.get(name)
  48 |         if func is None:
  49 |             return f"Error: Unknown tool '{name}'"
  50 | 
  51 |         try:
  52 |             if inspect.iscoroutinefunction(func):
  53 |                 result = await func(**arguments)
  54 |             else:
  55 |                 result = func(**arguments)
  56 |             return str(result) if result is not None else "Done."
  57 |         except Exception as e:
  58 |             return f"Error executing tool '{name}': {e}"

## src/cegraph/ui/console.py
# Included because: graph expansion (depth 2)

# [method] Console.show_search_results (relevance: 0.20, depth: 2)
 120 |     def show_search_results(self, results: list[dict]) -> None:
 121 |         """Display search results."""
 122 |         for r in results:
 123 |             self.console.print(
 124 |                 f"  [bold]{r.get('qualified_name', r.get('name', 'unknown'))}[/bold] "
 125 |                 f"[dim]({r.get('kind', '')})[/dim] "
 126 |                 f"at [cyan]{r.get('file_path', '')}:{r.get('line', '')}[/cyan]"
 127 |             )
 128 |             if r.get("signature"):
 129 |                 self.console.print(f"    [dim]{r['signature']}[/dim]")

## tests/test_graph.py
# Included because: graph expansion (depth 2)

# [method] TestGraphBuilder.test_file_nodes_present (relevance: 0.21, depth: 2)
  34 |     def test_file_nodes_present(self, tmp_project: Path):
  35 |         builder = GraphBuilder()
  36 |         graph = builder.build_from_directory(tmp_project)
  37 | 
  38 |         file_nodes = [
  39 |             n for n, d in graph.nodes(data=True) if d.get("type") == "file"
  40 |         ]
  41 |         file_paths = [graph.nodes[n].get("path") for n in file_nodes]
  42 |         assert "main.py" in file_paths
  43 |         assert "utils.py" in file_paths
  44 |         assert "models.py" in file_paths

# [method] TestGraphBuilder.test_symbol_nodes_have_attributes (relevance: 0.21, depth: 2)
  46 |     def test_symbol_nodes_have_attributes(self, tmp_project: Path):
  47 |         builder = GraphBuilder()
  48 |         graph = builder.build_from_directory(tmp_project)
  49 | 
  50 |         for node_id, data in graph.nodes(data=True):
  51 |             if data.get("type") == "symbol":
  52 |                 assert "name" in data
  53 |                 assert "kind" in data
  54 |                 assert "file_path" in data
  55 |                 assert "line_start" in data

# [method] TestGraphBuilder.test_call_edges_exist (relevance: 0.21, depth: 2)
  57 |     def test_call_edges_exist(self, tmp_project: Path):
  58 |         builder = GraphBuilder()
  59 |         graph = builder.build_from_directory(tmp_project)
  60 | 
  61 |         call_edges = [
  62 |             (u, v) for u, v, d in graph.edges(data=True) if d.get("kind") == "calls"
  63 |         ]
  64 |         assert len(call_edges) > 0

# [method] TestGraphBuilder.test_contains_edges_exist (relevance: 0.21, depth: 2)
  66 |     def test_contains_edges_exist(self, tmp_project: Path):
  67 |         builder = GraphBuilder()
  68 |         graph = builder.build_from_directory(tmp_project)
  69 | 
  70 |         contains_edges = [
  71 |             (u, v) for u, v, d in graph.edges(data=True) if d.get("kind") == "contains"
  72 |         ]
  73 |         assert len(contains_edges) > 0

## tests/test_mcp.py
# Included because: graph expansion (depth 2)

# [method] TestMCPTools.test_search_code (relevance: 0.20, depth: 2)
  93 |     def test_search_code(self, mcp_server: MCPServer):
  94 |         """Test the search_code tool."""
  95 |         result = mcp_server._dispatch("tools/call", {
  96 |             "name": "search_code",
  97 |             "arguments": {"query": "main"},
  98 |         })
  99 |         assert not result.get("isError")
 100 |         content = result["content"][0]["text"]
 101 |         assert "main" in content

# [method] TestMCPTools.test_who_calls (relevance: 0.20, depth: 2)
 103 |     def test_who_calls(self, mcp_server: MCPServer):
 104 |         """Test the who_calls tool."""
 105 |         result = mcp_server._dispatch("tools/call", {
 106 |             "name": "who_calls",
 107 |             "arguments": {"symbol": "helper_function"},
 108 |         })
 109 |         assert not result.get("isError")

# [method] TestMCPTools.test_impact_of (relevance: 0.20, depth: 2)
 111 |     def test_impact_of(self, mcp_server: MCPServer):
 112 |         """Test the impact_of tool."""
 113 |         result = mcp_server._dispatch("tools/call", {
 114 |             "name": "impact_of",
 115 |             "arguments": {"symbol": "calculate_total"},
 116 |         })
 117 |         assert not result.get("isError")
 118 |         content = result["content"][0]["text"]
 119 |         assert "Impact" in content or "calculate_total" in content

# [method] TestMCPTools.test_get_structure (relevance: 0.20, depth: 2)
 121 |     def test_get_structure(self, mcp_server: MCPServer):
 122 |         """Test the get_structure tool."""
 123 |         result = mcp_server._dispatch("tools/call", {
 124 |             "name": "get_structure",
 125 |             "arguments": {},
 126 |         })
 127 |         assert not result.get("isError")
 128 |         content = result["content"][0]["text"]
 129 |         assert "main.py" in content or "structure" in content.lower()

# [method] TestMCPTools.test_find_related (relevance: 0.20, depth: 2)
 131 |     def test_find_related(self, mcp_server: MCPServer):
 132 |         """Test the find_related tool."""
 133 |         result = mcp_server._dispatch("tools/call", {
 134 |             "name": "find_related",
 135 |             "arguments": {"symbol": "main"},
 136 |         })
 137 |         assert not result.get("isError")

# [method] TestMCPTools.test_unknown_tool (relevance: 0.20, depth: 2)
 139 |     def test_unknown_tool(self, mcp_server: MCPServer):
 140 |         """Test calling an unknown tool."""
 141 |         result = mcp_server._dispatch("tools/call", {
 142 |             "name": "nonexistent_tool",
 143 |             "arguments": {},
 144 |         })
 145 |         assert result.get("isError")

# [method] TestMCPTools.test_search_no_results (relevance: 0.20, depth: 2)
 147 |     def test_search_no_results(self, mcp_server: MCPServer):
 148 |         """Test search with no results."""
 149 |         result = mcp_server._dispatch("tools/call", {
 150 |             "name": "search_code",
 151 |             "arguments": {"query": "zzz_nonexistent_symbol_zzz"},
 152 |         })
 153 |         assert not result.get("isError")
 154 |         content = result["content"][0]["text"]
 155 |         assert "No symbols found" in content

# [method] TestMCPSecurity.test_resources_read_path_traversal (relevance: 0.20, depth: 2)
 171 |     def test_resources_read_path_traversal(self, mcp_server: MCPServer):
 172 |         """Regression: reading files outside the project root must be denied."""
 173 |         result = mcp_server._dispatch("resources/read", {
 174 |             "uri": "file://../../../../etc/hosts",
 175 |         })
 176 |         text = result["contents"][0].get("text", "")
 177 |         assert "Access denied" in text
 178 |         assert "localhost" not in text

# [method] TestMCPSecurity.test_resources_read_valid_file (relevance: 0.20, depth: 2)
 180 |     def test_resources_read_valid_file(self, mcp_server: MCPServer):
 181 |         """Reading a file inside the project root should work."""
 182 |         result = mcp_server._dispatch("resources/read", {
 183 |             "uri": "file://main.py",
 184 |         })
 185 |         text = result["contents"][0].get("text", "")
 186 |         assert "Access denied" not in text

## tests/test_tools.py
# Included because: graph expansion (depth 2)

# [method] TestToolRegistry.test_get_all_tools_creates_registry (relevance: 0.29, depth: 2)
 175 |     def test_get_all_tools_creates_registry(self, tmp_project: Path):
 176 |         builder = GraphBuilder()
 177 |         graph = builder.build_from_directory(tmp_project)
 178 |         query = GraphQuery(graph)
 179 |         search = HybridSearch(tmp_project, graph)
 180 |         registry = get_all_tools(tmp_project, graph, query, search)
 181 | 
 182 |         assert len(registry.list_tools()) > 0
 183 |         assert registry.get("search_code") is not None
 184 |         assert registry.get("nonexistent") is None
