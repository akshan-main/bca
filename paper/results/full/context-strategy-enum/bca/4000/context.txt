# Codebase Context for: ContextStrategy.SMART has the wrong string value — code that checks strategy == "smart" fails silently.
# 23 symbols from 7 files (~3,489 tokens, 87% of budget)

## src/cegraph/config.py
# Included because: matches 'value'; required dependency of has_tool_calls

# [import] BaseModel (relevance: 0.18, depth: 1)
  10 | from pydantic import BaseModel, Field

# [function] set_config_value (relevance: 0.40, depth: 0)
 125 | def set_config_value(config: ProjectConfig, key: str, value: Any) -> ProjectConfig:
 126 |     """Set a nested config value using dot notation (e.g., 'llm.provider')."""
 127 |     parts = key.split(".")
 128 |     data = config.model_dump()
 129 |     target = data
 130 |     for part in parts[:-1]:
 131 |         if part not in target or not isinstance(target[part], dict):
 132 |             raise KeyError(f"Invalid config key: {key}")
 133 |         target = target[part]
 134 |     if parts[-1] not in target:
 135 |         raise KeyError(f"Invalid config key: {key}")
 136 |     target[parts[-1]] = value
 137 |     return ProjectConfig(**data)

## src/cegraph/context/models.py
# Included because: required dependency of estimate; graph expansion (depth 2); matches 'ContextStrategy'

# [class] ContextStrategy (relevance: 1.21, depth: 0)
  11 | class ContextStrategy(str, Enum):
  12 |     """Strategy for assembling context."""
  13 | 
  14 |     PRECISE = "precise"  # Only directly relevant symbols
  15 |     SMART = "balanced"  # Graph-expanded with relevance scoring (default)
  16 |     THOROUGH = "thorough"  # Deep expansion, all related code

# [class] TokenEstimator (relevance: 0.26, depth: 2)
 159 | class TokenEstimator:
 160 |     """Estimate token counts for code."""
 161 | 
 162 |     # Rough heuristic: 1 token ≈ 4 characters for code
 163 |     CHARS_PER_TOKEN = 4.0
 164 | 
 165 |     @classmethod
 166 |     def estimate(cls, text: str) -> int:
 167 |         """Estimate token count for a string."""
 168 |         return max(1, int(len(text) / cls.CHARS_PER_TOKEN))
 169 | 
 170 |     @classmethod
 171 |     def estimate_lines(cls, line_count: int, avg_line_length: int = 40) -> int:
 172 |         """Estimate tokens for a given number of lines."""
 173 |         return max(1, int(line_count * avg_line_length / cls.CHARS_PER_TOKEN))

# [method] TokenEstimator.estimate (relevance: 0.40, depth: 2)
 166 |     def estimate(cls, text: str) -> int:
 167 |         """Estimate token count for a string."""
 168 |         return max(1, int(len(text) / cls.CHARS_PER_TOKEN))

# [method] TokenEstimator.estimate_lines (relevance: 0.32, depth: 2)
 171 |     def estimate_lines(cls, line_count: int, avg_line_length: int = 40) -> int:
 172 |         """Estimate tokens for a given number of lines."""
 173 |         return max(1, int(line_count * avg_line_length / cls.CHARS_PER_TOKEN))

## src/cegraph/llm/base.py
# Included because: matches 'has'; required dependency of has_tool_calls

# [class] LLMResponse (relevance: 0.22, depth: 1)
  46 | class LLMResponse(BaseModel):
  47 |     """Response from the LLM."""
  48 | 
  49 |     content: str = ""
  50 |     tool_calls: list[ToolCall] = Field(default_factory=list)
  51 |     finish_reason: str = ""
  52 |     usage: dict[str, int] = Field(default_factory=dict)
  53 | 
  54 |     @property
  55 |     def has_tool_calls(self) -> bool:
  56 |         return len(self.tool_calls) > 0

# [method] LLMResponse.has_tool_calls (relevance: 0.37, depth: 0)
  55 |     def has_tool_calls(self) -> bool:
  56 |         return len(self.tool_calls) > 0

## src/cegraph/parser/core.py
# Included because: graph expansion (depth 2)

# [function] parse_file (relevance: 0.23, depth: 2)
  13 | def parse_file(file_path: str, source: str | None = None) -> FileSymbols | None:
  14 |     """Parse a single file, auto-detecting language and selecting the best parser.
  15 | 
  16 |     Returns None if the file's language is not supported.
  17 | 
  18 |     - Python: uses stdlib ast (zero deps, high accuracy)
  19 |     - JS/TS, Go, Rust, Java: uses tree-sitter (required dep, full AST)
  20 |     """
  21 |     language = detect_language(file_path)
  22 |     if not language:
  23 |         return None
  24 | 
  25 |     # Python uses stdlib AST — better than tree-sitter for Python
  26 |     if language == "python":
  27 |         from cegraph.parser.python_parser import parse_python_file
  28 | 
  29 |         return parse_python_file(file_path, source)
  30 | 
  31 |     # Everything else uses tree-sitter
  32 |     from cegraph.parser.tree_sitter_parser import is_available, parse_tree_sitter_file
  33 | 
  34 |     if is_available(language):
  35 |         return parse_tree_sitter_file(file_path, language, source)
  36 | 
  37 |     # Language detected but no tree-sitter grammar installed
  38 |     return None

## src/cegraph/parser/python_parser.py
# Included because: graph expansion (depth 1); matches 'string'; graph expansion (depth 3); graph expansion (depth 2)

# [function] parse_python_file (relevance: 0.58, depth: 1)
  17 | def parse_python_file(file_path: str, source: str | None = None) -> FileSymbols:
  18 |     """Parse a Python file and extract symbols and relationships."""
  19 |     if source is None:
  20 |         source = Path(file_path).read_text(encoding="utf-8", errors="replace")
  21 | 
  22 |     result = FileSymbols(file_path=file_path, language="python")
  23 | 
  24 |     try:
  25 |         tree = ast.parse(source, filename=file_path)
  26 |     except SyntaxError as e:
  27 |         result.errors.append(f"SyntaxError: {e}")
  28 |         return result
  29 | 
  30 |     lines = source.splitlines()
  31 |     _extract_from_module(tree, file_path, lines, result)
  32 |     return result

# [function] _get_docstring (relevance: 0.42, depth: 0)
  35 | def _get_docstring(node: ast.AST) -> str:
  36 |     """Extract docstring from a node if present."""
  37 |     if (
  38 |         isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef, ast.Module))
  39 |         and node.body
  40 |         and isinstance(node.body[0], ast.Expr)
  41 |         and isinstance(node.body[0].value, (ast.Constant,))
  42 |         and isinstance(node.body[0].value.value, str)
  43 |     ):
  44 |         return node.body[0].value.value.strip()
  45 |     return ""

# [function] _get_decorators (relevance: 0.24, depth: 2)
  48 | def _get_decorators(node: ast.FunctionDef | ast.AsyncFunctionDef | ast.ClassDef) -> list[str]:
  49 |     """Extract decorator names."""
  50 |     decorators = []
  51 |     for dec in node.decorator_list:
  52 |         if isinstance(dec, ast.Name):
  53 |             decorators.append(dec.id)
  54 |         elif isinstance(dec, ast.Attribute):
  55 |             decorators.append(ast.dump(dec))
  56 |         elif isinstance(dec, ast.Call):
  57 |             if isinstance(dec.func, ast.Name):
  58 |                 decorators.append(dec.func.id)
  59 |             elif isinstance(dec.func, ast.Attribute):
  60 |                 decorators.append(ast.dump(dec.func))
  61 |     return decorators

# [function] _get_function_signature (relevance: 0.22, depth: 2)
  64 | def _get_function_signature(
  65 |     node: ast.FunctionDef | ast.AsyncFunctionDef, lines: list[str]
  66 | ) -> str:
  67 |     """Extract the function signature from source lines."""
  68 |     start = node.lineno - 1
  69 |     sig_lines = []
  70 |     for i in range(start, min(start + 10, len(lines))):
  71 |         line = lines[i]
  72 |         sig_lines.append(line.strip())
  73 |         if ":" in line:
  74 |             # Check if we've reached the colon that ends the signature
  75 |             text = "".join(sig_lines)
  76 |             if text.count("(") <= text.count(")"):
  77 |                 break
  78 |     sig = " ".join(sig_lines)
  79 |     # Trim to just the def ... : part
  80 |     if ":" in sig:
  81 |         sig = sig[: sig.rindex(":") + 1]
  82 |     return sig

# [function] _extract_from_module (relevance: 0.38, depth: 2)
  85 | def _extract_from_module(
  86 |     tree: ast.Module,
  87 |     file_path: str,
  88 |     lines: list[str],
  89 |     result: FileSymbols,
  90 |     parent_name: str = "",
  91 |     parent_id: str = "",
  92 | ) -> None:
  93 |     """Recursively extract symbols from an AST module/class body."""
  94 | 
  95 |     for node in ast.iter_child_nodes(tree):
  96 |         if isinstance(node, (ast.Import, ast.ImportFrom)):
  97 |             _extract_import(node, file_path, result)
  98 | 
  99 |         elif isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
 100 |             _extract_function(node, file_path, lines, result, parent_name, parent_id)
 101 | 
 102 |         elif isinstance(node, ast.ClassDef):
 103 |             _extract_class(node, file_path, lines, result, parent_name, parent_id)
 104 | 
 105 |         elif isinstance(node, ast.Assign):
 106 |             _extract_assignment(node, file_path, result, parent_name, parent_id)

# [function] _extract_import (relevance: 0.28, depth: 3)
 109 | def _extract_import(
 110 |     node: ast.Import | ast.ImportFrom, file_path: str, result: FileSymbols
 111 | ) -> None:
 112 |     """Extract import statements."""
 113 |     if isinstance(node, ast.Import):
 114 |         for alias in node.names:
 115 |             name = alias.asname or alias.name
 116 |             result.imports.append(alias.name)
 117 |             result.symbols.append(
 118 |                 Symbol(
 119 |                     name=name,
 120 |                     kind=SymbolKind.IMPORT,
 121 |                     file_path=file_path,
 122 |                     line_start=node.lineno,
 123 |                     line_end=node.end_lineno or node.lineno,
 124 |                 )
 125 |             )
 126 |             result.relationships.append(
 127 |                 Relationship(
 128 |                     source=f"{file_path}::{name}",
 129 |                     target=alias.name,
 130 |                     kind=RelKind.IMPORTS,
 131 |                     file_path=file_path,
 132 |                     line=node.lineno,
 133 |                 )
 134 |             )
 135 |     elif isinstance(node, ast.ImportFrom):
 136 |         module = node.module or ""
 137 |         for alias in node.names:
 138 |             name = alias.asname or alias.name
 139 |             full_import = f"{module}.{alias.name}" if module else alias.name
 140 |             result.imports.append(full_import)
 141 |             result.symbols.append(
 142 |                 Symbol(
 143 |                     name=name,
 144 |                     kind=SymbolKind.IMPORT,
 145 |                     file_path=file_path,
 146 |                     line_start=node.lineno,
 147 |                     line_end=node.end_lineno or node.lineno,
 148 |                 )
 149 |             )
 150 |             result.relationships.append(
 151 |                 Relationship(
 152 |                     source=f"{file_path}::{name}",
 153 |                     target=full_import,
 154 |                     kind=RelKind.IMPORTS,
 155 |                     file_path=file_path,
 156 |                     line=node.lineno,
 157 |                 )
 158 |             )

# [function] _extract_function (relevance: 0.38, depth: 1)
 161 | def _extract_function(
 162 |     node: ast.FunctionDef | ast.AsyncFunctionDef,
 163 |     file_path: str,
 164 |     lines: list[str],
 165 |     result: FileSymbols,
 166 |     parent_name: str,
 167 |     parent_id: str,
 168 | ) -> None:
 169 |     """Extract function/method definition."""
 170 |     qualified = f"{parent_name}.{node.name}" if parent_name else node.name
 171 |     kind = SymbolKind.METHOD if parent_name else SymbolKind.FUNCTION
 172 |     sig = _get_function_signature(node, lines)
 173 | 
 174 |     symbol = Symbol(
 175 |         name=node.name,
 176 |         qualified_name=qualified,
 177 |         kind=kind,
 178 |         file_path=file_path,
 179 |         line_start=node.lineno,
 180 |         line_end=node.end_lineno or node.lineno,
 181 |         signature=sig,
 182 |         docstring=_get_docstring(node),
 183 |         decorators=_get_decorators(node),
 184 |         parent=parent_id,
 185 |     )
 186 |     result.symbols.append(symbol)
 187 | 
 188 |     # Add contains relationship
 189 |     if parent_id:
 190 |         result.relationships.append(
 191 |             Relationship(
 192 |                 source=parent_id,
 193 |                 target=symbol.id,
 194 |                 kind=RelKind.CONTAINS,
 195 |                 file_path=file_path,
 196 |                 line=node.lineno,
 197 |             )
 198 |         )
 199 | 
 200 |     # Extract calls within the function body
 201 |     _extract_calls(node, file_path, symbol.id, result)

# [function] _extract_class (relevance: 0.38, depth: 1)
 204 | def _extract_class(
 205 |     node: ast.ClassDef,
 206 |     file_path: str,
 207 |     lines: list[str],
 208 |     result: FileSymbols,
 209 |     parent_name: str,
 210 |     parent_id: str,
 211 | ) -> None:
 212 |     """Extract class definition and its members."""
 213 |     qualified = f"{parent_name}.{node.name}" if parent_name else node.name
 214 | 
 215 |     symbol = Symbol(
 216 |         name=node.name,
 217 |         qualified_name=qualified,
 218 |         kind=SymbolKind.CLASS,
 219 |         file_path=file_path,
 220 |         line_start=node.lineno,
 221 |         line_end=node.end_lineno or node.lineno,
 222 |         signature=f"class {node.name}",
 223 |         docstring=_get_docstring(node),
 224 |         decorators=_get_decorators(node),
 225 |         parent=parent_id,
 226 |     )
 227 |     result.symbols.append(symbol)
 228 | 
 229 |     # Add contains relationship
 230 |     if parent_id:
 231 |         result.relationships.append(
 232 |             Relationship(
 233 |                 source=parent_id,
 234 |                 target=symbol.id,
 235 |                 kind=RelKind.CONTAINS,
 236 |                 file_path=file_path,
 237 |                 line=node.lineno,
 238 |             )
 239 |         )
 240 | 
 241 |     # Extract inheritance
 242 |     for base in node.bases:
 243 |         base_name = _node_to_name(base)
 244 |         if base_name:
 245 |             result.relationships.append(
 246 |                 Relationship(
 247 |                     source=symbol.id,
 248 |                     target=base_name,
 249 |                     kind=RelKind.INHERITS,
 250 |                     file_path=file_path,
 251 |                     line=node.lineno,
 252 |                 )
 253 |             )
 254 | 
 255 |     # Recurse into class body
 256 |     _extract_from_module(node, file_path, lines, result, qualified, symbol.id)

# [function] _extract_assignment (relevance: 0.28, depth: 3)
 259 | def _extract_assignment(
 260 |     node: ast.Assign,
 261 |     file_path: str,
 262 |     result: FileSymbols,
 263 |     parent_name: str,
 264 |     parent_id: str,
 265 | ) -> None:
 266 |     """Extract variable/constant assignments at module or class level."""
 267 |     for target in node.targets:
 268 |         name = _node_to_name(target)
 269 |         if not name:
 270 |             continue
 271 |         qualified = f"{parent_name}.{name}" if parent_name else name
 272 |         kind = SymbolKind.CONSTANT if name.isupper() else SymbolKind.VARIABLE
 273 | 
 274 |         symbol = Symbol(
 275 |             name=name,
 276 |             qualified_name=qualified,
 277 |             kind=kind,
 278 |             file_path=file_path,
 279 |             line_start=node.lineno,
 280 |             line_end=node.end_lineno or node.lineno,
 281 |             parent=parent_id,
 282 |         )
 283 |         result.symbols.append(symbol)

# [function] _extract_calls (relevance: 0.26, depth: 2)
 286 | def _extract_calls(
 287 |     node: ast.AST, file_path: str, caller_id: str, result: FileSymbols
 288 | ) -> None:
 289 |     """Walk a function body and extract all function calls."""
 290 |     for child in ast.walk(node):
 291 |         if isinstance(child, ast.Call):
 292 |             callee = _node_to_name(child.func)
 293 |             if callee:
 294 |                 result.relationships.append(
 295 |                     Relationship(
 296 |                         source=caller_id,
 297 |                         target=callee,
 298 |                         kind=RelKind.CALLS,
 299 |                         file_path=file_path,
 300 |                         line=child.lineno if hasattr(child, "lineno") else 0,
 301 |                     )
 302 |                 )

# [function] _node_to_name (relevance: 0.30, depth: 2)
 305 | def _node_to_name(node: ast.AST) -> str:
 306 |     """Convert an AST node to a dotted name string."""
 307 |     if isinstance(node, ast.Name):
 308 |         return node.id
 309 |     elif isinstance(node, ast.Attribute):
 310 |         parent = _node_to_name(node.value)
 311 |         if parent:
 312 |             return f"{parent}.{node.attr}"
 313 |         return node.attr
 314 |     elif isinstance(node, ast.Subscript):
 315 |         return _node_to_name(node.value)
 316 |     return ""

## src/cegraph/parser/tree_sitter_parser.py
# Included because: graph expansion (depth 3)

# [function] parse_tree_sitter_file (relevance: 0.23, depth: 3)
 106 | def parse_tree_sitter_file(
 107 |     file_path: str, language: str, source: str | None = None
 108 | ) -> FileSymbols:
 109 |     """Parse a file using tree-sitter for accurate AST extraction."""
 110 |     from tree_sitter import Parser
 111 | 
 112 |     if source is None:
 113 |         source = Path(file_path).read_text(encoding="utf-8", errors="replace")
 114 | 
 115 |     result = FileSymbols(file_path=file_path, language=language)
 116 |     source_bytes = source.encode("utf-8")
 117 | 
 118 |     try:
 119 |         ts_language = _get_language(language)
 120 |         parser = Parser(ts_language)
 121 |         tree = parser.parse(source_bytes)
 122 |     except Exception as e:
 123 |         result.errors.append(f"tree-sitter parse error: {e}")
 124 |         return result
 125 | 
 126 |     _walk_tree(tree.root_node, file_path, language, source_bytes, result)
 127 |     return result

## tests/test_context.py
# Included because: matches 'strategy'; graph expansion (depth 1)

# [class] TestContextStrategy (relevance: 0.40, depth: 0)
  48 | class TestContextStrategy:
  49 |     def test_strategies_exist(self):
  50 |         assert ContextStrategy.PRECISE.value == "precise"
  51 |         assert ContextStrategy.SMART.value == "smart"
  52 |         assert ContextStrategy.THOROUGH.value == "thorough"

# [method] TestContextStrategy.test_strategies_exist (relevance: 0.27, depth: 1)
  49 |     def test_strategies_exist(self):
  50 |         assert ContextStrategy.PRECISE.value == "precise"
  51 |         assert ContextStrategy.SMART.value == "smart"
  52 |         assert ContextStrategy.THOROUGH.value == "thorough"
