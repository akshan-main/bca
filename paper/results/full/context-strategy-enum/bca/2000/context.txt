# Codebase Context for: ContextStrategy.SMART has the wrong string value — code that checks strategy == "smart" fails silently.
# 18 symbols from 5 files (~1,909 tokens, 96% of budget)

## src/cegraph/config.py
# Included because: matches 'value'; required dependency of has_tool_calls

# [import] BaseModel (relevance: 0.18, depth: 1)
  10 | from pydantic import BaseModel, Field

# [function] set_config_value (relevance: 0.40, depth: 0)
 125 | def set_config_value(config: ProjectConfig, key: str, value: Any) -> ProjectConfig:
 126 |     """Set a nested config value using dot notation (e.g., 'llm.provider')."""
 127 |     parts = key.split(".")
 128 |     data = config.model_dump()
 129 |     target = data
 130 |     for part in parts[:-1]:
 131 |         if part not in target or not isinstance(target[part], dict):
 132 |             raise KeyError(f"Invalid config key: {key}")
 133 |         target = target[part]
 134 |     if parts[-1] not in target:
 135 |         raise KeyError(f"Invalid config key: {key}")
 136 |     target[parts[-1]] = value
 137 |     return ProjectConfig(**data)

## src/cegraph/context/models.py
# Included because: required dependency of estimate; graph expansion (depth 2); matches 'ContextStrategy'

# [class] ContextStrategy (relevance: 1.21, depth: 0)
  11 | class ContextStrategy(str, Enum):
  12 |     """Strategy for assembling context."""
  13 | 
  14 |     PRECISE = "precise"  # Only directly relevant symbols
  15 |     SMART = "balanced"  # Graph-expanded with relevance scoring (default)
  16 |     THOROUGH = "thorough"  # Deep expansion, all related code

# [class] TokenEstimator (relevance: 0.26, depth: 2)
 159 | class TokenEstimator:
 160 |     """Estimate token counts for code."""
 161 | 
 162 |     # Rough heuristic: 1 token ≈ 4 characters for code
 163 |     CHARS_PER_TOKEN = 4.0
 164 | 
 165 |     @classmethod
 166 |     def estimate(cls, text: str) -> int:
 167 |         """Estimate token count for a string."""
 168 |         return max(1, int(len(text) / cls.CHARS_PER_TOKEN))
 169 | 
 170 |     @classmethod
 171 |     def estimate_lines(cls, line_count: int, avg_line_length: int = 40) -> int:
 172 |         """Estimate tokens for a given number of lines."""
 173 |         return max(1, int(line_count * avg_line_length / cls.CHARS_PER_TOKEN))

# [method] TokenEstimator.estimate (relevance: 0.40, depth: 2)
 166 |     def estimate(cls, text: str) -> int:
 167 |         """Estimate token count for a string."""
 168 |         return max(1, int(len(text) / cls.CHARS_PER_TOKEN))

# [method] TokenEstimator.estimate_lines (relevance: 0.32, depth: 2)
 171 |     def estimate_lines(cls, line_count: int, avg_line_length: int = 40) -> int:
 172 |         """Estimate tokens for a given number of lines."""
 173 |         return max(1, int(line_count * avg_line_length / cls.CHARS_PER_TOKEN))

## src/cegraph/llm/base.py
# Included because: matches 'has'; required dependency of has_tool_calls

# [class] LLMResponse (relevance: 0.22, depth: 1)
  46 | class LLMResponse(BaseModel):
  47 |     """Response from the LLM."""
  48 | 
  49 |     content: str = ""
  50 |     tool_calls: list[ToolCall] = Field(default_factory=list)
  51 |     finish_reason: str = ""
  52 |     usage: dict[str, int] = Field(default_factory=dict)
  53 | 
  54 |     @property
  55 |     def has_tool_calls(self) -> bool:
  56 |         return len(self.tool_calls) > 0

# [method] LLMResponse.has_tool_calls (relevance: 0.37, depth: 0)
  55 |     def has_tool_calls(self) -> bool:
  56 |         return len(self.tool_calls) > 0

## src/cegraph/parser/python_parser.py
# Included because: graph expansion (depth 1); matches 'string'; graph expansion (depth 3); graph expansion (depth 2)

# [function] parse_python_file (relevance: 0.58, depth: 1)
  17 | def parse_python_file(file_path: str, source: str | None = None) -> FileSymbols:
  18 |     """Parse a Python file and extract symbols and relationships."""
  19 |     if source is None:
  20 |         source = Path(file_path).read_text(encoding="utf-8", errors="replace")
  21 | 
  22 |     result = FileSymbols(file_path=file_path, language="python")
  23 | 
  24 |     try:
  25 |         tree = ast.parse(source, filename=file_path)
  26 |     except SyntaxError as e:
  27 |         result.errors.append(f"SyntaxError: {e}")
  28 |         return result
  29 | 
  30 |     lines = source.splitlines()
  31 |     _extract_from_module(tree, file_path, lines, result)
  32 |     return result

# [function] _get_docstring (relevance: 0.42, depth: 0)
  35 | def _get_docstring(node: ast.AST) -> str:
  36 |     """Extract docstring from a node if present."""
  37 |     if (
  38 |         isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef, ast.Module))
  39 |         and node.body
  40 |         and isinstance(node.body[0], ast.Expr)
  41 |         and isinstance(node.body[0].value, (ast.Constant,))
  42 |         and isinstance(node.body[0].value.value, str)
  43 |     ):
  44 |         return node.body[0].value.value.strip()
  45 |     return ""

# [function] _get_decorators (relevance: 0.24, depth: 2)
  48 | def _get_decorators(node: ast.FunctionDef | ast.AsyncFunctionDef | ast.ClassDef) -> list[str]:
  49 |     """Extract decorator names."""
  50 |     decorators = []
  51 |     for dec in node.decorator_list:
  52 |         if isinstance(dec, ast.Name):
  53 |             decorators.append(dec.id)
  54 |         elif isinstance(dec, ast.Attribute):
  55 |             decorators.append(ast.dump(dec))
  56 |         elif isinstance(dec, ast.Call):
  57 |             if isinstance(dec.func, ast.Name):
  58 |                 decorators.append(dec.func.id)
  59 |             elif isinstance(dec.func, ast.Attribute):
  60 |                 decorators.append(ast.dump(dec.func))
  61 |     return decorators

# [function] _get_function_signature (relevance: 0.22, depth: 2)
  64 | def _get_function_signature(
  65 |     node: ast.FunctionDef | ast.AsyncFunctionDef, lines: list[str]
  66 | ) -> str:
  67 |     """Extract the function signature from source lines."""
  68 |     start = node.lineno - 1
  69 |     sig_lines = []
  70 |     for i in range(start, min(start + 10, len(lines))):
  71 |         line = lines[i]
  72 |         sig_lines.append(line.strip())
  73 |         if ":" in line:
  74 |             # Check if we've reached the colon that ends the signature
  75 |             text = "".join(sig_lines)
  76 |             if text.count("(") <= text.count(")"):
  77 |                 break
  78 |     sig = " ".join(sig_lines)
  79 |     # Trim to just the def ... : part
  80 |     if ":" in sig:
  81 |         sig = sig[: sig.rindex(":") + 1]
  82 |     return sig

# [function] _extract_from_module (relevance: 0.38, depth: 2)
  85 | def _extract_from_module(
  86 |     tree: ast.Module,
  87 |     file_path: str,
  88 |     lines: list[str],
  89 |     result: FileSymbols,
  90 |     parent_name: str = "",
  91 |     parent_id: str = "",
  92 | ) -> None:
  93 |     """Recursively extract symbols from an AST module/class body."""
  94 | 
  95 |     for node in ast.iter_child_nodes(tree):
  96 |         if isinstance(node, (ast.Import, ast.ImportFrom)):
  97 |             _extract_import(node, file_path, result)
  98 | 
  99 |         elif isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
 100 |             _extract_function(node, file_path, lines, result, parent_name, parent_id)
 101 | 
 102 |         elif isinstance(node, ast.ClassDef):
 103 |             _extract_class(node, file_path, lines, result, parent_name, parent_id)
 104 | 
 105 |         elif isinstance(node, ast.Assign):
 106 |             _extract_assignment(node, file_path, result, parent_name, parent_id)

# [function] _extract_assignment (relevance: 0.28, depth: 3)
 259 | def _extract_assignment(
 260 |     node: ast.Assign,
 261 |     file_path: str,
 262 |     result: FileSymbols,
 263 |     parent_name: str,
 264 |     parent_id: str,
 265 | ) -> None:
 266 |     """Extract variable/constant assignments at module or class level."""
 267 |     for target in node.targets:
 268 |         name = _node_to_name(target)
 269 |         if not name:
 270 |             continue
 271 |         qualified = f"{parent_name}.{name}" if parent_name else name
 272 |         kind = SymbolKind.CONSTANT if name.isupper() else SymbolKind.VARIABLE
 273 | 
 274 |         symbol = Symbol(
 275 |             name=name,
 276 |             qualified_name=qualified,
 277 |             kind=kind,
 278 |             file_path=file_path,
 279 |             line_start=node.lineno,
 280 |             line_end=node.end_lineno or node.lineno,
 281 |             parent=parent_id,
 282 |         )
 283 |         result.symbols.append(symbol)

# [function] _extract_calls (relevance: 0.26, depth: 2)
 286 | def _extract_calls(
 287 |     node: ast.AST, file_path: str, caller_id: str, result: FileSymbols
 288 | ) -> None:
 289 |     """Walk a function body and extract all function calls."""
 290 |     for child in ast.walk(node):
 291 |         if isinstance(child, ast.Call):
 292 |             callee = _node_to_name(child.func)
 293 |             if callee:
 294 |                 result.relationships.append(
 295 |                     Relationship(
 296 |                         source=caller_id,
 297 |                         target=callee,
 298 |                         kind=RelKind.CALLS,
 299 |                         file_path=file_path,
 300 |                         line=child.lineno if hasattr(child, "lineno") else 0,
 301 |                     )
 302 |                 )

# [function] _node_to_name (relevance: 0.30, depth: 2)
 305 | def _node_to_name(node: ast.AST) -> str:
 306 |     """Convert an AST node to a dotted name string."""
 307 |     if isinstance(node, ast.Name):
 308 |         return node.id
 309 |     elif isinstance(node, ast.Attribute):
 310 |         parent = _node_to_name(node.value)
 311 |         if parent:
 312 |             return f"{parent}.{node.attr}"
 313 |         return node.attr
 314 |     elif isinstance(node, ast.Subscript):
 315 |         return _node_to_name(node.value)
 316 |     return ""

## tests/test_context.py
# Included because: matches 'strategy'; graph expansion (depth 1)

# [class] TestContextStrategy (relevance: 0.40, depth: 0)
  48 | class TestContextStrategy:
  49 |     def test_strategies_exist(self):
  50 |         assert ContextStrategy.PRECISE.value == "precise"
  51 |         assert ContextStrategy.SMART.value == "smart"
  52 |         assert ContextStrategy.THOROUGH.value == "thorough"

# [method] TestContextStrategy.test_strategies_exist (relevance: 0.27, depth: 1)
  49 |     def test_strategies_exist(self):
  50 |         assert ContextStrategy.PRECISE.value == "precise"
  51 |         assert ContextStrategy.SMART.value == "smart"
  52 |         assert ContextStrategy.THOROUGH.value == "thorough"
