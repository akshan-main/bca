examples/demo.py
  def main():
paper/experiments/ablation.py
  class AblationResult
  def run_ablation( repo_path: Path, task: str, budgets: list[int], ground_truth_symbols: list[str] | None = None, ) -> list[AblationResult]:
  def format_results_table(results: list[AblationResult]) -> str:
  def main():
paper/experiments/baselines.py
  class BaselineResult
  def baseline_grep( repo_path: Path, task: str, budget: int, graph, ) -> BaselineResult:
  def baseline_bm25( repo_path: Path, task: str, budget: int, graph, ) -> BaselineResult:
  def baseline_unweighted_bfs( repo_path: Path, task: str, budget: int, graph, query_engine: GraphQuery, ) -> BaselineResult:
  def baseline_repo_map( repo_path: Path, task: str, budget: int, graph, ) -> BaselineResult:
  def run_bca( repo_path: Path, task: str, budget: int, graph, query_engine: GraphQuery, ) -> BaselineResult:
  def run_comparison( repo_path: Path, task: str, budgets: list[int], ground_truth_symbols: list[str] | None = None, ) -> list[BaselineResult]:
  def format_comparison_table(results: list[BaselineResult]) -> str:
  def main():
paper/experiments/benchmark.py
  class EvalTask
  class EvalResult
  def assemble_bca( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def assemble_bca_no_closure( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def assemble_bm25( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def assemble_grep( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def assemble_repo_map( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def assemble_vector( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def _vector_score_tfidf(query: str, symbols: list[dict]) -> list[float]:
  def _vector_score_dense(query: str, symbols: list[dict]) -> list[float]:
  def assemble_embedding( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def _embedding_score_openai(query_text: str, symbols: list[dict]) -> list[float]:
  def build_prompt(context: str, task: str) -> str:
  async def call_llm( provider, context: str, task: str, ) -> tuple[str, float, int, int]:
  class SearchReplaceEdit
  def _strip_line_prefixes(text: str) -> str:
  def extract_edits(llm_output: str) -> list[SearchReplaceEdit]:
  def extract_patch(llm_output: str) -> str:
  def apply_and_test( repo_path: Path, llm_output: str, test_cmd: str, timeout: int = 60, ) -> tuple[bool, str]:
  def _apply_mutation(repo_path: Path, mutation: dict) -> str | None:
  def _restore_mutation(repo_path: Path, mutation: dict, original: str) -> None:
  async def run_benchmark( tasks: list[EvalTask], budgets: list[int], methods: list[str], llm_config: LLMConfig, output_dir: Path, ) -> list[EvalResult]:
  def format_results(results: list[EvalResult], budgets: list[int]) -> str:
  def main():
paper/experiments/make_tasks.py
  def verify_mutations(repo_path: Path) -> list[dict]:
  def write_eval_tasks( repo_path: Path, mutations: list[dict], output_file: Path, ) -> None:
  def main():
paper/experiments/run_all.py
  def aggregate_baselines(results: list[BaselineResult]) -> str:
  def aggregate_ablation(results: list[AblationResult]) -> str:
  def generate_latex_baseline_table(results: list[BaselineResult]) -> str:
  def generate_latex_ablation_table(results: list[AblationResult]) -> str:
  def main():
src/cegraph/__init__.py
src/cegraph/__main__.py
src/cegraph/agent/__init__.py
src/cegraph/agent/loop.py
  class AgentStep
  class AgentResult
  class AgentLoop
    def __init__( self, llm: LLMProvider, tools: ToolRegistry, project_name: str = "", max_iterations: int = 15, on_step: Callable[[AgentStep], None] | None = None, on_approval_needed: Callable[[str], bool] | None = None, ) -> None:
    async def run(self, task: str, context: str = "") -> AgentResult:
    async def ask(self, question: str) -> str:
src/cegraph/agent/prompts.py
  def get_system_prompt(project_name: str = "") -> str:
  def get_question_prompt(project_name: str = "") -> str:
src/cegraph/cli.py
  def _get_project_root(path: str | None = None) -> Path:
  def _load_graph(root: Path):
  def main():
  def init(path: str | None, provider: str | None, model: str | None):
  def reindex(path: str | None):
  def _do_index(root: Path, config: ProjectConfig):
  def status(path: str | None):
  def search(query: str, path: str | None, kind: str):
  def who_calls(symbol_name: str, path: str | None, depth: int):
  def impact(symbol_name: str, path: str | None):
  def context( task: str, path: str | None, budget: int, strategy: str, compact: bool, savings: bool, focus: tuple[str, ...] ):
  def serve(path: str | None, transport: str, generate_config: str | None):
  def impact_pr(path: str | None, base: str, output_format: str):
  def code_map(path: str | None):
  def ask(question: str, path: str | None):
  def agent(task: str, path: str | None, auto: bool):
  def _run_agent( root: Path, config: ProjectConfig, graph, store, task: str, agent_mode: bool = True, auto_approve: bool = False, ):
  def benchmark(path: str | None):
  def config_cmd(action: str, key: str | None, value: str | None, path: str | None):
src/cegraph/config.py
  class LLMConfig
    def api_key(self) -> str | None:
  class AgentConfig
  class IndexerConfig
  class ProjectConfig
  def find_project_root(start: Path | None = None) -> Path | None:
  def get_cegraph_dir(root: Path) -> Path:
  def load_config(root: Path) -> ProjectConfig:
  def save_config(root: Path, config: ProjectConfig) -> None:
  def set_config_value(config: ProjectConfig, key: str, value: Any) -> ProjectConfig:
src/cegraph/context/__init__.py
src/cegraph/context/_native.py
  def _find_library() -> str | None:
  def _load_library():
  def _setup_signatures(lib):
  class NativeCAG
    def is_available() -> bool:
    def version() -> str:
    def create_graph(num_nodes: int) -> NativeGraph:
    def estimate_tokens(text: str) -> int:
    def extract_entities(text: str, max_entities: int = 200) -> list[dict]:
  class NativeGraph
    def __init__(self, lib, handle, num_nodes: int):
    def add_edge(self, src: int, dst: int, weight: float) -> None:
    def set_node_weight(self, node: int, weight: float) -> None:
    def set_lines(self, node: int, start: int, end: int) -> None:
    def weighted_bfs( self, seed_nodes: list[int], seed_scores: list[float], max_depth: int = 3, min_score: float = 0.1, backward_decay: float = 0.7, max_results: int = 5000, ) -> list[dict]:
    def topological_sort(self, nodes: list[int]) -> list[int]:
    def destroy(self) -> None:
    def __del__(self):
src/cegraph/context/engine.py
  class AblationConfig
  class ContextAssembler
    def __init__( self, root: Path, graph: nx.DiGraph, query: GraphQuery, ablation: AblationConfig | None = None, ) -> None:
    def _build_native_graph(self) -> None:
    def is_accelerated(self) -> bool:
    def assemble( self, task: str, token_budget: int = 8000, strategy: ContextStrategy = ContextStrategy.SMART, focus_files: list[str] | None = None, ) -> ContextPackage:
    def _extract_entities(self, task: str) -> list[dict]:
    def _find_seeds( self, entities: list[dict], focus_files: list[str] | None = None ) -> list[dict]:
    def _expand_context_native( self, seeds: list[dict], config: dict ) -> list[dict]:
    def _expand_context( self, seeds: list[dict], config: dict ) -> list[dict]:
    def _expand_context_pagerank( self, seeds: list[dict], config: dict ) -> list[dict]:
    def _score_candidates( self, candidates: list[dict], entities: list[dict], seeds: list[dict], ) -> list[dict]:
    def _compute_closures(self, candidates: list[dict]) -> dict[str, set[str]]:
    def _closure_of(self, symbol_id: str, candidate_ids: set[str]) -> set[str]:
    def _budget_select( self, candidates: list[dict], closures: dict[str, set[str]], token_budget: int, ) -> list[dict]:
    def _token_cost(self, symbol_id: str, cand: dict | None = None) -> int:
    def _marginal_utility( self, symbol_id: str, covered_edges: set[tuple[str, str]] ) -> float:
    def _update_coverage( self, symbol_id: str, covered_edges: set[tuple[str, str]] ) -> None:
    def _load_source(self, candidates: list[dict]) -> list[ContextItem]:
    def _dependency_order(self, items: list[ContextItem]) -> list[ContextItem]:
    def _scc_topo_sort( self, dep_graph: nx.DiGraph, items: list[ContextItem] ) -> list[str]:
    def estimate_savings(self, task: str, token_budget: int = 8000) -> dict:
src/cegraph/context/learned_weights.py
  def learn_edge_weights( root: Path, graph: nx.DiGraph, max_commits: int = 500, min_samples: int = 5, ) -> dict[str, float]:
  def _get_commit_file_changes( root: Path, max_commits: int ) -> list[set[str]]:
src/cegraph/context/models.py
  class ContextStrategy
  class ContextItem
  class ContextPackage
    def render(self, include_line_numbers: bool = True, include_metadata: bool = True) -> str:
    def render_compact(self) -> str:
    def summary(self) -> str:
  class TokenEstimator
    def estimate(cls, text: str) -> int:
    def estimate_lines(cls, line_count: int, avg_line_length: int = 40) -> int:
src/cegraph/exceptions.py
  class CeGraphError
  class ConfigError
  class ParserError
  class GraphError
  class LLMError
  class ToolError
  class IndexError
  class ProviderNotAvailable
    def __init__(self, provider: str, package: str):
src/cegraph/github/diff_parser.py
  class DiffHunk
  class FileDiff
    def changed_line_ranges(self) -> list[tuple[int, int]]:
  class ChangedSymbol
  def parse_diff(diff_text: str) -> list[FileDiff]:
  def get_changed_symbols( root: Path, graph, file_diffs: list[FileDiff] ) -> list[ChangedSymbol]:
  def get_git_diff(root: Path, base: str = "main") -> str:
  def get_pr_diff(root: Path) -> str:
src/cegraph/github/impact_bot.py
  def run_impact_analysis( root: Path, base: str = "main", is_pr: bool = False, ) -> dict:
  def post_github_comment(comment: str) -> bool:
src/cegraph/github/renderer.py
  def render_impact_comment( changed_symbols: list[ChangedSymbol], impact_results: list[dict], pr_title: str = "", stats: dict | None = None, ) -> str:
  def _risk_badge(risk: float) -> tuple[str, str, str]:
  def _render_file_tree(files: list[str]) -> list[str]:
  def _render_tree_recursive( node: dict, prefix: str, lines: list[str], is_last: bool = True, is_root: bool = False ) -> None:
  def _footer() -> str:
src/cegraph/graph/__init__.py
src/cegraph/graph/builder.py
  class GraphBuilder
    def __init__(self) -> None:
    def build_from_directory( self, root: str | Path, config: ProjectConfig | None = None, progress_callback: callable | None = None, ) -> nx.DiGraph:
    def _add_file(self, fs: FileSymbols, root: Path) -> None:
    def _try_resolve(self, rel: Relationship) -> bool:
    def _resolve_references(self) -> None:
    def get_stats(self) -> dict:
src/cegraph/graph/query.py
  class SymbolInfo
  class GraphQuery
    def __init__(self, graph: nx.DiGraph, store: GraphStore | None = None) -> None:
    def _build_index(self) -> None:
    def find_symbol(self, name: str) -> list[str]:
    def get_symbol_info(self, symbol_id: str) -> SymbolInfo | None:
    def who_calls(self, name: str, max_depth: int = 1) -> list[dict]:
    def what_calls(self, name: str) -> list[dict]:
    def impact_of(self, name: str, max_depth: int = 3) -> dict:
    def get_file_symbols(self, file_path: str) -> list[dict]:
    def get_structure(self, path_prefix: str = "") -> dict:
    def find_related(self, name: str, max_hops: int = 2) -> list[dict]:
src/cegraph/graph/store.py
  class GraphStore
    def __init__(self, db_path: str | Path) -> None:
    def _get_conn(self) -> sqlite3.Connection:
    def _create_tables(self) -> None:
    def _make_text_id(node_type: str, path: str, qualified_name: str = "") -> str:
    def _resolve_text_id(self, conn: sqlite3.Connection, text_id: str) -> int | None:
    def save(self, graph: nx.DiGraph, metadata: dict | None = None) -> None:
    def load(self) -> nx.DiGraph | None:
    def _load_legacy(self) -> nx.DiGraph | None:
    def _load_v1_normalized(self) -> nx.DiGraph | None:
    def _load_text_tables(self) -> nx.DiGraph | None:
    def search_symbols( self, query: str = "", kind: str = "", file_path: str = "", limit: int = 50, ) -> list[dict]:
    def get_callers(self, symbol_id: str) -> list[dict]:
    def get_callees(self, symbol_id: str) -> list[dict]:
    def get_metadata(self, key: str) -> str | None:
    def close(self) -> None:
src/cegraph/llm/__init__.py
src/cegraph/llm/anthropic_provider.py
  class AnthropicProvider
    def __init__( self, model: str = "claude-sonnet-4-5-20250929", api_key: str | None = None, base_url: str | None = None, ) -> None:
    def _get_client(self):
    def _format_messages(self, messages: list[Message]) -> tuple[str, list[dict]]:
    def _format_tools(self, tools: list[ToolDefinition]) -> list[dict]:
    async def complete( self, messages: list[Message], tools: list[ToolDefinition] | None = None, temperature: float = 0.0, max_tokens: int = 4096, ) -> LLMResponse:
    async def stream( self, messages: list[Message], tools: list[ToolDefinition] | None = None, temperature: float = 0.0, max_tokens: int = 4096, ) -> AsyncIterator[str]:
src/cegraph/llm/base.py
  class Message
  class ToolCall
  class ToolResult
  class ToolDefinition
  class LLMResponse
    def has_tool_calls(self) -> bool:
  class LLMProvider
    def __init__(self, model: str, api_key: str | None = None, base_url: str | None = None) -> None:
    async def complete( self, messages: list[Message], tools: list[ToolDefinition] | None = None, temperature: float = 0.0, max_tokens: int = 4096, ) -> LLMResponse:
    async def stream( self, messages: list[Message], tools: list[ToolDefinition] | None = None, temperature: float = 0.0, max_tokens: int = 4096, ) -> AsyncIterator[str]:
src/cegraph/llm/factory.py
  def create_provider(config: LLMConfig) -> LLMProvider:
src/cegraph/llm/openai_provider.py
  class OpenAIProvider
    def __init__( self, model: str = "gpt-4o", api_key: str | None = None, base_url: str | None = None ) -> None:
    def _get_client(self):
    def _format_messages(self, messages: list[Message]) -> list[dict]:
    def _format_tools(self, tools: list[ToolDefinition]) -> list[dict]:
    async def complete( self, messages: list[Message], tools: list[ToolDefinition] | None = None, temperature: float = 0.0, max_tokens: int = 4096, ) -> LLMResponse:
    async def stream( self, messages: list[Message], tools: list[ToolDefinition] | None = None, temperature: float = 0.0, max_tokens: int = 4096, ) -> AsyncIterator[str]:
src/cegraph/map/app.py
  def check_textual():
  def launch_map(root: Path, graph, query) -> None:
src/cegraph/mcp/__init__.py
src/cegraph/mcp/server.py
  class MCPServer
    def __init__(self, root: Path | None = None) -> None:
    def _ensure_graph(self):
    def _ensure_cag(self):
    def _define_tools(self) -> list[dict]:
    def _handle_tool_call(self, name: str, arguments: dict) -> Any:
    def _tool_cag_assemble(self, args: dict) -> str:
    def _tool_search_code(self, args: dict) -> str:
    def _tool_who_calls(self, args: dict) -> str:
    def _tool_impact_of(self, args: dict) -> str:
    def _tool_get_structure(self, _args: dict) -> str:
    def _render_structure(self, node: dict, lines: list[str], indent: int) -> None:
    def _tool_find_related(self, args: dict) -> str:
    async def run_stdio(self) -> None:
    async def _read_message(self, reader: asyncio.StreamReader) -> dict | None:
    async def _write_message(self, writer: asyncio.StreamWriter, message: dict) -> None:
    def _handle_message(self, message: dict) -> dict | None:
    def _handle_notification(self, method: str, params: dict) -> None:
    def _dispatch(self, method: str, params: dict) -> Any:
    def _rpc_initialize(self, params: dict) -> dict:
    def _rpc_tools_list(self, params: dict) -> dict:
    def _rpc_tools_call(self, params: dict) -> dict:
    def _rpc_resources_list(self, params: dict) -> dict:
    def _rpc_resources_read(self, params: dict) -> dict:
    def generate_claude_config(project_path: str | None = None) -> dict:
    def generate_cursor_config(project_path: str | None = None) -> dict:
src/cegraph/parser/__init__.py
src/cegraph/parser/core.py
  def parse_file(file_path: str, source: str | None = None) -> FileSymbols | None:
  def parse_directory( root: str | Path, config: IndexerConfig | None = None, progress_callback: callable | None = None, ) -> list[FileSymbols]:
  def _collect_files(root: Path, config: IndexerConfig) -> list[Path]:
  def _should_exclude(path: str, patterns: list[str]) -> bool:
  def _read_gitignore(root: Path) -> list[str]:
src/cegraph/parser/models.py
  class SymbolKind
  class RelKind
  class Symbol
    def model_post_init(self, __context: object) -> None:
  class Relationship
  class FileSymbols
  def detect_language(file_path: str) -> str | None:
src/cegraph/parser/python_parser.py
  def parse_python_file(file_path: str, source: str | None = None) -> FileSymbols:
  def _get_docstring(node: ast.AST) -> str:
  def _get_decorators(node: ast.FunctionDef | ast.AsyncFunctionDef | ast.ClassDef) -> list[str]:
  def _get_function_signature( node: ast.FunctionDef | ast.AsyncFunctionDef, lines: list[str] ) -> str:
  def _extract_from_module( tree: ast.Module, file_path: str, lines: list[str], result: FileSymbols, parent_name: str = "", parent_id: str = "", ) -> None:
  def _extract_import( node: ast.Import | ast.ImportFrom, file_path: str, result: FileSymbols ) -> None:
  def _extract_function( node: ast.FunctionDef | ast.AsyncFunctionDef, file_path: str, lines: list[str], result: FileSymbols, parent_name: str, parent_id: str, ) -> None:
  def _extract_class( node: ast.ClassDef, file_path: str, lines: list[str], result: FileSymbols, parent_name: str, parent_id: str, ) -> None:
  def _extract_assignment( node: ast.Assign, file_path: str, result: FileSymbols, parent_name: str, parent_id: str, ) -> None:
  def _extract_calls( node: ast.AST, file_path: str, caller_id: str, result: FileSymbols ) -> None:
  def _node_to_name(node: ast.AST) -> str:
src/cegraph/parser/tree_sitter_parser.py
  def is_available(language: str | None = None) -> bool:
  def _get_language(lang: str):
  def parse_tree_sitter_file( file_path: str, language: str, source: str | None = None ) -> FileSymbols:
  def _walk_tree( node, file_path: str, language: str, source: bytes, result: FileSymbols, parent_name: str = "", parent_id: str = "", ) -> None:
  def _extract_name(node, language: str) -> str:
  def _extract_ts_calls( node, file_path: str, language: str, source: bytes, caller_id: str, call_types: list[str], result: FileSymbols ) -> None:
  def _extract_ts_import(node, file_path: str, source: bytes, result: FileSymbols) -> None:
src/cegraph/search/__init__.py
src/cegraph/search/hybrid.py
  class HybridSearch
    def __init__(self, root: Path, graph: nx.DiGraph | None = None) -> None:
    def search( self, query: str, file_pattern: str = "", max_results: int = 20, context_lines: int = 2, ) -> list[SearchResult]:
    def search_symbols(self, query: str, kind: str = "", max_results: int = 20) -> list[dict]:
    def build_embeddings(self, force: bool = False) -> bool:
    def _semantic_scores(self, query: str) -> dict[str, float]:
  def _tokenize(text: str) -> list[str]:
src/cegraph/search/lexical.py
  class SearchResult
  class LexicalSearch
    def __init__(self, root: Path, graph: nx.DiGraph | None = None) -> None:
    def search( self, query: str, file_pattern: str = "", max_results: int = 20, context_lines: int = 2, regex: bool = False, ) -> list[SearchResult]:
    def search_symbols( self, query: str, kind: str = "", max_results: int = 20 ) -> list[dict]:
    def _get_searchable_files(self, file_pattern: str) -> list[str]:
    def _score_match(self, query: str, line: str, file_path: str) -> float:
    def _enrich_with_symbol( self, result: SearchResult, file_path: str, line_num: int ) -> None:
src/cegraph/tools/__init__.py
src/cegraph/tools/definitions.py
  class CeGraphTools
    def __init__( self, root: Path, graph: nx.DiGraph, query: GraphQuery, search: HybridSearch, ) -> None:
    def search_code(self, query: str, file_pattern: str = "", max_results: int = 10) -> str:
    def search_symbols(self, query: str, kind: str = "", max_results: int = 10) -> str:
    def who_calls(self, symbol_name: str, max_depth: int = 2) -> str:
    def what_calls(self, symbol_name: str) -> str:
    def impact_of(self, symbol_name: str) -> str:
    def read_file(self, file_path: str, start_line: int = 0, end_line: int = 0) -> str:
    def write_file(self, file_path: str, content: str) -> str:
    def edit_file( self, file_path: str, old_text: str, new_text: str ) -> str:
    def list_files(self, path: str = "", pattern: str = "") -> str:
    def get_structure(self, path: str = "") -> str:
    def get_context(self, symbol_name: str) -> str:
    def run_command(self, command: str) -> str:
  def get_tool_definitions() -> list[ToolDefinition]:
  def get_all_tools( root: Path, graph: nx.DiGraph, query: GraphQuery, search: HybridSearch, ) -> ToolRegistry:
src/cegraph/tools/registry.py
  class ToolRegistry
    def __init__(self) -> None:
    def register(self, func: Callable, definition: ToolDefinition) -> None:
    def get(self, name: str) -> Callable | None:
    def get_definition(self, name: str) -> ToolDefinition | None:
    def list_tools(self) -> list[str]:
    def get_definitions(self) -> list[ToolDefinition]:
    async def execute(self, name: str, arguments: dict[str, Any]) -> str:
  def tool( name: str, description: str, parameters: dict[str, Any] | None = None, ):
  def _infer_parameters(func: Callable) -> dict[str, Any]:
src/cegraph/ui/__init__.py
src/cegraph/ui/console.py
  class Console
    def __init__(self) -> None:
    def banner(self) -> None:
    def success(self, message: str) -> None:
    def error(self, message: str) -> None:
    def warning(self, message: str) -> None:
    def info(self, message: str) -> None:
    def markdown(self, text: str) -> None:
    def code(self, text: str, language: str = "python") -> None:
    def indexing_progress(self) -> Progress:
    def show_stats(self, stats: dict) -> None:
    def show_agent_step(self, step: AgentStep) -> None:
    def show_search_results(self, results: list[dict]) -> None:
    def show_callers(self, callers: list[dict], symbol_name: str) -> None:
    def show_impact(self, impact: dict) -> None:
    def confirm(self, message: str) -> bool:
tests/conftest.py
  def tmp_project(tmp_path: Path) -> Path:
  def sample_python_source() -> str:
  def sample_js_source() -> str:
tests/test_cli.py
  def runner():
  def indexed_project(tmp_project: Path) -> Path:
  class TestCLIInit
    def test_init_basic(self, runner: CliRunner, tmp_project: Path):
    def test_init_creates_cegraph_dir(self, runner: CliRunner, tmp_project: Path):
    def test_init_nonexistent_path(self, runner: CliRunner):
  class TestCLIStatus
    def test_status(self, runner: CliRunner, indexed_project: Path):
    def test_status_no_index(self, runner: CliRunner, tmp_path: Path):
  class TestCLISearch
    def test_search_symbol(self, runner: CliRunner, indexed_project: Path):
    def test_search_no_results(self, runner: CliRunner, indexed_project: Path):
  class TestCLIWhoCalls
    def test_who_calls(self, runner: CliRunner, indexed_project: Path):
    def test_who_calls_not_found(self, runner: CliRunner, indexed_project: Path):
  class TestCLIImpact
    def test_impact(self, runner: CliRunner, indexed_project: Path):
  class TestCLIConfig
    def test_config_show(self, runner: CliRunner, indexed_project: Path):
    def test_config_get(self, runner: CliRunner, indexed_project: Path):
    def test_config_set(self, runner: CliRunner, indexed_project: Path):
  class TestCLIVersion
    def test_version(self, runner: CliRunner):
tests/test_config.py
  class TestConfig
    def test_default_config(self):
    def test_save_and_load(self, tmp_path: Path):
    def test_find_project_root(self, tmp_path: Path):
    def test_set_config_value(self):
    def test_set_config_nested(self):
    def test_set_config_invalid_key(self):
    def test_exclude_patterns(self):
tests/test_context.py
  def cag_engine(tmp_project: Path):
  class TestTokenEstimator
    def test_estimate_basic(self):
    def test_estimate_empty(self):
    def test_estimate_lines(self):
    def test_estimate_proportional(self):
  class TestContextStrategy
    def test_strategies_exist(self):
  class TestContextPackage
    def test_empty_package(self):
    def test_render_empty(self):
    def test_render_with_items(self):
    def test_render_compact(self):
    def test_summary(self):
  class TestCAGEngine
    def test_assemble_basic(self, cag_engine: ContextAssembler):
    def test_assemble_with_specific_symbol(self, cag_engine: ContextAssembler):
    def test_assemble_with_class(self, cag_engine: ContextAssembler):
    def test_assemble_respects_budget(self, cag_engine: ContextAssembler):
    def test_strategies_differ(self, cag_engine: ContextAssembler):
    def test_focus_files(self, cag_engine: ContextAssembler):
    def test_dependency_ordering(self, cag_engine: ContextAssembler):
    def test_extract_entities(self, cag_engine: ContextAssembler):
    def test_extract_entities_snake_case(self, cag_engine: ContextAssembler):
    def test_extract_entities_quoted(self, cag_engine: ContextAssembler):
    def test_estimate_savings(self, cag_engine: ContextAssembler):
    def test_render_output(self, cag_engine: ContextAssembler):
    def test_assembly_time_tracked(self, cag_engine: ContextAssembler):
    def test_is_not_accelerated(self, cag_engine: ContextAssembler):
tests/test_graph.py
  class TestGraphBuilder
    def test_build_from_directory(self, tmp_project: Path):
    def test_stats(self, tmp_project: Path):
    def test_file_nodes_present(self, tmp_project: Path):
    def test_symbol_nodes_have_attributes(self, tmp_project: Path):
    def test_call_edges_exist(self, tmp_project: Path):
    def test_contains_edges_exist(self, tmp_project: Path):
  class TestGraphBuilderReuse
    def test_rebuild_resets_state(self, tmp_path: Path):
  class TestGraphStore
    def test_save_and_load(self, tmp_project: Path, tmp_path: Path):
    def test_search_symbols(self, tmp_project: Path, tmp_path: Path):
    def test_search_by_kind(self, tmp_project: Path, tmp_path: Path):
    def test_metadata(self, tmp_project: Path, tmp_path: Path):
  class TestGraphQuery
    def _build_query(self, tmp_project: Path) -> GraphQuery:
    def test_find_symbol(self, tmp_project: Path):
    def test_find_symbol_partial(self, tmp_project: Path):
    def test_who_calls(self, tmp_project: Path):
    def test_what_calls(self, tmp_project: Path):
    def test_impact_of(self, tmp_project: Path):
    def test_impact_not_found(self, tmp_project: Path):
    def test_get_file_symbols(self, tmp_project: Path):
    def test_get_structure(self, tmp_project: Path):
    def test_find_related(self, tmp_project: Path):
    def test_get_symbol_info(self, tmp_project: Path):
tests/test_impact_bot.py
  class TestDiffParser
    def test_parse_modified_file(self):
    def test_parse_added_lines(self):
    def test_parse_deleted_lines(self):
    def test_parse_new_file(self):
    def test_parse_deleted_file(self):
    def test_parse_multiple_files(self):
    def test_hunk_line_ranges(self):
    def test_parse_empty(self):
  class TestChangedSymbols
    def test_get_changed_symbols(self, tmp_project: Path):
    def test_deleted_file_symbols(self, tmp_project: Path):
  class TestRenderer
    def test_risk_badge_low(self):
    def test_risk_badge_medium(self):
    def test_risk_badge_high(self):
    def test_risk_badge_critical(self):
    def test_render_empty_comment(self):
    def test_render_with_changes(self):
    def test_render_file_tree(self):
    def test_footer_present(self):
tests/test_mcp.py
  def mcp_server(tmp_project: Path, tmp_path: Path):
  class TestMCPProtocol
    def test_initialize(self, mcp_server: MCPServer):
    def test_tools_list(self, mcp_server: MCPServer):
    def test_tool_schema(self, mcp_server: MCPServer):
    def test_ping(self, mcp_server: MCPServer):
  class TestMCPTools
    def test_cag_assemble(self, mcp_server: MCPServer):
    def test_search_code(self, mcp_server: MCPServer):
    def test_who_calls(self, mcp_server: MCPServer):
    def test_impact_of(self, mcp_server: MCPServer):
    def test_get_structure(self, mcp_server: MCPServer):
    def test_find_related(self, mcp_server: MCPServer):
    def test_unknown_tool(self, mcp_server: MCPServer):
    def test_search_no_results(self, mcp_server: MCPServer):
  class TestMCPConfigGen
    def test_generate_claude_config(self):
    def test_generate_cursor_config(self):
  class TestMCPSecurity
    def test_resources_read_path_traversal(self, mcp_server: MCPServer):
    def test_resources_read_valid_file(self, mcp_server: MCPServer):
  class TestMCPMessageHandling
    def test_handle_notification(self, mcp_server: MCPServer):
    def test_handle_request(self, mcp_server: MCPServer):
    def test_handle_unknown_method(self, mcp_server: MCPServer):
tests/test_parser.py
  class TestLanguageDetection
    def test_python(self):
    def test_javascript(self):
    def test_typescript(self):
    def test_go(self):
    def test_rust(self):
    def test_unknown(self):
  class TestPythonParser
    def test_parse_functions(self, sample_python_source: str):
    def test_parse_classes(self, sample_python_source: str):
    def test_parse_methods(self, sample_python_source: str):
    def test_parse_imports(self, sample_python_source: str):
    def test_parse_constants(self, sample_python_source: str):
    def test_parse_inheritance(self, sample_python_source: str):
    def test_parse_calls(self, sample_python_source: str):
    def test_parse_docstrings(self, sample_python_source: str):
    def test_parse_contains_relationships(self, sample_python_source: str):
    def test_syntax_error_handling(self):
    def test_empty_file(self):
  class TestJavaScriptParser
    def test_parse_classes(self, sample_js_source: str):
    def test_parse_functions(self, sample_js_source: str):
    def test_parse_methods(self, sample_js_source: str):
    def test_parse_imports(self, sample_js_source: str):
    def test_typescript_detection(self):
  class TestCoreParser
    def test_auto_detect_python(self, sample_python_source: str):
    def test_auto_detect_javascript(self, sample_js_source: str):
    def test_unsupported_file(self):
tests/test_search.py
  class TestLexicalSearch
    def _build_search(self, tmp_project: Path) -> LexicalSearch:
    def test_search_basic(self, tmp_project: Path):
    def test_search_with_file_pattern(self, tmp_project: Path):
    def test_search_context_lines(self, tmp_project: Path):
    def test_search_regex(self, tmp_project: Path):
    def test_search_no_results(self, tmp_project: Path):
    def test_search_symbols(self, tmp_project: Path):
    def test_search_symbols_by_kind(self, tmp_project: Path):
    def test_symbol_enrichment(self, tmp_project: Path):
  class TestHybridSearch
    def test_search_delegates_to_lexical(self, tmp_project: Path):
    def test_search_symbols(self, tmp_project: Path):
tests/test_tools.py
  class TestCeGraphTools
    def _build_tools(self, tmp_project: Path) -> CeGraphTools:
    def test_search_code(self, tmp_project: Path):
    def test_search_symbols(self, tmp_project: Path):
    def test_who_calls(self, tmp_project: Path):
    def test_what_calls(self, tmp_project: Path):
    def test_impact_of(self, tmp_project: Path):
    def test_read_file(self, tmp_project: Path):
    def test_read_file_with_lines(self, tmp_project: