# Codebase Context for: ContextStrategy.SMART has the wrong string value â€” code that checks strategy == "smart" fails silently.
# 16 symbols from 6 files (~1,183 tokens, 118% of budget)

## src/cegraph/config.py
# Included because: matches 'value'

# [function] set_config_value (relevance: 0.40, depth: 0)
 125 | def set_config_value(config: ProjectConfig, key: str, value: Any) -> ProjectConfig:
 126 |     """Set a nested config value using dot notation (e.g., 'llm.provider')."""
 127 |     parts = key.split(".")
 128 |     data = config.model_dump()
 129 |     target = data
 130 |     for part in parts[:-1]:
 131 |         if part not in target or not isinstance(target[part], dict):
 132 |             raise KeyError(f"Invalid config key: {key}")
 133 |         target = target[part]
 134 |     if parts[-1] not in target:
 135 |         raise KeyError(f"Invalid config key: {key}")
 136 |     target[parts[-1]] = value
 137 |     return ProjectConfig(**data)

## src/cegraph/context/models.py
# Included because: graph expansion (depth 2); matches 'ContextStrategy'

# [class] ContextStrategy (relevance: 1.21, depth: 0)
  11 | class ContextStrategy(str, Enum):
  12 |     """Strategy for assembling context."""
  13 | 
  14 |     PRECISE = "precise"  # Only directly relevant symbols
  15 |     SMART = "balanced"  # Graph-expanded with relevance scoring (default)
  16 |     THOROUGH = "thorough"  # Deep expansion, all related code

# [method] TokenEstimator.estimate (relevance: 0.40, depth: 2)
 166 |     def estimate(cls, text: str) -> int:
 167 |         """Estimate token count for a string."""
 168 |         return max(1, int(len(text) / cls.CHARS_PER_TOKEN))

# [method] TokenEstimator.estimate_lines (relevance: 0.32, depth: 2)
 171 |     def estimate_lines(cls, line_count: int, avg_line_length: int = 40) -> int:
 172 |         """Estimate tokens for a given number of lines."""
 173 |         return max(1, int(line_count * avg_line_length / cls.CHARS_PER_TOKEN))

## src/cegraph/llm/base.py
# Included because: matches 'has'

# [method] LLMResponse.has_tool_calls (relevance: 0.37, depth: 0)
  55 |     def has_tool_calls(self) -> bool:
  56 |         return len(self.tool_calls) > 0

## src/cegraph/parser/python_parser.py
# Included because: matches 'string'; graph expansion (depth 1)

# [function] parse_python_file (relevance: 0.58, depth: 1)
  17 | def parse_python_file(file_path: str, source: str | None = None) -> FileSymbols:
  18 |     """Parse a Python file and extract symbols and relationships."""
  19 |     if source is None:
  20 |         source = Path(file_path).read_text(encoding="utf-8", errors="replace")
  21 | 
  22 |     result = FileSymbols(file_path=file_path, language="python")
  23 | 
  24 |     try:
  25 |         tree = ast.parse(source, filename=file_path)
  26 |     except SyntaxError as e:
  27 |         result.errors.append(f"SyntaxError: {e}")
  28 |         return result
  29 | 
  30 |     lines = source.splitlines()
  31 |     _extract_from_module(tree, file_path, lines, result)
  32 |     return result

# [function] _get_docstring (relevance: 0.42, depth: 0)
  35 | def _get_docstring(node: ast.AST) -> str:
  36 |     """Extract docstring from a node if present."""
  37 |     if (
  38 |         isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef, ast.Module))
  39 |         and node.body
  40 |         and isinstance(node.body[0], ast.Expr)
  41 |         and isinstance(node.body[0].value, (ast.Constant,))
  42 |         and isinstance(node.body[0].value.value, str)
  43 |     ):
  44 |         return node.body[0].value.value.strip()
  45 |     return ""

## tests/test_context.py
# Included because: matches 'strategy'; graph expansion (depth 1)

# [class] TestContextStrategy (relevance: 0.40, depth: 0)
  48 | class TestContextStrategy:
  49 |     def test_strategies_exist(self):
  50 |         assert ContextStrategy.PRECISE.value == "precise"
  51 |         assert ContextStrategy.SMART.value == "smart"
  52 |         assert ContextStrategy.THOROUGH.value == "thorough"

# [method] TestContextStrategy.test_strategies_exist (relevance: 0.27, depth: 1)
  49 |     def test_strategies_exist(self):
  50 |         assert ContextStrategy.PRECISE.value == "precise"
  51 |         assert ContextStrategy.SMART.value == "smart"
  52 |         assert ContextStrategy.THOROUGH.value == "thorough"

## tests/test_parser.py
# Included because: matches 'string'; graph expansion (depth 2)

# [method] TestPythonParser.test_parse_imports (relevance: 0.21, depth: 2)
  71 |     def test_parse_imports(self, sample_python_source: str):
  72 |         result = parse_python_file("sample.py", sample_python_source)
  73 |         assert "os" in result.imports
  74 |         assert "typing.List" in result.imports
  75 |         assert "pathlib.Path" in result.imports

# [method] TestPythonParser.test_parse_constants (relevance: 0.21, depth: 2)
  77 |     def test_parse_constants(self, sample_python_source: str):
  78 |         result = parse_python_file("sample.py", sample_python_source)
  79 |         constants = [
  80 |             s for s in result.symbols if s.kind == SymbolKind.CONSTANT
  81 |         ]
  82 |         assert any(c.name == "CONSTANT_VALUE" for c in constants)

# [method] TestPythonParser.test_parse_inheritance (relevance: 0.21, depth: 2)
  84 |     def test_parse_inheritance(self, sample_python_source: str):
  85 |         result = parse_python_file("sample.py", sample_python_source)
  86 |         inherits = [
  87 |             r for r in result.relationships if r.kind == RelKind.INHERITS
  88 |         ]
  89 |         assert any("AdvancedProcessor" in r.source and "BaseProcessor" in r.target for r in inherits)

# [method] TestPythonParser.test_parse_docstrings (relevance: 0.39, depth: 0)
 100 |     def test_parse_docstrings(self, sample_python_source: str):
 101 |         result = parse_python_file("sample.py", sample_python_source)
 102 |         funcs = {s.name: s for s in result.symbols if s.kind in (SymbolKind.FUNCTION, SymbolKind.METHOD)}
 103 |         assert "Factory function" in funcs["create_processor"].docstring
 104 |         assert "Transform a single item" in funcs["_transform"].docstring

# [method] TestPythonParser.test_parse_contains_relationships (relevance: 0.21, depth: 2)
 106 |     def test_parse_contains_relationships(self, sample_python_source: str):
 107 |         result = parse_python_file("sample.py", sample_python_source)
 108 |         contains = [r for r in result.relationships if r.kind == RelKind.CONTAINS]
 109 |         # BaseProcessor should contain process, _transform, __init__
 110 |         assert any("BaseProcessor" in r.source and "process" in r.target for r in contains)

# [method] TestPythonParser.test_syntax_error_handling (relevance: 0.21, depth: 2)
 112 |     def test_syntax_error_handling(self):
 113 |         result = parse_python_file("bad.py", "def broken(:\n  pass")
 114 |         assert len(result.errors) > 0

# [method] TestPythonParser.test_empty_file (relevance: 0.21, depth: 2)
 116 |     def test_empty_file(self):
 117 |         result = parse_python_file("empty.py", "")
 118 |         assert result.language == "python"
 119 |         assert len(result.symbols) == 0
