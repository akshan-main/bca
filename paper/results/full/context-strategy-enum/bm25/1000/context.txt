# src/cegraph/context/models.py:15-15
    SMART = "balanced"  # Graph-expanded with relevance scoring (default)

# paper/experiments/ablation.py:21-21
from cegraph.context.models import ContextStrategy

# paper/experiments/ablation.py:21-21
from cegraph.context.models import ContextStrategy

# paper/experiments/ablation.py:21-21
from cegraph.context.models import ContextStrategy

# paper/experiments/ablation.py:21-21
from cegraph.context.models import ContextStrategy

# paper/experiments/ablation.py:21-21
from cegraph.context.models import ContextStrategy

# paper/experiments/ablation.py:21-21
from cegraph.context.models import ContextStrategy

# tests/test_context.py:48-52
class TestContextStrategy:
    def test_strategies_exist(self):
        assert ContextStrategy.PRECISE.value == "precise"
        assert ContextStrategy.SMART.value == "smart"
        assert ContextStrategy.THOROUGH.value == "thorough"

# paper/experiments/ablation.py:21-21
from cegraph.context.models import ContextStrategy

# src/cegraph/context/models.py:14-14
    PRECISE = "precise"  # Only directly relevant symbols

# src/cegraph/context/models.py:16-16
    THOROUGH = "thorough"  # Deep expansion, all related code

# src/cegraph/graph/builder.py:5-5
import hashlib

# tests/test_context.py:49-52
    def test_strategies_exist(self):
        assert ContextStrategy.PRECISE.value == "precise"
        assert ContextStrategy.SMART.value == "smart"
        assert ContextStrategy.THOROUGH.value == "thorough"

# src/cegraph/context/engine.py:90-109
_STRATEGY_CONFIG = {
    ContextStrategy.PRECISE: {
        "max_depth": 1,
        "min_score": 0.3,
        "include_callers": True,
        "include_callees": True,
    },
    ContextStrategy.SMART: {
        "max_depth": 3,
        "min_score": 0.1,
        "include_callers": True,
        "include_callees": True,
    },
    ContextStrategy.THOROUGH: {
        "max_depth": 5,
        "min_score": 0.05,
        "include_callers": True,
        "include_callees": True,
    },
}

# src/cegraph/cli.py:14-22
from cegraph.config import (
    GRAPH_DB_FILE,
    ProjectConfig,
    find_project_root,
    get_cegraph_dir,
    load_config,
    save_config,
    set_config_value,
)

# src/cegraph/cli.py:14-22
from cegraph.config import (
    GRAPH_DB_FILE,
    ProjectConfig,
    find_project_root,
    get_cegraph_dir,
    load_config,
    save_config,
    set_config_value,
)

# src/cegraph/llm/base.py:55-56
    def has_tool_calls(self) -> bool:
        return len(self.tool_calls) > 0

# src/cegraph/agent/loop.py:185-191
    async def ask(self, question: str) -> str:
        """Simple Q&A mode - ask a question about the codebase.

        Returns just the answer string.
        """
        result = await self.run(question)
        return result.answer

# src/cegraph/parser/python_parser.py:35-45
def _get_docstring(node: ast.AST) -> str:
    """Extract docstring from a node if present."""
    if (
        isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef, ast.Module))
        and node.body
        and isinstance(node.body[0], ast.Expr)
        and isinstance(node.body[0].value, (ast.Constant,))
        and isinstance(node.body[0].value.value, str)
    ):
        return node.body[0].value.value.strip()
    return ""

# tests/test_cli.py:19-24
def indexed_project(tmp_project: Path) -> Path:
    """Create a tmp_project that has been indexed."""
    runner = CliRunner()
    result = runner.invoke(main, ["init", "--path", str(tmp_project)])
    assert result.exit_code == 0, f"Init failed: {result.output}"
    return tmp_project

# examples/demo.py:14-70
def main():
    # Point at any code directory
    project_root = Path(".")

    # 1. Build the knowledge graph
    print("Building knowledge graph...")
    builder = GraphBuilder()
    graph = builder.build_from_directory(project_root)

    stats = builder.get_stats()
    print(f"  Files: {stats['files']}")
    print(f"  Functions/Methods: {stats['functions']}")
    print(f"  Classes: {stats['classes']}")
    print(f"  Total nodes: {stats['total_nodes']}")
    print(f"  Total edges: {stats['total_edges']}")

    # 2. Query the graph
    query = GraphQuery(graph)

    # Find a symbol
    print("\n--- Finding 'GraphBuilder' ---")
    symbol_ids = query.find_symbol("GraphBuilder")
    for sid in symbol_ids:
        info = query.get_symbol_info(sid)
        if info:
            print(f"  {info.qualified_name} ({info.kind}) at {info.file_path}:{info.line_start}")
            print(f"  Callers: {len(info.callers)}")
            print(f"  Callees: {len(info.callees)}")

    # Who calls a function?
    print("\n--- Who calls 'parse_file'? ---")
    callers = query.who_calls("parse_file", max_depth=2)
    for c in callers:
        indent = "  " * c["depth"]
        print(f"{indent}  {c['name']} at {c['file_path']}:{c['line']}")

    # Impact analysis
    print("\n--- Impact of changing 'GraphQuery' ---")
    impact = query.impact_of("GraphQuery")
    print(f"  Risk score: {impact['risk_score']:.1%}")
    print(f"  Direct callers: {len(impact['direct_callers'])}")
    print(f"  Affected files: {len(impact['affected_files'])}")
    for f in impact["affected_files"]:
        print(f"    - {f}")

    # 3. Search code
    search = HybridSearch(project_root, graph)

    print("\n--- Searching for 'knowledge graph' ---")
    results = search.search("knowledge graph", max_results=5)
    for r in results:
        print(f"  {r.file_path}:{r.line_number} - {r.line_content.strip()[:80]}")

    print("\n--- Searching for class definitions ---")
    symbols = search.search_symbols("", kind="class", max_results=10)
    for s in symbols:
        print(f"  {s['qualified_name']} at {s['file_path']}:{s['line']}")