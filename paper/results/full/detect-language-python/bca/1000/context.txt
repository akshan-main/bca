# Codebase Context for: detect_language returns "python3" instead of "python" for .py files, causing the parser to fail to select the correct Python parser.
# 7 symbols from 6 files (~809 tokens, 81% of budget)

## src/cegraph/github/diff_parser.py
# Included because: graph expansion (depth 2)

# [function] get_pr_diff (relevance: 0.44, depth: 2)
 205 | def get_pr_diff(root: Path) -> str:
 206 |     """Get the diff for the current PR (GitHub Actions context)."""
 207 |     import os
 208 |     base_ref = os.environ.get("GITHUB_BASE_REF", "main")
 209 |     return get_git_diff(root, base=f"origin/{base_ref}")

## src/cegraph/parser/models.py
# Included because: matches 'detect_language'

# [function] detect_language (relevance: 1.10, depth: 0)
 100 | def detect_language(file_path: str) -> str | None:
 101 |     """Detect programming language from file extension."""
 102 |     from pathlib import Path
 103 | 
 104 |     ext = Path(file_path).suffix.lower()
 105 |     return EXTENSION_LANGUAGE_MAP.get(ext)

## src/cegraph/parser/python_parser.py
# Included because: matches 'python'

# [function] parse_python_file (relevance: 1.12, depth: 0)
  17 | def parse_python_file(file_path: str, source: str | None = None) -> FileSymbols:
  18 |     """Parse a Python file and extract symbols and relationships."""
  19 |     if source is None:
  20 |         source = Path(file_path).read_text(encoding="utf-8", errors="replace")
  21 | 
  22 |     result = FileSymbols(file_path=file_path, language="python")
  23 | 
  24 |     try:
  25 |         tree = ast.parse(source, filename=file_path)
  26 |     except SyntaxError as e:
  27 |         result.errors.append(f"SyntaxError: {e}")
  28 |         return result
  29 | 
  30 |     lines = source.splitlines()
  31 |     _extract_from_module(tree, file_path, lines, result)
  32 |     return result

## src/cegraph/parser/tree_sitter_parser.py
# Included because: graph expansion (depth 3)

# [function] _extract_ts_import (relevance: 0.35, depth: 3)
 250 | def _extract_ts_import(node, file_path: str, source: bytes, result: FileSymbols) -> None:
 251 |     """Extract import information from a tree-sitter node."""
 252 |     text = node.text.decode("utf-8")
 253 |     result.imports.append(text)

## tests/conftest.py
# Included because: matches 'python'

# [function] sample_python_source (relevance: 0.84, depth: 0)
 143 | def sample_python_source() -> str:
 144 |     """Sample Python source code for parser testing."""
 145 |     return '''"""Sample module."""
 146 | 
 147 | import os
 148 | from typing import List, Optional
 149 | from pathlib import Path
 150 | 
 151 | 
 152 | CONSTANT_VALUE = 42
 153 | 
 154 | 
 155 | class BaseProcessor:
 156 |     """Base class for processors."""
 157 | 
 158 |     def __init__(self, name: str):
 159 |         self.name = name
 160 | 
 161 |     def process(self, data: List[str]) -> List[str]:
 162 |         """Process the data."""
 163 |         return [self._transform(item) for item in data]
 164 | 
 165 |     def _transform(self, item: str) -> str:
 166 |         """Transform a single item."""
 167 |         return item.strip()
 168 | 
 169 | 
 170 | class AdvancedProcessor(BaseProcessor):
 171 |     """Advanced processor with extra features."""
 172 | 
 173 |     def __init__(self, name: str, verbose: bool = False):
 174 |         super().__init__(name)
 175 |         self.verbose = verbose
 176 | 
 177 |     def process(self, data: List[str]) -> List[str]:
 178 |         """Process with logging."""
 179 |         if self.verbose:
 180 |             print(f"Processing {len(data)} items")
 181 |         return super().process(data)
 182 | 
 183 |     def batch_process(self, batches: List[List[str]]) -> List[List[str]]:
 184 |         """Process multiple batches."""
 185 |         return [self.process(batch) for batch in batches]
 186 | 
 187 | 
 188 | def create_processor(name: str, advanced: bool = False) -> BaseProcessor:
 189 |     """Factory function for creating processors."""
 190 |     if advanced:
 191 |         return AdvancedProcessor(name, verbose=True)
 192 |     return BaseProcessor(name)
 193 | 
 194 | 
 195 | def run_pipeline(items: List[str], processor_name: str = "default") -> List[str]:
 196 |     """Run the processing pipeline."""
 197 |     processor = create_processor(processor_name)
 198 |     result = processor.process(items)
 199 |     return result
 200 | '''

## tests/test_parser.py
# Included because: matches 'python'

# [method] TestLanguageDetection.test_python (relevance: 0.80, depth: 0)
  13 |     def test_python(self):
  14 |         assert detect_language("main.py") == "python"
  15 |         assert detect_language("types.pyi") == "python"

# [method] TestCoreParser.test_auto_detect_python (relevance: 0.80, depth: 0)
 155 |     def test_auto_detect_python(self, sample_python_source: str):
 156 |         result = parse_file("sample.py", sample_python_source)
 157 |         assert result is not None
 158 |         assert result.language == "python"
