# tests/conftest.py:143-200
def sample_python_source() -> str:
    """Sample Python source code for parser testing."""
    return '''"""Sample module."""

import os
from typing import List, Optional
from pathlib import Path


CONSTANT_VALUE = 42


class BaseProcessor:
    """Base class for processors."""

    def __init__(self, name: str):
        self.name = name

    def process(self, data: List[str]) -> List[str]:
        """Process the data."""
        return [self._transform(item) for item in data]

    def _transform(self, item: str) -> str:
        """Transform a single item."""
        return item.strip()


class AdvancedProcessor(BaseProcessor):
    """Advanced processor with extra features."""

    def __init__(self, name: str, verbose: bool = False):
        super().__init__(name)
        self.verbose = verbose

    def process(self, data: List[str]) -> List[str]:
        """Process with logging."""
        if self.verbose:
            print(f"Processing {len(data)} items")
        return super().process(data)

    def batch_process(self, batches: List[List[str]]) -> List[List[str]]:
        """Process multiple batches."""
        return [self.process(batch) for batch in batches]


def create_processor(name: str, advanced: bool = False) -> BaseProcessor:
    """Factory function for creating processors."""
    if advanced:
        return AdvancedProcessor(name, verbose=True)
    return BaseProcessor(name)


def run_pipeline(items: List[str], processor_name: str = "default") -> List[str]:
    """Run the processing pipeline."""
    processor = create_processor(processor_name)
    result = processor.process(items)
    return result
'''

# src/cegraph/parser/core.py:10-10
from cegraph.parser.models import FileSymbols, detect_language

# tests/test_parser.py:7-7
from cegraph.parser.models import SymbolKind, RelKind, detect_language

# src/cegraph/parser/models.py:100-105
def detect_language(file_path: str) -> str | None:
    """Detect programming language from file extension."""
    from pathlib import Path

    ext = Path(file_path).suffix.lower()
    return EXTENSION_LANGUAGE_MAP.get(ext)

# src/cegraph/parser/core.py:13-38
def parse_file(file_path: str, source: str | None = None) -> FileSymbols | None:
    """Parse a single file, auto-detecting language and selecting the best parser.

    Returns None if the file's language is not supported.

    - Python: uses stdlib ast (zero deps, high accuracy)
    - JS/TS, Go, Rust, Java: uses tree-sitter (required dep, full AST)
    """
    language = detect_language(file_path)
    if not language:
        return None

    # Python uses stdlib AST â€” better than tree-sitter for Python
    if language == "python":
        from cegraph.parser.python_parser import parse_python_file

        return parse_python_file(file_path, source)

    # Everything else uses tree-sitter
    from cegraph.parser.tree_sitter_parser import is_available, parse_tree_sitter_file

    if is_available(language):
        return parse_tree_sitter_file(file_path, language, source)

    # Language detected but no tree-sitter grammar installed
    return None

# tests/conftest.py:13-139
def tmp_project(tmp_path: Path) -> Path:
    """Create a temporary project directory with sample Python files."""
    # Main module
    (tmp_path / "main.py").write_text('''"""Main application entry point."""

from utils import helper_function, calculate_total
from models import User, Order


def main():
    """Run the main application."""
    user = User("Alice", "alice@example.com")
    order = Order(user, items=["widget", "gadget"])
    total = calculate_total(order.items)
    result = helper_function(total)
    print(f"Order total: {result}")
    return result


def parse_arguments():
    """Parse command line arguments."""
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--verbose", action="store_true")
    return parser.parse_args()


if __name__ == "__main__":
    args = parse_arguments()
    main()
''')

    # Utils module
    (tmp_path / "utils.py").write_text('''"""Utility functions."""

TAX_RATE = 0.08


def helper_function(value):
    """Apply formatting to a value."""
    return f"${value:.2f}"


def calculate_total(items):
    """Calculate total price for a list of items."""
    prices = {"widget": 9.99, "gadget": 24.99, "doohickey": 4.99}
    subtotal = sum(prices.get(item, 0) for item in items)
    tax = subtotal * TAX_RATE
    return subtotal + tax


def validate_email(email):
    """Validate an email address."""
    import re
    pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$"
    return bool(re.match(pattern, email))
''')

    # Models module
    (tmp_path / "models.py").write_text('''"""Data models."""


class User:
    """Represents a user in the system."""

    def __init__(self, name: str, email: str):
        self.name = name
        self.email = email

    def display_name(self):
        """Get the display name."""
        return self.name.title()

    def is_valid(self):
        """Check if user data is valid."""
        from utils import validate_email
        return bool(self.name) and validate_email(self.email)


class Order:
    """Represents an order."""

    def __init__(self, user: User, items: list):
        self.user = user
        self.items = items

    def get_total(self):
        """Get the order total."""
        from utils import calculate_total
        return calculate_total(self.items)

    def summary(self):
        """Get order summary string."""
        total = self.get_total()
        return f"Order for {self.user.display_name()}: {len(self.items)} items, ${total:.2f}"
''')

    # A subdirectory with more files
    api_dir = tmp_path / "api"
    api_dir.mkdir()

    (api_dir / "__init__.py").write_text('"""API package."""\n')

    (api_dir / "routes.py").write_text('''"""API routes."""

from models import User, Order


def get_user(user_id):
    """Get a user by ID."""
    # Simulated database lookup
    return User("Test User", "test@example.com")


def create_order(user_id, items):
    """Create a new order."""
    user = get_user(user_id)
    order = Order(user, items)
    return {"total": order.get_total(), "summary": order.summary()}


def health_check():
    """Health check endpoint."""
    return {"status": "ok"}
''')

    return tmp_path

# src/cegraph/context/engine.py:204-272
    def assemble(
        self,
        task: str,
        token_budget: int = 8000,
        strategy: ContextStrategy = ContextStrategy.SMART,
        focus_files: list[str] | None = None,
    ) -> ContextPackage:
        """Assemble a budgeted context package for a given task.

        Args:
            task: Natural language description of the task.
            token_budget: Maximum tokens to include (budget B).
            strategy: How aggressively to expand context.
            focus_files: Optional list of files to prioritize.

        Returns:
            A ContextPackage with the selected symbols and their source code,
            ordered by dependency (definitions before usage).
        """
        start_time = time.time()
        config = _STRATEGY_CONFIG[strategy]

        # Phase 1: Extract entities from the task
        entities = self._extract_entities(task)

        # Phase 2: Find seed symbols in the graph
        seeds = self._find_seeds(entities, focus_files)

        # Phase 3: Expand context via graph traversal
        if self.ablation.use_pagerank and seeds:
            candidates = self._expand_context_pagerank(seeds, config)
        elif self._native_graph and seeds:
            candidates = self._expand_context_native(seeds, config)
        else:
            candidates = self._expand_context(seeds, config)

        # Phase 4: Score candidates
        scored = self._score_candidates(candidates, entities, seeds)

        # Phase 5: Compute dependency closures
        closures = self._compute_closures(scored)

        # Phase 6: Budgeted selection with closure constraints
        selected = self._budget_select(scored, closures, token_budget)

        # Phase 7: Load source code
        items = self._load_source(selected)

        # Phase 8: Dependency-safe ordering
        if self.ablation.dependency_ordering:
            items = self._dependency_order(items)

        elapsed_ms = (time.time() - start_time) * 1000
        total_tokens = sum(item.token_estimate for item in items)
        files = set(item.file_path for item in items)

        return ContextPackage(
            task=task,
            strategy=strategy,
            items=items,
            seed_symbols=[s["symbol_id"] for s in seeds],
            total_tokens=total_tokens,
            token_budget=token_budget,
            files_included=len(files),
            symbols_included=len(items),
            symbols_available=len(scored),
            budget_used_pct=round(total_tokens / max(token_budget, 1) * 100, 1),
            assembly_time_ms=round(elapsed_ms, 1),
        )

# tests/conftest.py:204-235
def sample_js_source() -> str:
    """Sample JavaScript source code for parser testing."""
    return '''import { useState, useEffect } from "react";
import axios from "axios";

const API_URL = "https://api.example.com";

export class UserService {
    constructor(baseUrl) {
        this.baseUrl = baseUrl;
    }

    async getUser(id) {
        const response = await axios.get(`${this.baseUrl}/users/${id}`);
        return response.data;
    }

    async createUser(data) {
        const response = await axios.post(`${this.baseUrl}/users`, data);
        return response.data;
    }
}

export function formatName(first, last) {
    return `${first} ${last}`;
}

export const fetchData = async (url) => {
    const response = await fetch(url);
    return response.json();
};
'''

# src/cegraph/search/lexical.py:37-103
    def search(
        self,
        query: str,
        file_pattern: str = "",
        max_results: int = 20,
        context_lines: int = 2,
        regex: bool = False,
    ) -> list[SearchResult]:
        """Search for code matching the query.

        Args:
            query: Search query (text or regex pattern).
            file_pattern: Glob pattern to filter files (e.g., "*.py").
            max_results: Maximum results to return.
            context_lines: Number of context lines before/after match.
            regex: If True, treat query as regex pattern.

        Returns:
            Ranked list of search results.
        """
        results: list[SearchResult] = []

        if regex:
            try:
                pattern = re.compile(query, re.IGNORECASE)
            except re.error:
                return []
        else:
            pattern = re.compile(re.escape(query), re.IGNORECASE)

        # Get files from the graph or scan directory
        files = self._get_searchable_files(file_pattern)

        for file_path in files:
            full_path = self.root / file_path
            if not full_path.exists():
                continue

            try:
                lines = full_path.read_text(encoding="utf-8", errors="replace").splitlines()
            except OSError:
                continue

            for i, line in enumerate(lines):
                if pattern.search(line):
                    # Get context
                    start = max(0, i - context_lines)
                    end = min(len(lines), i + context_lines + 1)

                    result = SearchResult(
                        file_path=file_path,
                        line_number=i + 1,
                        line_content=line,
                        score=self._score_match(query, line, file_path),
                        context_before=lines[start:i],
                        context_after=lines[i + 1 : end],
                    )

                    # Enrich with symbol info from graph
                    if self.graph:
                        self._enrich_with_symbol(result, file_path, i + 1)

                    results.append(result)

        # Sort by score descending
        results.sort(key=lambda r: r.score, reverse=True)
        return results[:max_results]

# paper/experiments/benchmark.py:816-828
def _apply_mutation(repo_path: Path, mutation: dict) -> str | None:
    """Apply a mutation to the repo. Returns original content for restoration."""
    if not mutation:
        return None
    file_path = repo_path / mutation["file"]
    if not file_path.exists():
        return None
    original = file_path.read_text()
    mutated = original.replace(mutation["original"], mutation["mutated"], 1)
    if mutated == original:
        return None  # mutation string not found
    file_path.write_text(mutated)
    return original