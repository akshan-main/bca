# tests/conftest.py:143-200
def sample_python_source() -> str:
    """Sample Python source code for parser testing."""
    return '''"""Sample module."""

import os
from typing import List, Optional
from pathlib import Path


CONSTANT_VALUE = 42


class BaseProcessor:
    """Base class for processors."""

    def __init__(self, name: str):
        self.name = name

    def process(self, data: List[str]) -> List[str]:
        """Process the data."""
        return [self._transform(item) for item in data]

    def _transform(self, item: str) -> str:
        """Transform a single item."""
        return item.strip()


class AdvancedProcessor(BaseProcessor):
    """Advanced processor with extra features."""

    def __init__(self, name: str, verbose: bool = False):
        super().__init__(name)
        self.verbose = verbose

    def process(self, data: List[str]) -> List[str]:
        """Process with logging."""
        if self.verbose:
            print(f"Processing {len(data)} items")
        return super().process(data)

    def batch_process(self, batches: List[List[str]]) -> List[List[str]]:
        """Process multiple batches."""
        return [self.process(batch) for batch in batches]


def create_processor(name: str, advanced: bool = False) -> BaseProcessor:
    """Factory function for creating processors."""
    if advanced:
        return AdvancedProcessor(name, verbose=True)
    return BaseProcessor(name)


def run_pipeline(items: List[str], processor_name: str = "default") -> List[str]:
    """Run the processing pipeline."""
    processor = create_processor(processor_name)
    result = processor.process(items)
    return result
'''

# src/cegraph/parser/core.py:10-10
from cegraph.parser.models import FileSymbols, detect_language

# tests/test_parser.py:7-7
from cegraph.parser.models import SymbolKind, RelKind, detect_language

# src/cegraph/parser/models.py:100-105
def detect_language(file_path: str) -> str | None:
    """Detect programming language from file extension."""
    from pathlib import Path

    ext = Path(file_path).suffix.lower()
    return EXTENSION_LANGUAGE_MAP.get(ext)

# src/cegraph/parser/core.py:13-38
def parse_file(file_path: str, source: str | None = None) -> FileSymbols | None:
    """Parse a single file, auto-detecting language and selecting the best parser.

    Returns None if the file's language is not supported.

    - Python: uses stdlib ast (zero deps, high accuracy)
    - JS/TS, Go, Rust, Java: uses tree-sitter (required dep, full AST)
    """
    language = detect_language(file_path)
    if not language:
        return None

    # Python uses stdlib AST — better than tree-sitter for Python
    if language == "python":
        from cegraph.parser.python_parser import parse_python_file

        return parse_python_file(file_path, source)

    # Everything else uses tree-sitter
    from cegraph.parser.tree_sitter_parser import is_available, parse_tree_sitter_file

    if is_available(language):
        return parse_tree_sitter_file(file_path, language, source)

    # Language detected but no tree-sitter grammar installed
    return None

# tests/conftest.py:13-139
def tmp_project(tmp_path: Path) -> Path:
    """Create a temporary project directory with sample Python files."""
    # Main module
    (tmp_path / "main.py").write_text('''"""Main application entry point."""

from utils import helper_function, calculate_total
from models import User, Order


def main():
    """Run the main application."""
    user = User("Alice", "alice@example.com")
    order = Order(user, items=["widget", "gadget"])
    total = calculate_total(order.items)
    result = helper_function(total)
    print(f"Order total: {result}")
    return result


def parse_arguments():
    """Parse command line arguments."""
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--verbose", action="store_true")
    return parser.parse_args()


if __name__ == "__main__":
    args = parse_arguments()
    main()
''')

    # Utils module
    (tmp_path / "utils.py").write_text('''"""Utility functions."""

TAX_RATE = 0.08


def helper_function(value):
    """Apply formatting to a value."""
    return f"${value:.2f}"


def calculate_total(items):
    """Calculate total price for a list of items."""
    prices = {"widget": 9.99, "gadget": 24.99, "doohickey": 4.99}
    subtotal = sum(prices.get(item, 0) for item in items)
    tax = subtotal * TAX_RATE
    return subtotal + tax


def validate_email(email):
    """Validate an email address."""
    import re
    pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$"
    return bool(re.match(pattern, email))
''')

    # Models module
    (tmp_path / "models.py").write_text('''"""Data models."""


class User:
    """Represents a user in the system."""

    def __init__(self, name: str, email: str):
        self.name = name
        self.email = email

    def display_name(self):
        """Get the display name."""
        return self.name.title()

    def is_valid(self):
        """Check if user data is valid."""
        from utils import validate_email
        return bool(self.name) and validate_email(self.email)


class Order:
    """Represents an order."""

    def __init__(self, user: User, items: list):
        self.user = user
        self.items = items

    def get_total(self):
        """Get the order total."""
        from utils import calculate_total
        return calculate_total(self.items)

    def summary(self):
        """Get order summary string."""
        total = self.get_total()
        return f"Order for {self.user.display_name()}: {len(self.items)} items, ${total:.2f}"
''')

    # A subdirectory with more files
    api_dir = tmp_path / "api"
    api_dir.mkdir()

    (api_dir / "__init__.py").write_text('"""API package."""\n')

    (api_dir / "routes.py").write_text('''"""API routes."""

from models import User, Order


def get_user(user_id):
    """Get a user by ID."""
    # Simulated database lookup
    return User("Test User", "test@example.com")


def create_order(user_id, items):
    """Create a new order."""
    user = get_user(user_id)
    order = Order(user, items)
    return {"total": order.get_total(), "summary": order.summary()}


def health_check():
    """Health check endpoint."""
    return {"status": "ok"}
''')

    return tmp_path

# src/cegraph/context/engine.py:204-272
    def assemble(
        self,
        task: str,
        token_budget: int = 8000,
        strategy: ContextStrategy = ContextStrategy.SMART,
        focus_files: list[str] | None = None,
    ) -> ContextPackage:
        """Assemble a budgeted context package for a given task.

        Args:
            task: Natural language description of the task.
            token_budget: Maximum tokens to include (budget B).
            strategy: How aggressively to expand context.
            focus_files: Optional list of files to prioritize.

        Returns:
            A ContextPackage with the selected symbols and their source code,
            ordered by dependency (definitions before usage).
        """
        start_time = time.time()
        config = _STRATEGY_CONFIG[strategy]

        # Phase 1: Extract entities from the task
        entities = self._extract_entities(task)

        # Phase 2: Find seed symbols in the graph
        seeds = self._find_seeds(entities, focus_files)

        # Phase 3: Expand context via graph traversal
        if self.ablation.use_pagerank and seeds:
            candidates = self._expand_context_pagerank(seeds, config)
        elif self._native_graph and seeds:
            candidates = self._expand_context_native(seeds, config)
        else:
            candidates = self._expand_context(seeds, config)

        # Phase 4: Score candidates
        scored = self._score_candidates(candidates, entities, seeds)

        # Phase 5: Compute dependency closures
        closures = self._compute_closures(scored)

        # Phase 6: Budgeted selection with closure constraints
        selected = self._budget_select(scored, closures, token_budget)

        # Phase 7: Load source code
        items = self._load_source(selected)

        # Phase 8: Dependency-safe ordering
        if self.ablation.dependency_ordering:
            items = self._dependency_order(items)

        elapsed_ms = (time.time() - start_time) * 1000
        total_tokens = sum(item.token_estimate for item in items)
        files = set(item.file_path for item in items)

        return ContextPackage(
            task=task,
            strategy=strategy,
            items=items,
            seed_symbols=[s["symbol_id"] for s in seeds],
            total_tokens=total_tokens,
            token_budget=token_budget,
            files_included=len(files),
            symbols_included=len(items),
            symbols_available=len(scored),
            budget_used_pct=round(total_tokens / max(token_budget, 1) * 100, 1),
            assembly_time_ms=round(elapsed_ms, 1),
        )

# src/cegraph/tools/definitions.py:19-318
class CeGraphTools:
    """Collection of built-in tools for the CeGraph agent.

    Each tool interacts with the knowledge graph, search engine,
    and/or the filesystem to provide the agent with accurate information.
    """

    def __init__(
        self,
        root: Path,
        graph: nx.DiGraph,
        query: GraphQuery,
        search: HybridSearch,
    ) -> None:
        self.root = root
        self.graph = graph
        self.query = query
        self.search = search

    def search_code(self, query: str, file_pattern: str = "", max_results: int = 10) -> str:
        """Search for code in the repository matching a query."""
        results = self.search.search(query, file_pattern, max_results=max_results)
        if not results:
            return f"No results found for '{query}'"

        output = []
        for r in results:
            header = f"**{r.file_path}:{r.line_number}**"
            if r.symbol_name:
                header += f" (in `{r.symbol_name}`)"
            output.append(header)

            if r.context_before:
                for line in r.context_before:
                    output.append(f"  {line}")
            output.append(f"→ {r.line_content}")
            if r.context_after:
                for line in r.context_after:
                    output.append(f"  {line}")
            output.append("")

        return "\n".join(output)

    def search_symbols(self, query: str, kind: str = "", max_results: int = 10) -> str:
        """Search for symbol definitions (functions, classes, etc.)."""
        results = self.search.search_symbols(query, kind, max_results)
        if not results:
            return f"No symbols found matching '{query}'"

        output = []
        for r in results:
            output.append(
                f"- **{r['qualified_name']}** ({r['kind']}) at {r['file_path']}:{r['line']}"
            )
            if r.get("signature"):
                output.append(f"  `{r['signature']}`")
        return "\n".join(output)

    def who_calls(self, symbol_name: str, max_depth: int = 2) -> str:
        """Find all callers of a function/method."""
        results = self.query.who_calls(symbol_name, max_depth=max_depth)
        if not results:
            return f"No callers found for '{symbol_name}'"

        output = [f"Callers of `{symbol_name}`:"]
        for r in results:
            indent = "  " * r["depth"]
            output.append(
                f"{indent}← **{r['name']}** ({r['kind']}) at {r['file_path']}:{r['line']}"
            )
        return "\n".join(output)

    def what_calls(self, symbol_name: str) -> str:
        """Find all symbols called by a function/method."""
        results = self.query.what_calls(symbol_name)
        if not results:
            return f"No callees found for '{symbol_name}'"

        output = [f"`{symbol_name}` calls:"]
        for r in results:
            output.append(
                f"→ **{r['name']}** ({r['kind']}) at {r['file_path']}:{r['line']}"
            )
        return "\n".join(output)

    def impact_of(self, symbol_name: str) -> str:
        """Analyze the impact of changing a symbol."""
        result = self.query.impact_of(symbol_name)
        if not result.get("found"):
            return f"Symbol '{symbol_name}' not found in the knowledge graph"

        output = [f"Impact analysis for `{symbol_name}`:"]
        output.append(f"Risk score: {result['risk_score']:.1%}")
        output.append(f"Direct callers: {len(result['direct_callers'])}")
        output.append(f"Transitive callers: {len(result['transitive_callers'])}")
        output.append(f"Affected files ({len(result['affected_files'])}):")
        for f in result["affected_files"]:
            output.append(f"  - {f}")
        return "\n".join(output)

    def read_file(self, file_path: str, start_line: int = 0, end_line: int = 0) -> str:
        """Read a file from the repository."""
        full_path = self.root / file_path
        if not full_path.exists():
            return f"File not found: {file_path}"
        if not full_path.is_file():
            return f"Not a file: {file_path}"

        # Security: ensure we're within the project root
        try:
            full_path.resolve().relative_to(self.root.resolve())
        except ValueError:
            return f"Access denied: {file_path} is outside the project root"

        try:
            content = full_path.read_text(encoding="utf-8", errors="replace")
        except OSError as e:
            return f"Error reading file: {e}"

        lines = content.splitlines()
        if start_line or end_line:
            start = max(0, start_line - 1)
            end = end_line if end_line else len(lines)
            lines = lines[start:end]
            # Add line numbers
            numbered = [
                f"{i + start + 1:4d} | {line}" for i, line in enumerate(lines)
            ]
            return "\n".join(numbered)

        # If file is too long, truncate with message
        if len(lines) > 200:
            numbered = [f"{i + 1:4d} | {line}" for i, line in enumerate(lines[:200])]
            numbered.append(f"\n... ({len(lines) - 200} more lines)")
            return "\n".join(numbered)

        numbered = [f"{i + 1:4d} | {line}" for i, line in enumerate(lines)]
        return "\n".join(numbered)

    def write_file(self, file_path: str, content: str) -> str:
        """Write content to a file (creates or overwrites)."""
        full_path = self.root / file_path
        try:
            full_path.resolve().relative_to(self.root.resolve())
        except ValueError:
            return f"Access denied: {file_path} is outside the project root"

        full_path.parent.mkdir(parents=True, exist_ok=True)
        full_path.write_text(content, encoding="utf-8")
        return f"Successfully wrote {len(content)} bytes to {file_path}"

    def edit_file(
        self, file_path: str, old_text: str, new_text: str
    ) -> str:
        """Replace specific text in a file (targeted edit, not full rewrite)."""
        full_path = self.root / file_path
        if not full_path.exists():
            return f"File not found: {file_path}"

        try:
            full_path.resolve().relative_to(self.root.resolve())
        except ValueError:
            return f"Access denied: {file_path} is outside the project root"

        content = full_path.read_text(encoding="utf-8", errors="replace")
        if old_text not in content:
            return f"Text to replace not found in {file_path}"

        count = content.count(old_text)
        if count > 1:
            return f"Text to replace found {count} times. Please provide more context to make it unique."

        new_content = content.replace(old_text, new_text, 1)
        full_path.write_text(new_content, encoding="utf-8")
        return f"Successfully edited {file_path}"

    def list_files(self, path: str = "", pattern: str = "") -> str:
        """List files in the repository."""
        target = self.root / path if path else self.root
        if not target.exists():
            return f"Path not found: {path}"

        try:
            target.resolve().relative_to(self.root.resolve())
        except ValueError:
            return f"Access denied: {path} is outside the project root"

        files = []
        if pattern:
            import fnmatch

            for p in sorted(target.rglob("*")):
                if p.is_file() and fnmatch.fnmatch(p.name, pattern):
                    files.append(str(p.relative_to(self.root)))
        else:
            for p in sorted(target.iterdir()):
                prefix = "d " if p.is_dir() else "f "
                files.append(prefix + str(p.relative_to(self.root)))

        return "\n".join(files) if files else "No files found"

    def get_structure(self, path: str = "") -> str:
        """Get the project structure with symbol counts."""
        structure = self.query.get_structure(path)
        return json.dumps(structure, indent=2) if structure else "No structure data"

    def get_context(self, symbol_name: str) -> str:
        """Get full context for a symbol including its source code and relationships."""
        symbol_ids = self.query.find_symbol(symbol_name)
        if not symbol_ids:
            return f"Symbol '{symbol_name}' not found"

        output = []
        for sid in symbol_ids[:3]:  # Limit to 3 matches
            info = self.query.get_symbol_info(sid)
            if not info:
                continue

            output.append(f"## {info.qualified_name} ({info.kind})")
            output.append(f"**File:** {info.file_path}:{info.line_start}-{info.line_end}")
            if info.signature:
                output.append(f"**Signature:** `{info.signature}`")
            if info.docstring:
                output.append(f"**Docstring:** {info.docstring[:200]}")

            # Show source code
            file_content = self.read_file(
                info.file_path,
                start_line=info.line_start,
                end_line=info.line_end,
            )
            output.append(f"\n```\n{file_content}\n```")

            # Show relationships
            if info.callers:
                output.append(f"\n**Called by:** {', '.join(c.split('::')[-1] for c in info.callers[:5])}")
            if info.callees:
                output.append(f"**Calls:** {', '.join(c.split('::')[-1] for c in info.callees[:5])}")
            if info.children:
                output.append(f"**Contains:** {', '.join(c.split('::')[-1] for c in info.children[:5])}")

            output.append("")

        return "\n".join(output)

    def run_command(self, command: str) -> str:
        """Run a shell command in the project root (for tests, lint, etc.)."""
        import shlex

        # Parse into argv — this prevents injection via shell metacharacters
        try:
            argv = shlex.split(command)
        except ValueError as e:
            return f"Invalid command syntax: {e}"

        if not argv:
            return "Empty command"

        # Security: only allow specific executables (check first token only)
        allowed_executables = {
            "python", "python3", "pytest", "pip", "pip3",
            "npm", "node", "npx", "yarn", "pnpm",
            "go", "cargo", "make", "gradle", "mvn",
            "ruff", "black", "mypy", "flake8", "eslint", "prettier",
            "git", "ls", "cat", "head", "tail", "wc", "find", "grep",
        }
        # For git, only allow safe read-only subcommands
        _git_safe_subcommands = {"status", "diff", "log", "show", "branch", "tag"}

        exe = argv[0].lower()
        if exe not in allowed_executables:
            return f"Command not allowed for safety. Allowed executables: {', '.join(sorted(allowed_executables))}"

        if exe == "git":
            subcommand = argv[1].lower() if len(argv) > 1 else ""
            if subcommand not in _git_safe_subcommands:
                return f"Only read-only git subcommands are allowed: {', '.join(sorted(_git_safe_subcommands))}"

        try:
            result = subprocess.run(
                argv,
                shell=False,
                cwd=str(self.root),
                capture_output=True,
                text=True,
                timeout=60,
            )
            output = result.stdout
            if result.stderr:
                output += "\n[stderr]\n" + result.stderr
            if result.returncode != 0:
                output += f"\n[exit code: {result.returncode}]"
            # Truncate very long output
            if len(output) > 5000:
                output = output[:5000] + "\n... (truncated)"
            return output or "(no output)"
        except subprocess.TimeoutExpired:
            return "Command timed out after 60 seconds"
        except Exception as e:
            return f"Error running command: {e}"

# tests/conftest.py:204-235
def sample_js_source() -> str:
    """Sample JavaScript source code for parser testing."""
    return '''import { useState, useEffect } from "react";
import axios from "axios";

const API_URL = "https://api.example.com";

export class UserService {
    constructor(baseUrl) {
        this.baseUrl = baseUrl;
    }

    async getUser(id) {
        const response = await axios.get(`${this.baseUrl}/users/${id}`);
        return response.data;
    }

    async createUser(data) {
        const response = await axios.post(`${this.baseUrl}/users`, data);
        return response.data;
    }
}

export function formatName(first, last) {
    return `${first} ${last}`;
}

export const fetchData = async (url) => {
    const response = await fetch(url);
    return response.json();
};
'''

# src/cegraph/agent/loop.py:45-191
class AgentLoop:
    """ReAct agent loop that iteratively uses tools to complete tasks.

    The agent:
    1. Receives a task from the user
    2. Reasons about what to do next
    3. Calls tools to gather information or make changes
    4. Processes tool results
    5. Repeats until it has enough info to give a final answer
    6. Presents the answer/changes for user approval
    """

    def __init__(
        self,
        llm: LLMProvider,
        tools: ToolRegistry,
        project_name: str = "",
        max_iterations: int = 15,
        on_step: Callable[[AgentStep], None] | None = None,
        on_approval_needed: Callable[[str], bool] | None = None,
    ) -> None:
        self.llm = llm
        self.tools = tools
        self.project_name = project_name
        self.max_iterations = max_iterations
        self.on_step = on_step
        self.on_approval_needed = on_approval_needed

    async def run(self, task: str, context: str = "") -> AgentResult:
        """Run the agent loop for a given task.

        Args:
            task: The user's request/task.
            context: Additional context (e.g., file content, error messages).

        Returns:
            AgentResult with the final answer and step history.
        """
        messages: list[Message] = [
            Message(role="system", content=get_system_prompt(self.project_name)),
        ]

        # Add context if provided
        user_content = task
        if context:
            user_content = f"{task}\n\nContext:\n{context}"
        messages.append(Message(role="user", content=user_content))

        steps: list[AgentStep] = []
        total_tokens = 0

        for iteration in range(self.max_iterations):
            step = AgentStep(iteration=iteration + 1)

            try:
                response = await self.llm.complete(
                    messages=messages,
                    tools=self.tools.get_definitions(),
                    temperature=0.0,
                )
            except Exception as e:
                return AgentResult(
                    answer="",
                    steps=steps,
                    total_iterations=iteration + 1,
                    total_tokens=total_tokens,
                    success=False,
                    error=f"LLM error: {e}",
                )

            step.usage = response.usage
            total_tokens += sum(response.usage.values())

            if response.has_tool_calls:
                # Agent wants to use tools
                step.thought = response.content
                step.tool_calls = response.tool_calls

                # Add assistant message with tool calls
                messages.append(
                    Message(
                        role="assistant",
                        content=response.content,
                        tool_calls=response.tool_calls,
                    )
                )

                # Execute each tool call
                for tc in response.tool_calls:
                    result = await self.tools.execute(tc.name, tc.arguments)
                    tool_result = ToolResult(
                        tool_call_id=tc.id,
                        name=tc.name,
                        content=result,
                    )
                    step.tool_results.append(tool_result)

                    # Add tool result message
                    messages.append(
                        Message(
                            role="tool",
                            content=result,
                            tool_call_id=tc.id,
                            name=tc.name,
                        )
                    )

                # Notify step callback
                if self.on_step:
                    self.on_step(step)

                steps.append(step)

            else:
                # Agent is done - final answer
                step.response = response.content

                if self.on_step:
                    self.on_step(step)

                steps.append(step)

                return AgentResult(
                    answer=response.content,
                    steps=steps,
                    total_iterations=iteration + 1,
                    total_tokens=total_tokens,
                    success=True,
                )

        # Max iterations reached
        return AgentResult(
            answer="I reached the maximum number of iterations. Here's what I've found so far based on my analysis.",
            steps=steps,
            total_iterations=self.max_iterations,
            total_tokens=total_tokens,
            success=False,
            error="Max iterations reached",
        )

    async def ask(self, question: str) -> str:
        """Simple Q&A mode - ask a question about the codebase.

        Returns just the answer string.
        """
        result = await self.run(question)
        return result.answer

# src/cegraph/search/lexical.py:157-183
    def _get_searchable_files(self, file_pattern: str) -> list[str]:
        """Get list of files to search."""
        files = []
        if self.graph:
            for node_id, data in self.graph.nodes(data=True):
                if data.get("type") == "file":
                    path = data.get("path", "")
                    if file_pattern:
                        from fnmatch import fnmatch

                        if not fnmatch(path, file_pattern):
                            continue
                    files.append(path)
        else:
            # Scan directory
            import os

            for dirpath, _, filenames in os.walk(self.root):
                for filename in filenames:
                    rel_path = str(Path(dirpath, filename).relative_to(self.root))
                    if file_pattern:
                        from fnmatch import fnmatch

                        if not fnmatch(rel_path, file_pattern):
                            continue
                    files.append(rel_path)
        return sorted(files)

# src/cegraph/ui/console.py:49-51
    def code(self, text: str, language: str = "python") -> None:
        """Render syntax-highlighted code."""
        self.console.print(Syntax(text, language, theme="monokai", line_numbers=True))

# src/cegraph/tools/registry.py:38-40
    def get_definitions(self) -> list[ToolDefinition]:
        """Get all tool definitions (for passing to LLM)."""
        return list(self._definitions.values())