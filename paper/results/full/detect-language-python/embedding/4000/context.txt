# src/cegraph/parser/models.py:100-105
def detect_language(file_path: str) -> str | None:
    """Detect programming language from file extension."""
    from pathlib import Path

    ext = Path(file_path).suffix.lower()
    return EXTENSION_LANGUAGE_MAP.get(ext)

# src/cegraph/parser/core.py:10-10
from cegraph.parser.models import FileSymbols, detect_language

# tests/test_parser.py:7-7
from cegraph.parser.models import SymbolKind, RelKind, detect_language

# tests/test_parser.py:13-15
    def test_python(self):
        assert detect_language("main.py") == "python"
        assert detect_language("types.pyi") == "python"

# tests/test_parser.py:8-8
from cegraph.parser.python_parser import parse_python_file

# tests/test_parser.py:155-158
    def test_auto_detect_python(self, sample_python_source: str):
        result = parse_file("sample.py", sample_python_source)
        assert result is not None
        assert result.language == "python"

# tests/test_parser.py:148-151
    def test_typescript_detection(self):
        result = parse_file("app.ts", "const x: number = 1;")
        assert result is not None
        assert result.language == "typescript"

# tests/test_parser.py:112-114
    def test_syntax_error_handling(self):
        result = parse_python_file("bad.py", "def broken(:\n  pass")
        assert len(result.errors) > 0

# tests/test_parser.py:39-119
class TestPythonParser:
    def test_parse_functions(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)
        assert result.language == "python"
        assert len(result.errors) == 0

        # Check functions are found
        func_names = [
            s.name for s in result.symbols if s.kind == SymbolKind.FUNCTION
        ]
        assert "create_processor" in func_names
        assert "run_pipeline" in func_names

    def test_parse_classes(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)

        class_names = [
            s.name for s in result.symbols if s.kind == SymbolKind.CLASS
        ]
        assert "BaseProcessor" in class_names
        assert "AdvancedProcessor" in class_names

    def test_parse_methods(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)

        methods = [s for s in result.symbols if s.kind == SymbolKind.METHOD]
        method_names = [m.name for m in methods]
        assert "__init__" in method_names
        assert "process" in method_names
        assert "_transform" in method_names
        assert "batch_process" in method_names

    def test_parse_imports(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)
        assert "os" in result.imports
        assert "typing.List" in result.imports
        assert "pathlib.Path" in result.imports

    def test_parse_constants(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)
        constants = [
            s for s in result.symbols if s.kind == SymbolKind.CONSTANT
        ]
        assert any(c.name == "CONSTANT_VALUE" for c in constants)

    def test_parse_inheritance(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)
        inherits = [
            r for r in result.relationships if r.kind == RelKind.INHERITS
        ]
        assert any("AdvancedProcessor" in r.source and "BaseProcessor" in r.target for r in inherits)

    def test_parse_calls(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)
        calls = [r for r in result.relationships if r.kind == RelKind.CALLS]
        # run_pipeline calls create_processor
        assert any(
            "run_pipeline" in r.source and "create_processor" in r.target
            for r in calls
        )

    def test_parse_docstrings(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)
        funcs = {s.name: s for s in result.symbols if s.kind in (SymbolKind.FUNCTION, SymbolKind.METHOD)}
        assert "Factory function" in funcs["create_processor"].docstring
        assert "Transform a single item" in funcs["_transform"].docstring

    def test_parse_contains_relationships(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)
        contains = [r for r in result.relationships if r.kind == RelKind.CONTAINS]
        # BaseProcessor should contain process, _transform, __init__
        assert any("BaseProcessor" in r.source and "process" in r.target for r in contains)

    def test_syntax_error_handling(self):
        result = parse_python_file("bad.py", "def broken(:\n  pass")
        assert len(result.errors) > 0

    def test_empty_file(self):
        result = parse_python_file("empty.py", "")
        assert result.language == "python"
        assert len(result.symbols) == 0

# tests/test_parser.py:116-119
    def test_empty_file(self):
        result = parse_python_file("empty.py", "")
        assert result.language == "python"
        assert len(result.symbols) == 0

# src/cegraph/parser/core.py:13-38
def parse_file(file_path: str, source: str | None = None) -> FileSymbols | None:
    """Parse a single file, auto-detecting language and selecting the best parser.

    Returns None if the file's language is not supported.

    - Python: uses stdlib ast (zero deps, high accuracy)
    - JS/TS, Go, Rust, Java: uses tree-sitter (required dep, full AST)
    """
    language = detect_language(file_path)
    if not language:
        return None

    # Python uses stdlib AST â€” better than tree-sitter for Python
    if language == "python":
        from cegraph.parser.python_parser import parse_python_file

        return parse_python_file(file_path, source)

    # Everything else uses tree-sitter
    from cegraph.parser.tree_sitter_parser import is_available, parse_tree_sitter_file

    if is_available(language):
        return parse_tree_sitter_file(file_path, language, source)

    # Language detected but no tree-sitter grammar installed
    return None

# tests/test_parser.py:100-104
    def test_parse_docstrings(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)
        funcs = {s.name: s for s in result.symbols if s.kind in (SymbolKind.FUNCTION, SymbolKind.METHOD)}
        assert "Factory function" in funcs["create_processor"].docstring
        assert "Transform a single item" in funcs["_transform"].docstring

# tests/test_parser.py:165-167
    def test_unsupported_file(self):
        result = parse_file("readme.md", "# Hello")
        assert result is None

# tests/conftest.py:143-200
def sample_python_source() -> str:
    """Sample Python source code for parser testing."""
    return '''"""Sample module."""

import os
from typing import List, Optional
from pathlib import Path


CONSTANT_VALUE = 42


class BaseProcessor:
    """Base class for processors."""

    def __init__(self, name: str):
        self.name = name

    def process(self, data: List[str]) -> List[str]:
        """Process the data."""
        return [self._transform(item) for item in data]

    def _transform(self, item: str) -> str:
        """Transform a single item."""
        return item.strip()


class AdvancedProcessor(BaseProcessor):
    """Advanced processor with extra features."""

    def __init__(self, name: str, verbose: bool = False):
        super().__init__(name)
        self.verbose = verbose

    def process(self, data: List[str]) -> List[str]:
        """Process with logging."""
        if self.verbose:
            print(f"Processing {len(data)} items")
        return super().process(data)

    def batch_process(self, batches: List[List[str]]) -> List[List[str]]:
        """Process multiple batches."""
        return [self.process(batch) for batch in batches]


def create_processor(name: str, advanced: bool = False) -> BaseProcessor:
    """Factory function for creating processors."""
    if advanced:
        return AdvancedProcessor(name, verbose=True)
    return BaseProcessor(name)


def run_pipeline(items: List[str], processor_name: str = "default") -> List[str]:
    """Run the processing pipeline."""
    processor = create_processor(processor_name)
    result = processor.process(items)
    return result
'''

# tests/test_parser.py:52-59
    def test_parse_classes(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)

        class_names = [
            s.name for s in result.symbols if s.kind == SymbolKind.CLASS
        ]
        assert "BaseProcessor" in class_names
        assert "AdvancedProcessor" in class_names

# tests/test_parser.py:31-36
    def test_unknown(self):
        assert detect_language("readme.md") is None
        assert detect_language("data.json") is None
        # Languages without tree-sitter grammars are not supported
        assert detect_language("main.rb") is None
        assert detect_language("main.php") is None

# tests/test_impact_bot.py:95-98
    def test_parse_multiple_files(self):
        combined = SAMPLE_DIFF + SAMPLE_DIFF_NEW_FILE
        diffs = parse_diff(combined)
        assert len(diffs) == 2

# tests/test_impact_bot.py:90-93
    def test_parse_deleted_file(self):
        diffs = parse_diff(SAMPLE_DIFF_DELETED)
        assert len(diffs) == 1
        assert diffs[0].status == "deleted"

# tests/test_impact_bot.py:85-88
    def test_parse_new_file(self):
        diffs = parse_diff(SAMPLE_DIFF_NEW_FILE)
        assert len(diffs) == 1
        assert diffs[0].status == "added"

# tests/test_parser.py:71-75
    def test_parse_imports(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)
        assert "os" in result.imports
        assert "typing.List" in result.imports
        assert "pathlib.Path" in result.imports

# tests/test_parser.py:17-19
    def test_javascript(self):
        assert detect_language("app.js") == "javascript"
        assert detect_language("component.jsx") == "javascript"

# tests/test_parser.py:21-23
    def test_typescript(self):
        assert detect_language("app.ts") == "typescript"
        assert detect_language("component.tsx") == "typescript"

# tests/test_parser.py:91-98
    def test_parse_calls(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)
        calls = [r for r in result.relationships if r.kind == RelKind.CALLS]
        # run_pipeline calls create_processor
        assert any(
            "run_pipeline" in r.source and "create_processor" in r.target
            for r in calls
        )

# tests/test_parser.py:77-82
    def test_parse_constants(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)
        constants = [
            s for s in result.symbols if s.kind == SymbolKind.CONSTANT
        ]
        assert any(c.name == "CONSTANT_VALUE" for c in constants)

# tests/test_parser.py:28-29
    def test_rust(self):
        assert detect_language("main.rs") == "rust"

# tests/test_impact_bot.py:70-75
    def test_parse_modified_file(self):
        diffs = parse_diff(SAMPLE_DIFF)
        assert len(diffs) == 1
        assert diffs[0].path == "utils.py"
        assert diffs[0].status == "modified"
        assert len(diffs[0].hunks) == 2

# src/cegraph/parser/python_parser.py:17-32
def parse_python_file(file_path: str, source: str | None = None) -> FileSymbols:
    """Parse a Python file and extract symbols and relationships."""
    if source is None:
        source = Path(file_path).read_text(encoding="utf-8", errors="replace")

    result = FileSymbols(file_path=file_path, language="python")

    try:
        tree = ast.parse(source, filename=file_path)
    except SyntaxError as e:
        result.errors.append(f"SyntaxError: {e}")
        return result

    lines = source.splitlines()
    _extract_from_module(tree, file_path, lines, result)
    return result

# tests/test_parser.py:25-26
    def test_go(self):
        assert detect_language("main.go") == "go"

# src/cegraph/parser/tree_sitter_parser.py:106-127
def parse_tree_sitter_file(
    file_path: str, language: str, source: str | None = None
) -> FileSymbols:
    """Parse a file using tree-sitter for accurate AST extraction."""
    from tree_sitter import Parser

    if source is None:
        source = Path(file_path).read_text(encoding="utf-8", errors="replace")

    result = FileSymbols(file_path=file_path, language=language)
    source_bytes = source.encode("utf-8")

    try:
        ts_language = _get_language(language)
        parser = Parser(ts_language)
        tree = parser.parse(source_bytes)
    except Exception as e:
        result.errors.append(f"tree-sitter parse error: {e}")
        return result

    _walk_tree(tree.root_node, file_path, language, source_bytes, result)
    return result

# tests/test_parser.py:40-50
    def test_parse_functions(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)
        assert result.language == "python"
        assert len(result.errors) == 0

        # Check functions are found
        func_names = [
            s.name for s in result.symbols if s.kind == SymbolKind.FUNCTION
        ]
        assert "create_processor" in func_names
        assert "run_pipeline" in func_names

# src/cegraph/exceptions.py:12-13
class ParserError(CeGraphError):
    """Code parsing errors."""

# paper/experiments/baselines.py:18-18
import argparse

# paper/experiments/make_tasks.py:17-17
import argparse

# paper/experiments/benchmark.py:32-32
import argparse

# paper/experiments/ablation.py:13-13
import argparse

# paper/experiments/run_all.py:9-9
import argparse

# tests/test_parser.py:106-110
    def test_parse_contains_relationships(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)
        contains = [r for r in result.relationships if r.kind == RelKind.CONTAINS]
        # BaseProcessor should contain process, _transform, __init__
        assert any("BaseProcessor" in r.source and "process" in r.target for r in contains)

# src/cegraph/exceptions.py:24-25
class ToolError(CeGraphError):
    """Agent tool execution errors."""

# tests/test_parser.py:160-163
    def test_auto_detect_javascript(self, sample_js_source: str):
        result = parse_file("app.js", sample_js_source)
        assert result is not None
        assert result.language == "javascript"

# tests/test_tools.py:62-65
    def test_read_file_not_found(self, tmp_project: Path):
        tools = self._build_tools(tmp_project)
        result = tools.read_file("nonexistent.py")
        assert "not found" in result.lower()

# tests/test_parser.py:12-36
class TestLanguageDetection:
    def test_python(self):
        assert detect_language("main.py") == "python"
        assert detect_language("types.pyi") == "python"

    def test_javascript(self):
        assert detect_language("app.js") == "javascript"
        assert detect_language("component.jsx") == "javascript"

    def test_typescript(self):
        assert detect_language("app.ts") == "typescript"
        assert detect_language("component.tsx") == "typescript"

    def test_go(self):
        assert detect_language("main.go") == "go"

    def test_rust(self):
        assert detect_language("main.rs") == "rust"

    def test_unknown(self):
        assert detect_language("readme.md") is None
        assert detect_language("data.json") is None
        # Languages without tree-sitter grammars are not supported
        assert detect_language("main.rb") is None
        assert detect_language("main.php") is None

# tests/test_impact_bot.py:81-83
    def test_parse_deleted_lines(self):
        diffs = parse_diff(SAMPLE_DIFF)
        assert diffs[0].deleted_lines > 0

# tests/test_parser.py:61-69
    def test_parse_methods(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)

        methods = [s for s in result.symbols if s.kind == SymbolKind.METHOD]
        method_names = [m.name for m in methods]
        assert "__init__" in method_names
        assert "process" in method_names
        assert "_transform" in method_names
        assert "batch_process" in method_names

# src/cegraph/graph/builder.py:11-11
from cegraph.parser.core import parse_directory

# src/cegraph/parser/__init__.py:4-4
from cegraph.parser.core import parse_file, parse_directory

# tests/test_impact_bot.py:194-197
    def test_render_file_tree(self):
        files = ["src/main.py", "src/utils.py", "tests/test_main.py"]
        tree = _render_file_tree(files)
        assert len(tree) > 0

# tests/test_impact_bot.py:108-110
    def test_parse_empty(self):
        diffs = parse_diff("")
        assert diffs == []

# tests/test_tools.py:105-108
    def test_list_files_pattern(self, tmp_project: Path):
        tools = self._build_tools(tmp_project)
        result = tools.list_files(pattern="*.py")
        assert "main.py" in result

# tests/test_tools.py:87-90
    def test_edit_file_text_not_found(self, tmp_project: Path):
        tools = self._build_tools(tmp_project)
        result = tools.edit_file("utils.py", "NONEXISTENT_TEXT", "replacement")
        assert "not found" in result.lower()

# tests/test_impact_bot.py:77-79
    def test_parse_added_lines(self):
        diffs = parse_diff(SAMPLE_DIFF)
        assert diffs[0].added_lines > 0

# src/cegraph/parser/__init__.py:4-4
from cegraph.parser.core import parse_file, parse_directory

# tests/test_parser.py:9-9
from cegraph.parser.core import parse_file

# tests/test_tools.py:100-103
    def test_list_files(self, tmp_project: Path):
        tools = self._build_tools(tmp_project)
        result = tools.list_files()
        assert "main.py" in result

# src/cegraph/ui/console.py:49-51
    def code(self, text: str, language: str = "python") -> None:
        """Render syntax-highlighted code."""
        self.console.print(Syntax(text, language, theme="monokai", line_numbers=True))

# src/cegraph/llm/base.py:55-56
    def has_tool_calls(self) -> bool:
        return len(self.tool_calls) > 0