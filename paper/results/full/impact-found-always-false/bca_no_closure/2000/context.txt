# Codebase Context for: GraphQuery.impact_of always reports the symbol as not found, even when it exists in the graph. The return dict has found=False regardless of whether find_symbol matches.
# 36 symbols from 14 files (~2,173 tokens, 109% of budget)

## src/cegraph/context/_native.py
# Included because: graph expansion (depth 3)

# [method] NativeGraph.add_edge (relevance: 0.45, depth: 3)
 229 |     def add_edge(self, src: int, dst: int, weight: float) -> None:
 230 |         self._lib.cag_graph_add_edge(self._handle, src, dst, weight)

# [method] NativeGraph.set_node_weight (relevance: 0.29, depth: 3)
 232 |     def set_node_weight(self, node: int, weight: float) -> None:
 233 |         self._lib.cag_graph_set_node_weight(self._handle, node, weight)

# [method] NativeGraph.set_lines (relevance: 0.29, depth: 3)
 235 |     def set_lines(self, node: int, start: int, end: int) -> None:
 236 |         self._lib.cag_graph_set_lines(self._handle, node, start, end)

## src/cegraph/context/models.py
# Included because: graph expansion (depth 3)

# [method] TokenEstimator.estimate (relevance: 0.47, depth: 3)
 166 |     def estimate(cls, text: str) -> int:
 167 |         """Estimate token count for a string."""
 168 |         return max(1, int(len(text) / cls.CHARS_PER_TOKEN))

# [method] TokenEstimator.estimate_lines (relevance: 0.39, depth: 3)
 171 |     def estimate_lines(cls, line_count: int, avg_line_length: int = 40) -> int:
 172 |         """Estimate tokens for a given number of lines."""
 173 |         return max(1, int(line_count * avg_line_length / cls.CHARS_PER_TOKEN))

## src/cegraph/exceptions.py
# Included because: graph expansion (depth 2); graph expansion (depth 1)

# [class] CeGraphError (relevance: 0.43, depth: 2)
   4 | class CeGraphError(Exception):
   5 |     """Base exception for all CeGraph errors."""

# [class] LLMError (relevance: 0.39, depth: 1)
  20 | class LLMError(CeGraphError):
  21 |     """LLM provider errors."""

## src/cegraph/github/diff_parser.py
# Included because: graph expansion (depth 2)

# [function] get_pr_diff (relevance: 0.55, depth: 2)
 205 | def get_pr_diff(root: Path) -> str:
 206 |     """Get the diff for the current PR (GitHub Actions context)."""
 207 |     import os
 208 |     base_ref = os.environ.get("GITHUB_BASE_REF", "main")
 209 |     return get_git_diff(root, base=f"origin/{base_ref}")

## src/cegraph/graph/query.py
# Included because: matches 'find_symbol'; graph expansion (depth 1); matches 'impact_of'

# [method] GraphQuery.__init__ (relevance: 0.80, depth: 1)
  38 |     def __init__(self, graph: nx.DiGraph, store: GraphStore | None = None) -> None:
  39 |         self.graph = graph
  40 |         self.store = store
  41 |         self._name_index: dict[str, list[str]] = {}
  42 |         self._build_index()

# [method] GraphQuery.find_symbol (relevance: 1.22, depth: 0)
  56 |     def find_symbol(self, name: str) -> list[str]:
  57 |         """Find symbol node IDs matching a name (exact or qualified)."""
  58 |         results = self._name_index.get(name, [])
  59 |         if not results:
  60 |             # Try partial match
  61 |             for key, ids in self._name_index.items():
  62 |                 if name.lower() in key.lower():
  63 |                     results.extend(ids)
  64 |         return list(set(results))

# [method] GraphQuery.impact_of (relevance: 1.18, depth: 0)
 185 |     def impact_of(self, name: str, max_depth: int = 3) -> dict:
 186 |         """Analyze the impact of changing a symbol.
 187 | 
 188 |         Returns a dict with:
 189 |         - direct_callers: immediate callers
 190 |         - transitive_callers: all callers up to max_depth
 191 |         - affected_files: set of files that could be affected
 192 |         - risk_score: rough risk assessment (0-1)
 193 |         """
 194 |         symbol_ids = self.find_symbol(name)
 195 |         if not symbol_ids:
 196 |             return {
 197 |                 "symbol": name,
 198 |                 "found": False,
 199 |                 "direct_callers": [],
 200 |                 "transitive_callers": [],
 201 |                 "affected_files": [],
 202 |                 "risk_score": 0.0,
 203 |             }
 204 | 
 205 |         direct = self.who_calls(name, max_depth=1)
 206 |         transitive = self.who_calls(name, max_depth=max_depth)
 207 | 
 208 |         affected_files = set()
 209 |         for item in transitive:
 210 |             if item.get("file_path"):
 211 |                 affected_files.add(item["file_path"])
 212 |         # Also include the symbol's own file
 213 |         for sid in symbol_ids:
 214 |             data = self.graph.nodes.get(sid, {})
 215 |             if data.get("file_path"):
 216 |                 affected_files.add(data["file_path"])
 217 | 
 218 |         # Risk score based on impact breadth
 219 |         total_files = sum(1 for _, d in self.graph.nodes(data=True) if d.get("type") == "file")
 220 |         risk_score = min(len(affected_files) / max(total_files, 1), 1.0)
 221 | 
 222 |         return {
 223 |             "symbol": name,
 224 |             "found": False,
 225 |             "direct_callers": direct,
 226 |             "transitive_callers": transitive,
 227 |             "affected_files": sorted(affected_files),
 228 |             "risk_score": round(risk_score, 3),
 229 |         }

## src/cegraph/graph/store.py
# Included because: graph expansion (depth 2)

# [method] GraphStore.close (relevance: 0.63, depth: 2)
 499 |     def close(self) -> None:
 500 |         """Close the database connection."""
 501 |         if self._conn:
 502 |             self._conn.close()
 503 |             self._conn = None

## src/cegraph/parser/models.py
# Included because: matches 'symbol'; graph expansion (depth 2)

# [class] Symbol (relevance: 0.58, depth: 0)
  39 | class Symbol(BaseModel):
  40 |     """A code symbol (function, class, method, variable, etc.)."""
  41 | 
  42 |     id: str = ""  # auto-generated: "file_path::name"
  43 |     name: str
  44 |     qualified_name: str = ""  # e.g., "MyClass.my_method"
  45 |     kind: SymbolKind
  46 |     file_path: str
  47 |     line_start: int
  48 |     line_end: int
  49 |     column_start: int = 0
  50 |     column_end: int = 0
  51 |     signature: str = ""  # e.g., "def my_method(self, x: int) -> str"
  52 |     docstring: str = ""
  53 |     decorators: list[str] = Field(default_factory=list)
  54 |     parent: str = ""  # parent symbol ID (e.g., class for a method)
  55 | 
  56 |     def model_post_init(self, __context: object) -> None:
  57 |         if not self.id:
  58 |             self.id = f"{self.file_path}::{self.qualified_name or self.name}"
  59 |         if not self.qualified_name:
  60 |             self.qualified_name = self.name

# [function] detect_language (relevance: 0.49, depth: 2)
 100 | def detect_language(file_path: str) -> str | None:
 101 |     """Detect programming language from file extension."""
 102 |     from pathlib import Path
 103 | 
 104 |     ext = Path(file_path).suffix.lower()
 105 |     return EXTENSION_LANGUAGE_MAP.get(ext)

## src/cegraph/tools/definitions.py
# Included because: graph expansion (depth 2); matches 'impact_of'

# [method] CeGraphTools.impact_of (relevance: 1.04, depth: 0)
 104 |     def impact_of(self, symbol_name: str) -> str:
 105 |         """Analyze the impact of changing a symbol."""
 106 |         result = self.query.impact_of(symbol_name)
 107 |         if not result.get("found"):
 108 |             return f"Symbol '{symbol_name}' not found in the knowledge graph"
 109 | 
 110 |         output = [f"Impact analysis for `{symbol_name}`:"]
 111 |         output.append(f"Risk score: {result['risk_score']:.1%}")
 112 |         output.append(f"Direct callers: {len(result['direct_callers'])}")
 113 |         output.append(f"Transitive callers: {len(result['transitive_callers'])}")
 114 |         output.append(f"Affected files ({len(result['affected_files'])}):")
 115 |         for f in result["affected_files"]:
 116 |             output.append(f"  - {f}")
 117 |         return "\n".join(output)

# [method] CeGraphTools.get_structure (relevance: 0.37, depth: 2)
 220 |     def get_structure(self, path: str = "") -> str:
 221 |         """Get the project structure with symbol counts."""
 222 |         structure = self.query.get_structure(path)
 223 |         return json.dumps(structure, indent=2) if structure else "No structure data"

## src/cegraph/tools/registry.py
# Included because: graph expansion (depth 2); graph expansion (depth 1); graph expansion (depth 3)

# [method] ToolRegistry.get (relevance: 0.85, depth: 1)
  26 |     def get(self, name: str) -> Callable | None:
  27 |         """Get a tool function by name."""
  28 |         return self._tools.get(name)

# [method] ToolRegistry.get_definition (relevance: 0.35, depth: 2)
  30 |     def get_definition(self, name: str) -> ToolDefinition | None:
  31 |         """Get a tool definition by name."""
  32 |         return self._definitions.get(name)

# [method] ToolRegistry.list_tools (relevance: 0.29, depth: 3)
  34 |     def list_tools(self) -> list[str]:
  35 |         """List all registered tool names."""
  36 |         return list(self._tools.keys())

## src/cegraph/ui/console.py
# Included because: graph expansion (depth 3)

# [method] Console.success (relevance: 0.37, depth: 3)
  33 |     def success(self, message: str) -> None:
  34 |         self.console.print(f"[green]✓[/green] {message}")

# [method] Console.error (relevance: 0.54, depth: 3)
  36 |     def error(self, message: str) -> None:
  37 |         self.console.print(f"[red]✗[/red] {message}")

# [method] Console.warning (relevance: 0.42, depth: 3)
  39 |     def warning(self, message: str) -> None:
  40 |         self.console.print(f"[yellow]![/yellow] {message}")

# [method] Console.info (relevance: 0.50, depth: 3)
  42 |     def info(self, message: str) -> None:
  43 |         self.console.print(f"[blue]i[/blue] {message}")

## tests/test_graph.py
# Included because: graph expansion (depth 2); graph expansion (depth 1)

# [method] TestGraphQuery._build_query (relevance: 0.59, depth: 2)
 155 |     def _build_query(self, tmp_project: Path) -> GraphQuery:
 156 |         builder = GraphBuilder()
 157 |         graph = builder.build_from_directory(tmp_project)
 158 |         return GraphQuery(graph)

# [method] TestGraphQuery.test_find_symbol (relevance: 0.47, depth: 1)
 160 |     def test_find_symbol(self, tmp_project: Path):
 161 |         query = self._build_query(tmp_project)
 162 |         results = query.find_symbol("main")
 163 |         assert len(results) > 0

# [method] TestGraphQuery.test_find_symbol_partial (relevance: 0.47, depth: 1)
 165 |     def test_find_symbol_partial(self, tmp_project: Path):
 166 |         query = self._build_query(tmp_project)
 167 |         results = query.find_symbol("helper")
 168 |         assert len(results) > 0

# [method] TestGraphQuery.test_impact_not_found (relevance: 0.47, depth: 1)
 191 |     def test_impact_not_found(self, tmp_project: Path):
 192 |         query = self._build_query(tmp_project)
 193 |         impact = query.impact_of("nonexistent_function")
 194 |         assert impact["found"] is False

# [method] TestGraphQuery.test_get_structure (relevance: 0.38, depth: 2)
 203 |     def test_get_structure(self, tmp_project: Path):
 204 |         query = self._build_query(tmp_project)
 205 |         structure = query.get_structure()
 206 |         assert "main.py" in structure or len(structure) > 0

# [method] TestGraphQuery.test_find_related (relevance: 0.38, depth: 2)
 208 |     def test_find_related(self, tmp_project: Path):
 209 |         query = self._build_query(tmp_project)
 210 |         related = query.find_related("calculate_total")
 211 |         assert len(related) > 0

## tests/test_impact_bot.py
# Included because: graph expansion (depth 3)

# [method] TestDiffParser.test_parse_added_lines (relevance: 0.26, depth: 3)
  77 |     def test_parse_added_lines(self):
  78 |         diffs = parse_diff(SAMPLE_DIFF)
  79 |         assert diffs[0].added_lines > 0

# [method] TestDiffParser.test_parse_deleted_lines (relevance: 0.26, depth: 3)
  81 |     def test_parse_deleted_lines(self):
  82 |         diffs = parse_diff(SAMPLE_DIFF)
  83 |         assert diffs[0].deleted_lines > 0

# [method] TestDiffParser.test_parse_empty (relevance: 0.26, depth: 3)
 108 |     def test_parse_empty(self):
 109 |         diffs = parse_diff("")
 110 |         assert diffs == []

## tests/test_search.py
# Included because: graph expansion (depth 3)

# [method] TestLexicalSearch._build_search (relevance: 0.43, depth: 3)
  15 |     def _build_search(self, tmp_project: Path) -> LexicalSearch:
  16 |         builder = GraphBuilder()
  17 |         graph = builder.build_from_directory(tmp_project)
  18 |         return LexicalSearch(tmp_project, graph)

## tests/test_tools.py
# Included because: graph expansion (depth 2); graph expansion (depth 1)

# [method] TestCeGraphTools._build_tools (relevance: 0.59, depth: 2)
  16 |     def _build_tools(self, tmp_project: Path) -> CeGraphTools:
  17 |         builder = GraphBuilder()
  18 |         graph = builder.build_from_directory(tmp_project)
  19 |         query = GraphQuery(graph)
  20 |         search = HybridSearch(tmp_project, graph)
  21 |         return CeGraphTools(tmp_project, graph, query, search)

# [method] TestCeGraphTools.test_what_calls (relevance: 0.38, depth: 2)
  40 |     def test_what_calls(self, tmp_project: Path):
  41 |         tools = self._build_tools(tmp_project)
  42 |         result = tools.what_calls("main")
  43 |         assert len(result) > 0

# [method] TestCeGraphTools.test_impact_of (relevance: 0.47, depth: 1)
  45 |     def test_impact_of(self, tmp_project: Path):
  46 |         tools = self._build_tools(tmp_project)
  47 |         result = tools.impact_of("calculate_total")
  48 |         assert "Risk score" in result or "Impact" in result
