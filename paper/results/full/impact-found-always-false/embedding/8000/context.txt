# src/cegraph/graph/query.py:185-229
    def impact_of(self, name: str, max_depth: int = 3) -> dict:
        """Analyze the impact of changing a symbol.

        Returns a dict with:
        - direct_callers: immediate callers
        - transitive_callers: all callers up to max_depth
        - affected_files: set of files that could be affected
        - risk_score: rough risk assessment (0-1)
        """
        symbol_ids = self.find_symbol(name)
        if not symbol_ids:
            return {
                "symbol": name,
                "found": False,
                "direct_callers": [],
                "transitive_callers": [],
                "affected_files": [],
                "risk_score": 0.0,
            }

        direct = self.who_calls(name, max_depth=1)
        transitive = self.who_calls(name, max_depth=max_depth)

        affected_files = set()
        for item in transitive:
            if item.get("file_path"):
                affected_files.add(item["file_path"])
        # Also include the symbol's own file
        for sid in symbol_ids:
            data = self.graph.nodes.get(sid, {})
            if data.get("file_path"):
                affected_files.add(data["file_path"])

        # Risk score based on impact breadth
        total_files = sum(1 for _, d in self.graph.nodes(data=True) if d.get("type") == "file")
        risk_score = min(len(affected_files) / max(total_files, 1), 1.0)

        return {
            "symbol": name,
            "found": False,
            "direct_callers": direct,
            "transitive_callers": transitive,
            "affected_files": sorted(affected_files),
            "risk_score": round(risk_score, 3),
        }

# src/cegraph/graph/query.py:162-183
    def what_calls(self, name: str) -> list[dict]:
        """Find all symbols called by the given symbol."""
        symbol_ids = self.find_symbol(name)
        results = []

        for sid in symbol_ids:
            for succ in self.graph.successors(sid):
                edge_data = self.graph.edges[sid, succ]
                if edge_data.get("kind") != "calls":
                    continue
                succ_data = self.graph.nodes.get(succ, {})
                if succ_data.get("type") != "symbol":
                    continue
                results.append({
                    "symbol_id": succ,
                    "name": succ_data.get("qualified_name", succ_data.get("name", "")),
                    "kind": succ_data.get("kind", ""),
                    "file_path": succ_data.get("file_path", ""),
                    "line": succ_data.get("line_start", 0),
                })

        return results

# src/cegraph/tools/definitions.py:104-117
    def impact_of(self, symbol_name: str) -> str:
        """Analyze the impact of changing a symbol."""
        result = self.query.impact_of(symbol_name)
        if not result.get("found"):
            return f"Symbol '{symbol_name}' not found in the knowledge graph"

        output = [f"Impact analysis for `{symbol_name}`:"]
        output.append(f"Risk score: {result['risk_score']:.1%}")
        output.append(f"Direct callers: {len(result['direct_callers'])}")
        output.append(f"Transitive callers: {len(result['transitive_callers'])}")
        output.append(f"Affected files ({len(result['affected_files'])}):")
        for f in result["affected_files"]:
            output.append(f"  - {f}")
        return "\n".join(output)

# src/cegraph/graph/query.py:56-64
    def find_symbol(self, name: str) -> list[str]:
        """Find symbol node IDs matching a name (exact or qualified)."""
        results = self._name_index.get(name, [])
        if not results:
            # Try partial match
            for key, ids in self._name_index.items():
                if name.lower() in key.lower():
                    results.extend(ids)
        return list(set(results))

# src/cegraph/graph/query.py:31-315
class GraphQuery:
    """Query engine for the code knowledge graph.

    Provides high-level methods for common queries: who calls what,
    impact analysis, related symbols, etc.
    """

    def __init__(self, graph: nx.DiGraph, store: GraphStore | None = None) -> None:
        self.graph = graph
        self.store = store
        self._name_index: dict[str, list[str]] = {}
        self._build_index()

    def _build_index(self) -> None:
        """Build a name->node_id lookup index."""
        for node_id, data in self.graph.nodes(data=True):
            if data.get("type") != "symbol":
                continue
            name = data.get("name", "")
            qname = data.get("qualified_name", "")
            if name:
                self._name_index.setdefault(name, []).append(node_id)
            if qname and qname != name:
                self._name_index.setdefault(qname, []).append(node_id)

    def find_symbol(self, name: str) -> list[str]:
        """Find symbol node IDs matching a name (exact or qualified)."""
        results = self._name_index.get(name, [])
        if not results:
            # Try partial match
            for key, ids in self._name_index.items():
                if name.lower() in key.lower():
                    results.extend(ids)
        return list(set(results))

    def get_symbol_info(self, symbol_id: str) -> SymbolInfo | None:
        """Get detailed information about a symbol."""
        if not self.graph.has_node(symbol_id):
            return None

        data = self.graph.nodes[symbol_id]
        if data.get("type") != "symbol":
            return None

        # Get callers (reverse edges with kind=calls)
        callers = []
        for pred in self.graph.predecessors(symbol_id):
            edge_data = self.graph.edges[pred, symbol_id]
            if edge_data.get("kind") == "calls":
                callers.append(pred)

        # Get callees (forward edges with kind=calls)
        callees = []
        for succ in self.graph.successors(symbol_id):
            edge_data = self.graph.edges[symbol_id, succ]
            if edge_data.get("kind") == "calls":
                callees.append(succ)

        # Get children (contains edges)
        children = []
        for succ in self.graph.successors(symbol_id):
            edge_data = self.graph.edges[symbol_id, succ]
            if edge_data.get("kind") == "contains":
                children.append(succ)

        # Get parent
        parent = ""
        for pred in self.graph.predecessors(symbol_id):
            edge_data = self.graph.edges[pred, symbol_id]
            if edge_data.get("kind") == "contains":
                pred_data = self.graph.nodes.get(pred, {})
                if pred_data.get("type") == "symbol":
                    parent = pred
                    break

        return SymbolInfo(
            id=symbol_id,
            name=data.get("name", ""),
            qualified_name=data.get("qualified_name", ""),
            kind=data.get("kind", ""),
            file_path=data.get("file_path", ""),
            line_start=data.get("line_start", 0),
            line_end=data.get("line_end", 0),
            signature=data.get("signature", ""),
            docstring=data.get("docstring", ""),
            callers=callers,
            callees=callees,
            children=children,
            parent=parent,
        )

    def who_calls(self, name: str, max_depth: int = 1) -> list[dict]:
        """Find all callers of a symbol, optionally going N levels deep.

        Returns list of {symbol_id, name, file_path, line, depth}
        """
        symbol_ids = self.find_symbol(name)
        if not symbol_ids:
            return []

        results = []
        visited = set()

        def _traverse(node_id: str, depth: int) -> None:
            if depth > max_depth or node_id in visited:
                return
            visited.add(node_id)

            for pred in self.graph.predecessors(node_id):
                edge_data = self.graph.edges[pred, node_id]
                if edge_data.get("kind") != "calls":
                    continue
                pred_data = self.graph.nodes.get(pred, {})
                if pred_data.get("type") != "symbol":
                    continue

                results.append({
                    "symbol_id": pred,
                    "name": pred_data.get("qualified_name", pred_data.get("name", "")),
                    "kind": pred_data.get("kind", ""),
                    "file_path": pred_data.get("file_path", ""),
                    "line": pred_data.get("line_start", 0),
                    "depth": depth,
                })
                _traverse(pred, depth + 1)

        for sid in symbol_ids:
            _traverse(sid, 1)

        return results

    def what_calls(self, name: str) -> list[dict]:
        """Find all symbols called by the given symbol."""
        symbol_ids = self.find_symbol(name)
        results = []

        for sid in symbol_ids:
            for succ in self.graph.successors(sid):
                edge_data = self.graph.edges[sid, succ]
                if edge_data.get("kind") != "calls":
                    continue
                succ_data = self.graph.nodes.get(succ, {})
                if succ_data.get("type") != "symbol":
                    continue
                results.append({
                    "symbol_id": succ,
                    "name": succ_data.get("qualified_name", succ_data.get("name", "")),
                    "kind": succ_data.get("kind", ""),
                    "file_path": succ_data.get("file_path", ""),
                    "line": succ_data.get("line_start", 0),
                })

        return results

    def impact_of(self, name: str, max_depth: int = 3) -> dict:
        """Analyze the impact of changing a symbol.

        Returns a dict with:
        - direct_callers: immediate callers
        - transitive_callers: all callers up to max_depth
        - affected_files: set of files that could be affected
        - risk_score: rough risk assessment (0-1)
        """
        symbol_ids = self.find_symbol(name)
        if not symbol_ids:
            return {
                "symbol": name,
                "found": False,
                "direct_callers": [],
                "transitive_callers": [],
                "affected_files": [],
                "risk_score": 0.0,
            }

        direct = self.who_calls(name, max_depth=1)
        transitive = self.who_calls(name, max_depth=max_depth)

        affected_files = set()
        for item in transitive:
            if item.get("file_path"):
                affected_files.add(item["file_path"])
        # Also include the symbol's own file
        for sid in symbol_ids:
            data = self.graph.nodes.get(sid, {})
            if data.get("file_path"):
                affected_files.add(data["file_path"])

        # Risk score based on impact breadth
        total_files = sum(1 for _, d in self.graph.nodes(data=True) if d.get("type") == "file")
        risk_score = min(len(affected_files) / max(total_files, 1), 1.0)

        return {
            "symbol": name,
            "found": False,
            "direct_callers": direct,
            "transitive_callers": transitive,
            "affected_files": sorted(affected_files),
            "risk_score": round(risk_score, 3),
        }

    def get_file_symbols(self, file_path: str) -> list[dict]:
        """Get all symbols defined in a file."""
        file_node = f"file::{file_path}"
        if not self.graph.has_node(file_node):
            return []

        symbols = []
        for succ in self.graph.successors(file_node):
            data = self.graph.nodes.get(succ, {})
            if data.get("type") == "symbol":
                symbols.append({
                    "id": succ,
                    **{k: v for k, v in data.items() if k != "type"},
                })

        return sorted(symbols, key=lambda s: s.get("line_start", 0))

    def get_structure(self, path_prefix: str = "") -> dict:
        """Get the directory/file structure with symbol counts."""
        structure: dict = {}

        for node_id, data in self.graph.nodes(data=True):
            if data.get("type") != "file":
                continue
            file_path = data.get("path", "")
            if path_prefix and not file_path.startswith(path_prefix):
                continue

            parts = file_path.split("/")
            current = structure
            for part in parts[:-1]:
                current = current.setdefault(part, {})
            current[parts[-1]] = {
                "_language": data.get("language", ""),
                "_symbols": data.get("symbol_count", 0),
            }

        return structure

    def find_related(self, name: str, max_hops: int = 2) -> list[dict]:
        """Find symbols related to the given one within N hops."""
        symbol_ids = self.find_symbol(name)
        if not symbol_ids:
            return []

        related = set()
        visited = set()

        def _bfs(start: str, hops: int) -> None:
            if hops > max_hops or start in visited:
                return
            visited.add(start)

            # Forward edges
            for succ in self.graph.successors(start):
                succ_data = self.graph.nodes.get(succ, {})
                if succ_data.get("type") == "symbol":
                    related.add(succ)
                    _bfs(succ, hops + 1)

            # Backward edges
            for pred in self.graph.predecessors(start):
                pred_data = self.graph.nodes.get(pred, {})
                if pred_data.get("type") == "symbol":
                    related.add(pred)
                    _bfs(pred, hops + 1)

        for sid in symbol_ids:
            _bfs(sid, 0)

        # Remove the original symbols
        related -= set(symbol_ids)

        results = []
        for node_id in related:
            data = self.graph.nodes.get(node_id, {})
            results.append({
                "symbol_id": node_id,
                "name": data.get("qualified_name", data.get("name", "")),
                "kind": data.get("kind", ""),
                "file_path": data.get("file_path", ""),
                "line": data.get("line_start", 0),
            })

        return results

# src/cegraph/graph/query.py:66-120
    def get_symbol_info(self, symbol_id: str) -> SymbolInfo | None:
        """Get detailed information about a symbol."""
        if not self.graph.has_node(symbol_id):
            return None

        data = self.graph.nodes[symbol_id]
        if data.get("type") != "symbol":
            return None

        # Get callers (reverse edges with kind=calls)
        callers = []
        for pred in self.graph.predecessors(symbol_id):
            edge_data = self.graph.edges[pred, symbol_id]
            if edge_data.get("kind") == "calls":
                callers.append(pred)

        # Get callees (forward edges with kind=calls)
        callees = []
        for succ in self.graph.successors(symbol_id):
            edge_data = self.graph.edges[symbol_id, succ]
            if edge_data.get("kind") == "calls":
                callees.append(succ)

        # Get children (contains edges)
        children = []
        for succ in self.graph.successors(symbol_id):
            edge_data = self.graph.edges[symbol_id, succ]
            if edge_data.get("kind") == "contains":
                children.append(succ)

        # Get parent
        parent = ""
        for pred in self.graph.predecessors(symbol_id):
            edge_data = self.graph.edges[pred, symbol_id]
            if edge_data.get("kind") == "contains":
                pred_data = self.graph.nodes.get(pred, {})
                if pred_data.get("type") == "symbol":
                    parent = pred
                    break

        return SymbolInfo(
            id=symbol_id,
            name=data.get("name", ""),
            qualified_name=data.get("qualified_name", ""),
            kind=data.get("kind", ""),
            file_path=data.get("file_path", ""),
            line_start=data.get("line_start", 0),
            line_end=data.get("line_end", 0),
            signature=data.get("signature", ""),
            docstring=data.get("docstring", ""),
            callers=callers,
            callees=callees,
            children=children,
            parent=parent,
        )

# tests/test_graph.py:191-194
    def test_impact_not_found(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        impact = query.impact_of("nonexistent_function")
        assert impact["found"] is False

# tests/test_graph.py:160-163
    def test_find_symbol(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        results = query.find_symbol("main")
        assert len(results) > 0

# paper/experiments/ablation.py:23-23
from cegraph.graph.query import GraphQuery

# paper/experiments/baselines.py:30-30
from cegraph.graph.query import GraphQuery

# src/cegraph/graph/__init__.py:5-5
from cegraph.graph.query import GraphQuery

# src/cegraph/tools/definitions.py:13-13
from cegraph.graph.query import GraphQuery

# tests/test_mcp.py:11-11
from cegraph.graph.query import GraphQuery

# examples/demo.py:10-10
from cegraph.graph.query import GraphQuery

# paper/experiments/benchmark.py:57-57
from cegraph.graph.query import GraphQuery

# src/cegraph/context/engine.py:49-49
from cegraph.graph.query import GraphQuery

# tests/test_context.py:17-17
from cegraph.graph.query import GraphQuery

# tests/test_graph.py:11-11
from cegraph.graph.query import GraphQuery

# tests/test_tools.py:10-10
from cegraph.graph.query import GraphQuery

# tests/test_graph.py:165-168
    def test_find_symbol_partial(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        results = query.find_symbol("helper")
        assert len(results) > 0

# src/cegraph/search/lexical.py:105-155
    def search_symbols(
        self, query: str, kind: str = "", max_results: int = 20
    ) -> list[dict]:
        """Search through symbol definitions in the knowledge graph."""
        if not self.graph:
            return []

        results = []
        query_lower = query.lower()

        for node_id, data in self.graph.nodes(data=True):
            if data.get("type") != "symbol":
                continue

            name = data.get("name", "")
            qname = data.get("qualified_name", "")
            sig = data.get("signature", "")
            doc = data.get("docstring", "")
            sym_kind = data.get("kind", "")

            if kind and sym_kind != kind:
                continue

            # Score based on match quality
            score = 0.0
            if query_lower == name.lower():
                score = 1.0
            elif query_lower in name.lower():
                score = 0.8
            elif query_lower in qname.lower():
                score = 0.6
            elif query_lower in sig.lower():
                score = 0.4
            elif query_lower in doc.lower():
                score = 0.3
            else:
                continue

            results.append({
                "id": node_id,
                "name": name,
                "qualified_name": qname,
                "kind": sym_kind,
                "file_path": data.get("file_path", ""),
                "line": data.get("line_start", 0),
                "signature": sig,
                "score": score,
            })

        results.sort(key=lambda r: r["score"], reverse=True)
        return results[:max_results]

# src/cegraph/exceptions.py:16-17
class GraphError(CeGraphError):
    """Knowledge graph errors."""

# tests/test_graph.py:213-226
    def test_get_symbol_info(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        symbol_ids = query.find_symbol("User")
        assert len(symbol_ids) > 0
        # Find the class definition (not import)
        class_info = None
        for sid in symbol_ids:
            info = query.get_symbol_info(sid)
            if info and info.kind == "class":
                class_info = info
                break
        assert class_info is not None
        assert class_info.name == "User"
        assert class_info.kind == "class"

# src/cegraph/cli.py:224-235
def impact(symbol_name: str, path: str | None):
    """Analyze the blast radius of changing a symbol."""
    root = _get_project_root(path)
    graph, store = _load_graph(root)

    from cegraph.graph.query import GraphQuery

    query = GraphQuery(graph, store)
    result = query.impact_of(symbol_name)
    console.show_impact(result)

    store.close()

# src/cegraph/tools/definitions.py:91-102
    def what_calls(self, symbol_name: str) -> str:
        """Find all symbols called by a function/method."""
        results = self.query.what_calls(symbol_name)
        if not results:
            return f"No callees found for '{symbol_name}'"

        output = [f"`{symbol_name}` calls:"]
        for r in results:
            output.append(
                f"â†’ **{r['name']}** ({r['kind']}) at {r['file_path']}:{r['line']}"
            )
        return "\n".join(output)

# src/cegraph/ui/console.py:147-172
    def show_impact(self, impact: dict) -> None:
        """Display impact analysis results."""
        if not impact.get("found"):
            self.error(f"Symbol '{impact.get('symbol', '')}' not found")
            return

        risk = impact.get("risk_score", 0)
        risk_color = "green" if risk < 0.2 else "yellow" if risk < 0.5 else "red"

        self.console.print(
            Panel(
                f"[bold]Symbol:[/bold] {impact.get('symbol', '')}\n"
                f"[bold]Risk Score:[/bold] [{risk_color}]{risk:.1%}[/{risk_color}]\n"
                f"[bold]Direct Callers:[/bold] {len(impact.get('direct_callers', []))}\n"
                f"[bold]Transitive Callers:[/bold] {len(impact.get('transitive_callers', []))}\n"
                f"[bold]Affected Files:[/bold] {len(impact.get('affected_files', []))}",
                title="[bold]Impact Analysis[/bold]",
                border_style=risk_color,
            )
        )

        files = impact.get("affected_files", [])
        if files:
            self.console.print("\n[bold]Affected files:[/bold]")
            for f in files:
                self.console.print(f"  [cyan]{f}[/cyan]")

# src/cegraph/github/diff_parser.py:116-177
def get_changed_symbols(
    root: Path, graph, file_diffs: list[FileDiff]
) -> list[ChangedSymbol]:
    """Map diff hunks to symbols using the knowledge graph.

    For each changed line range, find which symbols in the graph
    overlap with those lines.
    """
    changed: list[ChangedSymbol] = []
    seen = set()

    for fd in file_diffs:
        if fd.status == "deleted":
            # All symbols in deleted file are affected
            for node_id, data in graph.nodes(data=True):
                if data.get("type") == "symbol" and data.get("file_path") == fd.path:
                    key = (data.get("name"), fd.path)
                    if key not in seen:
                        changed.append(ChangedSymbol(
                            name=data.get("name", ""),
                            qualified_name=data.get("qualified_name", ""),
                            kind=data.get("kind", ""),
                            file_path=fd.path,
                            line_start=data.get("line_start", 0),
                            line_end=data.get("line_end", 0),
                            change_type="deleted",
                        ))
                        seen.add(key)
            continue

        # For modified/added files, find overlapping symbols
        ranges = fd.changed_line_ranges
        for node_id, data in graph.nodes(data=True):
            if data.get("type") != "symbol":
                continue
            if data.get("file_path") != fd.path:
                continue

            sym_start = data.get("line_start", 0)
            sym_end = data.get("line_end", 0)

            # Check if any hunk overlaps with this symbol
            for r_start, r_end in ranges:
                if sym_start <= r_end and sym_end >= r_start:
                    key = (data.get("name"), fd.path)
                    if key not in seen:
                        overlap = min(sym_end, r_end) - max(sym_start, r_start)
                        change_type = "added" if fd.status == "added" else "modified"
                        changed.append(ChangedSymbol(
                            name=data.get("name", ""),
                            qualified_name=data.get("qualified_name", ""),
                            kind=data.get("kind", ""),
                            file_path=fd.path,
                            line_start=sym_start,
                            line_end=sym_end,
                            change_type=change_type,
                            lines_changed=max(0, overlap),
                        ))
                        seen.add(key)
                    break

    return changed

# src/cegraph/graph/query.py:270-315
    def find_related(self, name: str, max_hops: int = 2) -> list[dict]:
        """Find symbols related to the given one within N hops."""
        symbol_ids = self.find_symbol(name)
        if not symbol_ids:
            return []

        related = set()
        visited = set()

        def _bfs(start: str, hops: int) -> None:
            if hops > max_hops or start in visited:
                return
            visited.add(start)

            # Forward edges
            for succ in self.graph.successors(start):
                succ_data = self.graph.nodes.get(succ, {})
                if succ_data.get("type") == "symbol":
                    related.add(succ)
                    _bfs(succ, hops + 1)

            # Backward edges
            for pred in self.graph.predecessors(start):
                pred_data = self.graph.nodes.get(pred, {})
                if pred_data.get("type") == "symbol":
                    related.add(pred)
                    _bfs(pred, hops + 1)

        for sid in symbol_ids:
            _bfs(sid, 0)

        # Remove the original symbols
        related -= set(symbol_ids)

        results = []
        for node_id in related:
            data = self.graph.nodes.get(node_id, {})
            results.append({
                "symbol_id": node_id,
                "name": data.get("qualified_name", data.get("name", "")),
                "kind": data.get("kind", ""),
                "file_path": data.get("file_path", ""),
                "line": data.get("line_start", 0),
            })

        return results

# tests/test_graph.py:154-226
class TestGraphQuery:
    def _build_query(self, tmp_project: Path) -> GraphQuery:
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)
        return GraphQuery(graph)

    def test_find_symbol(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        results = query.find_symbol("main")
        assert len(results) > 0

    def test_find_symbol_partial(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        results = query.find_symbol("helper")
        assert len(results) > 0

    def test_who_calls(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        callers = query.who_calls("helper_function")
        # main() calls helper_function()
        caller_names = [c["name"] for c in callers]
        assert any("main" in name for name in caller_names)

    def test_what_calls(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        callees = query.what_calls("main")
        callee_names = [c["name"] for c in callees]
        # main() should call several functions
        assert len(callees) > 0

    def test_impact_of(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        impact = query.impact_of("calculate_total")
        assert impact["found"] is True
        assert len(impact["affected_files"]) > 0
        assert impact["risk_score"] >= 0

    def test_impact_not_found(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        impact = query.impact_of("nonexistent_function")
        assert impact["found"] is False

    def test_get_file_symbols(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        symbols = query.get_file_symbols("main.py")
        assert len(symbols) > 0
        names = [s["name"] for s in symbols]
        assert "main" in names

    def test_get_structure(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        structure = query.get_structure()
        assert "main.py" in structure or len(structure) > 0

    def test_find_related(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        related = query.find_related("calculate_total")
        assert len(related) > 0

    def test_get_symbol_info(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        symbol_ids = query.find_symbol("User")
        assert len(symbol_ids) > 0
        # Find the class definition (not import)
        class_info = None
        for sid in symbol_ids:
            info = query.get_symbol_info(sid)
            if info and info.kind == "class":
                class_info = info
                break
        assert class_info is not None
        assert class_info.name == "User"
        assert class_info.kind == "class"

# src/cegraph/graph/query.py:231-246
    def get_file_symbols(self, file_path: str) -> list[dict]:
        """Get all symbols defined in a file."""
        file_node = f"file::{file_path}"
        if not self.graph.has_node(file_node):
            return []

        symbols = []
        for succ in self.graph.successors(file_node):
            data = self.graph.nodes.get(succ, {})
            if data.get("type") == "symbol":
                symbols.append({
                    "id": succ,
                    **{k: v for k, v in data.items() if k != "type"},
                })

        return sorted(symbols, key=lambda s: s.get("line_start", 0))

# src/cegraph/tools/definitions.py:62-75
    def search_symbols(self, query: str, kind: str = "", max_results: int = 10) -> str:
        """Search for symbol definitions (functions, classes, etc.)."""
        results = self.search.search_symbols(query, kind, max_results)
        if not results:
            return f"No symbols found matching '{query}'"

        output = []
        for r in results:
            output.append(
                f"- **{r['qualified_name']}** ({r['kind']}) at {r['file_path']}:{r['line']}"
            )
            if r.get("signature"):
                output.append(f"  `{r['signature']}`")
        return "\n".join(output)

# tests/test_graph.py:184-189
    def test_impact_of(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        impact = query.impact_of("calculate_total")
        assert impact["found"] is True
        assert len(impact["affected_files"]) > 0
        assert impact["risk_score"] >= 0

# tests/test_cli.py:55-60
    def test_search_symbol(self, runner: CliRunner, indexed_project: Path):
        result = runner.invoke(
            main, ["search", "User", "--path", str(indexed_project)]
        )
        assert result.exit_code == 0
        assert "User" in result.output

# src/cegraph/search/hybrid.py:49-51
    def search_symbols(self, query: str, kind: str = "", max_results: int = 20) -> list[dict]:
        """Search symbols using lexical + optional semantic."""
        return self.lexical.search_symbols(query, kind, max_results)

# src/cegraph/graph/__init__.py:3-3
from cegraph.graph.builder import GraphBuilder

# tests/test_context.py:16-16
from cegraph.graph.builder import GraphBuilder

# tests/test_graph.py:10-10
from cegraph.graph.builder import GraphBuilder

# tests/test_impact_bot.py:17-17
from cegraph.graph.builder import GraphBuilder