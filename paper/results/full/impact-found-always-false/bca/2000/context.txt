# Codebase Context for: GraphQuery.impact_of always reports the symbol as not found, even when it exists in the graph. The return dict has found=False regardless of whether find_symbol matches.
# 22 symbols from 10 files (~1,889 tokens, 94% of budget)

## src/cegraph/cli.py
# Included because: graph expansion (depth 1); graph expansion (depth 2); graph expansion (depth 3)

# [function] _load_graph (relevance: 0.64, depth: 2)
  47 | def _load_graph(root: Path):
  48 |     """Load the knowledge graph and related objects."""
  49 |     from cegraph.graph.store import GraphStore
  50 | 
  51 |     db_path = get_cegraph_dir(root) / GRAPH_DB_FILE
  52 |     store = GraphStore(db_path)
  53 |     graph = store.load()
  54 |     if graph is None:
  55 |         console.error("No index found. Run 'cegraph init' or 'cegraph reindex' first.")
  56 |         sys.exit(1)
  57 |     return graph, store

# [function] reindex (relevance: 0.30, depth: 3)
 100 | def reindex(path: str | None):
 101 |     """Rebuild the knowledge graph from scratch."""
 102 |     root = _get_project_root(path)
 103 |     config = load_config(root)
 104 |     _do_index(root, config)

# [function] impact (relevance: 0.57, depth: 1)
 224 | def impact(symbol_name: str, path: str | None):
 225 |     """Analyze the blast radius of changing a symbol."""
 226 |     root = _get_project_root(path)
 227 |     graph, store = _load_graph(root)
 228 | 
 229 |     from cegraph.graph.query import GraphQuery
 230 | 
 231 |     query = GraphQuery(graph, store)
 232 |     result = query.impact_of(symbol_name)
 233 |     console.show_impact(result)
 234 | 
 235 |     store.close()

# [function] ask (relevance: 0.32, depth: 3)
 504 | def ask(question: str, path: str | None):
 505 |     """Ask a question about the codebase (uses LLM + knowledge graph)."""
 506 |     root = _get_project_root(path)
 507 |     config = load_config(root)
 508 |     graph, store = _load_graph(root)
 509 | 
 510 |     _run_agent(root, config, graph, store, question, agent_mode=False)

# [function] agent (relevance: 0.32, depth: 3)
 517 | def agent(task: str, path: str | None, auto: bool):
 518 |     """Run an agentic task (coding, debugging, refactoring)."""
 519 |     root = _get_project_root(path)
 520 |     config = load_config(root)
 521 |     graph, store = _load_graph(root)
 522 | 
 523 |     _run_agent(root, config, graph, store, task, agent_mode=True, auto_approve=auto)

## src/cegraph/config.py
# Included because: required dependency of model_post_init

# [import] BaseModel (relevance: 0.18, depth: 2)
  10 | from pydantic import BaseModel, Field

## src/cegraph/exceptions.py
# Included because: graph expansion (depth 2); graph expansion (depth 1)

# [class] CeGraphError (relevance: 0.43, depth: 2)
   4 | class CeGraphError(Exception):
   5 |     """Base exception for all CeGraph errors."""

# [class] LLMError (relevance: 0.39, depth: 1)
  20 | class LLMError(CeGraphError):
  21 |     """LLM provider errors."""

## src/cegraph/github/diff_parser.py
# Included because: matches 'symbol'; graph expansion (depth 2); graph expansion (depth 3)

# [class] DiffHunk (relevance: 0.46, depth: 3)
  18 | class DiffHunk:
  19 |     """A single hunk from a unified diff."""
  20 |     old_start: int
  21 |     old_count: int
  22 |     new_start: int
  23 |     new_count: int
  24 |     lines: list[str] = field(default_factory=list)

# [class] ChangedSymbol (relevance: 0.46, depth: 3)
  47 | class ChangedSymbol:
  48 |     """A symbol that was affected by the diff."""
  49 |     name: str
  50 |     qualified_name: str
  51 |     kind: str
  52 |     file_path: str
  53 |     line_start: int
  54 |     line_end: int
  55 |     change_type: str  # 'modified', 'added', 'deleted'
  56 |     lines_changed: int = 0

# [function] get_pr_diff (relevance: 0.55, depth: 2)
 205 | def get_pr_diff(root: Path) -> str:
 206 |     """Get the diff for the current PR (GitHub Actions context)."""
 207 |     import os
 208 |     base_ref = os.environ.get("GITHUB_BASE_REF", "main")
 209 |     return get_git_diff(root, base=f"origin/{base_ref}")

## src/cegraph/github/renderer.py
# Included because: graph expansion (depth 3)

# [function] _footer (relevance: 0.32, depth: 3)
 192 | def _footer() -> str:
 193 |     return (
 194 |         "---\n"
 195 |         "*Powered by [CeGraph](https://github.com/cegraph-ai/cegraph) "
 196 |         "â€” CAG-driven code intelligence*"
 197 |     )

## src/cegraph/graph/query.py
# Included because: matches 'find_symbol'; matches 'impact_of'

# [method] GraphQuery.find_symbol (relevance: 1.22, depth: 0)
  56 |     def find_symbol(self, name: str) -> list[str]:
  57 |         """Find symbol node IDs matching a name (exact or qualified)."""
  58 |         results = self._name_index.get(name, [])
  59 |         if not results:
  60 |             # Try partial match
  61 |             for key, ids in self._name_index.items():
  62 |                 if name.lower() in key.lower():
  63 |                     results.extend(ids)
  64 |         return list(set(results))

# [method] GraphQuery.impact_of (relevance: 1.18, depth: 0)
 185 |     def impact_of(self, name: str, max_depth: int = 3) -> dict:
 186 |         """Analyze the impact of changing a symbol.
 187 | 
 188 |         Returns a dict with:
 189 |         - direct_callers: immediate callers
 190 |         - transitive_callers: all callers up to max_depth
 191 |         - affected_files: set of files that could be affected
 192 |         - risk_score: rough risk assessment (0-1)
 193 |         """
 194 |         symbol_ids = self.find_symbol(name)
 195 |         if not symbol_ids:
 196 |             return {
 197 |                 "symbol": name,
 198 |                 "found": False,
 199 |                 "direct_callers": [],
 200 |                 "transitive_callers": [],
 201 |                 "affected_files": [],
 202 |                 "risk_score": 0.0,
 203 |             }
 204 | 
 205 |         direct = self.who_calls(name, max_depth=1)
 206 |         transitive = self.who_calls(name, max_depth=max_depth)
 207 | 
 208 |         affected_files = set()
 209 |         for item in transitive:
 210 |             if item.get("file_path"):
 211 |                 affected_files.add(item["file_path"])
 212 |         # Also include the symbol's own file
 213 |         for sid in symbol_ids:
 214 |             data = self.graph.nodes.get(sid, {})
 215 |             if data.get("file_path"):
 216 |                 affected_files.add(data["file_path"])
 217 | 
 218 |         # Risk score based on impact breadth
 219 |         total_files = sum(1 for _, d in self.graph.nodes(data=True) if d.get("type") == "file")
 220 |         risk_score = min(len(affected_files) / max(total_files, 1), 1.0)
 221 | 
 222 |         return {
 223 |             "symbol": name,
 224 |             "found": False,
 225 |             "direct_callers": direct,
 226 |             "transitive_callers": transitive,
 227 |             "affected_files": sorted(affected_files),
 228 |             "risk_score": round(risk_score, 3),
 229 |         }

## src/cegraph/parser/models.py
# Included because: matches 'symbol'; graph expansion (depth 2); graph expansion (depth 1)

# [class] Symbol (relevance: 0.58, depth: 0)
  39 | class Symbol(BaseModel):
  40 |     """A code symbol (function, class, method, variable, etc.)."""
  41 | 
  42 |     id: str = ""  # auto-generated: "file_path::name"
  43 |     name: str
  44 |     qualified_name: str = ""  # e.g., "MyClass.my_method"
  45 |     kind: SymbolKind
  46 |     file_path: str
  47 |     line_start: int
  48 |     line_end: int
  49 |     column_start: int = 0
  50 |     column_end: int = 0
  51 |     signature: str = ""  # e.g., "def my_method(self, x: int) -> str"
  52 |     docstring: str = ""
  53 |     decorators: list[str] = Field(default_factory=list)
  54 |     parent: str = ""  # parent symbol ID (e.g., class for a method)
  55 | 
  56 |     def model_post_init(self, __context: object) -> None:
  57 |         if not self.id:
  58 |             self.id = f"{self.file_path}::{self.qualified_name or self.name}"
  59 |         if not self.qualified_name:
  60 |             self.qualified_name = self.name

# [method] Symbol.model_post_init (relevance: 0.37, depth: 1)
  56 |     def model_post_init(self, __context: object) -> None:
  57 |         if not self.id:
  58 |             self.id = f"{self.file_path}::{self.qualified_name or self.name}"
  59 |         if not self.qualified_name:
  60 |             self.qualified_name = self.name

# [function] detect_language (relevance: 0.49, depth: 2)
 100 | def detect_language(file_path: str) -> str | None:
 101 |     """Detect programming language from file extension."""
 102 |     from pathlib import Path
 103 | 
 104 |     ext = Path(file_path).suffix.lower()
 105 |     return EXTENSION_LANGUAGE_MAP.get(ext)

## src/cegraph/parser/tree_sitter_parser.py
# Included because: graph expansion (depth 2); graph expansion (depth 3)

# [function] _get_language (relevance: 0.39, depth: 2)
  94 | def _get_language(lang: str):
  95 |     """Get a tree-sitter Language object for the given language."""
  96 |     from tree_sitter import Language
  97 | 
  98 |     module_name = _TS_LANGUAGE_MODULES.get(lang)
  99 |     if not module_name:
 100 |         raise ValueError(f"No tree-sitter grammar for language: {lang}")
 101 | 
 102 |     module = __import__(module_name)
 103 |     return Language(module.language())

# [function] _extract_ts_import (relevance: 0.32, depth: 3)
 250 | def _extract_ts_import(node, file_path: str, source: bytes, result: FileSymbols) -> None:
 251 |     """Extract import information from a tree-sitter node."""
 252 |     text = node.text.decode("utf-8")
 253 |     result.imports.append(text)

## src/cegraph/tools/definitions.py
# Included because: graph expansion (depth 2); matches 'impact_of'

# [method] CeGraphTools.impact_of (relevance: 1.04, depth: 0)
 104 |     def impact_of(self, symbol_name: str) -> str:
 105 |         """Analyze the impact of changing a symbol."""
 106 |         result = self.query.impact_of(symbol_name)
 107 |         if not result.get("found"):
 108 |             return f"Symbol '{symbol_name}' not found in the knowledge graph"
 109 | 
 110 |         output = [f"Impact analysis for `{symbol_name}`:"]
 111 |         output.append(f"Risk score: {result['risk_score']:.1%}")
 112 |         output.append(f"Direct callers: {len(result['direct_callers'])}")
 113 |         output.append(f"Transitive callers: {len(result['transitive_callers'])}")
 114 |         output.append(f"Affected files ({len(result['affected_files'])}):")
 115 |         for f in result["affected_files"]:
 116 |             output.append(f"  - {f}")
 117 |         return "\n".join(output)

# [function] get_tool_definitions (relevance: 0.18, depth: 2)
 468 | def get_tool_definitions() -> list[ToolDefinition]:
 469 |     """Get all built-in tool definitions."""
 470 |     return _TOOL_DEFINITIONS.copy()

## tests/test_context.py
# Included because: graph expansion (depth 3)

# [function] cag_engine (relevance: 0.29, depth: 3)
  21 | def cag_engine(tmp_project: Path):
  22 |     """Create a context assembler with a built graph."""
  23 |     builder = GraphBuilder()
  24 |     graph = builder.build_from_directory(tmp_project)
  25 |     query = GraphQuery(graph)
  26 |     return ContextAssembler(tmp_project, graph, query)
