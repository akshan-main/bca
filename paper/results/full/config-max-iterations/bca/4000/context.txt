# Codebase Context for: Default agent max_iterations is set to 150 instead of 15, allowing runaway agent loops that waste API credits.
# 24 symbols from 10 files (~3,148 tokens, 79% of budget)

## paper/experiments/benchmark.py
# Included because: graph expansion (depth 3)

# [function] call_llm (relevance: 0.29, depth: 3)
 606 | async def call_llm(
 607 |     provider, context: str, task: str,
 608 | ) -> tuple[str, float, int, int]:
 609 |     """Call the LLM and return (response_text, time_ms, input_tokens, output_tokens)."""
 610 |     messages = [
 611 |         Message(role="system", content=SYSTEM_PROMPT),
 612 |         Message(role="user", content=build_prompt(context, task)),
 613 |     ]
 614 | 
 615 |     start = time.time()
 616 |     response: LLMResponse = await provider.complete(
 617 |         messages=messages,
 618 |         temperature=0.0,
 619 |         max_tokens=4096,
 620 |     )
 621 |     elapsed = (time.time() - start) * 1000
 622 | 
 623 |     input_tokens = response.usage.get("prompt_tokens", 0) or response.usage.get("input_tokens", 0)
 624 |     output_tokens = response.usage.get("completion_tokens", 0) or response.usage.get("output_tokens", 0)
 625 | 
 626 |     return (response.content, round(elapsed, 1), input_tokens, output_tokens)

## src/cegraph/agent/loop.py
# Included because: graph expansion (depth 3)

# [class] AgentStep (relevance: 0.26, depth: 3)
  22 | class AgentStep:
  23 |     """A single step in the agent loop."""
  24 | 
  25 |     iteration: int
  26 |     thought: str = ""
  27 |     tool_calls: list[ToolCall] = field(default_factory=list)
  28 |     tool_results: list[ToolResult] = field(default_factory=list)
  29 |     response: str = ""
  30 |     usage: dict[str, int] = field(default_factory=dict)

# [class] AgentResult (relevance: 0.26, depth: 3)
  34 | class AgentResult:
  35 |     """Final result from the agent loop."""
  36 | 
  37 |     answer: str
  38 |     steps: list[AgentStep]
  39 |     total_iterations: int
  40 |     total_tokens: int
  41 |     success: bool = True
  42 |     error: str = ""

## src/cegraph/cli.py
# Included because: matches 'agent'; graph expansion (depth 2); graph expansion (depth 1); graph expansion (depth 3)

# [function] _get_project_root (relevance: 0.74, depth: 1)
  28 | def _get_project_root(path: str | None = None) -> Path:
  29 |     """Find the project root or error."""
  30 |     if path:
  31 |         root = Path(path).resolve()
  32 |         if not root.exists():
  33 |             console.error(f"Path does not exist: {path}")
  34 |             sys.exit(1)
  35 |         return root
  36 | 
  37 |     root = find_project_root()
  38 |     if root is None:
  39 |         console.error(
  40 |             "No CeGraph project found. Run 'cegraph init' first, "
  41 |             "or specify a path with --path."
  42 |         )
  43 |         sys.exit(1)
  44 |     return root

# [function] _load_graph (relevance: 0.72, depth: 1)
  47 | def _load_graph(root: Path):
  48 |     """Load the knowledge graph and related objects."""
  49 |     from cegraph.graph.store import GraphStore
  50 | 
  51 |     db_path = get_cegraph_dir(root) / GRAPH_DB_FILE
  52 |     store = GraphStore(db_path)
  53 |     graph = store.load()
  54 |     if graph is None:
  55 |         console.error("No index found. Run 'cegraph init' or 'cegraph reindex' first.")
  56 |         sys.exit(1)
  57 |     return graph, store

# [function] init (relevance: 0.38, depth: 3)
  71 | def init(path: str | None, provider: str | None, model: str | None):
  72 |     """Initialize CeGraph for a repository. Indexes the codebase and builds the knowledge graph."""
  73 |     root = Path(path or ".").resolve()
  74 |     if not root.exists():
  75 |         console.error(f"Path does not exist: {root}")
  76 |         sys.exit(1)
  77 | 
  78 |     console.banner()
  79 |     console.info(f"Initializing CeGraph for: {root}")
  80 | 
  81 |     # Create/load config
  82 |     config = load_config(root)
  83 |     config.name = root.name
  84 |     config.root_path = str(root)
  85 | 
  86 |     if provider:
  87 |         config.llm.provider = provider
  88 |     if model:
  89 |         config.llm.model = model
  90 | 
  91 |     save_config(root, config)
  92 |     console.success("Configuration saved")
  93 | 
  94 |     # Build the knowledge graph
  95 |     _do_index(root, config)

# [function] reindex (relevance: 0.34, depth: 2)
 100 | def reindex(path: str | None):
 101 |     """Rebuild the knowledge graph from scratch."""
 102 |     root = _get_project_root(path)
 103 |     config = load_config(root)
 104 |     _do_index(root, config)

# [function] _do_index (relevance: 0.52, depth: 3)
 107 | def _do_index(root: Path, config: ProjectConfig):
 108 |     """Index the codebase and build the knowledge graph."""
 109 |     from cegraph.graph.builder import GraphBuilder
 110 |     from cegraph.graph.store import GraphStore
 111 | 
 112 |     builder = GraphBuilder()
 113 | 
 114 |     console.info("Scanning and parsing source files...")
 115 |     start_time = time.time()
 116 | 
 117 |     with console.indexing_progress() as progress:
 118 |         task = progress.add_task("Indexing...", total=None)
 119 |         file_count = 0
 120 | 
 121 |         def on_progress(file_path: str, current: int, total: int):
 122 |             nonlocal file_count
 123 |             file_count = total
 124 |             progress.update(task, total=total, completed=current, description=f"Parsing {file_path}")
 125 | 
 126 |         graph = builder.build_from_directory(root, config, on_progress)
 127 | 
 128 |     elapsed = time.time() - start_time
 129 |     stats = builder.get_stats()
 130 | 
 131 |     console.success(f"Indexed {stats.get('files', 0)} files in {elapsed:.1f}s")
 132 |     console.show_stats(stats)
 133 | 
 134 |     # Persist the graph
 135 |     db_path = get_cegraph_dir(root) / GRAPH_DB_FILE
 136 |     store = GraphStore(db_path)
 137 |     store.save(graph, metadata={"stats": stats, "root": str(root)})
 138 |     store.close()
 139 | 
 140 |     console.success(f"Knowledge graph saved to .cegraph/")

# [function] status (relevance: 0.46, depth: 2)
 145 | def status(path: str | None):
 146 |     """Show the current index status and graph statistics."""
 147 |     root = _get_project_root(path)
 148 |     graph, store = _load_graph(root)
 149 | 
 150 |     stats = store.get_metadata("stats")
 151 |     if stats:
 152 |         console.banner()
 153 |         console.info(f"Project: {root.name}")
 154 |         console.show_stats(stats)
 155 |     else:
 156 |         from cegraph.graph.builder import GraphBuilder
 157 | 
 158 |         b = GraphBuilder()
 159 |         b.graph = graph
 160 |         console.show_stats(b.get_stats())
 161 |     store.close()

# [function] search (relevance: 0.56, depth: 2)
 168 | def search(query: str, path: str | None, kind: str):
 169 |     """Search for code or symbols in the repository."""
 170 |     root = _get_project_root(path)
 171 |     graph, store = _load_graph(root)
 172 | 
 173 |     from cegraph.search.hybrid import HybridSearch
 174 | 
 175 |     search_engine = HybridSearch(root, graph)
 176 | 
 177 |     # Try symbol search first
 178 |     symbol_results = search_engine.search_symbols(query, kind=kind)
 179 |     if symbol_results:
 180 |         console.info(f"Found {len(symbol_results)} symbol(s) matching '{query}':")
 181 |         console.show_search_results(symbol_results)
 182 |     else:
 183 |         console.info(f"No symbol definitions found for '{query}', searching code...")
 184 |         code_results = search_engine.search(query)
 185 |         if code_results:
 186 |             for r in code_results:
 187 |                 console.console.print(
 188 |                     f"  [cyan]{r.file_path}:{r.line_number}[/cyan] {r.line_content.strip()}"
 189 |                 )
 190 |                 if r.symbol_name:
 191 |                     console.console.print(f"    [dim]in {r.symbol_name}[/dim]")
 192 |         else:
 193 |             console.warning(f"No results found for '{query}'")
 194 | 
 195 |     store.close()

# [function] who_calls (relevance: 0.54, depth: 2)
 202 | def who_calls(symbol_name: str, path: str | None, depth: int):
 203 |     """Find all callers of a function or method."""
 204 |     root = _get_project_root(path)
 205 |     graph, store = _load_graph(root)
 206 | 
 207 |     from cegraph.graph.query import GraphQuery
 208 | 
 209 |     query = GraphQuery(graph, store)
 210 |     callers = query.who_calls(symbol_name, max_depth=depth)
 211 | 
 212 |     if callers:
 213 |         console.info(f"Callers of '{symbol_name}':")
 214 |         console.show_callers(callers, symbol_name)
 215 |     else:
 216 |         console.warning(f"No callers found for '{symbol_name}'")
 217 | 
 218 |     store.close()

# [function] impact (relevance: 0.40, depth: 2)
 224 | def impact(symbol_name: str, path: str | None):
 225 |     """Analyze the blast radius of changing a symbol."""
 226 |     root = _get_project_root(path)
 227 |     graph, store = _load_graph(root)
 228 | 
 229 |     from cegraph.graph.query import GraphQuery
 230 | 
 231 |     query = GraphQuery(graph, store)
 232 |     result = query.impact_of(symbol_name)
 233 |     console.show_impact(result)
 234 | 
 235 |     store.close()

# [function] impact_pr (relevance: 0.42, depth: 2)
 423 | def impact_pr(path: str | None, base: str, output_format: str):
 424 |     """Analyze PR impact and generate blast radius report.
 425 | 
 426 |     Parses the git diff, maps changes to symbols in the knowledge graph,
 427 |     and generates a detailed impact analysis.
 428 | 
 429 |     Usage in CI:
 430 | 
 431 |         cegraph impact-pr --format github-comment
 432 | 
 433 |     Local usage:
 434 | 
 435 |         cegraph impact-pr --base main --format markdown
 436 |     """
 437 |     root = _get_project_root(path)
 438 | 
 439 |     from cegraph.github.impact_bot import run_impact_analysis, post_github_comment
 440 | 
 441 |     import os
 442 |     is_pr = bool(os.environ.get("GITHUB_EVENT_PATH"))
 443 | 
 444 |     result = run_impact_analysis(root, base=base, is_pr=is_pr)
 445 | 
 446 |     if "error" in result:
 447 |         console.error(result["error"])
 448 |         sys.exit(1)
 449 | 
 450 |     if output_format == "json":
 451 |         click.echo(json.dumps(result, indent=2, default=str))
 452 |     elif output_format == "github-comment":
 453 |         click.echo(result["comment"])
 454 |         if is_pr:
 455 |             if post_github_comment(result["comment"]):
 456 |                 console.success("Posted impact comment to PR")
 457 |             else:
 458 |                 console.warning("Could not post comment (missing GITHUB_TOKEN or PR context)")
 459 |     else:
 460 |         click.echo(result["comment"])

# [function] code_map (relevance: 0.38, depth: 2)
 469 | def code_map(path: str | None):
 470 |     """Launch the interactive Live Code Map TUI.
 471 | 
 472 |     Explore your codebase as an interactive graph in the terminal.
 473 |     Navigate symbols, see relationships, trace call chains, and
 474 |     understand impact -- all without leaving your terminal.
 475 | 
 476 |     Requires: pip install cegraph[map]
 477 | 
 478 |     Keybindings:
 479 |       /  - Search symbols
 480 |       i  - Impact analysis for selected symbol
 481 |       c  - Show callers
 482 |       r  - Refresh
 483 |       q  - Quit
 484 |     """
 485 |     root = _get_project_root(path)
 486 |     graph, store = _load_graph(root)
 487 | 
 488 |     from cegraph.graph.query import GraphQuery
 489 |     from cegraph.map.app import launch_map
 490 | 
 491 |     query = GraphQuery(graph, store)
 492 |     launch_map(root, graph, query)
 493 | 
 494 |     store.close()

# [function] ask (relevance: 0.36, depth: 2)
 504 | def ask(question: str, path: str | None):
 505 |     """Ask a question about the codebase (uses LLM + knowledge graph)."""
 506 |     root = _get_project_root(path)
 507 |     config = load_config(root)
 508 |     graph, store = _load_graph(root)
 509 | 
 510 |     _run_agent(root, config, graph, store, question, agent_mode=False)

# [function] agent (relevance: 0.62, depth: 0)
 517 | def agent(task: str, path: str | None, auto: bool):
 518 |     """Run an agentic task (coding, debugging, refactoring)."""
 519 |     root = _get_project_root(path)
 520 |     config = load_config(root)
 521 |     graph, store = _load_graph(root)
 522 | 
 523 |     _run_agent(root, config, graph, store, task, agent_mode=True, auto_approve=auto)

## src/cegraph/config.py
# Included because: matches 'set'

# [function] set_config_value (relevance: 0.40, depth: 0)
 125 | def set_config_value(config: ProjectConfig, key: str, value: Any) -> ProjectConfig:
 126 |     """Set a nested config value using dot notation (e.g., 'llm.provider')."""
 127 |     parts = key.split(".")
 128 |     data = config.model_dump()
 129 |     target = data
 130 |     for part in parts[:-1]:
 131 |         if part not in target or not isinstance(target[part], dict):
 132 |             raise KeyError(f"Invalid config key: {key}")
 133 |         target = target[part]
 134 |     if parts[-1] not in target:
 135 |         raise KeyError(f"Invalid config key: {key}")
 136 |     target[parts[-1]] = value
 137 |     return ProjectConfig(**data)

## src/cegraph/context/_native.py
# Included because: graph expansion (depth 1)

# [function] _load_library (relevance: 0.38, depth: 1)
  55 | def _load_library():
  56 |     """Load the native library, or return None."""
  57 |     global _lib, _lib_path
  58 | 
  59 |     if _lib is not None:
  60 |         return _lib
  61 | 
  62 |     path = _find_library()
  63 |     if path is None:
  64 |         return None
  65 | 
  66 |     try:
  67 |         lib = ctypes.CDLL(path)
  68 | 
  69 |         # Verify it's the right library
  70 |         lib.cag_is_available.restype = ctypes.c_int32
  71 |         if lib.cag_is_available() != 1:
  72 |             return None
  73 | 
  74 |         # Set up function signatures
  75 |         _setup_signatures(lib)
  76 | 
  77 |         _lib = lib
  78 |         _lib_path = path
  79 |         return lib
  80 |     except (OSError, AttributeError):
  81 |         return None

## src/cegraph/github/diff_parser.py
# Included because: graph expansion (depth 3)

# [function] get_pr_diff (relevance: 0.23, depth: 3)
 205 | def get_pr_diff(root: Path) -> str:
 206 |     """Get the diff for the current PR (GitHub Actions context)."""
 207 |     import os
 208 |     base_ref = os.environ.get("GITHUB_BASE_REF", "main")
 209 |     return get_git_diff(root, base=f"origin/{base_ref}")

## src/cegraph/map/app.py
# Included because: graph expansion (depth 3)

# [function] launch_map (relevance: 0.25, depth: 3)
 397 | def launch_map(root: Path, graph, query) -> None:
 398 |     """Launch the Live Code Map TUI."""
 399 |     check_textual()
 400 |     app = CodeMapApp(root=root, graph=graph, query=query)
 401 |     app.run()

## src/cegraph/parser/models.py
# Included because: graph expansion (depth 3)

# [function] detect_language (relevance: 0.21, depth: 3)
 100 | def detect_language(file_path: str) -> str | None:
 101 |     """Detect programming language from file extension."""
 102 |     from pathlib import Path
 103 | 
 104 |     ext = Path(file_path).suffix.lower()
 105 |     return EXTENSION_LANGUAGE_MAP.get(ext)

## src/cegraph/parser/tree_sitter_parser.py
# Included because: graph expansion (depth 3)

# [function] is_available (relevance: 0.20, depth: 3)
  73 | def is_available(language: str | None = None) -> bool:
  74 |     """Check if tree-sitter and the required language grammar are available."""
  75 |     try:
  76 |         import tree_sitter  # noqa: F401
  77 |     except ImportError:
  78 |         return False
  79 | 
  80 |     if language is None:
  81 |         return True
  82 | 
  83 |     module_name = _TS_LANGUAGE_MODULES.get(language)
  84 |     if not module_name:
  85 |         return False
  86 | 
  87 |     try:
  88 |         __import__(module_name)
  89 |         return True
  90 |     except ImportError:
  91 |         return False

# [function] _get_language (relevance: 0.21, depth: 3)
  94 | def _get_language(lang: str):
  95 |     """Get a tree-sitter Language object for the given language."""
  96 |     from tree_sitter import Language
  97 | 
  98 |     module_name = _TS_LANGUAGE_MODULES.get(lang)
  99 |     if not module_name:
 100 |         raise ValueError(f"No tree-sitter grammar for language: {lang}")
 101 | 
 102 |     module = __import__(module_name)
 103 |     return Language(module.language())

## tests/test_mcp.py
# Included because: graph expansion (depth 3)

# [function] mcp_server (relevance: 0.32, depth: 3)
  17 | def mcp_server(tmp_project: Path, tmp_path: Path):
  18 |     """Create an MCP server with a built graph."""
  19 |     builder = GraphBuilder()
  20 |     graph = builder.build_from_directory(tmp_project)
  21 | 
  22 |     db_path = tmp_path / "test.db"
  23 |     store = GraphStore(db_path)
  24 |     store.save(graph, metadata={"stats": builder.get_stats()})
  25 |     store.close()
  26 | 
  27 |     # Create .cegraph dir in the project
  28 |     cs_dir = tmp_project / ".cegraph"
  29 |     cs_dir.mkdir(exist_ok=True)
  30 |     # Copy DB to the expected location
  31 |     import shutil
  32 |     shutil.copy(db_path, cs_dir / "graph.db")
  33 | 
  34 |     server = MCPServer(root=tmp_project)
  35 |     return server
