# Codebase Context for: Default agent max_iterations is set to 150 instead of 15, allowing runaway agent loops that waste API credits.
# 42 symbols from 14 files (~6,752 tokens, 84% of budget)

## paper/experiments/ablation.py
# Included because: graph expansion (depth 3)

# [function] main (relevance: 0.29, depth: 3)
 159 | def main():
 160 |     parser = argparse.ArgumentParser(description="BCA ablation study")
 161 |     parser.add_argument("--repo", required=True, help="Path to repository")
 162 |     parser.add_argument("--task", help="Single task description")
 163 |     parser.add_argument("--tasks-file", help="JSONL file with tasks")
 164 |     parser.add_argument(
 165 |         "--budgets", default="1000,2000,4000,8000",
 166 |         help="Comma-separated budget values",
 167 |     )
 168 |     parser.add_argument("--output", help="Output JSON file")
 169 |     parser.add_argument("--ground-truth", help="Comma-separated ground-truth symbol names")
 170 |     args = parser.parse_args()
 171 | 
 172 |     repo_path = Path(args.repo).resolve()
 173 |     budgets = [int(b) for b in args.budgets.split(",")]
 174 |     gt_symbols = args.ground_truth.split(",") if args.ground_truth else None
 175 | 
 176 |     tasks: list[dict] = []
 177 |     if args.task:
 178 |         tasks.append({"task": args.task, "ground_truth": gt_symbols})
 179 |     elif args.tasks_file:
 180 |         with open(args.tasks_file) as f:
 181 |             for line in f:
 182 |                 tasks.append(json.loads(line))
 183 |     else:
 184 |         parser.error("Provide --task or --tasks-file")
 185 | 
 186 |     all_results: list[AblationResult] = []
 187 |     for t in tasks:
 188 |         task_str = t["task"]
 189 |         gt = t.get("ground_truth", gt_symbols)
 190 |         print(f"\nTask: {task_str}")
 191 |         results = run_ablation(repo_path, task_str, budgets, gt)
 192 |         all_results.extend(results)
 193 |         print(format_results_table(results))
 194 | 
 195 |     if args.output:
 196 |         with open(args.output, "w") as f:
 197 |             json.dump([asdict(r) for r in all_results], f, indent=2)
 198 |         print(f"\nResults written to {args.output}")

## paper/experiments/benchmark.py
# Included because: graph expansion (depth 3)

# [function] call_llm (relevance: 0.29, depth: 3)
 606 | async def call_llm(
 607 |     provider, context: str, task: str,
 608 | ) -> tuple[str, float, int, int]:
 609 |     """Call the LLM and return (response_text, time_ms, input_tokens, output_tokens)."""
 610 |     messages = [
 611 |         Message(role="system", content=SYSTEM_PROMPT),
 612 |         Message(role="user", content=build_prompt(context, task)),
 613 |     ]
 614 | 
 615 |     start = time.time()
 616 |     response: LLMResponse = await provider.complete(
 617 |         messages=messages,
 618 |         temperature=0.0,
 619 |         max_tokens=4096,
 620 |     )
 621 |     elapsed = (time.time() - start) * 1000
 622 | 
 623 |     input_tokens = response.usage.get("prompt_tokens", 0) or response.usage.get("input_tokens", 0)
 624 |     output_tokens = response.usage.get("completion_tokens", 0) or response.usage.get("output_tokens", 0)
 625 | 
 626 |     return (response.content, round(elapsed, 1), input_tokens, output_tokens)

## src/cegraph/agent/loop.py
# Included because: graph expansion (depth 3)

# [class] AgentStep (relevance: 0.26, depth: 3)
  22 | class AgentStep:
  23 |     """A single step in the agent loop."""
  24 | 
  25 |     iteration: int
  26 |     thought: str = ""
  27 |     tool_calls: list[ToolCall] = field(default_factory=list)
  28 |     tool_results: list[ToolResult] = field(default_factory=list)
  29 |     response: str = ""
  30 |     usage: dict[str, int] = field(default_factory=dict)

# [class] AgentResult (relevance: 0.26, depth: 3)
  34 | class AgentResult:
  35 |     """Final result from the agent loop."""
  36 | 
  37 |     answer: str
  38 |     steps: list[AgentStep]
  39 |     total_iterations: int
  40 |     total_tokens: int
  41 |     success: bool = True
  42 |     error: str = ""

## src/cegraph/cli.py
# Included because: matches 'agent'; graph expansion (depth 2); graph expansion (depth 1); graph expansion (depth 3)

# [function] _get_project_root (relevance: 0.74, depth: 1)
  28 | def _get_project_root(path: str | None = None) -> Path:
  29 |     """Find the project root or error."""
  30 |     if path:
  31 |         root = Path(path).resolve()
  32 |         if not root.exists():
  33 |             console.error(f"Path does not exist: {path}")
  34 |             sys.exit(1)
  35 |         return root
  36 | 
  37 |     root = find_project_root()
  38 |     if root is None:
  39 |         console.error(
  40 |             "No CeGraph project found. Run 'cegraph init' first, "
  41 |             "or specify a path with --path."
  42 |         )
  43 |         sys.exit(1)
  44 |     return root

# [function] _load_graph (relevance: 0.72, depth: 1)
  47 | def _load_graph(root: Path):
  48 |     """Load the knowledge graph and related objects."""
  49 |     from cegraph.graph.store import GraphStore
  50 | 
  51 |     db_path = get_cegraph_dir(root) / GRAPH_DB_FILE
  52 |     store = GraphStore(db_path)
  53 |     graph = store.load()
  54 |     if graph is None:
  55 |         console.error("No index found. Run 'cegraph init' or 'cegraph reindex' first.")
  56 |         sys.exit(1)
  57 |     return graph, store

# [function] init (relevance: 0.38, depth: 3)
  71 | def init(path: str | None, provider: str | None, model: str | None):
  72 |     """Initialize CeGraph for a repository. Indexes the codebase and builds the knowledge graph."""
  73 |     root = Path(path or ".").resolve()
  74 |     if not root.exists():
  75 |         console.error(f"Path does not exist: {root}")
  76 |         sys.exit(1)
  77 | 
  78 |     console.banner()
  79 |     console.info(f"Initializing CeGraph for: {root}")
  80 | 
  81 |     # Create/load config
  82 |     config = load_config(root)
  83 |     config.name = root.name
  84 |     config.root_path = str(root)
  85 | 
  86 |     if provider:
  87 |         config.llm.provider = provider
  88 |     if model:
  89 |         config.llm.model = model
  90 | 
  91 |     save_config(root, config)
  92 |     console.success("Configuration saved")
  93 | 
  94 |     # Build the knowledge graph
  95 |     _do_index(root, config)

# [function] reindex (relevance: 0.34, depth: 2)
 100 | def reindex(path: str | None):
 101 |     """Rebuild the knowledge graph from scratch."""
 102 |     root = _get_project_root(path)
 103 |     config = load_config(root)
 104 |     _do_index(root, config)

# [function] _do_index (relevance: 0.52, depth: 3)
 107 | def _do_index(root: Path, config: ProjectConfig):
 108 |     """Index the codebase and build the knowledge graph."""
 109 |     from cegraph.graph.builder import GraphBuilder
 110 |     from cegraph.graph.store import GraphStore
 111 | 
 112 |     builder = GraphBuilder()
 113 | 
 114 |     console.info("Scanning and parsing source files...")
 115 |     start_time = time.time()
 116 | 
 117 |     with console.indexing_progress() as progress:
 118 |         task = progress.add_task("Indexing...", total=None)
 119 |         file_count = 0
 120 | 
 121 |         def on_progress(file_path: str, current: int, total: int):
 122 |             nonlocal file_count
 123 |             file_count = total
 124 |             progress.update(task, total=total, completed=current, description=f"Parsing {file_path}")
 125 | 
 126 |         graph = builder.build_from_directory(root, config, on_progress)
 127 | 
 128 |     elapsed = time.time() - start_time
 129 |     stats = builder.get_stats()
 130 | 
 131 |     console.success(f"Indexed {stats.get('files', 0)} files in {elapsed:.1f}s")
 132 |     console.show_stats(stats)
 133 | 
 134 |     # Persist the graph
 135 |     db_path = get_cegraph_dir(root) / GRAPH_DB_FILE
 136 |     store = GraphStore(db_path)
 137 |     store.save(graph, metadata={"stats": stats, "root": str(root)})
 138 |     store.close()
 139 | 
 140 |     console.success(f"Knowledge graph saved to .cegraph/")

# [function] status (relevance: 0.46, depth: 2)
 145 | def status(path: str | None):
 146 |     """Show the current index status and graph statistics."""
 147 |     root = _get_project_root(path)
 148 |     graph, store = _load_graph(root)
 149 | 
 150 |     stats = store.get_metadata("stats")
 151 |     if stats:
 152 |         console.banner()
 153 |         console.info(f"Project: {root.name}")
 154 |         console.show_stats(stats)
 155 |     else:
 156 |         from cegraph.graph.builder import GraphBuilder
 157 | 
 158 |         b = GraphBuilder()
 159 |         b.graph = graph
 160 |         console.show_stats(b.get_stats())
 161 |     store.close()

# [function] search (relevance: 0.56, depth: 2)
 168 | def search(query: str, path: str | None, kind: str):
 169 |     """Search for code or symbols in the repository."""
 170 |     root = _get_project_root(path)
 171 |     graph, store = _load_graph(root)
 172 | 
 173 |     from cegraph.search.hybrid import HybridSearch
 174 | 
 175 |     search_engine = HybridSearch(root, graph)
 176 | 
 177 |     # Try symbol search first
 178 |     symbol_results = search_engine.search_symbols(query, kind=kind)
 179 |     if symbol_results:
 180 |         console.info(f"Found {len(symbol_results)} symbol(s) matching '{query}':")
 181 |         console.show_search_results(symbol_results)
 182 |     else:
 183 |         console.info(f"No symbol definitions found for '{query}', searching code...")
 184 |         code_results = search_engine.search(query)
 185 |         if code_results:
 186 |             for r in code_results:
 187 |                 console.console.print(
 188 |                     f"  [cyan]{r.file_path}:{r.line_number}[/cyan] {r.line_content.strip()}"
 189 |                 )
 190 |                 if r.symbol_name:
 191 |                     console.console.print(f"    [dim]in {r.symbol_name}[/dim]")
 192 |         else:
 193 |             console.warning(f"No results found for '{query}'")
 194 | 
 195 |     store.close()

# [function] who_calls (relevance: 0.54, depth: 2)
 202 | def who_calls(symbol_name: str, path: str | None, depth: int):
 203 |     """Find all callers of a function or method."""
 204 |     root = _get_project_root(path)
 205 |     graph, store = _load_graph(root)
 206 | 
 207 |     from cegraph.graph.query import GraphQuery
 208 | 
 209 |     query = GraphQuery(graph, store)
 210 |     callers = query.who_calls(symbol_name, max_depth=depth)
 211 | 
 212 |     if callers:
 213 |         console.info(f"Callers of '{symbol_name}':")
 214 |         console.show_callers(callers, symbol_name)
 215 |     else:
 216 |         console.warning(f"No callers found for '{symbol_name}'")
 217 | 
 218 |     store.close()

# [function] impact (relevance: 0.40, depth: 2)
 224 | def impact(symbol_name: str, path: str | None):
 225 |     """Analyze the blast radius of changing a symbol."""
 226 |     root = _get_project_root(path)
 227 |     graph, store = _load_graph(root)
 228 | 
 229 |     from cegraph.graph.query import GraphQuery
 230 | 
 231 |     query = GraphQuery(graph, store)
 232 |     result = query.impact_of(symbol_name)
 233 |     console.show_impact(result)
 234 | 
 235 |     store.close()

# [function] serve (relevance: 0.42, depth: 2)
 369 | def serve(path: str | None, transport: str, generate_config: str | None):
 370 |     """Start the MCP server for AI tool integration.
 371 | 
 372 |     Exposes CeGraph's knowledge graph as MCP tools, allowing Claude Code,
 373 |     Cursor, and other MCP clients to query your codebase intelligently.
 374 | 
 375 |     Setup for Claude Code:
 376 | 
 377 |         cegraph serve --generate-config claude >> ~/.claude/mcp_servers.json
 378 | 
 379 |     Setup for Cursor:
 380 | 
 381 |         cegraph serve --generate-config cursor >> .cursor/mcp.json
 382 | 
 383 |     Then restart your AI tool. It will now have access to:
 384 |       - cag_assemble: Get budgeted context for any task
 385 |       - search_code: Search symbols in the graph
 386 |       - who_calls: Find callers of a function
 387 |       - impact_of: Analyze blast radius
 388 |       - get_structure: See codebase overview
 389 |     """
 390 |     if generate_config:
 391 |         from cegraph.mcp.server import MCPServer
 392 | 
 393 |         root_path = str(Path(path or ".").resolve())
 394 |         if generate_config == "claude":
 395 |             config = MCPServer.generate_claude_config(root_path)
 396 |         else:
 397 |             config = MCPServer.generate_cursor_config(root_path)
 398 |         click.echo(json.dumps(config, indent=2))
 399 |         return
 400 | 
 401 |     root = _get_project_root(path)
 402 |     from cegraph.mcp.server import MCPServer
 403 | 
 404 |     server = MCPServer(root)
 405 | 
 406 |     if transport == "stdio":
 407 |         asyncio.run(server.run_stdio())

# [function] impact_pr (relevance: 0.42, depth: 2)
 423 | def impact_pr(path: str | None, base: str, output_format: str):
 424 |     """Analyze PR impact and generate blast radius report.
 425 | 
 426 |     Parses the git diff, maps changes to symbols in the knowledge graph,
 427 |     and generates a detailed impact analysis.
 428 | 
 429 |     Usage in CI:
 430 | 
 431 |         cegraph impact-pr --format github-comment
 432 | 
 433 |     Local usage:
 434 | 
 435 |         cegraph impact-pr --base main --format markdown
 436 |     """
 437 |     root = _get_project_root(path)
 438 | 
 439 |     from cegraph.github.impact_bot import run_impact_analysis, post_github_comment
 440 | 
 441 |     import os
 442 |     is_pr = bool(os.environ.get("GITHUB_EVENT_PATH"))
 443 | 
 444 |     result = run_impact_analysis(root, base=base, is_pr=is_pr)
 445 | 
 446 |     if "error" in result:
 447 |         console.error(result["error"])
 448 |         sys.exit(1)
 449 | 
 450 |     if output_format == "json":
 451 |         click.echo(json.dumps(result, indent=2, default=str))
 452 |     elif output_format == "github-comment":
 453 |         click.echo(result["comment"])
 454 |         if is_pr:
 455 |             if post_github_comment(result["comment"]):
 456 |                 console.success("Posted impact comment to PR")
 457 |             else:
 458 |                 console.warning("Could not post comment (missing GITHUB_TOKEN or PR context)")
 459 |     else:
 460 |         click.echo(result["comment"])

# [function] code_map (relevance: 0.38, depth: 2)
 469 | def code_map(path: str | None):
 470 |     """Launch the interactive Live Code Map TUI.
 471 | 
 472 |     Explore your codebase as an interactive graph in the terminal.
 473 |     Navigate symbols, see relationships, trace call chains, and
 474 |     understand impact -- all without leaving your terminal.
 475 | 
 476 |     Requires: pip install cegraph[map]
 477 | 
 478 |     Keybindings:
 479 |       /  - Search symbols
 480 |       i  - Impact analysis for selected symbol
 481 |       c  - Show callers
 482 |       r  - Refresh
 483 |       q  - Quit
 484 |     """
 485 |     root = _get_project_root(path)
 486 |     graph, store = _load_graph(root)
 487 | 
 488 |     from cegraph.graph.query import GraphQuery
 489 |     from cegraph.map.app import launch_map
 490 | 
 491 |     query = GraphQuery(graph, store)
 492 |     launch_map(root, graph, query)
 493 | 
 494 |     store.close()

# [function] ask (relevance: 0.36, depth: 2)
 504 | def ask(question: str, path: str | None):
 505 |     """Ask a question about the codebase (uses LLM + knowledge graph)."""
 506 |     root = _get_project_root(path)
 507 |     config = load_config(root)
 508 |     graph, store = _load_graph(root)
 509 | 
 510 |     _run_agent(root, config, graph, store, question, agent_mode=False)

# [function] agent (relevance: 0.62, depth: 0)
 517 | def agent(task: str, path: str | None, auto: bool):
 518 |     """Run an agentic task (coding, debugging, refactoring)."""
 519 |     root = _get_project_root(path)
 520 |     config = load_config(root)
 521 |     graph, store = _load_graph(root)
 522 | 
 523 |     _run_agent(root, config, graph, store, task, agent_mode=True, auto_approve=auto)

# [function] _run_agent (relevance: 0.72, depth: 1)
 526 | def _run_agent(
 527 |     root: Path,
 528 |     config: ProjectConfig,
 529 |     graph,
 530 |     store,
 531 |     task: str,
 532 |     agent_mode: bool = True,
 533 |     auto_approve: bool = False,
 534 | ):
 535 |     """Run the agent loop."""
 536 |     from cegraph.agent.loop import AgentLoop, AgentStep
 537 |     from cegraph.graph.query import GraphQuery
 538 |     from cegraph.llm.factory import create_provider
 539 |     from cegraph.search.hybrid import HybridSearch
 540 |     from cegraph.tools.definitions import get_all_tools
 541 | 
 542 |     # Check for API key (skip for local providers that don't need one)
 543 |     llm_config = config.llm
 544 |     if not llm_config.api_key and llm_config.provider not in ("local",):
 545 |         provider = llm_config.provider
 546 |         env_var = {"openai": "OPENAI_API_KEY", "anthropic": "ANTHROPIC_API_KEY"}.get(
 547 |             provider, f"{provider.upper()}_API_KEY"
 548 |         )
 549 |         console.error(
 550 |             f"No API key found for {provider}. "
 551 |             f"Set the {env_var} environment variable or configure it with:\n"
 552 |             f"  cegraph config set llm.api_key_env {env_var}"
 553 |         )
 554 |         store.close()
 555 |         sys.exit(1)
 556 | 
 557 |     try:
 558 |         llm = create_provider(llm_config)
 559 |     except Exception as e:
 560 |         console.error(str(e))
 561 |         store.close()
 562 |         sys.exit(1)
 563 | 
 564 |     query = GraphQuery(graph, store)
 565 |     search_engine = HybridSearch(root, graph)
 566 |     tools = get_all_tools(root, graph, query, search_engine)
 567 | 
 568 |     def on_step(step: AgentStep):
 569 |         console.show_agent_step(step)
 570 | 
 571 |     agent_loop = AgentLoop(
 572 |         llm=llm,
 573 |         tools=tools,
 574 |         project_name=config.name,
 575 |         max_iterations=config.agent.max_iterations,
 576 |         on_step=on_step,
 577 |     )
 578 | 
 579 |     console.info(f"Running {'agent' if agent_mode else 'Q&A'} for: {task}")
 580 |     console.console.print()
 581 | 
 582 |     result = asyncio.run(agent_loop.run(task))
 583 | 
 584 |     if not result.success:
 585 |         if result.error:
 586 |             console.error(result.error)
 587 | 
 588 |     console.console.print()
 589 |     console.info(
 590 |         f"Completed in {result.total_iterations} step(s), "
 591 |         f"~{result.total_tokens:,} tokens used"
 592 |     )
 593 | 
 594 |     store.close()

# [function] config_cmd (relevance: 0.40, depth: 2)
 730 | def config_cmd(action: str, key: str | None, value: str | None, path: str | None):
 731 |     """Manage CeGraph configuration."""
 732 |     root = _get_project_root(path)
 733 |     config = load_config(root)
 734 | 
 735 |     if action == "show":
 736 |         console.console.print_json(json.dumps(config.model_dump(), indent=2))
 737 |     elif action == "get":
 738 |         if not key:
 739 |             console.error("Usage: cegraph config get <key>")
 740 |             sys.exit(1)
 741 |         data = config.model_dump()
 742 |         parts = key.split(".")
 743 |         for part in parts:
 744 |             if isinstance(data, dict) and part in data:
 745 |                 data = data[part]
 746 |             else:
 747 |                 console.error(f"Unknown key: {key}")
 748 |                 sys.exit(1)
 749 |         console.console.print(f"{key} = {data}")
 750 |     elif action == "set":
 751 |         if not key or value is None:
 752 |             console.error("Usage: cegraph config set <key> <value>")
 753 |             sys.exit(1)
 754 |         try:
 755 |             # Try to parse as JSON for non-string values
 756 |             try:
 757 |                 parsed_value = json.loads(value)
 758 |             except json.JSONDecodeError:
 759 |                 parsed_value = value
 760 | 
 761 |             config = set_config_value(config, key, parsed_value)
 762 |             save_config(root, config)
 763 |             console.success(f"Set {key} = {parsed_value}")
 764 |         except KeyError:
 765 |             console.error(f"Unknown config key: {key}")
 766 |             sys.exit(1)

## src/cegraph/config.py
# Included because: required dependency of api_key; graph expansion (depth 3); matches 'set'

# [import] BaseModel (relevance: 0.12, depth: 4)
  10 | from pydantic import BaseModel, Field

# [class] LLMConfig (relevance: 0.12, depth: 4)
  18 | class LLMConfig(BaseModel):
  19 |     """LLM provider configuration."""
  20 | 
  21 |     provider: str = "anthropic"
  22 |     model: str = "claude-sonnet-4-5-20250929"
  23 |     api_key_env: str = ""
  24 |     max_tokens: int = 4096
  25 |     temperature: float = 0.0
  26 |     base_url: str | None = None
  27 | 
  28 |     @property
  29 |     def api_key(self) -> str | None:
  30 |         if self.api_key_env:
  31 |             return os.environ.get(self.api_key_env)
  32 |         # Try common env vars
  33 |         env_map = {
  34 |             "openai": "OPENAI_API_KEY",
  35 |             "anthropic": "ANTHROPIC_API_KEY",
  36 |         }
  37 |         env_var = env_map.get(self.provider, "")
  38 |         return os.environ.get(env_var)

# [method] LLMConfig.api_key (relevance: 0.24, depth: 3)
  29 |     def api_key(self) -> str | None:
  30 |         if self.api_key_env:
  31 |             return os.environ.get(self.api_key_env)
  32 |         # Try common env vars
  33 |         env_map = {
  34 |             "openai": "OPENAI_API_KEY",
  35 |             "anthropic": "ANTHROPIC_API_KEY",
  36 |         }
  37 |         env_var = env_map.get(self.provider, "")
  38 |         return os.environ.get(env_var)

# [function] set_config_value (relevance: 0.40, depth: 0)
 125 | def set_config_value(config: ProjectConfig, key: str, value: Any) -> ProjectConfig:
 126 |     """Set a nested config value using dot notation (e.g., 'llm.provider')."""
 127 |     parts = key.split(".")
 128 |     data = config.model_dump()
 129 |     target = data
 130 |     for part in parts[:-1]:
 131 |         if part not in target or not isinstance(target[part], dict):
 132 |             raise KeyError(f"Invalid config key: {key}")
 133 |         target = target[part]
 134 |     if parts[-1] not in target:
 135 |         raise KeyError(f"Invalid config key: {key}")
 136 |     target[parts[-1]] = value
 137 |     return ProjectConfig(**data)

## src/cegraph/context/_native.py
# Included because: graph expansion (depth 2); graph expansion (depth 1)

# [function] _find_library (relevance: 0.24, depth: 2)
  27 | def _find_library() -> str | None:
  28 |     """Search for the compiled C++ library."""
  29 |     # Platform-specific extension
  30 |     system = platform.system()
  31 |     if system == "Darwin":
  32 |         ext = "dylib"
  33 |     elif system == "Windows":
  34 |         ext = "dll"
  35 |     else:
  36 |         ext = "so"
  37 | 
  38 |     name = f"cag_fast.{ext}"
  39 | 
  40 |     # Search locations (in priority order)
  41 |     search_dirs = [
  42 |         Path(__file__).parent,                          # Installed alongside Python code
  43 |         Path(__file__).parent.parent.parent.parent / "csrc",  # Development: csrc/
  44 |         Path.cwd() / "csrc",                           # Current directory
  45 |     ]
  46 | 
  47 |     for d in search_dirs:
  48 |         candidate = d / name
  49 |         if candidate.exists():
  50 |             return str(candidate)
  51 | 
  52 |     return None

# [function] _load_library (relevance: 0.38, depth: 1)
  55 | def _load_library():
  56 |     """Load the native library, or return None."""
  57 |     global _lib, _lib_path
  58 | 
  59 |     if _lib is not None:
  60 |         return _lib
  61 | 
  62 |     path = _find_library()
  63 |     if path is None:
  64 |         return None
  65 | 
  66 |     try:
  67 |         lib = ctypes.CDLL(path)
  68 | 
  69 |         # Verify it's the right library
  70 |         lib.cag_is_available.restype = ctypes.c_int32
  71 |         if lib.cag_is_available() != 1:
  72 |             return None
  73 | 
  74 |         # Set up function signatures
  75 |         _setup_signatures(lib)
  76 | 
  77 |         _lib = lib
  78 |         _lib_path = path
  79 |         return lib
  80 |     except (OSError, AttributeError):
  81 |         return None

## src/cegraph/github/diff_parser.py
# Included because: graph expansion (depth 3)

# [function] get_git_diff (relevance: 0.23, depth: 3)
 180 | def get_git_diff(root: Path, base: str = "main") -> str:
 181 |     """Get the git diff between the current branch and base."""
 182 |     try:
 183 |         result = subprocess.run(
 184 |             ["git", "diff", f"{base}...HEAD"],
 185 |             cwd=root,
 186 |             capture_output=True,
 187 |             text=True,
 188 |             timeout=30,
 189 |         )
 190 |         if result.returncode == 0:
 191 |             return result.stdout
 192 |         # Fallback: diff against base directly
 193 |         result = subprocess.run(
 194 |             ["git", "diff", base],
 195 |             cwd=root,
 196 |             capture_output=True,
 197 |             text=True,
 198 |             timeout=30,
 199 |         )
 200 |         return result.stdout
 201 |     except (subprocess.TimeoutExpired, FileNotFoundError):
 202 |         return ""

# [function] get_pr_diff (relevance: 0.23, depth: 3)
 205 | def get_pr_diff(root: Path) -> str:
 206 |     """Get the diff for the current PR (GitHub Actions context)."""
 207 |     import os
 208 |     base_ref = os.environ.get("GITHUB_BASE_REF", "main")
 209 |     return get_git_diff(root, base=f"origin/{base_ref}")

## src/cegraph/map/app.py
# Included because: graph expansion (depth 3)

# [function] launch_map (relevance: 0.25, depth: 3)
 397 | def launch_map(root: Path, graph, query) -> None:
 398 |     """Launch the Live Code Map TUI."""
 399 |     check_textual()
 400 |     app = CodeMapApp(root=root, graph=graph, query=query)
 401 |     app.run()

## src/cegraph/parser/models.py
# Included because: graph expansion (depth 3)

# [function] detect_language (relevance: 0.21, depth: 3)
 100 | def detect_language(file_path: str) -> str | None:
 101 |     """Detect programming language from file extension."""
 102 |     from pathlib import Path
 103 | 
 104 |     ext = Path(file_path).suffix.lower()
 105 |     return EXTENSION_LANGUAGE_MAP.get(ext)

## src/cegraph/parser/tree_sitter_parser.py
# Included because: graph expansion (depth 3)

# [function] _get_language (relevance: 0.21, depth: 3)
  94 | def _get_language(lang: str):
  95 |     """Get a tree-sitter Language object for the given language."""
  96 |     from tree_sitter import Language
  97 | 
  98 |     module_name = _TS_LANGUAGE_MODULES.get(lang)
  99 |     if not module_name:
 100 |         raise ValueError(f"No tree-sitter grammar for language: {lang}")
 101 | 
 102 |     module = __import__(module_name)
 103 |     return Language(module.language())

## src/cegraph/tools/definitions.py
# Included because: graph expansion (depth 3)

# [function] get_all_tools (relevance: 0.26, depth: 3)
 473 | def get_all_tools(
 474 |     root: Path,
 475 |     graph: nx.DiGraph,
 476 |     query: GraphQuery,
 477 |     search: HybridSearch,
 478 | ) -> ToolRegistry:
 479 |     """Create a ToolRegistry populated with all built-in tools."""
 480 |     tools = CeGraphTools(root, graph, query, search)
 481 |     registry = ToolRegistry()
 482 | 
 483 |     # Map tool definitions to their implementations
 484 |     impl_map = {
 485 |         "search_code": tools.search_code,
 486 |         "search_symbols": tools.search_symbols,
 487 |         "who_calls": tools.who_calls,
 488 |         "what_calls": tools.what_calls,
 489 |         "impact_of": tools.impact_of,
 490 |         "read_file": tools.read_file,
 491 |         "edit_file": tools.edit_file,
 492 |         "write_file": tools.write_file,
 493 |         "list_files": tools.list_files,
 494 |         "get_context": tools.get_context,
 495 |         "get_structure": tools.get_structure,
 496 |         "run_command": tools.run_command,
 497 |     }
 498 | 
 499 |     for defn in _TOOL_DEFINITIONS:
 500 |         func = impl_map.get(defn.name)
 501 |         if func:
 502 |             registry.register(func, defn)
 503 | 
 504 |     return registry

## src/cegraph/tools/registry.py
# Included because: graph expansion (depth 2); required dependency of get; graph expansion (depth 3)

# [class] ToolRegistry (relevance: 0.29, depth: 3)
  11 | class ToolRegistry:
  12 |     """Registry that manages available agent tools.
  13 | 
  14 |     Tools are functions decorated with @tool that the LLM agent can call.
  15 |     """
  16 | 
  17 |     def __init__(self) -> None:
  18 |         self._tools: dict[str, Callable] = {}
  19 |         self._definitions: dict[str, ToolDefinition] = {}
  20 | 
  21 |     def register(self, func: Callable, definition: ToolDefinition) -> None:
  22 |         """Register a tool function with its definition."""
  23 |         self._tools[definition.name] = func
  24 |         self._definitions[definition.name] = definition
  25 | 
  26 |     def get(self, name: str) -> Callable | None:
  27 |         """Get a tool function by name."""
  28 |         return self._tools.get(name)
  29 | 
  30 |     def get_definition(self, name: str) -> ToolDefinition | None:
  31 |         """Get a tool definition by name."""
  32 |         return self._definitions.get(name)
  33 | 
  34 |     def list_tools(self) -> list[str]:
  35 |         """List all registered tool names."""
  36 |         return list(self._tools.keys())
  37 | 
  38 |     def get_definitions(self) -> list[ToolDefinition]:
  39 |         """Get all tool definitions (for passing to LLM)."""
  40 |         return list(self._definitions.values())
  41 | 
  42 |     async def execute(self, name: str, arguments: dict[str, Any]) -> str:
  43 |         """Execute a tool by name with the given arguments.
  44 | 
  45 |         Returns the result as a string.
  46 |         """
  47 |         func = self._tools.get(name)
  48 |         if func is None:
  49 |             return f"Error: Unknown tool '{name}'"
  50 | 
  51 |         try:
  52 |             if inspect.iscoroutinefunction(func):
  53 |                 result = await func(**arguments)
  54 |             else:
  55 |                 result = func(**arguments)
  56 |             return str(result) if result is not None else "Done."
  57 |         except Exception as e:
  58 |             return f"Error executing tool '{name}': {e}"

# [method] ToolRegistry.get (relevance: 0.56, depth: 2)
  26 |     def get(self, name: str) -> Callable | None:
  27 |         """Get a tool function by name."""
  28 |         return self._tools.get(name)

# [method] ToolRegistry.get_definitions (relevance: 0.26, depth: 3)
  38 |     def get_definitions(self) -> list[ToolDefinition]:
  39 |         """Get all tool definitions (for passing to LLM)."""
  40 |         return list(self._definitions.values())

# [method] ToolRegistry.execute (relevance: 0.50, depth: 3)
  42 |     async def execute(self, name: str, arguments: dict[str, Any]) -> str:
  43 |         """Execute a tool by name with the given arguments.
  44 | 
  45 |         Returns the result as a string.
  46 |         """
  47 |         func = self._tools.get(name)
  48 |         if func is None:
  49 |             return f"Error: Unknown tool '{name}'"
  50 | 
  51 |         try:
  52 |             if inspect.iscoroutinefunction(func):
  53 |                 result = await func(**arguments)
  54 |             else:
  55 |                 result = func(**arguments)
  56 |             return str(result) if result is not None else "Done."
  57 |         except Exception as e:
  58 |             return f"Error executing tool '{name}': {e}"

## tests/test_mcp.py
# Included because: graph expansion (depth 3); required dependency of test_resources_read_valid_file

# [function] mcp_server (relevance: 0.32, depth: 3)
  17 | def mcp_server(tmp_project: Path, tmp_path: Path):
  18 |     """Create an MCP server with a built graph."""
  19 |     builder = GraphBuilder()
  20 |     graph = builder.build_from_directory(tmp_project)
  21 | 
  22 |     db_path = tmp_path / "test.db"
  23 |     store = GraphStore(db_path)
  24 |     store.save(graph, metadata={"stats": builder.get_stats()})
  25 |     store.close()
  26 | 
  27 |     # Create .cegraph dir in the project
  28 |     cs_dir = tmp_project / ".cegraph"
  29 |     cs_dir.mkdir(exist_ok=True)
  30 |     # Copy DB to the expected location
  31 |     import shutil
  32 |     shutil.copy(db_path, cs_dir / "graph.db")
  33 | 
  34 |     server = MCPServer(root=tmp_project)
  35 |     return server

# [class] TestMCPSecurity (relevance: 0.11, depth: 4)
 170 | class TestMCPSecurity:
 171 |     def test_resources_read_path_traversal(self, mcp_server: MCPServer):
 172 |         """Regression: reading files outside the project root must be denied."""
 173 |         result = mcp_server._dispatch("resources/read", {
 174 |             "uri": "file://../../../../etc/hosts",
 175 |         })
 176 |         text = result["contents"][0].get("text", "")
 177 |         assert "Access denied" in text
 178 |         assert "localhost" not in text
 179 | 
 180 |     def test_resources_read_valid_file(self, mcp_server: MCPServer):
 181 |         """Reading a file inside the project root should work."""
 182 |         result = mcp_server._dispatch("resources/read", {
 183 |             "uri": "file://main.py",
 184 |         })
 185 |         text = result["contents"][0].get("text", "")
 186 |         assert "Access denied" not in text

# [method] TestMCPSecurity.test_resources_read_path_traversal (relevance: 0.22, depth: 3)
 171 |     def test_resources_read_path_traversal(self, mcp_server: MCPServer):
 172 |         """Regression: reading files outside the project root must be denied."""
 173 |         result = mcp_server._dispatch("resources/read", {
 174 |             "uri": "file://../../../../etc/hosts",
 175 |         })
 176 |         text = result["contents"][0].get("text", "")
 177 |         assert "Access denied" in text
 178 |         assert "localhost" not in text

# [method] TestMCPSecurity.test_resources_read_valid_file (relevance: 0.22, depth: 3)
 180 |     def test_resources_read_valid_file(self, mcp_server: MCPServer):
 181 |         """Reading a file inside the project root should work."""
 182 |         result = mcp_server._dispatch("resources/read", {
 183 |             "uri": "file://main.py",
 184 |         })
 185 |         text = result["contents"][0].get("text", "")
 186 |         assert "Access denied" not in text

## tests/test_search.py
# Included because: graph expansion (depth 3); required dependency of test_search_delegates_to_lexical

# [class] TestHybridSearch (relevance: 0.11, depth: 4)
  69 | class TestHybridSearch:
  70 |     def test_search_delegates_to_lexical(self, tmp_project: Path):
  71 |         builder = GraphBuilder()
  72 |         graph = builder.build_from_directory(tmp_project)
  73 |         search = HybridSearch(tmp_project, graph)
  74 | 
  75 |         results = search.search("calculate_total")
  76 |         assert len(results) > 0
  77 | 
  78 |     def test_search_symbols(self, tmp_project: Path):
  79 |         builder = GraphBuilder()
  80 |         graph = builder.build_from_directory(tmp_project)
  81 |         search = HybridSearch(tmp_project, graph)
  82 | 
  83 |         results = search.search_symbols("Order")
  84 |         assert len(results) > 0

# [method] TestHybridSearch.test_search_delegates_to_lexical (relevance: 0.23, depth: 3)
  70 |     def test_search_delegates_to_lexical(self, tmp_project: Path):
  71 |         builder = GraphBuilder()
  72 |         graph = builder.build_from_directory(tmp_project)
  73 |         search = HybridSearch(tmp_project, graph)
  74 | 
  75 |         results = search.search("calculate_total")
  76 |         assert len(results) > 0
