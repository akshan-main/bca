# Codebase Context for: Default agent max_iterations is set to 150 instead of 15, allowing runaway agent loops that waste API credits.
# 82 symbols from 19 files (~7,968 tokens, 100% of budget)

## src/cegraph/agent/loop.py
# Included because: graph expansion (depth 3)

# [class] AgentStep (relevance: 0.26, depth: 3)
  22 | class AgentStep:
  23 |     """A single step in the agent loop."""
  24 | 
  25 |     iteration: int
  26 |     thought: str = ""
  27 |     tool_calls: list[ToolCall] = field(default_factory=list)
  28 |     tool_results: list[ToolResult] = field(default_factory=list)
  29 |     response: str = ""
  30 |     usage: dict[str, int] = field(default_factory=dict)

# [class] AgentResult (relevance: 0.26, depth: 3)
  34 | class AgentResult:
  35 |     """Final result from the agent loop."""
  36 | 
  37 |     answer: str
  38 |     steps: list[AgentStep]
  39 |     total_iterations: int
  40 |     total_tokens: int
  41 |     success: bool = True
  42 |     error: str = ""

# [method] AgentLoop.ask (relevance: 0.20, depth: 3)
 185 |     async def ask(self, question: str) -> str:
 186 |         """Simple Q&A mode - ask a question about the codebase.
 187 | 
 188 |         Returns just the answer string.
 189 |         """
 190 |         result = await self.run(question)
 191 |         return result.answer

## src/cegraph/cli.py
# Included because: matches 'agent'; graph expansion (depth 2); graph expansion (depth 1); graph expansion (depth 3)

# [function] _get_project_root (relevance: 0.74, depth: 1)
  28 | def _get_project_root(path: str | None = None) -> Path:
  29 |     """Find the project root or error."""
  30 |     if path:
  31 |         root = Path(path).resolve()
  32 |         if not root.exists():
  33 |             console.error(f"Path does not exist: {path}")
  34 |             sys.exit(1)
  35 |         return root
  36 | 
  37 |     root = find_project_root()
  38 |     if root is None:
  39 |         console.error(
  40 |             "No CeGraph project found. Run 'cegraph init' first, "
  41 |             "or specify a path with --path."
  42 |         )
  43 |         sys.exit(1)
  44 |     return root

# [function] _load_graph (relevance: 0.72, depth: 1)
  47 | def _load_graph(root: Path):
  48 |     """Load the knowledge graph and related objects."""
  49 |     from cegraph.graph.store import GraphStore
  50 | 
  51 |     db_path = get_cegraph_dir(root) / GRAPH_DB_FILE
  52 |     store = GraphStore(db_path)
  53 |     graph = store.load()
  54 |     if graph is None:
  55 |         console.error("No index found. Run 'cegraph init' or 'cegraph reindex' first.")
  56 |         sys.exit(1)
  57 |     return graph, store

# [function] init (relevance: 0.38, depth: 3)
  71 | def init(path: str | None, provider: str | None, model: str | None):
  72 |     """Initialize CeGraph for a repository. Indexes the codebase and builds the knowledge graph."""
  73 |     root = Path(path or ".").resolve()
  74 |     if not root.exists():
  75 |         console.error(f"Path does not exist: {root}")
  76 |         sys.exit(1)
  77 | 
  78 |     console.banner()
  79 |     console.info(f"Initializing CeGraph for: {root}")
  80 | 
  81 |     # Create/load config
  82 |     config = load_config(root)
  83 |     config.name = root.name
  84 |     config.root_path = str(root)
  85 | 
  86 |     if provider:
  87 |         config.llm.provider = provider
  88 |     if model:
  89 |         config.llm.model = model
  90 | 
  91 |     save_config(root, config)
  92 |     console.success("Configuration saved")
  93 | 
  94 |     # Build the knowledge graph
  95 |     _do_index(root, config)

# [function] reindex (relevance: 0.34, depth: 2)
 100 | def reindex(path: str | None):
 101 |     """Rebuild the knowledge graph from scratch."""
 102 |     root = _get_project_root(path)
 103 |     config = load_config(root)
 104 |     _do_index(root, config)

# [function] _do_index (relevance: 0.52, depth: 3)
 107 | def _do_index(root: Path, config: ProjectConfig):
 108 |     """Index the codebase and build the knowledge graph."""
 109 |     from cegraph.graph.builder import GraphBuilder
 110 |     from cegraph.graph.store import GraphStore
 111 | 
 112 |     builder = GraphBuilder()
 113 | 
 114 |     console.info("Scanning and parsing source files...")
 115 |     start_time = time.time()
 116 | 
 117 |     with console.indexing_progress() as progress:
 118 |         task = progress.add_task("Indexing...", total=None)
 119 |         file_count = 0
 120 | 
 121 |         def on_progress(file_path: str, current: int, total: int):
 122 |             nonlocal file_count
 123 |             file_count = total
 124 |             progress.update(task, total=total, completed=current, description=f"Parsing {file_path}")
 125 | 
 126 |         graph = builder.build_from_directory(root, config, on_progress)
 127 | 
 128 |     elapsed = time.time() - start_time
 129 |     stats = builder.get_stats()
 130 | 
 131 |     console.success(f"Indexed {stats.get('files', 0)} files in {elapsed:.1f}s")
 132 |     console.show_stats(stats)
 133 | 
 134 |     # Persist the graph
 135 |     db_path = get_cegraph_dir(root) / GRAPH_DB_FILE
 136 |     store = GraphStore(db_path)
 137 |     store.save(graph, metadata={"stats": stats, "root": str(root)})
 138 |     store.close()
 139 | 
 140 |     console.success(f"Knowledge graph saved to .cegraph/")

# [function] status (relevance: 0.46, depth: 2)
 145 | def status(path: str | None):
 146 |     """Show the current index status and graph statistics."""
 147 |     root = _get_project_root(path)
 148 |     graph, store = _load_graph(root)
 149 | 
 150 |     stats = store.get_metadata("stats")
 151 |     if stats:
 152 |         console.banner()
 153 |         console.info(f"Project: {root.name}")
 154 |         console.show_stats(stats)
 155 |     else:
 156 |         from cegraph.graph.builder import GraphBuilder
 157 | 
 158 |         b = GraphBuilder()
 159 |         b.graph = graph
 160 |         console.show_stats(b.get_stats())
 161 |     store.close()

# [function] search (relevance: 0.56, depth: 2)
 168 | def search(query: str, path: str | None, kind: str):
 169 |     """Search for code or symbols in the repository."""
 170 |     root = _get_project_root(path)
 171 |     graph, store = _load_graph(root)
 172 | 
 173 |     from cegraph.search.hybrid import HybridSearch
 174 | 
 175 |     search_engine = HybridSearch(root, graph)
 176 | 
 177 |     # Try symbol search first
 178 |     symbol_results = search_engine.search_symbols(query, kind=kind)
 179 |     if symbol_results:
 180 |         console.info(f"Found {len(symbol_results)} symbol(s) matching '{query}':")
 181 |         console.show_search_results(symbol_results)
 182 |     else:
 183 |         console.info(f"No symbol definitions found for '{query}', searching code...")
 184 |         code_results = search_engine.search(query)
 185 |         if code_results:
 186 |             for r in code_results:
 187 |                 console.console.print(
 188 |                     f"  [cyan]{r.file_path}:{r.line_number}[/cyan] {r.line_content.strip()}"
 189 |                 )
 190 |                 if r.symbol_name:
 191 |                     console.console.print(f"    [dim]in {r.symbol_name}[/dim]")
 192 |         else:
 193 |             console.warning(f"No results found for '{query}'")
 194 | 
 195 |     store.close()

# [function] who_calls (relevance: 0.54, depth: 2)
 202 | def who_calls(symbol_name: str, path: str | None, depth: int):
 203 |     """Find all callers of a function or method."""
 204 |     root = _get_project_root(path)
 205 |     graph, store = _load_graph(root)
 206 | 
 207 |     from cegraph.graph.query import GraphQuery
 208 | 
 209 |     query = GraphQuery(graph, store)
 210 |     callers = query.who_calls(symbol_name, max_depth=depth)
 211 | 
 212 |     if callers:
 213 |         console.info(f"Callers of '{symbol_name}':")
 214 |         console.show_callers(callers, symbol_name)
 215 |     else:
 216 |         console.warning(f"No callers found for '{symbol_name}'")
 217 | 
 218 |     store.close()

# [function] impact (relevance: 0.40, depth: 2)
 224 | def impact(symbol_name: str, path: str | None):
 225 |     """Analyze the blast radius of changing a symbol."""
 226 |     root = _get_project_root(path)
 227 |     graph, store = _load_graph(root)
 228 | 
 229 |     from cegraph.graph.query import GraphQuery
 230 | 
 231 |     query = GraphQuery(graph, store)
 232 |     result = query.impact_of(symbol_name)
 233 |     console.show_impact(result)
 234 | 
 235 |     store.close()

# [function] ask (relevance: 0.36, depth: 2)
 504 | def ask(question: str, path: str | None):
 505 |     """Ask a question about the codebase (uses LLM + knowledge graph)."""
 506 |     root = _get_project_root(path)
 507 |     config = load_config(root)
 508 |     graph, store = _load_graph(root)
 509 | 
 510 |     _run_agent(root, config, graph, store, question, agent_mode=False)

# [function] agent (relevance: 0.62, depth: 0)
 517 | def agent(task: str, path: str | None, auto: bool):
 518 |     """Run an agentic task (coding, debugging, refactoring)."""
 519 |     root = _get_project_root(path)
 520 |     config = load_config(root)
 521 |     graph, store = _load_graph(root)
 522 | 
 523 |     _run_agent(root, config, graph, store, task, agent_mode=True, auto_approve=auto)

## src/cegraph/config.py
# Included because: graph expansion (depth 3); matches 'set'

# [method] LLMConfig.api_key (relevance: 0.24, depth: 3)
  29 |     def api_key(self) -> str | None:
  30 |         if self.api_key_env:
  31 |             return os.environ.get(self.api_key_env)
  32 |         # Try common env vars
  33 |         env_map = {
  34 |             "openai": "OPENAI_API_KEY",
  35 |             "anthropic": "ANTHROPIC_API_KEY",
  36 |         }
  37 |         env_var = env_map.get(self.provider, "")
  38 |         return os.environ.get(env_var)

# [function] set_config_value (relevance: 0.40, depth: 0)
 125 | def set_config_value(config: ProjectConfig, key: str, value: Any) -> ProjectConfig:
 126 |     """Set a nested config value using dot notation (e.g., 'llm.provider')."""
 127 |     parts = key.split(".")
 128 |     data = config.model_dump()
 129 |     target = data
 130 |     for part in parts[:-1]:
 131 |         if part not in target or not isinstance(target[part], dict):
 132 |             raise KeyError(f"Invalid config key: {key}")
 133 |         target = target[part]
 134 |     if parts[-1] not in target:
 135 |         raise KeyError(f"Invalid config key: {key}")
 136 |     target[parts[-1]] = value
 137 |     return ProjectConfig(**data)

## src/cegraph/context/_native.py
# Included because: graph expansion (depth 3); matches 'set'

# [method] NativeGraph.add_edge (relevance: 0.46, depth: 3)
 229 |     def add_edge(self, src: int, dst: int, weight: float) -> None:
 230 |         self._lib.cag_graph_add_edge(self._handle, src, dst, weight)

# [method] NativeGraph.set_node_weight (relevance: 0.39, depth: 0)
 232 |     def set_node_weight(self, node: int, weight: float) -> None:
 233 |         self._lib.cag_graph_set_node_weight(self._handle, node, weight)

# [method] NativeGraph.set_lines (relevance: 0.39, depth: 0)
 235 |     def set_lines(self, node: int, start: int, end: int) -> None:
 236 |         self._lib.cag_graph_set_lines(self._handle, node, start, end)

## src/cegraph/context/engine.py
# Included because: graph expansion (depth 3)

# [method] ContextAssembler._token_cost (relevance: 0.24, depth: 3)
 898 |     def _token_cost(self, symbol_id: str, cand: dict | None = None) -> int:
 899 |         """Compute token cost c(v) for a symbol."""
 900 |         data = self.graph.nodes.get(symbol_id, {})
 901 |         line_start = data.get("line_start", 0)
 902 |         line_end = data.get("line_end", 0)
 903 |         line_count = max(1, line_end - line_start + 1)
 904 |         return TokenEstimator.estimate_lines(line_count)

# [method] ContextAssembler._update_coverage (relevance: 0.22, depth: 3)
 940 |     def _update_coverage(
 941 |         self, symbol_id: str, covered_edges: set[tuple[str, str]]
 942 |     ) -> None:
 943 |         """Mark edges incident to symbol_id as covered."""
 944 |         for succ in self.graph.successors(symbol_id):
 945 |             if self.graph.nodes.get(succ, {}).get("type") == "symbol":
 946 |                 covered_edges.add((symbol_id, succ))
 947 | 
 948 |         for pred in self.graph.predecessors(symbol_id):
 949 |             if self.graph.nodes.get(pred, {}).get("type") == "symbol":
 950 |                 covered_edges.add((pred, symbol_id))

## src/cegraph/github/diff_parser.py
# Included because: graph expansion (depth 3)

# [function] get_pr_diff (relevance: 0.23, depth: 3)
 205 | def get_pr_diff(root: Path) -> str:
 206 |     """Get the diff for the current PR (GitHub Actions context)."""
 207 |     import os
 208 |     base_ref = os.environ.get("GITHUB_BASE_REF", "main")
 209 |     return get_git_diff(root, base=f"origin/{base_ref}")

## src/cegraph/graph/query.py
# Included because: graph expansion (depth 3)

# [method] GraphQuery._build_index (relevance: 0.22, depth: 3)
  44 |     def _build_index(self) -> None:
  45 |         """Build a name->node_id lookup index."""
  46 |         for node_id, data in self.graph.nodes(data=True):
  47 |             if data.get("type") != "symbol":
  48 |                 continue
  49 |             name = data.get("name", "")
  50 |             qname = data.get("qualified_name", "")
  51 |             if name:
  52 |                 self._name_index.setdefault(name, []).append(node_id)
  53 |             if qname and qname != name:
  54 |                 self._name_index.setdefault(qname, []).append(node_id)

# [method] GraphQuery.find_symbol (relevance: 0.42, depth: 3)
  56 |     def find_symbol(self, name: str) -> list[str]:
  57 |         """Find symbol node IDs matching a name (exact or qualified)."""
  58 |         results = self._name_index.get(name, [])
  59 |         if not results:
  60 |             # Try partial match
  61 |             for key, ids in self._name_index.items():
  62 |                 if name.lower() in key.lower():
  63 |                     results.extend(ids)
  64 |         return list(set(results))

## src/cegraph/graph/store.py
# Included because: graph expansion (depth 2); graph expansion (depth 3)

# [method] GraphStore._get_conn (relevance: 0.48, depth: 3)
  28 |     def _get_conn(self) -> sqlite3.Connection:
  29 |         if self._conn is None:
  30 |             self.db_path.parent.mkdir(parents=True, exist_ok=True)
  31 |             self._conn = sqlite3.connect(str(self.db_path))
  32 |             self._conn.row_factory = sqlite3.Row
  33 |             self._conn.execute("PRAGMA journal_mode=WAL")
  34 |             self._create_tables()
  35 |         return self._conn

# [method] GraphStore.get_metadata (relevance: 0.32, depth: 3)
 491 |     def get_metadata(self, key: str) -> str | None:
 492 |         """Get a metadata value."""
 493 |         conn = self._get_conn()
 494 |         row = conn.execute("SELECT value FROM metadata WHERE key = ?", (key,)).fetchone()
 495 |         if row:
 496 |             return json.loads(row["value"])
 497 |         return None

# [method] GraphStore.close (relevance: 0.56, depth: 2)
 499 |     def close(self) -> None:
 500 |         """Close the database connection."""
 501 |         if self._conn:
 502 |             self._conn.close()
 503 |             self._conn = None

## src/cegraph/map/app.py
# Included because: graph expansion (depth 3)

# [function] launch_map (relevance: 0.25, depth: 3)
 397 | def launch_map(root: Path, graph, query) -> None:
 398 |     """Launch the Live Code Map TUI."""
 399 |     check_textual()
 400 |     app = CodeMapApp(root=root, graph=graph, query=query)
 401 |     app.run()

## src/cegraph/mcp/server.py
# Included because: graph expansion (depth 3)

# [method] MCPServer._ensure_graph (relevance: 0.40, depth: 3)
  48 |     def _ensure_graph(self):
  49 |         """Lazy-load the knowledge graph."""
  50 |         if self._graph is not None:
  51 |             return
  52 | 
  53 |         from cegraph.graph.store import GraphStore
  54 |         from cegraph.graph.query import GraphQuery
  55 | 
  56 |         db_path = get_cegraph_dir(self.root) / GRAPH_DB_FILE
  57 |         if not db_path.exists():
  58 |             raise RuntimeError(
  59 |                 f"No CeGraph index found at {db_path}. "
  60 |                 "Run 'cegraph init' first."
  61 |             )
  62 | 
  63 |         self._store = GraphStore(db_path)
  64 |         self._graph = self._store.load()
  65 |         if self._graph is None:
  66 |             raise RuntimeError("Failed to load knowledge graph")
  67 |         self._query = GraphQuery(self._graph, self._store)

# [method] MCPServer._tool_search_code (relevance: 0.26, depth: 3)
 250 |     def _tool_search_code(self, args: dict) -> str:
 251 |         self._ensure_graph()
 252 |         results = self._query.find_symbol(args["query"])
 253 |         if not results:
 254 |             return f"No symbols found matching '{args['query']}'"
 255 | 
 256 |         lines = []
 257 |         for sid in results[:20]:
 258 |             data = self._graph.nodes.get(sid, {})
 259 |             name = data.get("name", sid)
 260 |             kind = data.get("kind", "")
 261 |             fp = data.get("file_path", "")
 262 |             line = data.get("line_start", 0)
 263 |             if args.get("kind") and kind != args["kind"]:
 264 |                 continue
 265 |             lines.append(f"  {name} ({kind}) at {fp}:{line}")
 266 | 
 267 |         return "\n".join(lines) if lines else f"No symbols found matching '{args['query']}'"

# [method] MCPServer._tool_who_calls (relevance: 0.26, depth: 3)
 269 |     def _tool_who_calls(self, args: dict) -> str:
 270 |         self._ensure_graph()
 271 |         callers = self._query.who_calls(
 272 |             args["symbol"], max_depth=args.get("max_depth", 3)
 273 |         )
 274 |         if not callers:
 275 |             return f"No callers found for '{args['symbol']}'"
 276 | 
 277 |         lines = [f"Callers of '{args['symbol']}':"]
 278 |         for c in callers:
 279 |             indent = "  " * c.get("depth", 1)
 280 |             lines.append(f"{indent}{c['name']} ({c['kind']}) at {c['file_path']}:{c['line']}")
 281 |         return "\n".join(lines)

# [method] MCPServer._render_structure (relevance: 0.26, depth: 3)
 316 |     def _render_structure(self, node: dict, lines: list[str], indent: int) -> None:
 317 |         """Recursively render the structure tree."""
 318 |         prefix = "  " * indent
 319 |         for key, value in sorted(node.items()):
 320 |             if key.startswith("_"):
 321 |                 continue
 322 |             if isinstance(value, dict):
 323 |                 syms = value.get("_symbols", 0)
 324 |                 lang = value.get("_language", "")
 325 |                 # Check if it's a file (has _language/_symbols) or a directory
 326 |                 if "_language" in value or "_symbols" in value:
 327 |                     lang_str = f" [{lang}]" if lang else ""
 328 |                     lines.append(f"{prefix}{key}{lang_str} ({syms} symbols)")
 329 |                 else:
 330 |                     lines.append(f"\n{prefix}{key}/")
 331 |                     self._render_structure(value, lines, indent + 1)

# [method] MCPServer._tool_find_related (relevance: 0.26, depth: 3)
 333 |     def _tool_find_related(self, args: dict) -> str:
 334 |         self._ensure_graph()
 335 |         related = self._query.find_related(args["symbol"])
 336 |         if not related:
 337 |             return f"No related symbols found for '{args['symbol']}'"
 338 | 
 339 |         lines = [f"Related to '{args['symbol']}':"]
 340 |         for r in related:
 341 |             lines.append(f"  {r['name']} ({r['kind']}) — {r.get('relation', 'related')}")
 342 |         return "\n".join(lines)

# [method] MCPServer._handle_message (relevance: 0.32, depth: 3)
 403 |     def _handle_message(self, message: dict) -> dict | None:
 404 |         """Route a JSON-RPC message to the appropriate handler."""
 405 |         method = message.get("method", "")
 406 |         msg_id = message.get("id")
 407 |         params = message.get("params", {})
 408 | 
 409 |         # Notifications (no id) don't get responses
 410 |         if msg_id is None:
 411 |             self._handle_notification(method, params)
 412 |             return None
 413 | 
 414 |         try:
 415 |             result = self._dispatch(method, params)
 416 |             return {"jsonrpc": "2.0", "id": msg_id, "result": result}
 417 |         except Exception as e:
 418 |             return {
 419 |                 "jsonrpc": "2.0",
 420 |                 "id": msg_id,
 421 |                 "error": {"code": -32603, "message": str(e)},
 422 |             }

# [method] MCPServer._handle_notification (relevance: 0.24, depth: 3)
 424 |     def _handle_notification(self, method: str, params: dict) -> None:
 425 |         """Handle a notification (no response needed)."""
 426 |         if method == "notifications/initialized":
 427 |             logger.info("Client initialized")
 428 |         elif method == "notifications/cancelled":
 429 |             logger.info(f"Request cancelled: {params.get('requestId')}")

# [method] MCPServer._rpc_tools_call (relevance: 0.24, depth: 3)
 466 |     def _rpc_tools_call(self, params: dict) -> dict:
 467 |         """Call a tool and return the result."""
 468 |         name = params.get("name", "")
 469 |         arguments = params.get("arguments", {})
 470 | 
 471 |         try:
 472 |             result = self._handle_tool_call(name, arguments)
 473 |             return {
 474 |                 "content": [{"type": "text", "text": result}],
 475 |                 "isError": False,
 476 |             }
 477 |         except Exception as e:
 478 |             return {
 479 |                 "content": [{"type": "text", "text": f"Error: {e}"}],
 480 |                 "isError": True,
 481 |             }

# [method] MCPServer.generate_claude_config (relevance: 0.23, depth: 3)
 528 |     def generate_claude_config(project_path: str | None = None) -> dict:
 529 |         """Generate MCP config for Claude Code (~/.claude/mcp_servers.json)."""
 530 |         return {
 531 |             "cegraph": {
 532 |                 "command": "cegraph",
 533 |                 "args": ["serve", "--transport", "stdio"],
 534 |                 "cwd": project_path or ".",
 535 |             }
 536 |         }

# [method] MCPServer.generate_cursor_config (relevance: 0.23, depth: 3)
 539 |     def generate_cursor_config(project_path: str | None = None) -> dict:
 540 |         """Generate MCP config for Cursor (.cursor/mcp.json)."""
 541 |         return {
 542 |             "mcpServers": {
 543 |                 "cegraph": {
 544 |                     "command": "cegraph",
 545 |                     "args": ["serve", "--transport", "stdio"],
 546 |                     "cwd": project_path or ".",
 547 |                 }
 548 |             }
 549 |         }

## src/cegraph/parser/models.py
# Included because: graph expansion (depth 3)

# [function] detect_language (relevance: 0.21, depth: 3)
 100 | def detect_language(file_path: str) -> str | None:
 101 |     """Detect programming language from file extension."""
 102 |     from pathlib import Path
 103 | 
 104 |     ext = Path(file_path).suffix.lower()
 105 |     return EXTENSION_LANGUAGE_MAP.get(ext)

## src/cegraph/parser/tree_sitter_parser.py
# Included because: graph expansion (depth 3)

# [function] _get_language (relevance: 0.21, depth: 3)
  94 | def _get_language(lang: str):
  95 |     """Get a tree-sitter Language object for the given language."""
  96 |     from tree_sitter import Language
  97 | 
  98 |     module_name = _TS_LANGUAGE_MODULES.get(lang)
  99 |     if not module_name:
 100 |         raise ValueError(f"No tree-sitter grammar for language: {lang}")
 101 | 
 102 |     module = __import__(module_name)
 103 |     return Language(module.language())

## src/cegraph/tools/definitions.py
# Included because: graph expansion (depth 3)

# [method] CeGraphTools.search_symbols (relevance: 0.24, depth: 3)
  62 |     def search_symbols(self, query: str, kind: str = "", max_results: int = 10) -> str:
  63 |         """Search for symbol definitions (functions, classes, etc.)."""
  64 |         results = self.search.search_symbols(query, kind, max_results)
  65 |         if not results:
  66 |             return f"No symbols found matching '{query}'"
  67 | 
  68 |         output = []
  69 |         for r in results:
  70 |             output.append(
  71 |                 f"- **{r['qualified_name']}** ({r['kind']}) at {r['file_path']}:{r['line']}"
  72 |             )
  73 |             if r.get("signature"):
  74 |                 output.append(f"  `{r['signature']}`")
  75 |         return "\n".join(output)

# [method] CeGraphTools.impact_of (relevance: 0.24, depth: 3)
 104 |     def impact_of(self, symbol_name: str) -> str:
 105 |         """Analyze the impact of changing a symbol."""
 106 |         result = self.query.impact_of(symbol_name)
 107 |         if not result.get("found"):
 108 |             return f"Symbol '{symbol_name}' not found in the knowledge graph"
 109 | 
 110 |         output = [f"Impact analysis for `{symbol_name}`:"]
 111 |         output.append(f"Risk score: {result['risk_score']:.1%}")
 112 |         output.append(f"Direct callers: {len(result['direct_callers'])}")
 113 |         output.append(f"Transitive callers: {len(result['transitive_callers'])}")
 114 |         output.append(f"Affected files ({len(result['affected_files'])}):")
 115 |         for f in result["affected_files"]:
 116 |             output.append(f"  - {f}")
 117 |         return "\n".join(output)

## src/cegraph/tools/registry.py
# Included because: graph expansion (depth 2); graph expansion (depth 3)

# [method] ToolRegistry.get (relevance: 0.56, depth: 2)
  26 |     def get(self, name: str) -> Callable | None:
  27 |         """Get a tool function by name."""
  28 |         return self._tools.get(name)

# [method] ToolRegistry.get_definition (relevance: 0.20, depth: 3)
  30 |     def get_definition(self, name: str) -> ToolDefinition | None:
  31 |         """Get a tool definition by name."""
  32 |         return self._definitions.get(name)

# [method] ToolRegistry.get_definitions (relevance: 0.26, depth: 3)
  38 |     def get_definitions(self) -> list[ToolDefinition]:
  39 |         """Get all tool definitions (for passing to LLM)."""
  40 |         return list(self._definitions.values())

# [method] ToolRegistry.execute (relevance: 0.50, depth: 3)
  42 |     async def execute(self, name: str, arguments: dict[str, Any]) -> str:
  43 |         """Execute a tool by name with the given arguments.
  44 | 
  45 |         Returns the result as a string.
  46 |         """
  47 |         func = self._tools.get(name)
  48 |         if func is None:
  49 |             return f"Error: Unknown tool '{name}'"
  50 | 
  51 |         try:
  52 |             if inspect.iscoroutinefunction(func):
  53 |                 result = await func(**arguments)
  54 |             else:
  55 |                 result = func(**arguments)
  56 |             return str(result) if result is not None else "Done."
  57 |         except Exception as e:
  58 |             return f"Error executing tool '{name}': {e}"

## src/cegraph/ui/console.py
# Included because: graph expansion (depth 2); graph expansion (depth 3)

# [method] Console.banner (relevance: 0.26, depth: 3)
  22 |     def banner(self) -> None:
  23 |         """Show the CeGraph banner."""
  24 |         self.console.print(
  25 |             Panel(
  26 |                 "[bold cyan]CeGraph[/bold cyan] [dim]v0.1.0[/dim]\n"
  27 |                 "[dim]AI that actually understands your entire codebase[/dim]",
  28 |                 border_style="cyan",
  29 |                 padding=(1, 2),
  30 |             )
  31 |         )

# [method] Console.success (relevance: 0.28, depth: 3)
  33 |     def success(self, message: str) -> None:
  34 |         self.console.print(f"[green]✓[/green] {message}")

# [method] Console.error (relevance: 0.52, depth: 2)
  36 |     def error(self, message: str) -> None:
  37 |         self.console.print(f"[red]✗[/red] {message}")

# [method] Console.warning (relevance: 0.29, depth: 3)
  39 |     def warning(self, message: str) -> None:
  40 |         self.console.print(f"[yellow]![/yellow] {message}")

# [method] Console.info (relevance: 0.48, depth: 2)
  42 |     def info(self, message: str) -> None:
  43 |         self.console.print(f"[blue]i[/blue] {message}")

# [method] Console.show_search_results (relevance: 0.23, depth: 3)
 120 |     def show_search_results(self, results: list[dict]) -> None:
 121 |         """Display search results."""
 122 |         for r in results:
 123 |             self.console.print(
 124 |                 f"  [bold]{r.get('qualified_name', r.get('name', 'unknown'))}[/bold] "
 125 |                 f"[dim]({r.get('kind', '')})[/dim] "
 126 |                 f"at [cyan]{r.get('file_path', '')}:{r.get('line', '')}[/cyan]"
 127 |             )
 128 |             if r.get("signature"):
 129 |                 self.console.print(f"    [dim]{r['signature']}[/dim]")

# [method] Console.show_callers (relevance: 0.26, depth: 3)
 131 |     def show_callers(self, callers: list[dict], symbol_name: str) -> None:
 132 |         """Display caller tree."""
 133 |         tree = Tree(f"[bold cyan]{symbol_name}[/bold cyan]")
 134 |         depth_nodes: dict[int, Tree] = {0: tree}
 135 | 
 136 |         for caller in callers:
 137 |             depth = caller.get("depth", 1)
 138 |             parent = depth_nodes.get(depth - 1, tree)
 139 |             node = parent.add(
 140 |                 f"[bold]{caller['name']}[/bold] [dim]({caller['kind']})[/dim] "
 141 |                 f"at [cyan]{caller['file_path']}:{caller['line']}[/cyan]"
 142 |             )
 143 |             depth_nodes[depth] = node
 144 | 
 145 |         self.console.print(tree)

## tests/test_graph.py
# Included because: graph expansion (depth 3)

# [method] TestGraphBuilder.test_file_nodes_present (relevance: 0.24, depth: 3)
  34 |     def test_file_nodes_present(self, tmp_project: Path):
  35 |         builder = GraphBuilder()
  36 |         graph = builder.build_from_directory(tmp_project)
  37 | 
  38 |         file_nodes = [
  39 |             n for n, d in graph.nodes(data=True) if d.get("type") == "file"
  40 |         ]
  41 |         file_paths = [graph.nodes[n].get("path") for n in file_nodes]
  42 |         assert "main.py" in file_paths
  43 |         assert "utils.py" in file_paths
  44 |         assert "models.py" in file_paths

# [method] TestGraphBuilder.test_symbol_nodes_have_attributes (relevance: 0.24, depth: 3)
  46 |     def test_symbol_nodes_have_attributes(self, tmp_project: Path):
  47 |         builder = GraphBuilder()
  48 |         graph = builder.build_from_directory(tmp_project)
  49 | 
  50 |         for node_id, data in graph.nodes(data=True):
  51 |             if data.get("type") == "symbol":
  52 |                 assert "name" in data
  53 |                 assert "kind" in data
  54 |                 assert "file_path" in data
  55 |                 assert "line_start" in data

# [method] TestGraphBuilder.test_call_edges_exist (relevance: 0.24, depth: 3)
  57 |     def test_call_edges_exist(self, tmp_project: Path):
  58 |         builder = GraphBuilder()
  59 |         graph = builder.build_from_directory(tmp_project)
  60 | 
  61 |         call_edges = [
  62 |             (u, v) for u, v, d in graph.edges(data=True) if d.get("kind") == "calls"
  63 |         ]
  64 |         assert len(call_edges) > 0

# [method] TestGraphBuilder.test_contains_edges_exist (relevance: 0.24, depth: 3)
  66 |     def test_contains_edges_exist(self, tmp_project: Path):
  67 |         builder = GraphBuilder()
  68 |         graph = builder.build_from_directory(tmp_project)
  69 | 
  70 |         contains_edges = [
  71 |             (u, v) for u, v, d in graph.edges(data=True) if d.get("kind") == "contains"
  72 |         ]
  73 |         assert len(contains_edges) > 0

# [method] TestGraphStore.test_save_and_load (relevance: 0.30, depth: 3)
 102 |     def test_save_and_load(self, tmp_project: Path, tmp_path: Path):
 103 |         builder = GraphBuilder()
 104 |         graph = builder.build_from_directory(tmp_project)
 105 | 
 106 |         db_path = tmp_path / "test.db"
 107 |         store = GraphStore(db_path)
 108 |         store.save(graph, metadata={"test": True})
 109 | 
 110 |         loaded = store.load()
 111 |         assert loaded is not None
 112 |         assert loaded.number_of_nodes() == graph.number_of_nodes()
 113 |         assert loaded.number_of_edges() == graph.number_of_edges()
 114 |         store.close()

# [method] TestGraphStore.test_search_symbols (relevance: 0.30, depth: 3)
 116 |     def test_search_symbols(self, tmp_project: Path, tmp_path: Path):
 117 |         builder = GraphBuilder()
 118 |         graph = builder.build_from_directory(tmp_project)
 119 | 
 120 |         db_path = tmp_path / "test.db"
 121 |         store = GraphStore(db_path)
 122 |         store.save(graph)
 123 | 
 124 |         results = store.search_symbols(query="main")
 125 |         assert len(results) > 0
 126 |         assert any(r["name"] == "main" for r in results)
 127 |         store.close()

# [method] TestGraphStore.test_search_by_kind (relevance: 0.30, depth: 3)
 129 |     def test_search_by_kind(self, tmp_project: Path, tmp_path: Path):
 130 |         builder = GraphBuilder()
 131 |         graph = builder.build_from_directory(tmp_project)
 132 | 
 133 |         db_path = tmp_path / "test.db"
 134 |         store = GraphStore(db_path)
 135 |         store.save(graph)
 136 | 
 137 |         results = store.search_symbols(kind="class")
 138 |         assert len(results) > 0
 139 |         assert all(r["kind"] == "class" for r in results)
 140 |         store.close()

# [method] TestGraphStore.test_metadata (relevance: 0.30, depth: 3)
 142 |     def test_metadata(self, tmp_project: Path, tmp_path: Path):
 143 |         builder = GraphBuilder()
 144 |         graph = builder.build_from_directory(tmp_project)
 145 | 
 146 |         db_path = tmp_path / "test.db"
 147 |         store = GraphStore(db_path)
 148 |         store.save(graph, metadata={"version": "1.0"})
 149 | 
 150 |         assert store.get_metadata("version") == "1.0"
 151 |         store.close()

# [method] TestGraphQuery.test_who_calls (relevance: 0.19, depth: 3)
 170 |     def test_who_calls(self, tmp_project: Path):
 171 |         query = self._build_query(tmp_project)
 172 |         callers = query.who_calls("helper_function")
 173 |         # main() calls helper_function()
 174 |         caller_names = [c["name"] for c in callers]
 175 |         assert any("main" in name for name in caller_names)

## tests/test_mcp.py
# Included because: graph expansion (depth 3)

# [function] mcp_server (relevance: 0.32, depth: 3)
  17 | def mcp_server(tmp_project: Path, tmp_path: Path):
  18 |     """Create an MCP server with a built graph."""
  19 |     builder = GraphBuilder()
  20 |     graph = builder.build_from_directory(tmp_project)
  21 | 
  22 |     db_path = tmp_path / "test.db"
  23 |     store = GraphStore(db_path)
  24 |     store.save(graph, metadata={"stats": builder.get_stats()})
  25 |     store.close()
  26 | 
  27 |     # Create .cegraph dir in the project
  28 |     cs_dir = tmp_project / ".cegraph"
  29 |     cs_dir.mkdir(exist_ok=True)
  30 |     # Copy DB to the expected location
  31 |     import shutil
  32 |     shutil.copy(db_path, cs_dir / "graph.db")
  33 | 
  34 |     server = MCPServer(root=tmp_project)
  35 |     return server

# [method] TestMCPTools.test_cag_assemble (relevance: 0.22, depth: 3)
  80 |     def test_cag_assemble(self, mcp_server: MCPServer):
  81 |         """Test the cag_assemble tool."""
  82 |         result = mcp_server._dispatch("tools/call", {
  83 |             "name": "cag_assemble",
  84 |             "arguments": {
  85 |                 "task": "fix the main function",
  86 |                 "token_budget": 4000,
  87 |             },
  88 |         })
  89 |         assert not result.get("isError")
  90 |         content = result["content"][0]["text"]
  91 |         assert "CAG" in content or "Context" in content

# [method] TestMCPTools.test_search_code (relevance: 0.22, depth: 3)
  93 |     def test_search_code(self, mcp_server: MCPServer):
  94 |         """Test the search_code tool."""
  95 |         result = mcp_server._dispatch("tools/call", {
  96 |             "name": "search_code",
  97 |             "arguments": {"query": "main"},
  98 |         })
  99 |         assert not result.get("isError")
 100 |         content = result["content"][0]["text"]
 101 |         assert "main" in content

# [method] TestMCPTools.test_who_calls (relevance: 0.22, depth: 3)
 103 |     def test_who_calls(self, mcp_server: MCPServer):
 104 |         """Test the who_calls tool."""
 105 |         result = mcp_server._dispatch("tools/call", {
 106 |             "name": "who_calls",
 107 |             "arguments": {"symbol": "helper_function"},
 108 |         })
 109 |         assert not result.get("isError")

# [method] TestMCPTools.test_impact_of (relevance: 0.22, depth: 3)
 111 |     def test_impact_of(self, mcp_server: MCPServer):
 112 |         """Test the impact_of tool."""
 113 |         result = mcp_server._dispatch("tools/call", {
 114 |             "name": "impact_of",
 115 |             "arguments": {"symbol": "calculate_total"},
 116 |         })
 117 |         assert not result.get("isError")
 118 |         content = result["content"][0]["text"]
 119 |         assert "Impact" in content or "calculate_total" in content

# [method] TestMCPTools.test_get_structure (relevance: 0.22, depth: 3)
 121 |     def test_get_structure(self, mcp_server: MCPServer):
 122 |         """Test the get_structure tool."""
 123 |         result = mcp_server._dispatch("tools/call", {
 124 |             "name": "get_structure",
 125 |             "arguments": {},
 126 |         })
 127 |         assert not result.get("isError")
 128 |         content = result["content"][0]["text"]
 129 |         assert "main.py" in content or "structure" in content.lower()

# [method] TestMCPTools.test_find_related (relevance: 0.22, depth: 3)
 131 |     def test_find_related(self, mcp_server: MCPServer):
 132 |         """Test the find_related tool."""
 133 |         result = mcp_server._dispatch("tools/call", {
 134 |             "name": "find_related",
 135 |             "arguments": {"symbol": "main"},
 136 |         })
 137 |         assert not result.get("isError")

# [method] TestMCPTools.test_unknown_tool (relevance: 0.22, depth: 3)
 139 |     def test_unknown_tool(self, mcp_server: MCPServer):
 140 |         """Test calling an unknown tool."""
 141 |         result = mcp_server._dispatch("tools/call", {
 142 |             "name": "nonexistent_tool",
 143 |             "arguments": {},
 144 |         })
 145 |         assert result.get("isError")

# [method] TestMCPTools.test_search_no_results (relevance: 0.22, depth: 3)
 147 |     def test_search_no_results(self, mcp_server: MCPServer):
 148 |         """Test search with no results."""
 149 |         result = mcp_server._dispatch("tools/call", {
 150 |             "name": "search_code",
 151 |             "arguments": {"query": "zzz_nonexistent_symbol_zzz"},
 152 |         })
 153 |         assert not result.get("isError")
 154 |         content = result["content"][0]["text"]
 155 |         assert "No symbols found" in content

# [method] TestMCPSecurity.test_resources_read_path_traversal (relevance: 0.22, depth: 3)
 171 |     def test_resources_read_path_traversal(self, mcp_server: MCPServer):
 172 |         """Regression: reading files outside the project root must be denied."""
 173 |         result = mcp_server._dispatch("resources/read", {
 174 |             "uri": "file://../../../../etc/hosts",
 175 |         })
 176 |         text = result["contents"][0].get("text", "")
 177 |         assert "Access denied" in text
 178 |         assert "localhost" not in text

# [method] TestMCPSecurity.test_resources_read_valid_file (relevance: 0.22, depth: 3)
 180 |     def test_resources_read_valid_file(self, mcp_server: MCPServer):
 181 |         """Reading a file inside the project root should work."""
 182 |         result = mcp_server._dispatch("resources/read", {
 183 |             "uri": "file://main.py",
 184 |         })
 185 |         text = result["contents"][0].get("text", "")
 186 |         assert "Access denied" not in text

## tests/test_search.py
# Included because: graph expansion (depth 3)

# [method] TestLexicalSearch.test_search_basic (relevance: 0.19, depth: 3)
  20 |     def test_search_basic(self, tmp_project: Path):
  21 |         search = self._build_search(tmp_project)
  22 |         results = search.search("calculate_total")
  23 |         assert len(results) > 0
  24 |         assert any("calculate_total" in r.line_content for r in results)

# [method] TestLexicalSearch.test_search_with_file_pattern (relevance: 0.19, depth: 3)
  26 |     def test_search_with_file_pattern(self, tmp_project: Path):
  27 |         search = self._build_search(tmp_project)
  28 |         results = search.search("def ", file_pattern="*.py")
  29 |         assert len(results) > 0
  30 |         assert all(r.file_path.endswith(".py") for r in results)

# [method] TestLexicalSearch.test_search_context_lines (relevance: 0.19, depth: 3)
  32 |     def test_search_context_lines(self, tmp_project: Path):
  33 |         search = self._build_search(tmp_project)
  34 |         results = search.search("calculate_total", context_lines=3)
  35 |         if results:
  36 |             # Should have context
  37 |             assert len(results[0].context_before) > 0 or len(results[0].context_after) > 0

# [method] TestLexicalSearch.test_search_regex (relevance: 0.19, depth: 3)
  39 |     def test_search_regex(self, tmp_project: Path):
  40 |         search = self._build_search(tmp_project)
  41 |         results = search.search(r"def \w+\(self", regex=True)
  42 |         assert len(results) > 0

# [method] TestLexicalSearch.test_search_no_results (relevance: 0.19, depth: 3)
  44 |     def test_search_no_results(self, tmp_project: Path):
  45 |         search = self._build_search(tmp_project)
  46 |         results = search.search("xyznonexistent123")
  47 |         assert len(results) == 0

# [method] TestLexicalSearch.test_symbol_enrichment (relevance: 0.19, depth: 3)
  61 |     def test_symbol_enrichment(self, tmp_project: Path):
  62 |         search = self._build_search(tmp_project)
  63 |         results = search.search("TAX_RATE")
  64 |         # Should find the constant and know it's in utils.py
  65 |         assert len(results) > 0
  66 |         assert any("utils" in r.file_path for r in results)

# [method] TestHybridSearch.test_search_delegates_to_lexical (relevance: 0.23, depth: 3)
  70 |     def test_search_delegates_to_lexical(self, tmp_project: Path):
  71 |         builder = GraphBuilder()
  72 |         graph = builder.build_from_directory(tmp_project)
  73 |         search = HybridSearch(tmp_project, graph)
  74 | 
  75 |         results = search.search("calculate_total")
  76 |         assert len(results) > 0

## tests/test_tools.py
# Included because: graph expansion (depth 3)

# [method] TestCeGraphTools.test_who_calls (relevance: 0.19, depth: 3)
  35 |     def test_who_calls(self, tmp_project: Path):
  36 |         tools = self._build_tools(tmp_project)
  37 |         result = tools.who_calls("helper_function")
  38 |         assert "main" in result.lower() or "Callers" in result

# [method] TestToolRegistry.test_get_all_tools_creates_registry (relevance: 0.32, depth: 3)
 175 |     def test_get_all_tools_creates_registry(self, tmp_project: Path):
 176 |         builder = GraphBuilder()
 177 |         graph = builder.build_from_directory(tmp_project)
 178 |         query = GraphQuery(graph)
 179 |         search = HybridSearch(tmp_project, graph)
 180 |         registry = get_all_tools(tmp_project, graph, query, search)
 181 | 
 182 |         assert len(registry.list_tools()) > 0
 183 |         assert registry.get("search_code") is not None
 184 |         assert registry.get("nonexistent") is None
