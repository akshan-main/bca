# src/cegraph/graph/builder.py:30-64
    def build_from_directory(
        self,
        root: str | Path,
        config: ProjectConfig | None = None,
        progress_callback: callable | None = None,
    ) -> nx.DiGraph:
        """Build the full knowledge graph from a directory.

        Args:
            root: Root directory to index.
            config: Project configuration.
            progress_callback: Optional callback(file_path, current, total).

        Returns:
            The constructed NetworkX directed graph.
        """
        root = Path(root).resolve()
        indexer_config = config.indexer if config else IndexerConfig()

        # Reset state so reusing a builder doesn't accumulate stale data
        # self.graph = nx.DiGraph()
        # self._file_hashes = {}
        # self._unresolved = []

        # Parse all files
        all_parsed = parse_directory(root, indexer_config, progress_callback)

        # Build graph from parsed results
        for file_symbols in all_parsed:
            self._add_file(file_symbols, root)

        # Resolve cross-file references
        self._resolve_references()

        return self.graph

# examples/demo.py:9-9
from cegraph.graph.builder import GraphBuilder

# paper/experiments/ablation.py:22-22
from cegraph.graph.builder import GraphBuilder

# paper/experiments/baselines.py:29-29
from cegraph.graph.builder import GraphBuilder

# paper/experiments/benchmark.py:56-56
from cegraph.graph.builder import GraphBuilder

# src/cegraph/graph/__init__.py:3-3
from cegraph.graph.builder import GraphBuilder

# tests/test_context.py:16-16
from cegraph.graph.builder import GraphBuilder

# tests/test_graph.py:10-10
from cegraph.graph.builder import GraphBuilder

# tests/test_impact_bot.py:17-17
from cegraph.graph.builder import GraphBuilder

# tests/test_mcp.py:10-10
from cegraph.graph.builder import GraphBuilder

# tests/test_search.py:9-9
from cegraph.graph.builder import GraphBuilder

# tests/test_tools.py:9-9
from cegraph.graph.builder import GraphBuilder

# src/cegraph/context/engine.py:906-938
    def _marginal_utility(
        self, symbol_id: str, covered_edges: set[tuple[str, str]]
    ) -> float:
        """Compute marginal coverage gain of adding symbol_id.

        This makes the utility submodular: each new symbol covers some edges
        in the graph. As more symbols are selected, each new symbol covers
        fewer NEW edges â†’ diminishing returns.

        Returns a value in [0, 1] representing the fraction of new edges.
        """
        new_edges = 0
        total_edges = 0

        for succ in self.graph.successors(symbol_id):
            succ_data = self.graph.nodes.get(succ, {})
            if succ_data.get("type") == "symbol":
                total_edges += 1
                edge_key = (symbol_id, succ)
                if edge_key not in covered_edges:
                    new_edges += 1

        for pred in self.graph.predecessors(symbol_id):
            pred_data = self.graph.nodes.get(pred, {})
            if pred_data.get("type") == "symbol":
                total_edges += 1
                edge_key = (pred, symbol_id)
                if edge_key not in covered_edges:
                    new_edges += 1

        if total_edges == 0:
            return 1.0
        return new_edges / total_edges

# paper/experiments/benchmark.py:591-603
def build_prompt(context: str, task: str) -> str:
    """Build the user prompt from assembled context and task."""
    return f"""## Source Code Context

{context}

## Bug Report

{task}

## Fix

Produce SEARCH/REPLACE blocks to fix this bug."""

# src/cegraph/exceptions.py:32-39
class ProviderNotAvailable(LLMError):
    """Raised when an LLM provider's SDK is not installed."""

    def __init__(self, provider: str, package: str):
        super().__init__(
            f"Provider '{provider}' requires the '{package}' package. "
            f"Install it with: pip install cegraph[{provider}]"
        )