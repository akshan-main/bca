# Codebase Context for: GraphBuilder accumulates stale nodes and edges when build_from_directory is called multiple times — the second build has duplicate symbols from the first.
# 41 symbols from 14 files (~3,867 tokens, 97% of budget)

## paper/experiments/benchmark.py
# Included because: graph expansion (depth 2)

# [function] _restore_mutation (relevance: 0.40, depth: 2)
 831 | def _restore_mutation(repo_path: Path, mutation: dict, original: str) -> None:
 832 |     """Restore original content after mutation."""
 833 |     file_path = repo_path / mutation["file"]
 834 |     file_path.write_text(original)

## src/cegraph/context/_native.py
# Included because: graph expansion (depth 2)

# [method] NativeGraph.add_edge (relevance: 0.63, depth: 2)
 229 |     def add_edge(self, src: int, dst: int, weight: float) -> None:
 230 |         self._lib.cag_graph_add_edge(self._handle, src, dst, weight)

## src/cegraph/context/models.py
# Included because: graph expansion (depth 3)

# [method] TokenEstimator.estimate (relevance: 0.50, depth: 3)
 166 |     def estimate(cls, text: str) -> int:
 167 |         """Estimate token count for a string."""
 168 |         return max(1, int(len(text) / cls.CHARS_PER_TOKEN))

# [method] TokenEstimator.estimate_lines (relevance: 0.42, depth: 3)
 171 |     def estimate_lines(cls, line_count: int, avg_line_length: int = 40) -> int:
 172 |         """Estimate tokens for a given number of lines."""
 173 |         return max(1, int(line_count * avg_line_length / cls.CHARS_PER_TOKEN))

## src/cegraph/github/diff_parser.py
# Included because: graph expansion (depth 3)

# [function] get_pr_diff (relevance: 0.42, depth: 3)
 205 | def get_pr_diff(root: Path) -> str:
 206 |     """Get the diff for the current PR (GitHub Actions context)."""
 207 |     import os
 208 |     base_ref = os.environ.get("GITHUB_BASE_REF", "main")
 209 |     return get_git_diff(root, base=f"origin/{base_ref}")

## src/cegraph/graph/builder.py
# Included because: matches 'GraphBuilder'; matches 'build_from_directory'; graph expansion (depth 1)

# [class] GraphBuilder (relevance: 1.05, depth: 0)
  15 | class GraphBuilder:
  16 |     """Builds and maintains a code knowledge graph.
  17 | 
  18 |     The graph has two types of nodes:
  19 |     - File nodes: represent source files
  20 |     - Symbol nodes: represent code symbols (functions, classes, etc.)
  21 | 
  22 |     Edges represent relationships (calls, imports, inherits, contains, etc.)
  23 |     """
  24 | 
  25 |     def __init__(self) -> None:
  26 |         self.graph = nx.DiGraph()
  27 |         self._file_hashes: dict[str, str] = {}
  28 |         self._unresolved: list[Relationship] = []
  29 | 
  30 |     def build_from_directory(
  31 |         self,
  32 |         root: str | Path,
  33 |         config: ProjectConfig | None = None,
  34 |         progress_callback: callable | None = None,
  35 |     ) -> nx.DiGraph:
  36 |         """Build the full knowledge graph from a directory.
  37 | 
  38 |         Args:
  39 |             root: Root directory to index.
  40 |             config: Project configuration.
  41 |             progress_callback: Optional callback(file_path, current, total).
  42 | 
  43 |         Returns:
  44 |             The constructed NetworkX directed graph.
  45 |         """
  46 |         root = Path(root).resolve()
  47 |         indexer_config = config.indexer if config else IndexerConfig()
  48 | 
  49 |         # Reset state so reusing a builder doesn't accumulate stale data
  50 |         # self.graph = nx.DiGraph()
  51 |         # self._file_hashes = {}
  52 |         # self._unresolved = []
  53 | 
  54 |         # Parse all files
  55 |         all_parsed = parse_directory(root, indexer_config, progress_callback)
  56 | 
  57 |         # Build graph from parsed results
  58 |         for file_symbols in all_parsed:
  59 |             self._add_file(file_symbols, root)
  60 | 
  61 |         # Resolve cross-file references
  62 |         self._resolve_references()
  63 | 
  64 |         return self.graph
  65 | 
  66 |     def _add_file(self, fs: FileSymbols, root: Path) -> None:
  67 |         """Add a file and its symbols to the graph."""
  68 |         file_path = fs.file_path
  69 | 
  70 |         # Add file node
  71 |         self.graph.add_node(
  72 |             f"file::{file_path}",
  73 |             type="file",
  74 |             path=file_path,
  75 |             language=fs.language,
  76 |             symbol_count=len(fs.symbols),
  77 |             import_count=len(fs.imports),
  78 |         )
  79 | 
  80 |         # Compute file hash for change detection
  81 |         try:
  82 |             full_path = root / file_path
  83 |             content = full_path.read_bytes()
  84 |             self._file_hashes[file_path] = hashlib.sha256(content).hexdigest()[:16]
  85 |         except OSError:
  86 |             pass
  87 | 
  88 |         # Add symbol nodes
  89 |         for symbol in fs.symbols:
  90 |             attrs = {
  91 |                 "type": "symbol",
  92 |                 "name": symbol.name,
  93 |                 "qualified_name": symbol.qualified_name,
  94 |                 "kind": symbol.kind.value,
  95 |                 "file_path": symbol.file_path,
  96 |                 "line_start": symbol.line_start,
  97 |                 "line_end": symbol.line_end,
  98 |                 "signature": symbol.signature,
  99 |                 "docstring": symbol.docstring,
 100 |             }
 101 |             self.graph.add_node(symbol.id, **attrs)
 102 | 
 103 |             # Link symbol to its file
 104 |             self.graph.add_edge(
 105 |                 f"file::{file_path}",
 106 |                 symbol.id,
 107 |                 kind="contains",
 108 |             )
 109 | 
 110 |         # Add relationships
 111 |         for rel in fs.relationships:
 112 |             if rel.resolved or self._try_resolve(rel):
 113 |                 self.graph.add_edge(
 114 |                     rel.source,
 115 |                     rel.target,
 116 |                     kind=rel.kind.value,
 117 |                     file_path=rel.file_path,
 118 |                     line=rel.line,
 119 |                 )
 120 |             else:
 121 |                 self._unresolved.append(rel)
 122 | 
 123 |     def _try_resolve(self, rel: Relationship) -> bool:
 124 |         """Try to resolve a relationship's target to an existing node."""
 125 |         target = rel.target
 126 | 
 127 |         # Direct match
 128 |         if self.graph.has_node(target):
 129 |             return True
 130 | 
 131 |         # Try finding by name across all files
 132 |         for node_id, data in self.graph.nodes(data=True):
 133 |             if data.get("type") != "symbol":
 134 |                 continue
 135 |             if data.get("name") == target or data.get("qualified_name") == target:
 136 |                 rel.target = node_id
 137 |                 rel.resolved = True
 138 |                 return True
 139 | 
 140 |         return False
 141 | 
 142 |     def _resolve_references(self) -> None:
 143 |         """Try to resolve all unresolved references after the full graph is built."""
 144 |         still_unresolved = []
 145 | 
 146 |         # Build a lookup index: name -> [node_ids]
 147 |         name_index: dict[str, list[str]] = {}
 148 |         for node_id, data in self.graph.nodes(data=True):
 149 |             if data.get("type") != "symbol":
 150 |                 continue
 151 |             name = data.get("name", "")
 152 |             qname = data.get("qualified_name", "")
 153 |             if name:
 154 |                 name_index.setdefault(name, []).append(node_id)
 155 |             if qname and qname != name:
 156 |                 name_index.setdefault(qname, []).append(node_id)
 157 | 
 158 |         for rel in self._unresolved:
 159 |             target = rel.target
 160 |             # Try exact match by name
 161 |             candidates = name_index.get(target, [])
 162 | 
 163 |             # Try dotted parts (e.g., "module.func" -> "func")
 164 |             if not candidates and "." in target:
 165 |                 parts = target.split(".")
 166 |                 candidates = name_index.get(parts[-1], [])
 167 | 
 168 |             if candidates:
 169 |                 # Pick the best candidate (same file first, then any)
 170 |                 best = None
 171 |                 for c in candidates:
 172 |                     c_data = self.graph.nodes[c]
 173 |                     if c_data.get("file_path") == rel.file_path:
 174 |                         best = c
 175 |                         break
 176 |                 if best is None:
 177 |                     best = candidates[0]
 178 | 
 179 |                 self.graph.add_edge(
 180 |                     rel.source,
 181 |                     best,
 182 |                     kind=rel.kind.value,
 183 |                     file_path=rel.file_path,
 184 |                     line=rel.line,
 185 |                 )
 186 |             else:
 187 |                 still_unresolved.append(rel)
 188 | 
 189 |         self._unresolved = still_unresolved
 190 | 
 191 |     def get_stats(self) -> dict:
 192 |         """Get graph statistics."""
 193 |         node_types: dict[str, int] = {}
 194 |         edge_types: dict[str, int] = {}
 195 | 
 196 |         for _, data in self.graph.nodes(data=True):
 197 |             kind = data.get("kind", data.get("type", "unknown"))
 198 |             node_types[kind] = node_types.get(kind, 0) + 1
 199 | 
 200 |         for _, _, data in self.graph.edges(data=True):
 201 |             kind = data.get("kind", "unknown")
 202 |             edge_types[kind] = edge_types.get(kind, 0) + 1
 203 | 
 204 |         return {
 205 |             "total_nodes": self.graph.number_of_nodes(),
 206 |             "total_edges": self.graph.number_of_edges(),
 207 |             "node_types": node_types,
 208 |             "edge_types": edge_types,
 209 |             "files": node_types.get("file", 0),
 210 |             "functions": node_types.get("function", 0) + node_types.get("method", 0),
 211 |             "classes": node_types.get("class", 0),
 212 |             "unresolved_refs": len(self._unresolved),
 213 |         }

# [method] GraphBuilder.__init__ (relevance: 0.78, depth: 1)
  25 |     def __init__(self) -> None:
  26 |         self.graph = nx.DiGraph()
  27 |         self._file_hashes: dict[str, str] = {}
  28 |         self._unresolved: list[Relationship] = []

# [method] GraphBuilder.build_from_directory (relevance: 1.24, depth: 0)
  30 |     def build_from_directory(
  31 |         self,
  32 |         root: str | Path,
  33 |         config: ProjectConfig | None = None,
  34 |         progress_callback: callable | None = None,
  35 |     ) -> nx.DiGraph:
  36 |         """Build the full knowledge graph from a directory.
  37 | 
  38 |         Args:
  39 |             root: Root directory to index.
  40 |             config: Project configuration.
  41 |             progress_callback: Optional callback(file_path, current, total).
  42 | 
  43 |         Returns:
  44 |             The constructed NetworkX directed graph.
  45 |         """
  46 |         root = Path(root).resolve()
  47 |         indexer_config = config.indexer if config else IndexerConfig()
  48 | 
  49 |         # Reset state so reusing a builder doesn't accumulate stale data
  50 |         # self.graph = nx.DiGraph()
  51 |         # self._file_hashes = {}
  52 |         # self._unresolved = []
  53 | 
  54 |         # Parse all files
  55 |         all_parsed = parse_directory(root, indexer_config, progress_callback)
  56 | 
  57 |         # Build graph from parsed results
  58 |         for file_symbols in all_parsed:
  59 |             self._add_file(file_symbols, root)
  60 | 
  61 |         # Resolve cross-file references
  62 |         self._resolve_references()
  63 | 
  64 |         return self.graph

## src/cegraph/graph/store.py
# Included because: graph expansion (depth 2)

# [method] GraphStore.close (relevance: 0.63, depth: 2)
 499 |     def close(self) -> None:
 500 |         """Close the database connection."""
 501 |         if self._conn:
 502 |             self._conn.close()
 503 |             self._conn = None

## src/cegraph/tools/definitions.py
# Included because: graph expansion (depth 3)

# [method] CeGraphTools.get_structure (relevance: 0.29, depth: 3)
 220 |     def get_structure(self, path: str = "") -> str:
 221 |         """Get the project structure with symbol counts."""
 222 |         structure = self.query.get_structure(path)
 223 |         return json.dumps(structure, indent=2) if structure else "No structure data"

## src/cegraph/tools/registry.py
# Included because: graph expansion (depth 2); graph expansion (depth 3)

# [method] ToolRegistry.get (relevance: 0.73, depth: 2)
  26 |     def get(self, name: str) -> Callable | None:
  27 |         """Get a tool function by name."""
  28 |         return self._tools.get(name)

# [method] ToolRegistry.get_definition (relevance: 0.29, depth: 3)
  30 |     def get_definition(self, name: str) -> ToolDefinition | None:
  31 |         """Get a tool definition by name."""
  32 |         return self._definitions.get(name)

# [method] ToolRegistry.list_tools (relevance: 0.35, depth: 2)
  34 |     def list_tools(self) -> list[str]:
  35 |         """List all registered tool names."""
  36 |         return list(self._tools.keys())

## src/cegraph/ui/console.py
# Included because: graph expansion (depth 2); graph expansion (depth 3)

# [method] Console.success (relevance: 0.45, depth: 2)
  33 |     def success(self, message: str) -> None:
  34 |         self.console.print(f"[green]✓[/green] {message}")

# [method] Console.error (relevance: 0.46, depth: 3)
  36 |     def error(self, message: str) -> None:
  37 |         self.console.print(f"[red]✗[/red] {message}")

# [method] Console.warning (relevance: 0.42, depth: 3)
  39 |     def warning(self, message: str) -> None:
  40 |         self.console.print(f"[yellow]![/yellow] {message}")

# [method] Console.info (relevance: 0.55, depth: 2)
  42 |     def info(self, message: str) -> None:
  43 |         self.console.print(f"[blue]i[/blue] {message}")

## tests/test_context.py
# Included because: graph expansion (depth 1)

# [function] cag_engine (relevance: 0.53, depth: 1)
  21 | def cag_engine(tmp_project: Path):
  22 |     """Create a context assembler with a built graph."""
  23 |     builder = GraphBuilder()
  24 |     graph = builder.build_from_directory(tmp_project)
  25 |     query = GraphQuery(graph)
  26 |     return ContextAssembler(tmp_project, graph, query)

## tests/test_graph.py
# Included because: matches 'edges'; graph expansion (depth 2); graph expansion (depth 1)

# [method] TestGraphBuilder.test_build_from_directory (relevance: 0.58, depth: 1)
  16 |     def test_build_from_directory(self, tmp_project: Path):
  17 |         builder = GraphBuilder()
  18 |         graph = builder.build_from_directory(tmp_project)
  19 | 
  20 |         assert graph.number_of_nodes() > 0
  21 |         assert graph.number_of_edges() > 0

# [method] TestGraphBuilder.test_call_edges_exist (relevance: 0.60, depth: 1)
  57 |     def test_call_edges_exist(self, tmp_project: Path):
  58 |         builder = GraphBuilder()
  59 |         graph = builder.build_from_directory(tmp_project)
  60 | 
  61 |         call_edges = [
  62 |             (u, v) for u, v, d in graph.edges(data=True) if d.get("kind") == "calls"
  63 |         ]
  64 |         assert len(call_edges) > 0

# [method] TestGraphBuilder.test_contains_edges_exist (relevance: 0.60, depth: 1)
  66 |     def test_contains_edges_exist(self, tmp_project: Path):
  67 |         builder = GraphBuilder()
  68 |         graph = builder.build_from_directory(tmp_project)
  69 | 
  70 |         contains_edges = [
  71 |             (u, v) for u, v, d in graph.edges(data=True) if d.get("kind") == "contains"
  72 |         ]
  73 |         assert len(contains_edges) > 0

# [method] TestGraphQuery._build_query (relevance: 0.80, depth: 1)
 155 |     def _build_query(self, tmp_project: Path) -> GraphQuery:
 156 |         builder = GraphBuilder()
 157 |         graph = builder.build_from_directory(tmp_project)
 158 |         return GraphQuery(graph)

# [method] TestGraphQuery.test_find_symbol (relevance: 0.35, depth: 2)
 160 |     def test_find_symbol(self, tmp_project: Path):
 161 |         query = self._build_query(tmp_project)
 162 |         results = query.find_symbol("main")
 163 |         assert len(results) > 0

# [method] TestGraphQuery.test_find_symbol_partial (relevance: 0.35, depth: 2)
 165 |     def test_find_symbol_partial(self, tmp_project: Path):
 166 |         query = self._build_query(tmp_project)
 167 |         results = query.find_symbol("helper")
 168 |         assert len(results) > 0

# [method] TestGraphQuery.test_impact_not_found (relevance: 0.35, depth: 2)
 191 |     def test_impact_not_found(self, tmp_project: Path):
 192 |         query = self._build_query(tmp_project)
 193 |         impact = query.impact_of("nonexistent_function")
 194 |         assert impact["found"] is False

# [method] TestGraphQuery.test_get_structure (relevance: 0.35, depth: 2)
 203 |     def test_get_structure(self, tmp_project: Path):
 204 |         query = self._build_query(tmp_project)
 205 |         structure = query.get_structure()
 206 |         assert "main.py" in structure or len(structure) > 0

# [method] TestGraphQuery.test_find_related (relevance: 0.35, depth: 2)
 208 |     def test_find_related(self, tmp_project: Path):
 209 |         query = self._build_query(tmp_project)
 210 |         related = query.find_related("calculate_total")
 211 |         assert len(related) > 0

## tests/test_impact_bot.py
# Included because: matches 'multiple'

# [method] TestDiffParser.test_parse_multiple_files (relevance: 0.39, depth: 0)
  95 |     def test_parse_multiple_files(self):
  96 |         combined = SAMPLE_DIFF + SAMPLE_DIFF_NEW_FILE
  97 |         diffs = parse_diff(combined)
  98 |         assert len(diffs) == 2

## tests/test_search.py
# Included because: graph expansion (depth 2); graph expansion (depth 1)

# [method] TestLexicalSearch._build_search (relevance: 0.65, depth: 1)
  15 |     def _build_search(self, tmp_project: Path) -> LexicalSearch:
  16 |         builder = GraphBuilder()
  17 |         graph = builder.build_from_directory(tmp_project)
  18 |         return LexicalSearch(tmp_project, graph)

# [method] TestLexicalSearch.test_search_regex (relevance: 0.29, depth: 2)
  39 |     def test_search_regex(self, tmp_project: Path):
  40 |         search = self._build_search(tmp_project)
  41 |         results = search.search(r"def \w+\(self", regex=True)
  42 |         assert len(results) > 0

# [method] TestHybridSearch.test_search_delegates_to_lexical (relevance: 0.51, depth: 1)
  70 |     def test_search_delegates_to_lexical(self, tmp_project: Path):
  71 |         builder = GraphBuilder()
  72 |         graph = builder.build_from_directory(tmp_project)
  73 |         search = HybridSearch(tmp_project, graph)
  74 | 
  75 |         results = search.search("calculate_total")
  76 |         assert len(results) > 0

# [method] TestHybridSearch.test_search_symbols (relevance: 0.51, depth: 1)
  78 |     def test_search_symbols(self, tmp_project: Path):
  79 |         builder = GraphBuilder()
  80 |         graph = builder.build_from_directory(tmp_project)
  81 |         search = HybridSearch(tmp_project, graph)
  82 | 
  83 |         results = search.search_symbols("Order")
  84 |         assert len(results) > 0

## tests/test_tools.py
# Included because: graph expansion (depth 2); graph expansion (depth 1)

# [method] TestCeGraphTools._build_tools (relevance: 0.69, depth: 1)
  16 |     def _build_tools(self, tmp_project: Path) -> CeGraphTools:
  17 |         builder = GraphBuilder()
  18 |         graph = builder.build_from_directory(tmp_project)
  19 |         query = GraphQuery(graph)
  20 |         search = HybridSearch(tmp_project, graph)
  21 |         return CeGraphTools(tmp_project, graph, query, search)

# [method] TestCeGraphTools.test_who_calls (relevance: 0.29, depth: 2)
  35 |     def test_who_calls(self, tmp_project: Path):
  36 |         tools = self._build_tools(tmp_project)
  37 |         result = tools.who_calls("helper_function")
  38 |         assert "main" in result.lower() or "Callers" in result

# [method] TestCeGraphTools.test_what_calls (relevance: 0.29, depth: 2)
  40 |     def test_what_calls(self, tmp_project: Path):
  41 |         tools = self._build_tools(tmp_project)
  42 |         result = tools.what_calls("main")
  43 |         assert len(result) > 0

# [method] TestCeGraphTools.test_impact_of (relevance: 0.29, depth: 2)
  45 |     def test_impact_of(self, tmp_project: Path):
  46 |         tools = self._build_tools(tmp_project)
  47 |         result = tools.impact_of("calculate_total")
  48 |         assert "Risk score" in result or "Impact" in result

# [method] TestCeGraphTools.test_read_file (relevance: 0.29, depth: 2)
  50 |     def test_read_file(self, tmp_project: Path):
  51 |         tools = self._build_tools(tmp_project)
  52 |         result = tools.read_file("main.py")
  53 |         assert "def main" in result

# [method] TestCeGraphTools.test_read_file_not_found (relevance: 0.29, depth: 2)
  62 |     def test_read_file_not_found(self, tmp_project: Path):
  63 |         tools = self._build_tools(tmp_project)
  64 |         result = tools.read_file("nonexistent.py")
  65 |         assert "not found" in result.lower()

# [method] TestCeGraphTools.test_read_file_outside_root (relevance: 0.29, depth: 2)
  67 |     def test_read_file_outside_root(self, tmp_project: Path):
  68 |         tools = self._build_tools(tmp_project)
  69 |         result = tools.read_file("../../etc/passwd")
  70 |         assert "denied" in result.lower() or "not found" in result.lower()

# [method] TestCeGraphTools.test_edit_file_text_not_found (relevance: 0.29, depth: 2)
  87 |     def test_edit_file_text_not_found(self, tmp_project: Path):
  88 |         tools = self._build_tools(tmp_project)
  89 |         result = tools.edit_file("utils.py", "NONEXISTENT_TEXT", "replacement")
  90 |         assert "not found" in result.lower()

# [method] TestCeGraphTools.test_list_files (relevance: 0.29, depth: 2)
 100 |     def test_list_files(self, tmp_project: Path):
 101 |         tools = self._build_tools(tmp_project)
 102 |         result = tools.list_files()
 103 |         assert "main.py" in result
