# examples/demo.py
#!/usr/bin/env python3
"""Demo: Using CeGraph as a Python library.

This shows how to use CeGraph programmatically, not just as a CLI tool.
"""

from pathlib import Path

from cegraph.graph.builder import GraphBuilder
from cegraph.graph.query import GraphQuery
from cegraph.search.hybrid import HybridSearch


def main():
    # Point at any code directory
    project_root = Path(".")

    # 1. Build the knowledge graph
    print("Building knowledge graph...")
    builder = GraphBuilder()
    graph = builder.build_from_directory(project_root)

    stats = builder.get_stats()
    print(f"  Files: {stats['files']}")
    print(f"  Functions/Methods: {stats['functions']}")
    print(f"  Classes: {stats['classes']}")
    print(f"  Total nodes: {stats['total_nodes']}")
    print(f"  Total edges: {stats['total_edges']}")

    # 2. Query the graph
    query = GraphQuery(graph)

    # Find a symbol
    print("\n--- Finding 'GraphBuilder' ---")
    symbol_ids = query.find_symbol("GraphBuilder")
    for sid in symbol_ids:
        info = query.get_symbol_info(sid)
        if info:
            print(f"  {info.qualified_name} ({info.kind}) at {info.file_path}:{info.line_start}")
            print(f"  Callers: {len(info.callers)}")
            print(f"  Callees: {len(info.callees)}")

    # Who calls a function?
    print("\n--- Who calls 'parse_file'? ---")
    callers = query.who_calls("parse_file", max_depth=2)
    for c in callers:
        indent = "  " * c["depth"]
        print(f"{indent}  {c['name']} at {c['file_path']}:{c['line']}")

    # Impact analysis
    print("\n--- Impact of changing 'GraphQuery' ---")
    impact = query.impact_of("GraphQuery")
    print(f"  Risk score: {impact['risk_score']:.1%}")
    print(f"  Direct callers: {len(impact['direct_callers'])}")
    print(f"  Affected files: {len(impact['affected_files'])}")
    for f in impact["affected_files"]:
        print(f"    - {f}")

    # 3. Search code
    search = HybridSearch(project_root, graph)

    print("\n--- Searching for 'knowledge graph' ---")
    results = search.search("knowledge graph", max_results=5)
    for r in results:
        print(f"  {r.file_path}:{r.line_number} - {r.line_content.strip()[:80]}")

    print("\n--- Searching for class definitions ---")
    symbols = search.search_symbols("", kind="class", max_results=10)
    for s in symbols:
        print(f"  {s['qualified_name']} at {s['file_path']}:{s['line']}")


if __name__ == "__main__":
    main()


# paper/experiments/ablation.py
"""Ablation study runner for BCA.

Runs the context assembler with each component individually disabled,
measures recall of ground-truth patch symbols at fixed budgets.

Usage:
    python -m paper.experiments.ablation --repo /path/to/repo --task "fix the bug"
    python -m paper.experiments.ablation --repo /path/to/repo --tasks-file tasks.jsonl
"""

from __future__ import annotations

import argparse
import json
import sys
import time
from dataclasses import asdict, dataclass, field
from pathlib import Path

from cegraph.context.engine import AblationConfig, ContextAssembler
from cegraph.context.models import ContextStrategy
from cegraph.graph.builder import GraphBuilder
from cegraph.graph.query import GraphQuery


@dataclass
class AblationResult:
    """Result of a single ablation run."""

    config_name: str
    task: str
    budget: int
    symbols_selected: int
    symbols_available: int
    tokens_used: int
    budget_used_pct: float
    assembly_time_ms: float
    selected_symbols: list[str] = field(default_factory=list)
    closure_violations: int = 0
    recall: float | None = None  # Set if ground-truth symbols provided


# Each ablation disables exactly one component.
ABLATION_CONFIGS: dict[str, AblationConfig] = {
    "full": AblationConfig(),
    "-dependency_closure": AblationConfig(dependency_closure=False),
    "-submodular_coverage": AblationConfig(submodular_coverage=False),
    "-centrality_scoring": AblationConfig(centrality_scoring=False),
    "-file_proximity": AblationConfig(file_proximity=False),
    "-kind_weights": AblationConfig(kind_weights=False),
    "-dependency_ordering": AblationConfig(dependency_ordering=False),
    "base_bfs_only": AblationConfig(
        dependency_closure=False,
        submodular_coverage=False,
        centrality_scoring=False,
        file_proximity=False,
        kind_weights=False,
        dependency_ordering=False,
    ),
    "+pagerank": AblationConfig(use_pagerank=True),
    "+learned_weights": AblationConfig(learned_weights=True),
}


def run_ablation(
    repo_path: Path,
    task: str,
    budgets: list[int],
    ground_truth_symbols: list[str] | None = None,
) -> list[AblationResult]:
    """Run all ablation configs for a single task across budgets."""
    builder = GraphBuilder()
    graph = builder.build_from_directory(repo_path)
    query = GraphQuery(graph)

    results: list[AblationResult] = []

    for budget in budgets:
        for config_name, ablation_config in ABLATION_CONFIGS.items():
            assembler = ContextAssembler(repo_path, graph, query, ablation=ablation_config)

            start = time.time()
            package = assembler.assemble(
                task=task,
                token_budget=budget,
                strategy=ContextStrategy.SMART,
            )
            elapsed_ms = (time.time() - start) * 1000

            selected_syms = [item.qualified_name or item.name for item in package.items]

            # Compute recall against ground truth if provided
            recall = None
            if ground_truth_symbols:
                hits = sum(
                    1 for gt in ground_truth_symbols
                    if any(gt in s or s in gt for s in selected_syms)
                )
                recall = hits / len(ground_truth_symbols) if ground_truth_symbols else 0.0

            # Check closure violations (symbols whose deps are missing)
            closure_violations = 0
            if ablation_config.dependency_closure:
                selected_ids = {item.symbol_id for item in package.items}
                for item in package.items:
                    for succ in graph.successors(item.symbol_id):
                        edge_data = graph.edges[item.symbol_id, succ]
                        if edge_data.get("kind") in ("inherits", "implements"):
                            if succ not in selected_ids:
                                closure_violations += 1

            results.append(AblationResult(
                config_name=config_name,
                task=task,
                budget=budget,
                symbols_selected=package.symbols_included,
                symbols_available=package.symbols_available,
                tokens_used=package.total_tokens,
                budget_used_pct=package.budget_used_pct,
                assembly_time_ms=round(elapsed_ms, 1),
                selected_symbols=selected_syms,
                closure_violations=closure_violations,
                recall=recall,
            ))

    return results


def format_results_table(results: list[AblationResult]) -> str:
    """Format ablation results as a readable table."""
    lines = []

    # Group by budget
    budgets = sorted(set(r.budget for r in results))

    for budget in budgets:
        lines.append(f"\n{'='*70}")
        lines.append(f"Budget: {budget} tokens")
        lines.append(f"{'='*70}")
        lines.append(
            f"{'Config':<25} {'Syms':>5} {'Tokens':>7} {'Used%':>6} "
            f"{'Time':>8} {'Violations':>10} {'Recall':>7}"
        )
        lines.append("-" * 70)

        budget_results = [r for r in results if r.budget == budget]
        for r in budget_results:
            recall_str = f"{r.recall:.3f}" if r.recall is not None else "n/a"
            lines.append(
                f"{r.config_name:<25} {r.symbols_selected:>5} "
                f"{r.tokens_used:>7} {r.budget_used_pct:>5.1f}% "
                f"{r.assembly_time_ms:>7.1f}ms {r.closure_violations:>10} "
                f"{recall_str:>7}"
 