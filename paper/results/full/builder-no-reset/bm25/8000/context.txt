# tests/test_graph.py:16-21
    def test_build_from_directory(self, tmp_project: Path):
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)

        assert graph.number_of_nodes() > 0
        assert graph.number_of_edges() > 0

# examples/demo.py:9-9
from cegraph.graph.builder import GraphBuilder

# src/cegraph/graph/builder.py:66-121
    def _add_file(self, fs: FileSymbols, root: Path) -> None:
        """Add a file and its symbols to the graph."""
        file_path = fs.file_path

        # Add file node
        self.graph.add_node(
            f"file::{file_path}",
            type="file",
            path=file_path,
            language=fs.language,
            symbol_count=len(fs.symbols),
            import_count=len(fs.imports),
        )

        # Compute file hash for change detection
        try:
            full_path = root / file_path
            content = full_path.read_bytes()
            self._file_hashes[file_path] = hashlib.sha256(content).hexdigest()[:16]
        except OSError:
            pass

        # Add symbol nodes
        for symbol in fs.symbols:
            attrs = {
                "type": "symbol",
                "name": symbol.name,
                "qualified_name": symbol.qualified_name,
                "kind": symbol.kind.value,
                "file_path": symbol.file_path,
                "line_start": symbol.line_start,
                "line_end": symbol.line_end,
                "signature": symbol.signature,
                "docstring": symbol.docstring,
            }
            self.graph.add_node(symbol.id, **attrs)

            # Link symbol to its file
            self.graph.add_edge(
                f"file::{file_path}",
                symbol.id,
                kind="contains",
            )

        # Add relationships
        for rel in fs.relationships:
            if rel.resolved or self._try_resolve(rel):
                self.graph.add_edge(
                    rel.source,
                    rel.target,
                    kind=rel.kind.value,
                    file_path=rel.file_path,
                    line=rel.line,
                )
            else:
                self._unresolved.append(rel)

# tests/test_graph.py:77-98
    def test_rebuild_resets_state(self, tmp_path: Path):
        """Regression: reusing a builder must not accumulate stale nodes."""
        # First project
        p1 = tmp_path / "proj1"
        p1.mkdir()
        (p1 / "a.py").write_text("def a_func():\n    pass\n")

        builder = GraphBuilder()
        g1 = builder.build_from_directory(p1)
        g1_files = {d["path"] for _, d in g1.nodes(data=True) if d.get("type") == "file"}

        # Second project with different files
        p2 = tmp_path / "proj2"
        p2.mkdir()
        (p2 / "b.py").write_text("def b_func():\n    pass\n")

        g2 = builder.build_from_directory(p2)
        g2_files = {d["path"] for _, d in g2.nodes(data=True) if d.get("type") == "file"}

        # g2 should NOT contain files from g1
        assert "a.py" not in g2_files
        assert "b.py" in g2_files

# tests/test_graph.py:57-64
    def test_call_edges_exist(self, tmp_project: Path):
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)

        call_edges = [
            (u, v) for u, v, d in graph.edges(data=True) if d.get("kind") == "calls"
        ]
        assert len(call_edges) > 0

# paper/experiments/benchmark.py:591-603
def build_prompt(context: str, task: str) -> str:
    """Build the user prompt from assembled context and task."""
    return f"""## Source Code Context

{context}

## Bug Report

{task}

## Fix

Produce SEARCH/REPLACE blocks to fix this bug."""

# tests/test_graph.py:66-73
    def test_contains_edges_exist(self, tmp_project: Path):
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)

        contains_edges = [
            (u, v) for u, v, d in graph.edges(data=True) if d.get("kind") == "contains"
        ]
        assert len(contains_edges) > 0

# examples/demo.py:9-9
from cegraph.graph.builder import GraphBuilder

# examples/demo.py:9-9
from cegraph.graph.builder import GraphBuilder

# examples/demo.py:9-9
from cegraph.graph.builder import GraphBuilder

# examples/demo.py:9-9
from cegraph.graph.builder import GraphBuilder

# examples/demo.py:9-9
from cegraph.graph.builder import GraphBuilder

# examples/demo.py:9-9
from cegraph.graph.builder import GraphBuilder

# examples/demo.py:9-9
from cegraph.graph.builder import GraphBuilder

# examples/demo.py:9-9
from cegraph.graph.builder import GraphBuilder

# examples/demo.py:9-9
from cegraph.graph.builder import GraphBuilder

# examples/demo.py:9-9
from cegraph.graph.builder import GraphBuilder

# examples/demo.py:9-9
from cegraph.graph.builder import GraphBuilder

# tests/test_graph.py:34-44
    def test_file_nodes_present(self, tmp_project: Path):
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)

        file_nodes = [
            n for n, d in graph.nodes(data=True) if d.get("type") == "file"
        ]
        file_paths = [graph.nodes[n].get("path") for n in file_nodes]
        assert "main.py" in file_paths
        assert "utils.py" in file_paths
        assert "models.py" in file_paths

# tests/test_graph.py:15-73
class TestGraphBuilder:
    def test_build_from_directory(self, tmp_project: Path):
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)

        assert graph.number_of_nodes() > 0
        assert graph.number_of_edges() > 0

    def test_stats(self, tmp_project: Path):
        builder = GraphBuilder()
        builder.build_from_directory(tmp_project)
        stats = builder.get_stats()

        assert stats["files"] > 0
        assert stats["functions"] > 0
        assert stats["classes"] > 0
        assert stats["total_nodes"] > 0
        assert stats["total_edges"] > 0

    def test_file_nodes_present(self, tmp_project: Path):
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)

        file_nodes = [
            n for n, d in graph.nodes(data=True) if d.get("type") == "file"
        ]
        file_paths = [graph.nodes[n].get("path") for n in file_nodes]
        assert "main.py" in file_paths
        assert "utils.py" in file_paths
        assert "models.py" in file_paths

    def test_symbol_nodes_have_attributes(self, tmp_project: Path):
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)

        for node_id, data in graph.nodes(data=True):
            if data.get("type") == "symbol":
                assert "name" in data
                assert "kind" in data
                assert "file_path" in data
                assert "line_start" in data

    def test_call_edges_exist(self, tmp_project: Path):
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)

        call_edges = [
            (u, v) for u, v, d in graph.edges(data=True) if d.get("kind") == "calls"
        ]
        assert len(call_edges) > 0

    def test_contains_edges_exist(self, tmp_project: Path):
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)

        contains_edges = [
            (u, v) for u, v, d in graph.edges(data=True) if d.get("kind") == "contains"
        ]
        assert len(contains_edges) > 0

# tests/test_graph.py:76-98
class TestGraphBuilderReuse:
    def test_rebuild_resets_state(self, tmp_path: Path):
        """Regression: reusing a builder must not accumulate stale nodes."""
        # First project
        p1 = tmp_path / "proj1"
        p1.mkdir()
        (p1 / "a.py").write_text("def a_func():\n    pass\n")

        builder = GraphBuilder()
        g1 = builder.build_from_directory(p1)
        g1_files = {d["path"] for _, d in g1.nodes(data=True) if d.get("type") == "file"}

        # Second project with different files
        p2 = tmp_path / "proj2"
        p2.mkdir()
        (p2 / "b.py").write_text("def b_func():\n    pass\n")

        g2 = builder.build_from_directory(p2)
        g2_files = {d["path"] for _, d in g2.nodes(data=True) if d.get("type") == "file"}

        # g2 should NOT contain files from g1
        assert "a.py" not in g2_files
        assert "b.py" in g2_files

# tests/test_graph.py:46-55
    def test_symbol_nodes_have_attributes(self, tmp_project: Path):
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)

        for node_id, data in graph.nodes(data=True):
            if data.get("type") == "symbol":
                assert "name" in data
                assert "kind" in data
                assert "file_path" in data
                assert "line_start" in data

# src/cegraph/graph/builder.py:30-64
    def build_from_directory(
        self,
        root: str | Path,
        config: ProjectConfig | None = None,
        progress_callback: callable | None = None,
    ) -> nx.DiGraph:
        """Build the full knowledge graph from a directory.

        Args:
            root: Root directory to index.
            config: Project configuration.
            progress_callback: Optional callback(file_path, current, total).

        Returns:
            The constructed NetworkX directed graph.
        """
        root = Path(root).resolve()
        indexer_config = config.indexer if config else IndexerConfig()

        # Reset state so reusing a builder doesn't accumulate stale data
        # self.graph = nx.DiGraph()
        # self._file_hashes = {}
        # self._unresolved = []

        # Parse all files
        all_parsed = parse_directory(root, indexer_config, progress_callback)

        # Build graph from parsed results
        for file_symbols in all_parsed:
            self._add_file(file_symbols, root)

        # Resolve cross-file references
        self._resolve_references()

        return self.graph

# src/cegraph/cli.py:107-140
def _do_index(root: Path, config: ProjectConfig):
    """Index the codebase and build the knowledge graph."""
    from cegraph.graph.builder import GraphBuilder
    from cegraph.graph.store import GraphStore

    builder = GraphBuilder()

    console.info("Scanning and parsing source files...")
    start_time = time.time()

    with console.indexing_progress() as progress:
        task = progress.add_task("Indexing...", total=None)
        file_count = 0

        def on_progress(file_path: str, current: int, total: int):
            nonlocal file_count
            file_count = total
            progress.update(task, total=total, completed=current, description=f"Parsing {file_path}")

        graph = builder.build_from_directory(root, config, on_progress)

    elapsed = time.time() - start_time
    stats = builder.get_stats()

    console.success(f"Indexed {stats.get('files', 0)} files in {elapsed:.1f}s")
    console.show_stats(stats)

    # Persist the graph
    db_path = get_cegraph_dir(root) / GRAPH_DB_FILE
    store = GraphStore(db_path)
    store.save(graph, metadata={"stats": stats, "root": str(root)})
    store.close()

    console.success(f"Knowledge graph saved to .cegraph/")

# src/cegraph/cli.py:100-104
def reindex(path: str | None):
    """Rebuild the knowledge graph from scratch."""
    root = _get_project_root(path)
    config = load_config(root)
    _do_index(root, config)

# src/cegraph/graph/query.py:162-183
    def what_calls(self, name: str) -> list[dict]:
        """Find all symbols called by the given symbol."""
        symbol_ids = self.find_symbol(name)
        results = []

        for sid in symbol_ids:
            for succ in self.graph.successors(sid):
                edge_data = self.graph.edges[sid, succ]
                if edge_data.get("kind") != "calls":
                    continue
                succ_data = self.graph.nodes.get(succ, {})
                if succ_data.get("type") != "symbol":
                    continue
                results.append({
                    "symbol_id": succ,
                    "name": succ_data.get("qualified_name", succ_data.get("name", "")),
                    "kind": succ_data.get("kind", ""),
                    "file_path": succ_data.get("file_path", ""),
                    "line": succ_data.get("line_start", 0),
                })

        return results

# src/cegraph/graph/store.py:469-489
    def get_callees(self, symbol_id: str) -> list[dict]:
        """Get all symbols called by the given symbol."""
        conn = self._get_conn()
        source_nid = self._resolve_text_id(conn, symbol_id)
        if source_nid is None:
            return []

        rows = conn.execute(
            """SELECT (sp.path || '::' || s.qualified_name) as id,
                      s.name, s.qualified_name, s.kind,
                      sp.path as file_path, s.line_start, s.line_end,
                      s.signature, s.docstring,
                      e.line as call_line, rp.path as call_file
               FROM edges e
               JOIN nodes s ON s.nid = e.target_nid AND s.node_type = 'symbol'
               JOIN path_map sp ON sp.pid = s.path_id
               LEFT JOIN path_map rp ON rp.pid = e.path_id
               WHERE e.source_nid = ? AND e.kind = 'calls'""",
            (source_nid,),
        ).fetchall()
        return [dict(row) for row in rows]

# src/cegraph/graph/builder.py:25-28
    def __init__(self) -> None:
        self.graph = nx.DiGraph()
        self._file_hashes: dict[str, str] = {}
        self._unresolved: list[Relationship] = []

# src/cegraph/cli.py:71-95
def init(path: str | None, provider: str | None, model: str | None):
    """Initialize CeGraph for a repository. Indexes the codebase and builds the knowledge graph."""
    root = Path(path or ".").resolve()
    if not root.exists():
        console.error(f"Path does not exist: {root}")
        sys.exit(1)

    console.banner()
    console.info(f"Initializing CeGraph for: {root}")

    # Create/load config
    config = load_config(root)
    config.name = root.name
    config.root_path = str(root)

    if provider:
        config.llm.provider = provider
    if model:
        config.llm.model = model

    save_config(root, config)
    console.success("Configuration saved")

    # Build the knowledge graph
    _do_index(root, config)

# src/cegraph/graph/builder.py:12-12
from cegraph.parser.models import FileSymbols, RelKind, Relationship, Symbol, SymbolKind

# tests/test_graph.py:23-32
    def test_stats(self, tmp_project: Path):
        builder = GraphBuilder()
        builder.build_from_directory(tmp_project)
        stats = builder.get_stats()

        assert stats["files"] > 0
        assert stats["functions"] > 0
        assert stats["classes"] > 0
        assert stats["total_nodes"] > 0
        assert stats["total_edges"] > 0

# tests/test_impact_bot.py:95-98
    def test_parse_multiple_files(self):
        combined = SAMPLE_DIFF + SAMPLE_DIFF_NEW_FILE
        diffs = parse_diff(combined)
        assert len(diffs) == 2

# src/cegraph/graph/builder.py:5-5
import hashlib

# src/cegraph/context/engine.py:112-112
_HARD_DEP_EDGES = {"inherits", "implements"}

# src/cegraph/context/engine.py:171-193
    def _build_native_graph(self) -> None:
        """Build the C++ graph representation for accelerated BFS."""
        nodes = list(self.graph.nodes())
        self._node_to_idx = {n: i for i, n in enumerate(nodes)}
        self._idx_to_node = {i: n for i, n in enumerate(nodes)}

        self._native_graph = NativeCAG.create_graph(len(nodes))

        for n, data in self.graph.nodes(data=True):
            idx = self._node_to_idx[n]
            kind = data.get("kind", "")
            weight = _KIND_WEIGHTS.get(kind, 0.5)
            self._native_graph.set_node_weight(idx, weight)
            self._native_graph.set_lines(
                idx, data.get("line_start", 0), data.get("line_end", 0)
            )

        for u, v, data in self.graph.edges(data=True):
            kind = data.get("kind", "")
            weight = self._edge_weights.get(kind, 0.3)
            src = self._node_to_idx[u]
            dst = self._node_to_idx[v]
            self._native_graph.add_edge(src, dst, weight)

# src/cegraph/parser/tree_sitter_parser.py:130-204
def _walk_tree(
    node,
    file_path: str,
    language: str,
    source: bytes,
    result: FileSymbols,
    parent_name: str = "",
    parent_id: str = "",
) -> None:
    """Recursively walk the tree-sitter AST and extract symbols."""
    symbol_types = _SYMBOL_NODE_TYPES.get(language, {})

    for child in node.children:
        node_type = child.type

        if node_type in symbol_types:
            kind = symbol_types[node_type]
            if kind is None:
                # Unwrap (e.g., decorated_definition)
                _walk_tree(child, file_path, language, source, result, parent_name, parent_id)
                continue

            name = _extract_name(child, language)
            if not name:
                continue

            qualified = f"{parent_name}.{name}" if parent_name else name
            if parent_name and kind == SymbolKind.FUNCTION:
                kind = SymbolKind.METHOD

            sig_start = child.start_byte
            sig_end = min(sig_start + 200, child.end_byte)
            sig_text = source[sig_start:sig_end].decode("utf-8", errors="replace")
            # Trim signature to first line or first brace
            sig_text = sig_text.split("\n")[0].strip()

            symbol = Symbol(
                name=name,
                qualified_name=qualified,
                kind=kind,
                file_path=file_path,
                line_start=child.start_point[0] + 1,
                line_end=child.end_point[0] + 1,
                column_start=child.start_point[1],
                column_end=child.end_point[1],
                signature=sig_text,
                parent=parent_id,
            )
            result.symbols.append(symbol)

            if parent_id:
                result.relationships.append(
                    Relationship(
                        source=parent_id,
                        target=symbol.id,
                        kind=RelKind.CONTAINS,
                        file_path=file_path,
                        line=child.start_point[0] + 1,
                    )
                )

            # Extract calls within this symbol
            call_types = _CALL_NODE_TYPES.get(language, [])
            _extract_ts_calls(child, file_path, language, source, symbol.id, call_types, result)

            # Recurse for nested definitions (e.g., methods in classes)
            _walk_tree(
                child, file_path, language, source, result, qualified, symbol.id
            )

        elif node_type in ("import_statement", "import_from_statement", "import_declaration"):
            _extract_ts_import(child, file_path, source, result)
        else:
            # Continue walking
            _walk_tree(child, file_path, language, source, result, parent_name, parent_id)

# src/cegraph/graph/builder.py:191-213
    def get_stats(self) -> dict:
        """Get graph statistics."""
        node_types: dict[str, int] = {}
        edge_types: dict[str, int] = {}

        for _, data in self.graph.nodes(data=True):
            kind = data.get("kind", data.get("type", "unknown"))
            node_types[kind] = node_types.get(kind, 0) + 1

        for _, _, data in self.graph.edges(data=True):
            kind = data.get("kind", "unknown")
            edge_types[kind] = edge_types.get(kind, 0) + 1

        return {
            "total_nodes": self.graph.number_of_nodes(),
            "total_edges": self.graph.number_of_edges(),
            "node_types": node_types,
            "edge_types": edge_types,
            "files": node_types.get("file", 0),
            "functions": node_types.get("function", 0) + node_types.get("method", 0),
            "classes": node_types.get("class", 0),
            "unresolved_refs": len(self._unresolved),
        }

# tests/test_mcp.py:198-208
    def test_handle_request(self, mcp_server: MCPServer):
        """Test request handling (has id, gets response)."""
        result = mcp_server._handle_message({
            "jsonrpc": "2.0",
            "id": 1,
            "method": "ping",
            "params": {},
        })
        assert result is not None
        assert result["jsonrpc"] == "2.0"
        assert result["id"] == 1

# src/cegraph/llm/base.py:55-56
    def has_tool_calls(self) -> bool:
        return len(self.tool_calls) > 0

# src/cegraph/graph/builder.py:142-189
    def _resolve_references(self) -> None:
        """Try to resolve all unresolved references after the full graph is built."""
        still_unresolved = []

        # Build a lookup index: name -> [node_ids]
        name_index: dict[str, list[str]] = {}
        for node_id, data in self.graph.nodes(data=True):
            if data.get("type") != "symbol":
                continue
            name = data.get("name", "")
            qname = data.get("qualified_name", "")
            if name:
                name_index.setdefault(name, []).append(node_id)
            if qname and qname != name:
                name_index.setdefault(qname, []).append(node_id)

        for rel in self._unresolved:
            target = rel.target
            # Try exact match by name
            candidates = name_index.get(target, [])

            # Try dotted parts (e.g., "module.func" -> "func")
            if not candidates and "." in target:
                parts = target.split(".")
                candidates = name_index.get(parts[-1], [])

            if candidates:
                # Pick the best candidate (same file first, then any)
                best = None
                for c in candidates:
                    c_data = self.graph.nodes[c]
                    if c_data.get("file_path") == rel.file_path:
                        best = c
                        break
                if best is None:
                    best = candidates[0]

                self.graph.add_edge(
                    rel.source,
                    best,
                    kind=rel.kind.value,
                    file_path=rel.file_path,
                    line=rel.line,
                )
            else:
                still_unresolved.append(rel)

        self._unresolved = still_unresolved

# src/cegraph/mcp/server.py:210-225
    def _handle_tool_call(self, name: str, arguments: dict) -> Any:
        """Execute a tool and return the result."""
        if name == "cag_assemble":
            return self._tool_cag_assemble(arguments)
        elif name == "search_code":
            return self._tool_search_code(arguments)
        elif name == "who_calls":
            return self._tool_who_calls(arguments)
        elif name == "impact_of":
            return self._tool_impact_of(arguments)
        elif name == "get_structure":
            return self._tool_get_structure(arguments)
        elif name == "find_related":
            return self._tool_find_related(arguments)
        else:
            raise ValueError(f"Unknown tool: {name}")

# tests/test_graph.py:155-158
    def _build_query(self, tmp_project: Path) -> GraphQuery:
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)
        return GraphQuery(graph)

# src/cegraph/graph/builder.py:12-12
from cegraph.parser.models import FileSymbols, RelKind, Relationship, Symbol, SymbolKind