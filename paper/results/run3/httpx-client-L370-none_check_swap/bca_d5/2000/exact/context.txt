## httpx/_client.py

def _port_or_default(url: URL) -> int | None:
    if url.port is not None:
        return url.port
    return {"http": 80, "https": 443}.get(url.scheme)

USE_CLIENT_DEFAULT = UseClientDefault()

## httpx/_status_codes.py

    def is_client_error(cls, value: int) -> bool:
        """
        Returns `True` for 4xx status codes, `False` otherwise.
        """
        return 400 <= value <= 499

    CONTINUE = 100, "Continue"

    SWITCHING_PROTOCOLS = 101, "Switching Protocols"

    PROCESSING = 102, "Processing"

    EARLY_HINTS = 103, "Early Hints"

    OK = 200, "OK"

    CREATED = 201, "Created"

    ACCEPTED = 202, "Accepted"

    NON_AUTHORITATIVE_INFORMATION = 203, "Non-Authoritative Information"

    NO_CONTENT = 204, "No Content"

    RESET_CONTENT = 205, "Reset Content"

    PARTIAL_CONTENT = 206, "Partial Content"

    MULTI_STATUS = 207, "Multi-Status"

    ALREADY_REPORTED = 208, "Already Reported"

    IM_USED = 226, "IM Used"

    MULTIPLE_CHOICES = 300, "Multiple Choices"

    MOVED_PERMANENTLY = 301, "Moved Permanently"

    FOUND = 302, "Found"

    SEE_OTHER = 303, "See Other"

    NOT_MODIFIED = 304, "Not Modified"

    USE_PROXY = 305, "Use Proxy"

    TEMPORARY_REDIRECT = 307, "Temporary Redirect"

    PERMANENT_REDIRECT = 308, "Permanent Redirect"

    BAD_REQUEST = 400, "Bad Request"

    UNAUTHORIZED = 401, "Unauthorized"

    PAYMENT_REQUIRED = 402, "Payment Required"

    FORBIDDEN = 403, "Forbidden"

    NOT_FOUND = 404, "Not Found"

    METHOD_NOT_ALLOWED = 405, "Method Not Allowed"

    NOT_ACCEPTABLE = 406, "Not Acceptable"

    PROXY_AUTHENTICATION_REQUIRED = 407, "Proxy Authentication Required"

    REQUEST_TIMEOUT = 408, "Request Timeout"

    CONFLICT = 409, "Conflict"

    GONE = 410, "Gone"

    LENGTH_REQUIRED = 411, "Length Required"

    PRECONDITION_FAILED = 412, "Precondition Failed"

    REQUEST_ENTITY_TOO_LARGE = 413, "Request Entity Too Large"

    REQUEST_URI_TOO_LONG = 414, "Request-URI Too Long"

    EXPECTATION_FAILED = 417, "Expectation Failed"

    UNPROCESSABLE_ENTITY = 422, "Unprocessable Entity"

    LOCKED = 423, "Locked"

    FAILED_DEPENDENCY = 424, "Failed Dependency"

    TOO_EARLY = 425, "Too Early"

    UPGRADE_REQUIRED = 426, "Upgrade Required"

    PRECONDITION_REQUIRED = 428, "Precondition Required"

    TOO_MANY_REQUESTS = 429, "Too Many Requests"

    REQUEST_HEADER_FIELDS_TOO_LARGE = 431, "Request Header Fields Too Large"

    UNAVAILABLE_FOR_LEGAL_REASONS = 451, "Unavailable For Legal Reasons"

    NOT_IMPLEMENTED = 501, "Not Implemented"

    BAD_GATEWAY = 502, "Bad Gateway"

    SERVICE_UNAVAILABLE = 503, "Service Unavailable"

    GATEWAY_TIMEOUT = 504, "Gateway Timeout"

    HTTP_VERSION_NOT_SUPPORTED = 505, "HTTP Version Not Supported"

    VARIANT_ALSO_NEGOTIATES = 506, "Variant Also Negotiates"

    INSUFFICIENT_STORAGE = 507, "Insufficient Storage"

    LOOP_DETECTED = 508, "Loop Detected"

    NOT_EXTENDED = 510, "Not Extended"

    NETWORK_AUTHENTICATION_REQUIRED = 511, "Network Authentication Required"

## httpx/_urlparse.py

def PERCENT(string: str) -> str:
    return "".join([f"%{byte:02X}" for byte in string.encode("utf-8")])

## httpx/_utils.py

def to_str(value: str | bytes, encoding: str = "utf-8") -> str:
    return value if isinstance(value, str) else value.decode(encoding)

## tests/client/test_async_client.py

async def test_get_invalid_url(server, url):
    async with httpx.AsyncClient() as client:
        with pytest.raises((httpx.UnsupportedProtocol, httpx.LocalProtocolError)):
            await client.get(url)

def hello_world(request):
    return httpx.Response(200, text="Hello, world!")

## tests/client/test_client.py

def autodetect(content):
    return chardet.detect(content).get("encoding")

def test_get_invalid_url(server, url):
    with httpx.Client() as client:
        with pytest.raises((httpx.UnsupportedProtocol, httpx.LocalProtocolError)):
            client.get(url)

## tests/client/test_headers.py

def echo_headers(request: httpx.Request) -> httpx.Response:
    data = {"headers": dict(request.headers)}
    return httpx.Response(200, json=data)

def echo_repeated_headers_items(request: httpx.Request) -> httpx.Response:
    data = {"headers": list(request.headers.items())}
    return httpx.Response(200, json=data)

def test_client_header():
    """
    Set a header in the Client.
    """
    url = "http://example.org/echo_headers"
    headers = {"Example-Header": "example-value"}

    client = httpx.Client(transport=httpx.MockTransport(echo_headers), headers=headers)
    response = client.get(url)

    assert response.status_code == 200
    assert response.json() == {
        "headers": {
            "accept": "*/*",
            "accept-encoding": "gzip, deflate, br, zstd",
            "connection": "keep-alive",
            "example-header": "example-value",
            "host": "example.org",
            "user-agent": f"python-httpx/{httpx.__version__}",
        }
    }

def test_header_does_not_exist():
    headers = httpx.Headers({"foo": "bar"})
    with pytest.raises(KeyError):
        del headers["baz"]

## tests/client/test_properties.py

def test_client_base_url():
    client = httpx.Client()
    client.base_url = "https://www.example.org/"
    assert isinstance(client.base_url, httpx.URL)
    assert client.base_url == "https://www.example.org/"

def test_client_headers():
    client = httpx.Client()
    client.headers = {"a": "b"}
    assert isinstance(client.headers, httpx.Headers)
    assert client.headers["A"] == "b"

def test_client_cookies():
    client = httpx.Client()
    client.cookies = {"a": "b"}
    assert isinstance(client.cookies, httpx.Cookies)
    mycookies = list(client.cookies.jar)
    assert len(mycookies) == 1
    assert mycookies[0].name == "a" and mycookies[0].value == "b"

def test_client_timeout():
    expected_timeout = 12.0
    client = httpx.Client()

    client.timeout = expected_timeout

    assert isinstance(client.timeout, httpx.Timeout)
    assert client.timeout.connect == expected_timeout
    assert client.timeout.read == expected_timeout
    assert client.timeout.write == expected_timeout
    assert client.timeout.pool == expected_timeout

def test_client_event_hooks():
    def on_request(request):
        pass  # pragma: no cover

    client = httpx.Client()
    client.event_hooks = {"request": [on_request]}
    assert client.event_hooks == {"request": [on_request], "response": []}

def test_client_trust_env():
    client = httpx.Client()
    assert client.trust_env

    client = httpx.Client(trust_env=False)
    assert not client.trust_env

## tests/client/test_queryparams.py

def hello_world(request: httpx.Request) -> httpx.Response:
    return httpx.Response(200, text="Hello, world")

def test_client_queryparams():
    client = httpx.Client(params={"a": "b"})
    assert isinstance(client.params, httpx.QueryParams)
    assert client.params["a"] == "b"

## tests/client/test_redirects.py

def test_invalid_redirect():
    client = httpx.Client(transport=httpx.MockTransport(redirects))
    with pytest.raises(httpx.RemoteProtocolError):
        client.get("http://example.org/invalid_redirect", follow_redirects=True)

def test_redirect_loop():
    client = httpx.Client(transport=httpx.MockTransport(redirects))
    with pytest.raises(httpx.TooManyRedirects):
        client.get("https://example.org/redirect_loop", follow_redirects=True)

## tests/models/test_responses.py

def streaming_body() -> typing.Iterator[bytes]:
    yield b"Hello, "
    yield b"world!"

async def async_streaming_body() -> typing.AsyncIterator[bytes]:
    yield b"Hello, "
    yield b"world!"

def autodetect(content):
    return chardet.detect(content).get("encoding")

## tests/test_api.py

def test_get_invalid_url():
    with pytest.raises(httpx.UnsupportedProtocol):
        httpx.get("invalid://example.org")

## tests/test_config.py

def test_SSLContext_with_get_request(server, cert_pem_file):
    context = httpx.create_ssl_context()
    context.load_verify_locations(cert_pem_file)
    response = httpx.get(server.url, verify=context)
    assert response.status_code == 200

## tests/test_main.py

def splitlines(output: str) -> typing.Iterable[str]:
    return [line.strip() for line in output.splitlines()]

def remove_date_header(lines: typing.Iterable[str]) -> typing.Iterable[str]:
    return [line for line in lines if not line.startswith("date:")]

## tests/test_wsgi.py

def test_wsgi_http_error():
    transport = httpx.WSGITransport(app=partial(raise_exc, exc=RuntimeError))
    client = httpx.Client(transport=transport)
    with pytest.raises(RuntimeError):
        client.get("http://www.example.org/")
