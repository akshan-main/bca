FILE: pydantic_ai_slim/pydantic_ai/retries.py
SEARCH:
    if isinstance(exc, HTTPStatusError):
        retry_after = exc.response.headers.get('retry-after')
        if retry_after:
            try:
                # Try parsing as seconds first
                wait_seconds = int(retry_after)
                return min(float(wait_seconds), max_wait)
            except ValueError:
                # Try parsing as HTTP date
                try:
                    retry_time = cast(datetime, parsedate_to_datetime(retry_after))
                    assert isinstance(retry_time, datetime)
                    now = datetime.now(timezone.utc)
                    wait_seconds = (retry_time - now).total_seconds()

                    if wait_seconds > 0:
                        return min(wait_seconds, max_wait)
                except (ValueError, TypeError, AssertionError):
                    # If date parsing fails, fall back to fallback strategy
                    pass
REPLACE:
    if isinstance(exc, HTTPStatusError):
        retry_after = exc.response.headers.get('retry-after')
        if retry_after:
            try:
                # Try parsing as seconds first
                wait_seconds = int(retry_after)
                return min(float(wait_seconds), max_wait)
            except ValueError:
                # Try parsing as HTTP date
                try:
                    retry_time = cast(datetime, parsedate_to_datetime(retry_after))
                    assert isinstance(retry_time, datetime)
                    now = datetime.now(timezone.utc)
                    wait_seconds = (retry_time - now).total_seconds()

                    if wait_seconds >= 0:  # Changed from > 0 to >= 0
                        return min(wait_seconds, max_wait)
                except (ValueError, TypeError, AssertionError):
                    # If date parsing fails, fall back to fallback strategy
                    pass
