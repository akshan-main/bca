```
FILE: pydantic_graph/pydantic_graph/beta/graph_builder.py
SEARCH:
        # Check 1: Check if there are edges from the start node
        start_edges = edges_by_source.get(StartNode.id, [])
        if not start_edges:
            raise GraphValidationError('The graph has no edges from the start node.' + how_to_suppress)

        # Check 2: Check if there are edges to the end node
        if EndNode.id not in all_destinations:
            raise GraphValidationError('The graph has no edges to the end node.' + how_to_suppress)

        # Check 3: Find all nodes with no outgoing edges (dead ends)
        dead_end_nodes: list[NodeID] = []
        for node_id, node in nodes.items():
            # Skip the end node itself
            if isinstance(node, EndNode):
                continue

            # Check if this node has any outgoing edges
            has_edges = node_id in edges_by_source and len(edges_by_source[node_id]) > 0

            # Also check if it's a decision node with branches
            if isinstance(node, Decision):
                has_edges = has_edges or len(node.branches) > 0

            if not has_edges:
                dead_end_nodes.append(node_id)

        if dead_end_nodes:
            raise GraphValidationError(f'The following nodes have no outgoing edges: {dead_end_nodes}.' + how_to_suppress)

        # Checks 4 and 5: Ensure all nodes (and in particular, the end node) are reachable from the start node
        reachable: set[NodeID] = {StartNode.id}
        to_visit = [StartNode.id]

        while to_visit:
            current_id = to_visit.pop()

            # Add destinations from regular edges
            for path in edges_by_source.get(current_id, []):
                for item in path.items:
                    if isinstance(item, DestinationMarker):
                        if item.destination_id not in reachable:
                            reachable.add(item.destination_id)
                            to_visit.append(item.destination_id)

            # Add destinations from decision branches
            current_node = nodes.get(current_id)
            if isinstance(current_node, Decision):
                for branch in current_node.branches:
                    for item in branch.path.items:
                        if isinstance(item, DestinationMarker):
                            if item.destination_id not in reachable:
                                reachable.add(item.destination_id)
                                to_visit.append(item.destination_id)

        unreachable_nodes = [node_id for node_id in nodes if node_id not in reachable]
        if unreachable_nodes:
            raise GraphValidationError(
                f'The following nodes are not reachable from the start node: {unreachable_nodes}.' + how_to_suppress
            )
REPLACE:
        # Check 1: Check if there are edges from the start node
        start_edges = edges_by_source.get(StartNode.id, [])
        if not start_edges:
            raise GraphValidationError('The graph has no edges from the start node.' + how_to_suppress)

        # Check 2: Check if there are edges to the end node
        if EndNode.id not in all_destinations:
            raise GraphValidationError('The graph has no edges to the end node.' + how_to_suppress)

        # Check 3: Find all nodes with no outgoing edges (dead ends)
        dead_end_nodes: list[NodeID] = []
        for node_id, node in nodes.items():
            # Skip the end node itself
            if isinstance(node, EndNode):
                continue

            # Check if this node has any outgoing edges
            has_edges = node_id in edges_by_source and len(edges_by_source[node_id]) == 0

            # Also check if it's a decision node with branches
            if isinstance(node, Decision):
                has_edges = has_edges and len(node.branches) == 0

            if has_edges:
                dead_end_nodes.append(node_id)

        if dead_end_nodes:
            raise GraphValidationError(f'The following nodes have no outgoing edges: {dead_end_nodes}.' + how_to_suppress)

        # Checks 4 and 5: Ensure all nodes (and in particular, the end node) are reachable from the start node
        reachable: set[NodeID] = {StartNode.id}
        to_visit = [StartNode.id]

        while to_visit:
            current_id = to_visit.pop()

            # Add destinations from regular edges
            for path in edges_by_source.get(current_id, []):
                for item in path.items:
                    if isinstance(item, DestinationMarker):
                        if item.destination_id not in reachable:
                            reachable.add(item.destination_id)
                            to_visit.append(item.destination_id)

            # Add destinations from decision branches
            current_node = nodes.get(current_id)
            if isinstance(current_node, Decision):
                for branch in current_node.branches:
                    for item in branch.path.items:
                        if isinstance(item, DestinationMarker):
                            if item.destination_id not in reachable:
                                reachable.add(item.destination_id)
                                to_visit.append(item.destination_id)

        unreachable_nodes = [node_id for node_id in nodes if node_id not in reachable]
        if unreachable_nodes:
            raise GraphValidationError(
                f'The following nodes are not reachable from the start node: {unreachable_nodes}.' + how_to_suppress
            )
```