# pydantic_ai_slim/pydantic_ai/usage.py:200-200
    details: dict[str, int] = dataclasses.field(default_factory=dict[str, int])

# pydantic_ai_slim/pydantic_ai/usage.py:46-50
    details: Annotated[
        dict[str, int],
        # `details` can not be `None` any longer, but we still want to support deserializing model responses stored in a DB before this was changed
        BeforeValidator(lambda d: d or {}),
    ] = dataclasses.field(default_factory=dict[str, int])

# tests/models/test_mistral.py:82-83
    def get_server_details(self) -> tuple[str, ...]:
        return ('https://api.mistral.ai',)

# pydantic_ai_slim/pydantic_ai/models/gemini.py:450-450
    api_key: str

# tests/providers/test_together.py:39-48
def test_together_provider_need_api_key(env: TestEnv) -> None:
    env.remove('TOGETHER_API_KEY')
    with pytest.raises(
        UserError,
        match=re.escape(
            'Set the `TOGETHER_API_KEY` environment variable or pass it via `TogetherProvider(api_key=...)`'
            'to use the Together AI provider.'
        ),
    ):
        TogetherProvider()

# examples/pydantic_ai_examples/slack_lead_qualifier/slack.py:8-8
API_KEY = os.getenv('SLACK_API_KEY')

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:443-443
    cost_details: _OpenRouterCostDetails | None = None

# tests/conftest.py:435-436
def co_api_key() -> str:
    return os.getenv('CO_API_KEY', 'mock-api-key')

# tests/conftest.py:470-471
def xai_api_key() -> str:
    return os.getenv('XAI_API_KEY', 'mock-api-key')

# tests/models/mock_xai.py:65-65
    api_key: str = 'test-api-key'

# tests/test_agent.py:15-15
from pydantic_core import ErrorDetails, to_json

# tests/test_agent.py:15-15
from pydantic_core import ErrorDetails, to_json

# tests/test_agent.py:15-15
from pydantic_core import ErrorDetails, to_json

# tests/conftest.py:425-426
def groq_api_key() -> str:
    return os.getenv('GROQ_API_KEY', 'mock-api-key')

# pydantic_evals/pydantic_evals/otel/span_tree.py:113-114
    def node_key(self) -> str:
        return f'{self.trace_id:032x}:{self.span_id:016x}'

# tests/conftest.py:415-416
def openai_api_key() -> str:
    return os.getenv('OPENAI_API_KEY', 'mock-api-key')

# tests/conftest.py:420-421
def gemini_api_key() -> str:
    return os.getenv('GEMINI_API_KEY', os.getenv('GOOGLE_API_KEY', 'mock-api-key'))

# tests/conftest.py:440-441
def voyage_api_key() -> str:
    return os.getenv('VOYAGE_API_KEY', 'mock-api-key')

# pydantic_ai_slim/pydantic_ai/models/gemini.py:447-454
class ApiKeyAuth:
    """Authentication using an API key for the `X-Goog-Api-Key` header."""

    api_key: str

    async def headers(self) -> dict[str, str]:
        # https://cloud.google.com/docs/authentication/api-keys-use#using-with-rest
        return {'X-Goog-Api-Key': self.api_key}  # pragma: no cover

# tests/conftest.py:445-446
def mistral_api_key() -> str:
    return os.getenv('MISTRAL_API_KEY', 'mock-api-key')

# tests/providers/test_gateway.py:72-73
def gateway_api_key():
    return os.getenv('PYDANTIC_AI_GATEWAY_API_KEY', 'test-api-key')

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:447-447
    prompt_tokens_details: _OpenRouterPromptTokenDetails | None = None  # type: ignore[reportIncompatibleVariableOverride]

# pydantic_ai_slim/pydantic_ai/messages.py:927-927
error_details_ta = pydantic.TypeAdapter(list[pydantic_core.ErrorDetails], config=pydantic.ConfigDict(defer_build=True))

# examples/pydantic_ai_examples/flight_booking.py:28-35
class FlightDetails(BaseModel):
    """Details of the most suitable flight."""

    flight_number: str
    price: int
    origin: str = Field(description='Three-letter airport code')
    destination: str = Field(description='Three-letter airport code')
    date: datetime.date

# tests/conftest.py:410-411
def deepseek_api_key() -> str:
    return os.getenv('DEEPSEEK_API_KEY', 'mock-api-key')

# tests/conftest.py:465-466
def cerebras_api_key() -> str:
    return os.getenv('CEREBRAS_API_KEY', 'mock-api-key')

# tests/providers/test_google_gla.py:16-20
def test_api_key_arg(env: TestEnv):
    env.set('GEMINI_API_KEY', 'via-env-var')
    provider = GoogleGLAProvider(api_key='via-arg')
    assert provider.client.headers['x-goog-api-key'] == 'via-arg'
    assert provider.client.base_url == 'https://generativelanguage.googleapis.com/v1beta/models/'

# tests/test_format_as_xml.py:606-608
def test_invalid_key():
    with pytest.raises(TypeError, match='Unsupported key type for XML formatting'):
        format_as_xml({(1, 2): 42})

# pydantic_ai_slim/pydantic_ai/models/gemini.py:902-904
    cache_tokens_details: NotRequired[
        Annotated[list[_GeminiModalityTokenCount], pydantic.Field(alias='cacheTokensDetails')]
    ]

# tests/conftest.py:430-431
def anthropic_api_key() -> str:
    return os.getenv('ANTHROPIC_API_KEY', 'mock-api-key')

# pydantic_ai_slim/pydantic_ai/models/gemini.py:899-901
    prompt_tokens_details: NotRequired[
        Annotated[list[_GeminiModalityTokenCount], pydantic.Field(alias='promptTokensDetails')]
    ]

# tests/conftest.py:450-451
def openrouter_api_key() -> str:
    return os.getenv('OPENROUTER_API_KEY', 'mock-api-key')

# tests/providers/test_google_gla.py:40-48
def test_api_key_empty(env: TestEnv):
    env.set('GEMINI_API_KEY', '')
    with pytest.raises(
        UserError,
        match=re.escape(
            'Set the `GEMINI_API_KEY` environment variable or pass it via `GoogleGLAProvider(api_key=...)`'
        ),
    ):
        GoogleGLAProvider()

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:449-449
    completion_tokens_details: _OpenRouterCompletionTokenDetails | None = None  # type: ignore[reportIncompatibleVariableOverride]

# tests/conftest.py:455-456
def huggingface_api_key() -> str:
    return os.getenv('HF_TOKEN', 'hf_token')

# pydantic_ai_slim/pydantic_ai/_parts_manager.py:21-34
from pydantic_ai.messages import (
    BuiltinToolCallPart,
    ModelResponsePart,
    ModelResponseStreamEvent,
    PartDeltaEvent,
    PartStartEvent,
    ProviderDetailsDelta,
    TextPart,
    TextPartDelta,
    ThinkingPart,
    ThinkingPartDelta,
    ToolCallPart,
    ToolCallPartDelta,
)

# pydantic_ai_slim/pydantic_ai/_parts_manager.py:21-34
from pydantic_ai.messages import (
    BuiltinToolCallPart,
    ModelResponsePart,
    ModelResponseStreamEvent,
    PartDeltaEvent,
    PartStartEvent,
    ProviderDetailsDelta,
    TextPart,
    TextPartDelta,
    ThinkingPart,
    ThinkingPartDelta,
    ToolCallPart,
    ToolCallPartDelta,
)

# pydantic_ai_slim/pydantic_ai/_parts_manager.py:21-34
from pydantic_ai.messages import (
    BuiltinToolCallPart,
    ModelResponsePart,
    ModelResponseStreamEvent,
    PartDeltaEvent,
    PartStartEvent,
    ProviderDetailsDelta,
    TextPart,
    TextPartDelta,
    ThinkingPart,
    ThinkingPartDelta,
    ToolCallPart,
    ToolCallPartDelta,
)

# pydantic_evals/pydantic_evals/otel/span_tree.py:117-118
    def parent_node_key(self) -> str | None:
        return None if self.parent_span_id is None else f'{self.trace_id:032x}:{self.parent_span_id:016x}'

# pydantic_ai_slim/pydantic_ai/messages.py:1081-1081
    provider_details: dict[str, Any] | None = None

# pydantic_ai_slim/pydantic_ai/messages.py:1171-1171
    provider_details: dict[str, Any] | None = None

# tests/conftest.py:460-461
def heroku_inference_key() -> str:
    return os.getenv('HEROKU_INFERENCE_KEY', 'mock-api-key')

# tests/providers/test_google_gla.py:23-26
def test_api_key_env_var(env: TestEnv):
    env.set('GEMINI_API_KEY', 'via-env-var')
    provider = GoogleGLAProvider()
    assert 'x-goog-api-key' in dict(provider.client.headers)

# tests/providers/test_google_gla.py:29-37
def test_api_key_not_set(env: TestEnv):
    env.remove('GEMINI_API_KEY')
    with pytest.raises(
        UserError,
        match=re.escape(
            'Set the `GEMINI_API_KEY` environment variable or pass it via `GoogleGLAProvider(api_key=...)`'
        ),
    ):
        GoogleGLAProvider()

# pydantic_ai_slim/pydantic_ai/messages.py:1533-1534
    def vendor_details(self) -> dict[str, Any] | None:
        return self.provider_details

# pydantic_ai_slim/pydantic_ai/models/openai.py:2825-2836
def _map_provider_details(
    choice: chat_completion_chunk.Choice | chat_completion.Choice,
) -> dict[str, Any] | None:
    provider_details: dict[str, Any] = {}

    # Add logprobs to vendor_details if available
    if choice.logprobs is not None and choice.logprobs.content:
        provider_details['logprobs'] = _map_logprobs(choice.logprobs.content)
    if raw_finish_reason := choice.finish_reason:
        provider_details['finish_reason'] = raw_finish_reason

    return provider_details or None

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:417-420
class _OpenRouterCostDetails:
    """OpenRouter specific cost details."""

    upstream_inference_cost: float | None = None

# pydantic_ai_slim/pydantic_ai/models/gemini.py:905-907
    candidates_tokens_details: NotRequired[
        Annotated[list[_GeminiModalityTokenCount], pydantic.Field(alias='candidatesTokensDetails')]
    ]

# pydantic_ai_slim/pydantic_ai/ui/vercel_ai/_utils.py:10-10
PROVIDER_METADATA_KEY = 'pydantic_ai'

# pydantic_evals/pydantic_evals/evaluators/report_common.py:91-91
    score_key: str

# pydantic_ai_slim/pydantic_ai/messages.py:1133-1133
    provider_details: dict[str, Any] | None = None

# pydantic_ai_slim/pydantic_ai/messages.py:1327-1331
    provider_details: Annotated[
        dict[str, Any] | None,
        # `vendor_details` is deprecated, but we still want to support deserializing model responses stored in a DB before the name was changed
        pydantic.Field(validation_alias=pydantic.AliasChoices('provider_details', 'vendor_details')),
    ] = None

# pydantic_ai_slim/pydantic_ai/messages.py:1573-1573
    provider_details: dict[str, Any] | None = None

# tests/models/test_openrouter.py:347-378
async def test_openrouter_with_provider_details_but_no_parent_details(openrouter_api_key: str) -> None:
    from typing import Any

    class TestOpenRouterModel(OpenRouterModel):
        def _process_provider_details(self, response: ChatCompletion) -> dict[str, Any] | None:
            from pydantic_ai.models.openrouter import (
                _map_openrouter_provider_details,  # pyright: ignore[reportPrivateUsage]
                _OpenRouterChatCompletion,  # pyright: ignore[reportPrivateUsage]
            )

            assert isinstance(response, _OpenRouterChatCompletion)
            openrouter_details = _map_openrouter_provider_details(response)
            return openrouter_details or None

    provider = OpenRouterProvider(api_key=openrouter_api_key)
    model = TestOpenRouterModel('google/gemini-2.0-flash-exp:free', provider=provider)

    choice = Choice.model_construct(
        index=0, message={'role': 'assistant', 'content': 'test'}, finish_reason='stop', native_finish_reason='stop'
    )
    response = ChatCompletion.model_construct(
        id='test', choices=[choice], created=1704067200, object='chat.completion', model='test', provider='TestProvider'
    )
    result = model._process_response(response)  # type: ignore[reportPrivateUsage]

    assert result.provider_details == snapshot(
        {
            'downstream_provider': 'TestProvider',
            'finish_reason': 'stop',
            'timestamp': datetime.datetime(2024, 1, 1, 0, 0, tzinfo=datetime.timezone.utc),
        }
    )

# pydantic_evals/pydantic_evals/otel/span_tree.py:44-44
    has_attribute_keys: list[str]

# pydantic_ai_slim/pydantic_ai/embeddings/result.py:79-79
    provider_details: dict[str, Any] | None = None

# pydantic_evals/pydantic_evals/evaluators/spec.py:124-142
    def enforce_one_key(cls, value: str | dict[str, Any]) -> Any:
        """Enforce that the root value has exactly one key (the evaluator name) when it is a dict.

        Args:
            value: The value to validate.

        Returns:
            The validated value.

        Raises:
            ValueError: If the value is a dict with multiple keys.
        """
        if isinstance(value, str):
            return value
        if len(value) != 1:
            raise ValueError(
                f'Expected a single key containing the Evaluator class name, found keys {list(value.keys())}'
            )
        return value

# pydantic_ai_slim/pydantic_ai/messages.py:1223-1223
    provider_details: dict[str, Any] | None = None

# pydantic_ai_slim/pydantic_ai/models/__init__.py:928-928
    provider_details: dict[str, Any] | None = field(default=None, init=False)

# pydantic_ai_slim/pydantic_ai/messages.py:1628-1628
    provider_details: ProviderDetailsDelta = None

# pydantic_ai_slim/pydantic_ai/messages.py:1743-1743
    provider_details: dict[str, Any] | None = None

# pydantic_evals/pydantic_evals/evaluators/report_common.py:32-32
    expected_key: str | None = None

# pydantic_evals/pydantic_evals/evaluators/report_common.py:93-93
    positive_key: str | None = None

# pydantic_ai_slim/pydantic_ai/profiles/openai.py:179-192
_STRICT_INCOMPATIBLE_KEYS = [
    'minLength',
    'maxLength',
    'patternProperties',
    'unevaluatedProperties',
    'propertyNames',
    'minProperties',
    'maxProperties',
    'unevaluatedItems',
    'contains',
    'minContains',
    'maxContains',
    'uniqueItems',
]

# tests/providers/test_litellm.py:25-28
def test_init_without_api_key():
    provider = LiteLLMProvider()
    assert provider.name == 'litellm'
    assert provider.client.api_key == 'litellm-placeholder'

# pydantic_ai_slim/pydantic_ai/models/gemini.py:908-910
    tool_use_prompt_tokens_details: NotRequired[
        Annotated[list[_GeminiModalityTokenCount], pydantic.Field(alias='toolUsePromptTokensDetails')]
    ]

# pydantic_evals/pydantic_evals/evaluators/report_common.py:29-29
    predicted_key: str | None = None

# pydantic_ai_slim/pydantic_ai/messages.py:917-917
    provider_details: dict[str, Any] | None = None

# pydantic_ai_slim/pydantic_ai/tools.py:491-491
    outer_typed_dict_key: str | None = None

# tests/test_usage_limits.py:258-284
def test_add_usages_with_none_detail_value():
    """Test that None values in details are skipped when incrementing usage."""
    usage = RunUsage(
        requests=1,
        input_tokens=10,
        output_tokens=20,
        details={'reasoning_tokens': 5},
    )

    # Create a usage with None in details (simulating model response with missing detail)
    incr_usage = RunUsage(
        requests=1,
        input_tokens=5,
        output_tokens=10,
    )
    # Manually set a None value in details to simulate edge case from model responses
    incr_usage.details = {'reasoning_tokens': None, 'other_tokens': 10}  # type: ignore[dict-item]

    result = usage + incr_usage
    assert result == snapshot(
        RunUsage(
            requests=2,
            input_tokens=15,
            output_tokens=30,
            details={'reasoning_tokens': 5, 'other_tokens': 10},
        )
    )

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:613-613
    reasoning_details: list[_OpenRouterReasoningDetail] | None = None

# tests/providers/test_alibaba_provider.py:26-29
def test_alibaba_provider_env_key(env: TestEnv):
    env.set('ALIBABA_API_KEY', 'env-key')
    provider = AlibabaProvider()
    assert provider.client.api_key == 'env-key'

# examples/pydantic_ai_examples/flight_booking.py:70-75
async def extract_flights(ctx: RunContext[Deps]) -> list[FlightDetails]:
    """Get details of all flights."""
    # we pass the usage to the search agent so requests within this agent are counted
    result = await extraction_agent.run(ctx.deps.web_page_text, usage=ctx.usage)
    logfire.info('found {flight_count} flights', flight_count=len(result.output))
    return result.output

# tests/providers/test_xai.py:24-33
def test_xai_provider_need_api_key(env: TestEnv) -> None:
    env.remove('XAI_API_KEY')
    with pytest.raises(
        UserError,
        match=re.escape(
            'Set the `XAI_API_KEY` environment variable or pass it via `XaiProvider(api_key=...)`'
            'to use the xAI provider.'
        ),
    ):
        XaiProvider()

# tests/graph/beta/test_joins_and_reducers.py:235-261
async def test_reduce_dict_update_with_overlapping_keys():
    """Test that reduce_dict_update properly handles overlapping keys (later values win)."""
    g = GraphBuilder(state_type=SimpleState, output_type=dict[str, int])

    @g.step
    async def generate(ctx: StepContext[SimpleState, None, None]) -> list[int]:
        return [1, 2, 3]

    @g.step
    async def create_dict(ctx: StepContext[SimpleState, None, int]) -> dict[str, int]:
        # All create the same key
        return {'key': ctx.inputs}

    dict_join = g.join(reduce_dict_update, initial_factory=dict[str, int])

    g.add(
        g.edge_from(g.start_node).to(generate),
        g.edge_from(generate).map().to(create_dict),
        g.edge_from(create_dict).to(dict_join),
        g.edge_from(dict_join).to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=SimpleState())
    # One of the values should win (1, 2, or 3)
    assert 'key' in result
    assert result['key'] in [1, 2, 3]

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:390-390
    reasoning_details: list[_OpenRouterReasoningDetail] | None = None

# pydantic_ai_slim/pydantic_ai/_output.py:533-533
    outer_typed_dict_key: str | None = None

# tests/providers/test_grok.py:35-44
def test_grok_provider_need_api_key(env: TestEnv) -> None:
    env.remove('GROK_API_KEY')
    with pytest.raises(
        UserError,
        match=re.escape(
            'Set the `GROK_API_KEY` environment variable or pass it via `GrokProvider(api_key=...)`'
            'to use the Grok provider.'
        ),
    ):
        GrokProvider()

# tests/providers/test_groq.py:39-48
def test_groq_provider_need_api_key(env: TestEnv) -> None:
    env.remove('GROQ_API_KEY')
    with pytest.raises(
        UserError,
        match=re.escape(
            'Set the `GROQ_API_KEY` environment variable or pass it via `GroqProvider(api_key=...)`'
            'to use the Groq provider.'
        ),
    ):
        GroqProvider()

# tests/providers/test_sambanova_provider.py:26-29
def test_sambanova_provider_env_key(env: TestEnv):
    env.set('SAMBANOVA_API_KEY', 'env-key')
    provider = SambaNovaProvider()
    assert provider.client.api_key == 'env-key'

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:468-487
def _map_openrouter_provider_details(
    response: _OpenRouterChatCompletion | _OpenRouterChatCompletionChunk,
) -> dict[str, Any]:
    provider_details: dict[str, Any] = {}

    provider_details['downstream_provider'] = response.provider
    if native_finish_reason := response.choices[0].native_finish_reason:
        provider_details['finish_reason'] = native_finish_reason

    if usage := response.usage:
        if cost := usage.cost:
            provider_details['cost'] = cost

        if cost_details := usage.cost_details:
            provider_details['upstream_inference_cost'] = cost_details.upstream_inference_cost

        if (is_byok := usage.is_byok) is not None:
            provider_details['is_byok'] = is_byok

    return provider_details

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:569-574
    def _process_provider_details(self, response: chat.ChatCompletion) -> dict[str, Any] | None:
        assert isinstance(response, _OpenRouterChatCompletion)

        provider_details = super()._process_provider_details(response) or {}
        provider_details.update(_map_openrouter_provider_details(response))
        return provider_details or None

# tests/providers/test_alibaba_provider.py:47-51
def test_alibaba_provider_missing_key(env: TestEnv):
    env.remove('ALIBABA_API_KEY')
    env.remove('DASHSCOPE_API_KEY')
    with pytest.raises(UserError, match='Set the `ALIBABA_API_KEY`'):
        AlibabaProvider()

# tests/providers/test_cohere.py:28-31
def test_cohere_provider_need_api_key(env: TestEnv) -> None:
    env.remove('CO_API_KEY')
    with pytest.raises(UserError, match='CO_API_KEY'):
        CohereProvider()

# tests/providers/test_github.py:34-43
def test_github_provider_need_api_key(env: TestEnv) -> None:
    env.remove('GITHUB_API_KEY')
    with pytest.raises(
        UserError,
        match=re.escape(
            'Set the `GITHUB_API_KEY` environment variable or pass it via `GitHubProvider(api_key=...)`'
            ' to use the GitHub Models provider.'
        ),
    ):
        GitHubProvider()

# tests/providers/test_heroku.py:34-43
def test_heroku_provider_need_api_key(env: TestEnv) -> None:
    env.remove('HEROKU_INFERENCE_KEY')
    with pytest.raises(
        UserError,
        match=re.escape(
            'Set the `HEROKU_INFERENCE_KEY` environment variable or pass it via `HerokuProvider(api_key=...)`'
            'to use the Heroku provider.'
        ),
    ):
        HerokuProvider()

# examples/pydantic_ai_examples/flight_booking.py:35-35
    date: datetime.date