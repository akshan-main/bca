# tests/models/test_gemini_vertex.py:6-6
from inline_snapshot import Is, snapshot

# tests/models/test_google.py:16-16
from inline_snapshot import Is, snapshot

# pydantic_ai_slim/pydantic_ai/_utils.py:305-372
class PeekableAsyncStream(Generic[T]):
    """Wraps an async iterable of type T and allows peeking at the *next* item without consuming it.

    We only buffer one item at a time (the next item). Once that item is yielded, it is discarded.
    This is a single-pass stream.
    """

    def __init__(self, source: AsyncIterable[T]):
        self._source = source
        self._source_iter: AsyncIterator[T] | None = None
        self._buffer: T | Unset = UNSET
        self._exhausted = False

    async def peek(self) -> T | Unset:
        """Returns the next item that would be yielded without consuming it.

        Returns None if the stream is exhausted.
        """
        if self._exhausted:
            return UNSET

        # If we already have a buffered item, just return it.
        if not isinstance(self._buffer, Unset):
            return self._buffer

        # Otherwise, we need to fetch the next item from the underlying iterator.
        if self._source_iter is None:
            self._source_iter = aiter(self._source)

        try:
            self._buffer = await anext(self._source_iter)
        except StopAsyncIteration:
            self._exhausted = True
            return UNSET

        return self._buffer

    async def is_exhausted(self) -> bool:
        """Returns True if the stream is exhausted, False otherwise."""
        return isinstance(await self.peek(), Unset)

    def __aiter__(self) -> AsyncIterator[T]:
        # For a single-pass iteration, we can return self as the iterator.
        return self

    async def __anext__(self) -> T:
        """Yields the buffered item if present, otherwise fetches the next item from the underlying source.

        Raises StopAsyncIteration if the stream is exhausted.
        """
        if self._exhausted:
            raise StopAsyncIteration

        # If we have a buffered item, yield it.
        if not isinstance(self._buffer, Unset):
            item = self._buffer
            self._buffer = UNSET
            return item

        # Otherwise, fetch the next item from the source.
        if self._source_iter is None:
            self._source_iter = aiter(self._source)

        try:
            return await anext(self._source_iter)
        except StopAsyncIteration:
            self._exhausted = True
            raise

# examples/pydantic_ai_examples/question_graph.py:17-22
from pydantic_graph import (
    BaseNode,
    End,
    Graph,
    GraphRunContext,
)

# pydantic_ai_slim/pydantic_ai/_agent_graph.py:26-26
from pydantic_graph.nodes import End, NodeRunEndT

# pydantic_ai_slim/pydantic_ai/agent/abstract.py:15-15
from pydantic_graph import End

# pydantic_ai_slim/pydantic_ai/run.py:9-9
from pydantic_graph import BaseNode, End, GraphRunContext

# pydantic_graph/pydantic_graph/__init__.py:3-3
from .nodes import BaseNode, Edge, End, GraphRunContext

# pydantic_graph/pydantic_graph/beta/graph.py:43-43
from pydantic_graph.nodes import BaseNode, End

# pydantic_graph/pydantic_graph/beta/graph_builder.py:50-50
from pydantic_graph.nodes import BaseNode, End

# pydantic_graph/pydantic_graph/beta/join.py:18-18
from pydantic_graph import BaseNode, End, GraphRunContext

# pydantic_graph/pydantic_graph/beta/step.py:17-17
from pydantic_graph.nodes import BaseNode, End, GraphRunContext

# pydantic_graph/pydantic_graph/graph.py:17-17
from .nodes import BaseNode, DepsT, End, GraphRunContext, NodeDef, RunEndT, StateT

# pydantic_graph/pydantic_graph/persistence/__init__.py:12-12
from ..nodes import BaseNode, End

# pydantic_graph/pydantic_graph/persistence/file.py:15-15
from ..nodes import BaseNode, End

# pydantic_graph/pydantic_graph/persistence/in_mem.py:18-18
from ..nodes import BaseNode, End

# tests/graph/beta/test_decisions.py:10-10
from pydantic_graph import BaseNode, End, GraphRunContext

# tests/graph/beta/test_v1_v2_integration.py:11-11
from pydantic_graph import BaseNode, End, GraphRunContext

# tests/graph/test_file_persistence.py:11-18
from pydantic_graph import (
    BaseNode,
    End,
    EndSnapshot,
    Graph,
    GraphRunContext,
    NodeSnapshot,
)

# tests/graph/test_graph.py:13-24
from pydantic_graph import (
    BaseNode,
    End,
    EndSnapshot,
    FullStatePersistence,
    Graph,
    GraphRunContext,
    GraphRuntimeError,
    GraphSetupError,
    NodeSnapshot,
    SimpleStatePersistence,
)

# tests/graph/test_mermaid.py:14-24
from pydantic_graph import (
    BaseNode,
    Edge,
    End,
    EndSnapshot,
    FullStatePersistence,
    Graph,
    GraphRunContext,
    GraphSetupError,
    NodeSnapshot,
)

# tests/graph/test_persistence.py:13-22
from pydantic_graph import (
    BaseNode,
    End,
    EndSnapshot,
    FullStatePersistence,
    Graph,
    GraphRunContext,
    NodeSnapshot,
    SimpleStatePersistence,
)

# tests/graph/test_state.py:9-17
from pydantic_graph import (
    BaseNode,
    End,
    EndSnapshot,
    FullStatePersistence,
    Graph,
    GraphRunContext,
    NodeSnapshot,
)

# tests/test_streaming.py:57-57
from pydantic_graph import End

# tests/typed_graph.py:8-8
from pydantic_graph import BaseNode, End, FullStatePersistence, Graph, GraphRunContext

# pydantic_graph/pydantic_graph/nodes.py:144-167
class End(Generic[RunEndT]):
    """Type to return from a node to signal the end of the graph."""

    data: RunEndT
    """Data to return from the graph."""

    def deep_copy_data(self) -> End[RunEndT]:
        """Returns a deep copy of the end of the run."""
        if self.data is None:
            return self
        else:
            end = End(copy.deepcopy(self.data))
            end.set_snapshot_id(self.get_snapshot_id())
            return end

    def get_snapshot_id(self) -> str:
        if snapshot_id := getattr(self, '__snapshot_id', None):
            return snapshot_id
        else:
            self.__dict__['__snapshot_id'] = snapshot_id = generate_snapshot_id('end')
            return snapshot_id

    def set_snapshot_id(self, set_id: str) -> None:
        self.__dict__['__snapshot_id'] = set_id

# pydantic_ai_slim/pydantic_ai/_utils.py:350-372
    async def __anext__(self) -> T:
        """Yields the buffered item if present, otherwise fetches the next item from the underlying source.

        Raises StopAsyncIteration if the stream is exhausted.
        """
        if self._exhausted:
            raise StopAsyncIteration

        # If we have a buffered item, yield it.
        if not isinstance(self._buffer, Unset):
            item = self._buffer
            self._buffer = UNSET
            return item

        # Otherwise, fetch the next item from the source.
        if self._source_iter is None:
            self._source_iter = aiter(self._source)

        try:
            return await anext(self._source_iter)
        except StopAsyncIteration:
            self._exhausted = True
            raise

# pydantic_ai_slim/pydantic_ai/agent/abstract.py:1227-1234
    def is_end_node(
        node: _agent_graph.AgentNode[T, S] | End[result.FinalResult[S]],
    ) -> TypeIs[End[result.FinalResult[S]]]:
        """Check if the node is a `End`, narrowing the type if it is.

        This method preserves the generic parameters while narrowing the type, unlike a direct call to `isinstance`.
        """
        return isinstance(node, End)

# tests/models/test_anthropic.py:142-142
    stream: Sequence[MockRawMessageStreamEvent] | Sequence[Sequence[MockRawMessageStreamEvent]] | None = None

# tests/models/mock_openai.py:31-31
    stream: Sequence[MockChatCompletionChunk] | Sequence[Sequence[MockChatCompletionChunk]] | None = None

# tests/models/mock_openai.py:101-101
    stream: Sequence[MockResponseStreamEvent] | Sequence[Sequence[MockResponseStreamEvent]] | None = None