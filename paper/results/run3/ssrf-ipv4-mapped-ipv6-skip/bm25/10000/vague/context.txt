# pydantic_ai_slim/pydantic_ai/_ssrf.py:82-97
def is_private_ip(ip_str: str) -> bool:
    """Check if an IP address is in a private/internal range.

    Handles both IPv4 and IPv6 addresses, including IPv4-mapped IPv6 addresses.
    """
    try:
        ip = ipaddress.ip_address(ip_str)

        # Handle IPv4-mapped IPv6 addresses (e.g., ::ffff:192.168.1.1)
        if isinstance(ip, ipaddress.IPv6Address) and not ip.ipv4_mapped:
            ip = ip.ipv4_mapped

        return any(ip in network for network in _PRIVATE_NETWORKS)
    except ValueError:
        # Invalid IP address, treat as potentially dangerous
        return True

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# tests/mcp_server.py:7-17
from mcp.types import (
    Annotations,
    BlobResourceContents,
    CreateMessageResult,
    EmbeddedResource,
    ResourceLink,
    SamplingMessage,
    TextContent,
    TextResourceContents,
    ToolAnnotations,
)

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# tests/mcp_server.py:7-17
from mcp.types import (
    Annotations,
    BlobResourceContents,
    CreateMessageResult,
    EmbeddedResource,
    ResourceLink,
    SamplingMessage,
    TextContent,
    TextResourceContents,
    ToolAnnotations,
)

# tests/test_ssrf.py:99-100
    def test_ipv4_mapped_ipv6_private(self, ip: str) -> None:
        assert is_private_ip(ip) is True

# pydantic_ai_slim/pydantic_ai/mcp.py:143-143
    annotations: ResourceAnnotations | None = None

# pydantic_ai_slim/pydantic_ai/mcp.py:103-124
class ResourceAnnotations:
    """Additional properties describing MCP entities.

    See the [resource annotations in the MCP specification](https://modelcontextprotocol.io/specification/2025-06-18/server/resources#annotations).
    """

    audience: list[mcp_types.Role] | None = None
    """Intended audience for this entity."""

    priority: Annotated[float, Field(ge=0.0, le=1.0)] | None = None
    """Priority level for this entity, ranging from 0.0 to 1.0."""

    __repr__ = _utils.dataclasses_no_defaults_repr

    @classmethod
    def from_mcp_sdk(cls, mcp_annotations: mcp_types.Annotations) -> ResourceAnnotations:
        """Convert from MCP SDK Annotations to ResourceAnnotations.

        Args:
            mcp_annotations: The MCP SDK annotations object.
        """
        return cls(audience=mcp_annotations.audience, priority=mcp_annotations.priority)

# pydantic_ai_slim/pydantic_ai/mcp.py:118-124
    def from_mcp_sdk(cls, mcp_annotations: mcp_types.Annotations) -> ResourceAnnotations:
        """Convert from MCP SDK Annotations to ResourceAnnotations.

        Args:
            mcp_annotations: The MCP SDK annotations object.
        """
        return cls(audience=mcp_annotations.audience, priority=mcp_annotations.priority)

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:360-360
_OpenRouterAnnotation: TypeAlias = _OpenAIAnnotation | _OpenRouterFileAnnotation

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:616-616
    annotations: list[_OpenRouterAnnotation] | None = None

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:396-396
    annotations: list[_OpenRouterAnnotation] | None = None  # type: ignore[reportIncompatibleVariableOverride]

# tests/test_function_schema.py:171-178
def test_function_no_annotations():
    """Test function with no type annotations."""

    def func_no_annotations(ctx, x):  # type: ignore
        ...  # pragma: no cover

    # Without annotations, _takes_ctx should return False
    assert _takes_ctx(func_no_annotations) is False  # type: ignore

# tests/test_function_schema.py:181-186
def test_function_wrong_annotation_type():
    """Test function with wrong annotation type for first parameter."""

    def func_wrong_annotation(ctx: str, x: int) -> str: ...  # pragma: no cover

    assert _takes_ctx(func_wrong_annotation) is False

# pydantic_ai_slim/pydantic_ai/models/openai.py:1282-1282
responses_output_text_annotations_ta = TypeAdapter(list[responses.response_output_text.Annotation])

# tests/conftest.py:674-694
def disable_ssrf_protection_for_vcr():
    """Disable SSRF protection for VCR compatibility.

    VCR cassettes record requests with the original hostname. Since SSRF protection
    resolves hostnames to IPs before making requests, we need to disable the validation
    for VCR tests to match the pre-recorded cassettes.

    This fixture patches validate_and_resolve_url to return the hostname in place
    of the resolved IP, allowing the request URL to use the original hostname.
    """
    from unittest.mock import patch

    from pydantic_ai._ssrf import ResolvedUrl, extract_host_and_port

    async def mock_validate_and_resolve(url: str, allow_local: bool) -> ResolvedUrl:
        hostname, path, port, is_https = extract_host_and_port(url)
        # Return hostname in place of resolved IP - this allows VCR matching
        return ResolvedUrl(resolved_ip=hostname, hostname=hostname, port=port, is_https=is_https, path=path)

    with patch('pydantic_ai._ssrf.validate_and_resolve_url', mock_validate_and_resolve):
        yield

# tests/test_ssrf.py:110-111
    def test_ipv4_mapped_ipv6_public(self, ip: str) -> None:
        assert is_private_ip(ip) is False

# pydantic_ai_slim/pydantic_ai/mcp.py:103-124
class ResourceAnnotations:
    """Additional properties describing MCP entities.

    See the [resource annotations in the MCP specification](https://modelcontextprotocol.io/specification/2025-06-18/server/resources#annotations).
    """

    audience: list[mcp_types.Role] | None = None
    """Intended audience for this entity."""

    priority: Annotated[float, Field(ge=0.0, le=1.0)] | None = None
    """Priority level for this entity, ranging from 0.0 to 1.0."""

    __repr__ = _utils.dataclasses_no_defaults_repr

    @classmethod
    def from_mcp_sdk(cls, mcp_annotations: mcp_types.Annotations) -> ResourceAnnotations:
        """Convert from MCP SDK Annotations to ResourceAnnotations.

        Args:
            mcp_annotations: The MCP SDK annotations object.
        """
        return cls(audience=mcp_annotations.audience, priority=mcp_annotations.priority)

# tests/test_ssrf.py:388-392
    async def test_6to4_address_blocked(self) -> None:
        """Test that 6to4 addresses (which can embed private IPv4) are blocked."""
        # 2002:c0a8:0101::1 embeds 192.168.1.1
        with pytest.raises(ValueError, match='Access to private/internal IP address'):
            await validate_and_resolve_url('http://[2002:c0a8:0101::1]/path', allow_local=False)

# tests/test_ssrf.py:461-482
    async def test_redirect_to_private_ip_blocked(self) -> None:
        """Test that redirects to private IPs are blocked."""
        redirect_response = AsyncMock()
        redirect_response.is_redirect = True
        redirect_response.headers = {'location': 'http://internal.local/file.txt'}

        with (
            patch('pydantic_ai._ssrf.run_in_executor') as mock_executor,
            patch('pydantic_ai._ssrf.cached_async_http_client') as mock_client_fn,
        ):
            # First call for example.com (public), second for internal.local (private)
            mock_executor.side_effect = [
                [(2, 1, 6, '', ('93.184.215.14', 0))],
                [(2, 1, 6, '', ('192.168.1.1', 0))],
            ]

            mock_client = AsyncMock()
            mock_client.get.return_value = redirect_response
            mock_client_fn.return_value = mock_client

            with pytest.raises(ValueError, match='Access to private/internal IP address'):
                await safe_download('https://example.com/file.txt')

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:349-357
class _OpenRouterFileAnnotation(BaseModel, frozen=True):
    """File annotation from OpenRouter.

    OpenRouter can return file annotations when processing uploaded files like PDFs.
    The schema is flexible since OpenRouter doesn't document the exact fields.
    """

    type: Literal['file']
    file: dict[str, Any] | None = None

# tests/test_ssrf.py:372-375
    async def test_literal_private_ip_blocked(self) -> None:
        """Test that literal private IPs in URLs are blocked."""
        with pytest.raises(ValueError, match='Access to private/internal IP address'):
            await validate_and_resolve_url('http://192.168.1.1/path', allow_local=False)

# tests/test_ssrf.py:337-342
    async def test_private_ip_blocked_by_default(self) -> None:
        """Test that private IPs are blocked by default."""
        with patch('pydantic_ai._ssrf.run_in_executor') as mock_executor:
            mock_executor.return_value = [(2, 1, 6, '', ('192.168.1.1', 0))]
            with pytest.raises(ValueError, match='Access to private/internal IP address'):
                await validate_and_resolve_url('http://internal.local/path', allow_local=False)

# tests/test_tools.py:892-895
async def tool_without_return_annotation_in_docstring() -> str:  # pragma: no cover
    """A tool that documents what it returns but doesn't have a return annotation in the docstring."""

    return ''

# pydantic_ai_slim/pydantic_ai/models/openai.py:458-458
    openai_include_raw_annotations: bool

# tests/test_ssrf.py:694-703
    async def test_multiple_ips_with_any_private_blocked(self) -> None:
        """Test that if any IP in the resolution is private, request is blocked."""
        with patch('pydantic_ai._ssrf.run_in_executor') as mock_executor:
            # DNS returns multiple IPs, one of which is private
            mock_executor.return_value = [
                (2, 1, 6, '', ('8.8.8.8', 0)),  # Public
                (10, 1, 6, '', ('::1', 0)),  # Private IPv6 loopback
            ]
            with pytest.raises(ValueError, match='Access to private/internal IP address'):
                await validate_and_resolve_url('http://attacker.com/path', allow_local=False)

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:356-356
    type: Literal['file']

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:357-357
    file: dict[str, Any] | None = None

# tests/models/test_openrouter.py:574-596
async def test_openrouter_file_annotation(
    allow_model_requests: None, openrouter_api_key: str, document_content: BinaryContent
) -> None:
    """Test that file annotations from OpenRouter are handled correctly.

    When sending files (e.g., PDFs) to OpenRouter, the response can include
    annotations with type="file". This test ensures those annotations are
    parsed without validation errors.
    """
    provider = OpenRouterProvider(api_key=openrouter_api_key)
    model = OpenRouterModel('openai/gpt-5.1-codex-mini', provider=provider)
    agent = Agent(model)

    result = await agent.run(
        user_prompt=[
            'What does this PDF contain? Answer in one short sentence.',
            document_content,
        ]
    )

    # The response should contain text (model may or may not include file annotations)
    assert isinstance(result.output, str)
    assert len(result.output) > 0

# pydantic_ai_slim/pydantic_ai/mcp.py:109-109
    audience: list[mcp_types.Role] | None = None

# pydantic_ai_slim/pydantic_ai/mcp.py:112-112
    priority: Annotated[float, Field(ge=0.0, le=1.0)] | None = None

# pydantic_ai_slim/pydantic_ai/mcp.py:115-115
    __repr__ = _utils.dataclasses_no_defaults_repr

# tests/models/test_openrouter.py:599-625
async def test_openrouter_file_annotation_validation(openrouter_api_key: str) -> None:
    """Test that file annotations from OpenRouter are correctly validated.

    This unit test verifies that responses containing type="file" annotations
    are parsed without validation errors, which was failing before the fix.
    """
    from openai.types.chat.chat_completion_message import ChatCompletionMessage

    provider = OpenRouterProvider(api_key=openrouter_api_key)
    model = OpenRouterModel('openai/gpt-4.1-mini', provider=provider)

    message = ChatCompletionMessage.model_construct(
        role='assistant',
        content='Here is the summary of your file.',
        annotations=[
            {'type': 'file', 'file': {'filename': 'test.pdf', 'file_id': 'file-123'}},
        ],
    )
    choice = Choice.model_construct(index=0, message=message, finish_reason='stop', native_finish_reason='stop')
    response = ChatCompletion.model_construct(
        id='test', choices=[choice], created=0, object='chat.completion', model='test', provider='test'
    )

    # This should not raise a validation error
    result = model._process_response(response)  # type: ignore[reportPrivateUsage]
    text_part = cast(TextPart, result.parts[0])
    assert text_part.content == 'Here is the summary of your file.'

# pydantic_ai_slim/pydantic_ai/_function_schema.py:300-302
def _is_call_ctx(annotation: Any) -> bool:
    """Return whether the annotation is the `RunContext` class, parameterized or not."""
    return annotation is RunContext or get_origin(annotation) is RunContext

# tests/models/test_openrouter.py:628-653
async def test_openrouter_url_citation_annotation_validation(openrouter_api_key: str) -> None:
    """Test that url_citation annotations from OpenRouter are correctly validated."""
    from openai.types.chat.chat_completion_message import ChatCompletionMessage

    provider = OpenRouterProvider(api_key=openrouter_api_key)
    model = OpenRouterModel('openai/gpt-4.1-mini', provider=provider)

    message = ChatCompletionMessage.model_construct(
        role='assistant',
        content='According to the source, this is the answer.',
        annotations=[
            {
                'type': 'url_citation',
                'url_citation': {'url': 'https://example.com', 'title': 'Example', 'start_index': 0, 'end_index': 10},
            },
        ],
    )
    choice = Choice.model_construct(index=0, message=message, finish_reason='stop', native_finish_reason='stop')
    response = ChatCompletion.model_construct(
        id='test', choices=[choice], created=0, object='chat.completion', model='test', provider='test'
    )

    # This should not raise a validation error
    result = model._process_response(response)  # type: ignore[reportPrivateUsage]
    text_part = cast(TextPart, result.parts[0])
    assert text_part.content == 'According to the source, this is the answer.'

# tests/test_ssrf.py:678-684
    async def test_hostname_resolving_to_private_ip_blocked(self) -> None:
        """Test that a hostname resolving to a private IP is blocked."""
        with patch('pydantic_ai._ssrf.run_in_executor') as mock_executor:
            # Attacker's DNS returns private IP
            mock_executor.return_value = [(2, 1, 6, '', ('127.0.0.1', 0))]
            with pytest.raises(ValueError, match='Access to private/internal IP address'):
                await validate_and_resolve_url('http://attacker.com/path', allow_local=False)

# tests/test_ssrf.py:583-603
    async def test_protocol_relative_redirect_to_private_blocked(self) -> None:
        """Test that protocol-relative redirects to private IPs are blocked."""
        redirect_response = AsyncMock()
        redirect_response.is_redirect = True
        redirect_response.headers = {'location': '//internal.local/file.txt'}

        with (
            patch('pydantic_ai._ssrf.run_in_executor') as mock_executor,
            patch('pydantic_ai._ssrf.cached_async_http_client') as mock_client_fn,
        ):
            mock_executor.side_effect = [
                [(2, 1, 6, '', ('93.184.215.14', 0))],
                [(2, 1, 6, '', ('192.168.1.1', 0))],
            ]

            mock_client = AsyncMock()
            mock_client.get.return_value = redirect_response
            mock_client_fn.return_value = mock_client

            with pytest.raises(ValueError, match='Access to private/internal IP address'):
                await safe_download('https://example.com/file.txt')

# pydantic_graph/pydantic_graph/_utils.py:75-86
def unpack_annotated(tp: Any) -> tuple[Any, list[Any]]:
    """Strip `Annotated` from the type if present.

    Returns:
        `(tp argument, ())` if not annotated, otherwise `(stripped type, annotations)`.
    """
    origin = get_origin(tp)
    if typing_objects.is_annotated(origin):
        inner_tp, *args = get_args(tp)
        return inner_tp, args
    else:
        return tp, []

# pydantic_graph/pydantic_graph/__init__.py:3-3
from .nodes import BaseNode, Edge, End, GraphRunContext

# tests/test_ssrf.py:377-386
    async def test_any_private_ip_blocks_request(self) -> None:
        """Test that if any resolved IP is private, the request is blocked."""
        with patch('pydantic_ai._ssrf.run_in_executor') as mock_executor:
            # Return both public and private IPs
            mock_executor.return_value = [
                (2, 1, 6, '', ('93.184.215.14', 0)),
                (2, 1, 6, '', ('192.168.1.1', 0)),
            ]
            with pytest.raises(ValueError, match='Access to private/internal IP address'):
                await validate_and_resolve_url('http://example.com/path', allow_local=False)

# tests/test_ssrf.py:27-116
class TestIsPrivateIp:
    """Tests for is_private_ip function."""

    @pytest.mark.parametrize(
        'ip',
        [
            # IPv4 loopback
            '127.0.0.1',
            '127.0.0.2',
            '127.255.255.255',
            # IPv4 private class A
            '10.0.0.1',
            '10.255.255.255',
            # IPv4 private class B
            '172.16.0.1',
            '172.31.255.255',
            # IPv4 private class C
            '192.168.0.1',
            '192.168.255.255',
            # IPv4 link-local
            '169.254.0.1',
            '169.254.255.255',
            # IPv4 "this" network
            '0.0.0.0',
            '0.255.255.255',
            # IPv4 CGNAT (RFC 6598)
            '100.64.0.1',
            '100.127.255.255',
            '100.100.100.200',  # Alibaba Cloud metadata
            # IPv6 loopback
            '::1',
            # IPv6 link-local
            'fe80::1',
            'fe80::ffff:ffff:ffff:ffff',
            # IPv6 unique local
            'fc00::1',
            'fdff:ffff:ffff:ffff:ffff:ffff:ffff:ffff',
            # IPv6 6to4 (can embed private IPv4)
            '2002::1',
            '2002:c0a8:0101::1',  # Embeds 192.168.1.1
            '2002:0a00:0001::1',  # Embeds 10.0.0.1
        ],
    )
    def test_private_ips_detected(self, ip: str) -> None:
        assert is_private_ip(ip) is True

    @pytest.mark.parametrize(
        'ip',
        [
            # Public IPv4
            '8.8.8.8',
            '1.1.1.1',
            '203.0.113.50',
            '198.51.100.1',
            # Public IPv6
            '2001:4860:4860::8888',
            '2606:4700:4700::1111',
        ],
    )
    def test_public_ips_allowed(self, ip: str) -> None:
        assert is_private_ip(ip) is False

    @pytest.mark.parametrize(
        'ip',
        [
            # IPv4-mapped IPv6 private addresses
            '::ffff:127.0.0.1',
            '::ffff:10.0.0.1',
            '::ffff:192.168.1.1',
            '::ffff:172.16.0.1',
        ],
    )
    def test_ipv4_mapped_ipv6_private(self, ip: str) -> None:
        assert is_private_ip(ip) is True

    @pytest.mark.parametrize(
        'ip',
        [
            # IPv4-mapped IPv6 public addresses
            '::ffff:8.8.8.8',
            '::ffff:1.1.1.1',
        ],
    )
    def test_ipv4_mapped_ipv6_public(self, ip: str) -> None:
        assert is_private_ip(ip) is False

    def test_invalid_ip_treated_as_private(self) -> None:
        """Invalid IP addresses should be treated as potentially dangerous."""
        assert is_private_ip('not-an-ip') is True
        assert is_private_ip('') is True

# pydantic_ai_slim/pydantic_ai/_ssrf.py:182-204
def build_url_with_ip(resolved: ResolvedUrl) -> str:
    """Build a URL using a resolved IP address instead of the hostname.

    For IPv6 addresses, wraps them in brackets as required by URL syntax.
    """
    scheme = 'https' if resolved.is_https else 'http'
    default_port = 443 if resolved.is_https else 80

    # IPv6 addresses need brackets in URLs
    try:
        ip_obj = ipaddress.ip_address(resolved.resolved_ip)
        if isinstance(ip_obj, ipaddress.IPv6Address):
            host_part = f'[{resolved.resolved_ip}]'
        else:
            host_part = resolved.resolved_ip
    except ValueError:
        host_part = resolved.resolved_ip

    # Only include port if non-default
    if resolved.port != default_port:
        host_part = f'{host_part}:{resolved.port}'

    return urlunparse((scheme, host_part, resolved.path, '', '', ''))

# pydantic_ai_slim/pydantic_ai/models/test.py:42-45
class _WrappedTextOutput:
    """A private wrapper class to tag an output that came from the custom_output_text field."""

    value: str | None

# tests/graph/beta/test_parent_forks.py:33-53
def test_parent_fork_with_cycle():
    """Test parent fork identification when there's a cycle bypassing the fork."""
    join_id = 'J'
    nodes = {'start', 'F', 'A', 'B', 'C', 'J', 'end'}
    start_ids = {'start'}
    fork_ids = {'F'}
    # C creates a cycle back to A, bypassing F
    edges = {
        'start': ['F'],
        'F': ['A', 'B'],
        'A': ['J'],
        'B': ['J'],
        'J': ['C'],
        'C': ['A'],  # Cycle that bypasses F
    }

    finder = ParentForkFinder(nodes, start_ids, fork_ids, edges)
    parent_fork = finder.find_parent_fork(join_id)

    # Should return None because J sits on a cycle avoiding F
    assert parent_fork is None

# tests/test_ssrf.py:256-259
    def test_ipv6_address(self) -> None:
        resolved = ResolvedUrl(resolved_ip='2001:db8::1', hostname='example.com', port=443, is_https=True, path='/path')
        url = build_url_with_ip(resolved)
        assert url == 'https://[2001:db8::1]/path'

# tests/test_ssrf.py:113-116
    def test_invalid_ip_treated_as_private(self) -> None:
        """Invalid IP addresses should be treated as potentially dangerous."""
        assert is_private_ip('not-an-ip') is True
        assert is_private_ip('') is True

# tests/test_ssrf.py:261-266
    def test_ipv6_address_custom_port(self) -> None:
        resolved = ResolvedUrl(
            resolved_ip='2001:db8::1', hostname='example.com', port=8443, is_https=True, path='/path'
        )
        url = build_url_with_ip(resolved)
        assert url == 'https://[2001:db8::1]:8443/path'

# pydantic_evals/pydantic_evals/reporting/render_numbers.py:120-129
def _render_signed(val: float, sig_figs: int) -> str:
    """Format a number with a fixed number of significant figures.

    If the result does not use scientific notation and lacks a decimal point,
    force a '.0' suffix. Always include a leading '+' for nonnegative numbers.
    """
    s = format(abs(val), f',.{sig_figs}g')
    if 'e' not in s and '.' not in s:
        s += '.0'
    return f'{"+" if val >= 0 else "-"}{s}'

# pydantic_ai_slim/pydantic_ai/models/__init__.py:1274-1333
async def download_item(
    item: FileUrl,
    data_format: Literal['bytes', 'base64', 'base64_uri', 'text'] = 'bytes',
    type_format: Literal['mime', 'extension'] = 'mime',
) -> DownloadedItem[str] | DownloadedItem[bytes]:
    """Download an item by URL and return the content as a bytes object or a (base64-encoded) string.

    This function includes SSRF (Server-Side Request Forgery) protection:
    - Only http:// and https:// protocols are allowed
    - Private/internal IP addresses are blocked by default
    - Cloud metadata endpoints (169.254.169.254) are always blocked
    - Hostnames are resolved before requests to prevent DNS rebinding

    Set `item.force_download='allow-local'` to allow private IP addresses.

    Args:
        item: The item to download.
        data_format: The format to return the content in:
            - `bytes`: The raw bytes of the content.
            - `base64`: The base64-encoded content.
            - `base64_uri`: The base64-encoded content as a data URI.
            - `text`: The content as a string.
        type_format: The format to return the media type in:
            - `mime`: The media type as a MIME type.
            - `extension`: The media type as an extension.

    Raises:
        UserError: If the URL points to a YouTube video.
        ValueError: If the URL uses an unsupported protocol or targets a private/internal
            IP address (unless allow-local is set).
    """
    if isinstance(item, VideoUrl) and item.is_youtube:
        raise UserError('Downloading YouTube videos is not supported.')

    from .._ssrf import safe_download

    allow_local = item.force_download == 'allow-local'
    response = await safe_download(item.url, allow_local=allow_local)

    if content_type := response.headers.get('content-type'):
        content_type = content_type.split(';')[0]
        if content_type == 'application/octet-stream':
            content_type = None

    media_type = content_type or item.media_type

    data_type = media_type
    if type_format == 'extension':
        data_type = item.format

    data = response.content
    if data_format in ('base64', 'base64_uri'):
        data = base64.b64encode(data).decode('utf-8')
        if data_format == 'base64_uri':
            data = f'data:{media_type};base64,{data}'
        return DownloadedItem[str](data=data, data_type=data_type)
    elif data_format == 'text':
        return DownloadedItem[str](data=data.decode('utf-8'), data_type=data_type)
    else:
        return DownloadedItem[bytes](data=data, data_type=data_type)

# pydantic_ai_slim/pydantic_ai/models/gemini.py:967-967
    blocked: NotRequired[bool]

# pydantic_ai_slim/pydantic_ai/_ssrf.py:82-97
def is_private_ip(ip_str: str) -> bool:
    """Check if an IP address is in a private/internal range.

    Handles both IPv4 and IPv6 addresses, including IPv4-mapped IPv6 addresses.
    """
    try:
        ip = ipaddress.ip_address(ip_str)

        # Handle IPv4-mapped IPv6 addresses (e.g., ::ffff:192.168.1.1)
        if isinstance(ip, ipaddress.IPv6Address) and not ip.ipv4_mapped:
            ip = ip.ipv4_mapped

        return any(ip in network for network in _PRIVATE_NETWORKS)
    except ValueError:
        # Invalid IP address, treat as potentially dangerous
        return True

# pydantic_ai_slim/pydantic_ai/builtin_tools.py:225-225
    blocked_domains: list[str] | None = None

# pydantic_ai_slim/pydantic_ai/builtin_tools.py:119-119
    blocked_domains: list[str] | None = None

# pydantic_ai_slim/pydantic_ai/models/wrapper.py:24-24
    wrapped: Model

# pydantic_ai_slim/pydantic_ai/_ssrf.py:23-37
_PRIVATE_NETWORKS: tuple[ipaddress.IPv4Network | ipaddress.IPv6Network, ...] = (
    # IPv4 private ranges
    ipaddress.IPv4Network('127.0.0.0/8'),  # Loopback
    ipaddress.IPv4Network('10.0.0.0/8'),  # Private
    ipaddress.IPv4Network('172.16.0.0/12'),  # Private
    ipaddress.IPv4Network('192.168.0.0/16'),  # Private
    ipaddress.IPv4Network('169.254.0.0/16'),  # Link-local (includes cloud metadata)
    ipaddress.IPv4Network('0.0.0.0/8'),  # "This" network
    ipaddress.IPv4Network('100.64.0.0/10'),  # CGNAT (RFC 6598), includes Alibaba Cloud metadata
    # IPv6 private ranges
    ipaddress.IPv6Network('::1/128'),  # Loopback
    ipaddress.IPv6Network('fe80::/10'),  # Link-local
    ipaddress.IPv6Network('fc00::/7'),  # Unique local address
    ipaddress.IPv6Network('2002::/16'),  # 6to4 (can embed private IPv4 addresses)
)

# tests/test_ssrf.py:70-71
    def test_private_ips_detected(self, ip: str) -> None:
        assert is_private_ip(ip) is True

# pydantic_ai_slim/pydantic_ai/toolsets/wrapper.py:20-20
    wrapped: AbstractToolset[AgentDepsT]

# tests/models/mock_xai.py:416-441
def _get_example_tool_output(
    tool_type: chat_pb2.ToolCallType,
    content: ToolCallOutputType | None = None,
) -> ToolCallOutputType:
    """Return content if provided, otherwise a realistic default for the tool type."""
    if content is not None:
        return content
    if tool_type == chat_pb2.ToolCallType.TOOL_CALL_TYPE_CODE_EXECUTION_TOOL:
        return {'stdout': '4\n', 'stderr': '', 'output_files': {}, 'error': '', 'ret': ''}
    elif tool_type == chat_pb2.ToolCallType.TOOL_CALL_TYPE_WEB_SEARCH_TOOL:
        return {}  # Web search has no content currently, in future will return inline citations
    elif tool_type == chat_pb2.ToolCallType.TOOL_CALL_TYPE_MCP_TOOL:
        return [
            {
                'id': 'issue_001',
                'identifier': 'PROJ-123',
                'title': 'example-issue',
                'description': 'example-issue description',
                'status': 'Todo',
                'priority': {'value': 3, 'name': 'Medium'},
                'url': 'https://linear.app/team/issue/PROJ-123/example-issue',
            }
        ]
    else:  # pragma: no cover
        # Unknown tool type - return empty dict as fallback
        return {}

# pydantic_graph/pydantic_graph/beta/parent_forks.py:199-232
    def _get_upstream_nodes_if_parent(self, join_id: T, fork_id: T) -> set[T] | None:
        """Check if a fork is a valid parent and return upstream nodes.

        Tests whether the given fork can serve as a parent fork for the join by checking
        for cycles that bypass the fork. If valid, returns all nodes that can reach the
        join without going through the fork.

        Args:
            join_id: The join node being analyzed.
            fork_id: The potential parent fork to test.

        Returns:
            The set of node IDs upstream of the join (excluding the fork) if the fork is
            a valid parent, or None if a cycle exists that bypasses the fork (making it
            invalid as a parent fork).

        Note:
            If, in the graph with fork_id removed, a path exists that starts and ends at
            the join (i.e., join is on a cycle avoiding the fork), we return None because
            the fork would not be a valid "parent fork".
        """
        upstream: set[T] = set()
        stack = [join_id]
        while stack:
            v = stack.pop()
            for p in self._predecessors[v]:
                if p == fork_id:
                    continue
                if p == join_id:
                    return None  # J sits on a cycle w/out the specified node
                if p not in upstream:
                    upstream.add(p)
                    stack.append(p)
        return upstream

# tests/test_agent.py:3207-3215
def test_model_requests_blocked(env: TestEnv):
    try:
        env.set('GEMINI_API_KEY', 'foobar')
        agent = Agent('google-gla:gemini-3-flash-preview', output_type=tuple[str, str], defer_model_check=True)

        with pytest.raises(RuntimeError, match='Model requests are not allowed, since ALLOW_MODEL_REQUESTS is False'):
            agent.run_sync('Hello')
    except ImportError:  # pragma: lax no cover
        pytest.skip('google-genai not installed')

# pydantic_ai_slim/pydantic_ai/embeddings/wrapper.py:27-27
    wrapped: EmbeddingModel

# tests/test_ssrf.py:177-179
    def test_blocked_protocols(self, url: str, protocol: str) -> None:
        with pytest.raises(ValueError, match=f'URL protocol "{protocol}" is not allowed'):
            validate_url_protocol(url)

# pydantic_ai_slim/pydantic_ai/models/wrapper.py:83-85
    def settings(self) -> ModelSettings | None:
        """Get the settings from the wrapped model."""
        return self.wrapped.settings

# tests/test_ssrf.py:394-399
    async def test_cgnat_range_blocked(self) -> None:
        """Test that CGNAT range (100.64.0.0/10) is blocked."""
        with patch('pydantic_ai._ssrf.run_in_executor') as mock_executor:
            mock_executor.return_value = [(2, 1, 6, '', ('100.64.0.1', 0))]
            with pytest.raises(ValueError, match='Access to private/internal IP address'):
                await validate_and_resolve_url('http://cgnat-host.internal/path', allow_local=False)

# pydantic_graph/pydantic_graph/beta/graph.py:156-171
    def get_parent_fork(self, join_id: JoinID) -> ParentFork[NodeID]:
        """Get the parent fork information for a join node.

        Args:
            join_id: The ID of the join node

        Returns:
            The parent fork information for the join

        Raises:
            RuntimeError: If the join ID is not found or has no parent fork
        """
        result = self.parent_forks.get(join_id)
        if result is None:
            raise RuntimeError(f'Node {join_id} is not a join node or did not have a dominating fork (this is a bug)')
        return result

# pydantic_evals/pydantic_evals/_utils.py:49-75
def get_unwrapped_function_name(func: Callable[..., Any]) -> str:
    """Get the name of a function, unwrapping partials and decorators.

    Args:
        func: The function to get the name of.

    Returns:
        The name of the function.

    Raises:
        AttributeError: If the function doesn't have a __name__ attribute and isn't a method.
    """

    def _unwrap(f: Callable[..., Any]) -> Callable[..., Any]:
        """Unwraps f, also unwrapping partials, for the sake of getting f's name."""
        if isinstance(f, partial):
            return _unwrap(f.func)
        return inspect.unwrap(f)

    try:
        return _unwrap(func).__name__
    except AttributeError as e:
        # Handle instances of types with `__call__` as a method
        if inspect.ismethod(getattr(func, '__call__', None)):
            return f'{type(func).__qualname__}.__call__'
        else:
            raise e

# pydantic_ai_slim/pydantic_ai/models/mistral.py:425-435
    def _generate_user_output_format(self, schemas: list[dict[str, Any]]) -> MistralUserMessage:
        """Get a message with an example of the expected output format."""
        examples: list[dict[str, Any]] = []
        for schema in schemas:
            typed_dict_definition: dict[str, Any] = {}
            for key, value in schema.get('properties', {}).items():
                typed_dict_definition[key] = self._get_python_type(value)
            examples.append(typed_dict_definition)

        example_schema = examples[0] if len(examples) == 1 else examples
        return MistralUserMessage(content=self.json_mode_schema_prompt.format(schema=example_schema))

# tests/example_modules/mcp_server.py:11-13
async def get_weather_forecast(location: str) -> str:
    """Get the weather forecast for a location."""
    return f'The weather in {location} is sunny and 26 degrees Celsius.'

# tests/test_examples.py:19-19
from pytest_examples import CodeExample, EvalExample, find_examples

# tests/test_examples.py:19-19
from pytest_examples import CodeExample, EvalExample, find_examples