# pydantic_ai_slim/pydantic_ai/_utils.py:150-153
class Unset:
    """A singleton to represent an unset value."""

    pass

# pydantic_evals/pydantic_evals/_utils.py:37-46
def is_set(t_or_unset: T | Unset) -> TypeIs[T]:
    """Check if a value is set (not the UNSET singleton).

    Args:
        t_or_unset: The value to check, which may be the UNSET singleton or a regular value.

    Returns:
        True if the value is not UNSET, narrowing the type to T in a type-aware way.
    """
    return t_or_unset is not UNSET

# pydantic_graph/pydantic_graph/_utils.py:116-122
class Unset:
    """A singleton to represent an unset value.

    Copied from pydantic_ai/_utils.py.
    """

    pass

# pydantic_ai_slim/pydantic_ai/_utils.py:156-156
UNSET = Unset()

# pydantic_evals/pydantic_evals/_utils.py:31-31
UNSET = Unset()

# pydantic_evals/pydantic_evals/reporting/__init__.py:16-16
from pydantic_evals._utils import UNSET, Unset

# pydantic_evals/pydantic_evals/reporting/__init__.py:16-16
from pydantic_evals._utils import UNSET, Unset

# pydantic_graph/pydantic_graph/_utils.py:125-125
UNSET = Unset()

# pydantic_graph/pydantic_graph/beta/graph_builder.py:20-20
from pydantic_graph._utils import UNSET, Unset

# pydantic_graph/pydantic_graph/beta/graph_builder.py:20-20
from pydantic_graph._utils import UNSET, Unset

# tests/test_utils.py:14-24
from pydantic_ai._utils import (
    UNSET,
    PeekableAsyncStream,
    check_object_json_schema,
    group_by_temporal,
    is_async_callable,
    merge_json_schema_defs,
    run_in_executor,
    strip_markdown_fences,
    validate_empty_kwargs,
)

# pydantic_evals/pydantic_evals/_utils.py:20-28
class Unset:
    """A singleton to represent an unset value.

    Used to distinguish between explicitly set `None` values and values that were never set.

    Copied from pydantic_ai/_utils.py.
    """

    pass

# pydantic_graph/pydantic_graph/nodes.py:184-204
class NodeDef(Generic[StateT, DepsT, NodeRunEndT]):
    """Definition of a node.

    This is a primarily internal representation of a node; in general, it shouldn't be necessary to use it directly.

    Used by [`Graph`][pydantic_graph.graph.Graph] to store information about a node, and when generating
    mermaid graphs.
    """

    node: type[BaseNode[StateT, DepsT, NodeRunEndT]]
    """The node definition itself."""
    node_id: str
    """ID of the node."""
    note: str | None
    """Note about the node to render on mermaid charts."""
    next_node_edges: dict[str, Edge]
    """IDs of the nodes that can be called next."""
    end_edge: Edge | None
    """If node definition returns an `End` this is an Edge, indicating the node can end the run."""
    returns_base_node: bool
    """The node definition returns a `BaseNode`, hence any node in the next can be called next."""

# pydantic_evals/pydantic_evals/evaluators/spec.py:124-142
    def enforce_one_key(cls, value: str | dict[str, Any]) -> Any:
        """Enforce that the root value has exactly one key (the evaluator name) when it is a dict.

        Args:
            value: The value to validate.

        Returns:
            The validated value.

        Raises:
            ValueError: If the value is a dict with multiple keys.
        """
        if isinstance(value, str):
            return value
        if len(value) != 1:
            raise ValueError(
                f'Expected a single key containing the Evaluator class name, found keys {list(value.keys())}'
            )
        return value

# tests/test_validation_context.py:22-27
class Value(BaseModel):
    x: int

    @field_validator('x')
    def increment_value(cls, value: int, info: ValidationInfo):
        return value + (info.context or 0)

# pydantic_ai_slim/pydantic_ai/_agent_graph.py:60-60
T = TypeVar('T')

# pydantic_ai_slim/pydantic_ai/_output.py:41-41
T = TypeVar('T')

# pydantic_ai_slim/pydantic_ai/_utils.py:136-136
T = TypeVar('T')

# pydantic_ai_slim/pydantic_ai/agent/__init__.py:99-99
T = TypeVar('T')

# pydantic_ai_slim/pydantic_ai/agent/abstract.py:59-59
T = TypeVar('T')

# pydantic_ai_slim/pydantic_ai/models/bedrock.py:156-156
T = typing.TypeVar('T')

# pydantic_ai_slim/pydantic_ai/output.py:35-35
T = TypeVar('T')

# pydantic_ai_slim/pydantic_ai/result.py:42-42
T = TypeVar('T')

# pydantic_evals/pydantic_evals/_utils.py:34-34
T = TypeVar('T')

# pydantic_evals/pydantic_evals/evaluators/evaluator.py:56-56
T = TypeVar('T')

# pydantic_evals/pydantic_evals/reporting/__init__.py:934-934
T = TypeVar('T')

# pydantic_graph/pydantic_graph/_utils.py:126-126
T = TypeVar('T')

# pydantic_graph/pydantic_graph/beta/decision.py:36-36
T = TypeVar('T', infer_variance=True)

# pydantic_graph/pydantic_graph/beta/graph_builder.py:61-61
T = TypeVar('T', infer_variance=True)

# pydantic_graph/pydantic_graph/beta/join.py:25-25
T = TypeVar('T', infer_variance=True)

# pydantic_graph/pydantic_graph/beta/parent_forks.py:29-29
T = TypeVar('T', bound=Hashable, infer_variance=True, default=str)

# pydantic_graph/pydantic_graph/beta/paths.py:26-26
T = TypeVar('T')

# pydantic_graph/pydantic_graph/beta/util.py:12-12
T = TypeVar('T', infer_variance=True)

# tests/models/mock_async_stream.py:18-18
T = TypeVar('T')

# tests/models/test_anthropic.py:127-127
T = TypeVar('T')

# tests/test_agent.py:108-108
T = TypeVar('T')

# tests/test_toolsets.py:34-34
T = TypeVar('T')

# pydantic_ai_slim/pydantic_ai/tools.py:446-460
    async def prepare_tool_def(self, ctx: RunContext[ToolAgentDepsT]) -> ToolDefinition | None:
        """Get the tool definition.

        By default, this method creates a tool definition, then either returns it, or calls `self.prepare`
        if it's set.

        Returns:
            return a `ToolDefinition` or `None` if the tools should not be registered for this run.
        """
        base_tool_def = self.tool_def

        if self.prepare is not None:
            return await self.prepare(ctx, base_tool_def)
        else:
            return base_tool_def

# pydantic_evals/pydantic_evals/evaluators/common.py:73-73
    value: Any

# pydantic_graph/pydantic_graph/beta/graph.py:86-87
    def value(self) -> OutputT:
        return self._value

# pydantic_evals/pydantic_evals/evaluators/evaluator.py:73-73
    value: EvaluationScalarT

# pydantic_ai_slim/pydantic_ai/_utils.py:143-143
    value: T

# pydantic_graph/pydantic_graph/beta/util.py:66-66
    value: T

# tests/graph/beta/test_graph_edge_cases.py:20-20
    value: int = 0

# tests/graph/beta/test_paths.py:27-27
    value: int = 0

# pydantic_evals/pydantic_evals/evaluators/evaluator.py:44-44
    value: EvaluationScalar

# pydantic_ai_slim/pydantic_ai/models/__init__.py:1002-1012
    async def _get_event_iterator(self) -> AsyncIterator[ModelResponseStreamEvent]:
        """Return an async iterator of [`ModelResponseStreamEvent`][pydantic_ai.messages.ModelResponseStreamEvent]s.

        This method should be implemented by subclasses to translate the vendor-specific stream of events into
        pydantic_ai-format events.

        It should use the `_parts_manager` to handle deltas, and should update the `_usage` attributes as it goes.
        """
        raise NotImplementedError()
        # noinspection PyUnreachableCode
        yield

# pydantic_evals/pydantic_evals/reporting/analyses.py:65-65
    value: float | int

# pydantic_evals/pydantic_evals/evaluators/common.py:32-32
    value: Any

# pydantic_ai_slim/pydantic_ai/_utils.py:318-340
    async def peek(self) -> T | Unset:
        """Returns the next item that would be yielded without consuming it.

        Returns None if the stream is exhausted.
        """
        if self._exhausted:
            return UNSET

        # If we already have a buffered item, just return it.
        if not isinstance(self._buffer, Unset):
            return self._buffer

        # Otherwise, we need to fetch the next item from the underlying iterator.
        if self._source_iter is None:
            self._source_iter = aiter(self._source)

        try:
            self._buffer = await anext(self._source_iter)
        except StopAsyncIteration:
            self._exhausted = True
            return UNSET

        return self._buffer

# tests/graph/beta/test_joins_and_reducers.py:24-24
    value: int = 0

# examples/pydantic_ai_examples/ag_ui/api/agentic_generative_ui.py:42-45
    value: Any = Field(
        default=None,
        description='The value to apply (for add, replace operations)',
    )

# pydantic_ai_slim/pydantic_ai/models/test.py:52-52
    value: dict[str, Any] | None

# tests/test_agent.py:3308-3308
    value: str

# tests/test_streaming.py:1141-1141
    value: str

# pydantic_ai_slim/pydantic_ai/models/test.py:45-45
    value: str | None

# tests/graph/beta/test_decisions.py:20-20
    value: int = 0

# tests/graph/beta/test_edge_cases.py:19-19
    value: int = 0

# tests/test_agent.py:114-114
    value: T

# tests/graph/beta/test_edge_labels.py:17-17
    value: int = 0

# tests/test_ag_ui.py:158-158
    value: int = 0

# tests/test_prefect.py:1195-1195
    value: str

# pydantic_ai_slim/pydantic_ai/tools.py:178-186
class ToolDenied:
    """Indicates that a tool call has been denied and that a denial message should be returned to the model."""

    message: str = 'The tool call was denied.'
    """The message to return to the model."""

    _: KW_ONLY

    kind: Literal['tool-denied'] = 'tool-denied'