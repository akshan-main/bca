# tests/test_ssrf.py:242-247
    def test_https_default_port(self) -> None:
        resolved = ResolvedUrl(
            resolved_ip='203.0.113.50', hostname='example.com', port=443, is_https=True, path='/path'
        )
        url = build_url_with_ip(resolved)
        assert url == 'https://203.0.113.50/path'

# pydantic_ai_slim/pydantic_ai/_cli/__init__.py:13-13
from pydantic import ImportString, TypeAdapter, ValidationError

# pydantic_ai_slim/pydantic_ai/_ssrf.py:151-179
def extract_host_and_port(url: str) -> tuple[str, str, int, bool]:
    """Extract hostname, path, port, and protocol info from a URL.

    Returns:
        Tuple of (hostname, path_with_query, port, is_https)

    Raises:
        ValueError: If the URL is malformed or uses an unsupported protocol.
    """
    # Validate protocol first, before trying to extract hostname
    _, is_https = validate_url_protocol(url)

    parsed = urlparse(url)
    hostname = parsed.hostname

    if not hostname:
        raise ValueError(f'Invalid URL: no hostname found in "{url}"')

    default_port = 80 if is_https else 443
    port = parsed.port or default_port

    # Reconstruct path with query string
    path = parsed.path or '/'
    if parsed.query:
        path = f'{path}?{parsed.query}'
    if parsed.fragment:
        path = f'{path}#{parsed.fragment}'

    return hostname, path, port, is_https

# tests/test_ssrf.py:235-240
    def test_http_default_port(self) -> None:
        resolved = ResolvedUrl(
            resolved_ip='203.0.113.50', hostname='example.com', port=80, is_https=False, path='/path'
        )
        url = build_url_with_ip(resolved)
        assert url == 'http://203.0.113.50/path'

# tests/test_ssrf.py:192-197
    def test_basic_https_url(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('https://example.com/path')
        assert hostname == 'example.com'
        assert path == '/path'
        assert port == 443
        assert is_https is True

# pydantic_ai_slim/pydantic_ai/profiles/__init__.py:26-26
    supports_tools: bool = True

# pydantic_ai_slim/pydantic_ai/profiles/openai.py:93-93
    openai_chat_supports_file_urls: bool = False

# pydantic_graph/pydantic_graph/beta/join.py:124-129
class SupportsSum(Protocol):
    """A protocol for a type that supports adding to itself."""

    @abstractmethod
    def __add__(self, other: Self, /) -> Self:
        pass

# pydantic_ai_slim/pydantic_ai/embeddings/bedrock.py:234-236
    def supports_batch(self) -> bool:
        """Whether this handler supports batch embedding in a single request."""
        return False

# pydantic_ai_slim/pydantic_ai/embeddings/bedrock.py:316-318
    def supports_batch(self) -> bool:
        """Cohere models support batch embedding."""
        return True

# pydantic_ai_slim/pydantic_ai/profiles/__init__.py:40-40
    supports_image_output: bool = False

# tests/profiles/test_openai.py:27-27
    supports_reasoning: bool = False

# pydantic_ai_slim/pydantic_ai/_ssrf.py:151-179
def extract_host_and_port(url: str) -> tuple[str, str, int, bool]:
    """Extract hostname, path, port, and protocol info from a URL.

    Returns:
        Tuple of (hostname, path_with_query, port, is_https)

    Raises:
        ValueError: If the URL is malformed or uses an unsupported protocol.
    """
    # Validate protocol first, before trying to extract hostname
    _, is_https = validate_url_protocol(url)

    parsed = urlparse(url)
    hostname = parsed.hostname

    if not hostname:
        raise ValueError(f'Invalid URL: no hostname found in "{url}"')

    default_port = 80 if is_https else 443
    port = parsed.port or default_port

    # Reconstruct path with query string
    path = parsed.path or '/'
    if parsed.query:
        path = f'{path}?{parsed.query}'
    if parsed.fragment:
        path = f'{path}#{parsed.fragment}'

    return hostname, path, port, is_https

# pydantic_ai_slim/pydantic_ai/retries.py:18-26
from httpx import (
    AsyncBaseTransport,
    AsyncHTTPTransport,
    BaseTransport,
    HTTPStatusError,
    HTTPTransport,
    Request,
    Response,
)

# tests/test_fastmcp.py:534-563
    async def test_transports(self):
        """Test creating toolset from different transports."""
        toolset = FastMCPToolset('http://localhost:8000/mcp')
        assert isinstance(toolset.client.transport, StreamableHttpTransport)

        toolset = FastMCPToolset('http://localhost:8000/sse')
        assert isinstance(toolset.client.transport, SSETransport)

        toolset = FastMCPToolset(StdioTransport(command='python', args=['-c', 'print("test")']))
        assert isinstance(toolset.client.transport, StdioTransport)

        with TemporaryDirectory() as temp_dir:
            server_py: Path = Path(temp_dir) / 'server.py'
            server_py.write_text(data='', encoding='utf-8')
            toolset = FastMCPToolset(server_py)
            assert isinstance(toolset.client.transport, PythonStdioTransport)
            toolset = FastMCPToolset(str(server_py))
            assert isinstance(toolset.client.transport, PythonStdioTransport)

            server_js: Path = Path(temp_dir) / 'server.js'
            server_js.write_text(data='', encoding='utf-8')
            toolset = FastMCPToolset(server_js)
            assert isinstance(toolset.client.transport, NodeStdioTransport)
            toolset = FastMCPToolset(str(server_js))
            assert isinstance(toolset.client.transport, NodeStdioTransport)

        toolset = FastMCPToolset(
            {'mcpServers': {'test_server': {'command': 'python', 'args': ['-c', 'print("test")']}}}
        )
        assert isinstance(toolset.client.transport, MCPConfigTransport)

# tests/models/test_outlines.py:92-92
skip_if_vllm_imports_unsuccessful = pytest.mark.skipif(not vllm_imports_successful(), reason='vllm not available')

# tests/test_ssrf.py:182-229
class TestExtractHostAndPort:
    """Tests for extract_host_and_port function."""

    def test_basic_http_url(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('http://example.com/path')
        assert hostname == 'example.com'
        assert path == '/path'
        assert port == 80
        assert is_https is False

    def test_basic_https_url(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('https://example.com/path')
        assert hostname == 'example.com'
        assert path == '/path'
        assert port == 443
        assert is_https is True

    def test_custom_port(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('http://example.com:8080/path')
        assert hostname == 'example.com'
        assert path == '/path'
        assert port == 8080
        assert is_https is False

    def test_path_with_query_string(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('https://example.com/path?query=value')
        assert hostname == 'example.com'
        assert path == '/path?query=value'
        assert port == 443
        assert is_https is True

    def test_path_with_fragment(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('https://example.com/path#fragment')
        assert hostname == 'example.com'
        assert path == '/path#fragment'
        assert port == 443
        assert is_https is True

    def test_empty_path(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('https://example.com')
        assert hostname == 'example.com'
        assert path == '/'
        assert port == 443
        assert is_https is True

    def test_invalid_url_no_hostname(self) -> None:
        with pytest.raises(ValueError, match='Invalid URL: no hostname found'):
            extract_host_and_port('http://')

# pydantic_ai_slim/pydantic_ai/profiles/__init__.py:28-28
    supports_json_schema_output: bool = False

# pydantic_ai_slim/pydantic_ai/profiles/__init__.py:34-34
    supports_json_object_output: bool = False

# tests/models/test_outlines.py:96-96
skip_if_mlxlm_imports_unsuccessful = pytest.mark.skipif(not mlxlm_imports_successful(), reason='mlx_lm not available')

# pydantic_ai_slim/pydantic_ai/profiles/openai.py:103-103
    openai_supports_reasoning: bool = False

# tests/test_fastmcp.py:573-576
    async def test_bad_transports(self):
        """Test creating toolset from invalid transports."""
        with pytest.raises(ValueError, match='No MCP servers defined in the config'):
            FastMCPToolset({'bad_transport': 'bad_value'})

# tests/models/test_outlines.py:94-94
skip_if_sglang_imports_unsuccessful = pytest.mark.skipif(not sglang_imports_successful(), reason='openai not available')

# pydantic_ai_slim/pydantic_ai/profiles/grok.py:16-16
    grok_supports_builtin_tools: bool = False

# tests/test_ssrf.py:185-190
    def test_basic_http_url(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('http://example.com/path')
        assert hostname == 'example.com'
        assert path == '/path'
        assert port == 80
        assert is_https is False

# pydantic_ai_slim/pydantic_ai/_ssrf.py:64-64
    port: int

# pydantic_ai_slim/pydantic_ai/retries.py:18-26
from httpx import (
    AsyncBaseTransport,
    AsyncHTTPTransport,
    BaseTransport,
    HTTPStatusError,
    HTTPTransport,
    Request,
    Response,
)

# pydantic_ai_slim/pydantic_ai/providers/bedrock.py:41-41
    bedrock_supports_tool_choice: bool = False

# tests/models/test_outlines.py:87-90
skip_if_llama_cpp_imports_unsuccessful = pytest.mark.skipif(
    not llama_cpp_imports_successful() or os.getenv('CI') == 'true',
    reason='llama_cpp not available or skipped in CI due to SIGILL risk',
)

# pydantic_graph/pydantic_graph/beta/join.py:128-129
    def __add__(self, other: Self, /) -> Self:
        pass

# pydantic_ai_slim/pydantic_ai/providers/bedrock.py:45-45
    bedrock_supports_tool_caching: bool = False