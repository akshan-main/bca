# pydantic_ai_slim/pydantic_ai/providers/bedrock.py:99-100
    def name(self) -> str:
        return 'bedrock'

# pydantic_ai_slim/pydantic_ai/providers/google.py:29-30
    def name(self) -> str:
        return 'google-vertex' if self._client._api_client.vertexai else 'google-gla'  # type: ignore[reportPrivateUsage]

# pydantic_ai_slim/pydantic_ai/providers/outlines.py:13-15
    def name(self) -> str:
        """The provider name."""
        return 'outlines'

# pydantic_ai_slim/pydantic_ai/providers/__init__.py:30-32
    def name(self) -> str:
        """The provider name."""
        raise NotImplementedError()

# pydantic_ai_slim/pydantic_ai/providers/sentence_transformers.py:12-14
    def name(self) -> str:
        """The provider name."""
        return 'sentence-transformers'  # pragma: no cover

# pydantic_ai_slim/pydantic_ai/providers/xai.py:24-25
    def name(self) -> str:
        return 'xai'

# pydantic_ai_slim/pydantic_ai/tools.py:273-273
    name: str

# pydantic_ai_slim/pydantic_ai/providers/sambanova.py:36-38
    def name(self) -> str:
        """Return the provider name."""
        return 'sambanova'

# pydantic_ai_slim/pydantic_ai/providers/google_gla.py:20-21
    def name(self):
        return 'google-gla'

# pydantic_ai_slim/pydantic_ai/ext/langchain.py:21-21
    def name(self) -> str: ...

# pydantic_ai_slim/pydantic_ai/providers/cohere.py:26-27
    def name(self) -> str:
        return 'cohere'

# pydantic_ai_slim/pydantic_ai/providers/grok.py:54-55
    def name(self) -> str:
        return 'grok'

# pydantic_ai_slim/pydantic_ai/providers/openai.py:26-27
    def name(self) -> str:
        return 'openai'

# pydantic_ai_slim/pydantic_ai/providers/deepseek.py:32-33
    def name(self) -> str:
        return 'deepseek'

# pydantic_ai_slim/pydantic_ai/providers/openrouter.py:98-99
    def name(self) -> str:
        return 'openrouter'

# pydantic_ai_slim/pydantic_ai/providers/alibaba.py:29-30
    def name(self) -> str:
        return 'alibaba'

# pydantic_ai_slim/pydantic_ai/providers/anthropic.py:33-34
    def name(self) -> str:
        return 'anthropic'

# pydantic_ai_slim/pydantic_ai/providers/azure.py:36-37
    def name(self) -> str:
        return 'azure'

# pydantic_ai_slim/pydantic_ai/providers/cerebras.py:31-32
    def name(self) -> str:
        return 'cerebras'

# pydantic_ai_slim/pydantic_ai/providers/fireworks.py:33-34
    def name(self) -> str:
        return 'fireworks'

# pydantic_ai_slim/pydantic_ai/providers/github.py:36-37
    def name(self) -> str:
        return 'github'

# pydantic_ai_slim/pydantic_ai/providers/google_vertex.py:39-40
    def name(self) -> str:
        return 'google-vertex'

# pydantic_ai_slim/pydantic_ai/providers/groq.py:51-52
    def name(self) -> str:
        return 'groq'

# pydantic_ai_slim/pydantic_ai/providers/heroku.py:28-29
    def name(self) -> str:
        return 'heroku'

# pydantic_ai_slim/pydantic_ai/providers/huggingface.py:32-33
    def name(self) -> str:
        return 'huggingface'

# pydantic_ai_slim/pydantic_ai/providers/litellm.py:37-38
    def name(self) -> str:
        return 'litellm'

# pydantic_ai_slim/pydantic_ai/providers/mistral.py:27-28
    def name(self) -> str:
        return 'mistral'

# pydantic_ai_slim/pydantic_ai/providers/moonshotai.py:36-37
    def name(self) -> str:
        return 'moonshotai'

# pydantic_ai_slim/pydantic_ai/providers/nebius.py:34-35
    def name(self) -> str:
        return 'nebius'

# pydantic_ai_slim/pydantic_ai/providers/ollama.py:34-35
    def name(self) -> str:
        return 'ollama'

# pydantic_ai_slim/pydantic_ai/providers/ovhcloud.py:32-33
    def name(self) -> str:
        return 'ovhcloud'

# pydantic_ai_slim/pydantic_ai/providers/together.py:33-34
    def name(self) -> str:
        return 'together'

# pydantic_ai_slim/pydantic_ai/providers/vercel.py:34-35
    def name(self) -> str:
        return 'vercel'

# pydantic_ai_slim/pydantic_ai/providers/voyageai.py:22-23
    def name(self) -> str:
        return 'voyageai'

# tests/models/test_bedrock.py:102-103
    def name(self) -> str:
        return 'bedrock-stub'

# pydantic_graph/pydantic_graph/beta/graph.py:123-123
    name: str | None

# pydantic_graph/pydantic_graph/graph.py:68-68
    name: str | None

# pydantic_ai_slim/pydantic_ai/_otel_messages.py:22-22
    name: str

# pydantic_ai_slim/pydantic_ai/tools.py:482-482
    name: str

# pydantic_evals/pydantic_evals/dataset.py:228-228
    name: str | None = None

# pydantic_evals/pydantic_evals/dataset.py:132-132
    name: str | None

# pydantic_ai_slim/pydantic_ai/concurrency.py:141-143
    def name(self) -> str | None:
        """Name of the limiter for observability."""
        return self._name

# pydantic_evals/pydantic_evals/otel/span_tree.py:85-85
    name: str

# pydantic_evals/pydantic_evals/reporting/__init__.py:72-72
    name: str

# pydantic_evals/pydantic_evals/reporting/__init__.py:302-302
    name: str

# pydantic_graph/pydantic_graph/beta/graph_builder.py:79-79
    name: str | None

# pydantic_evals/pydantic_evals/evaluators/context.py:55-55
    name: str | None

# pydantic_ai_slim/pydantic_ai/agent/wrapper.py:47-48
    def name(self, value: str | None) -> None:
        self.wrapped.name = value

# pydantic_ai_slim/pydantic_ai/output.py:162-162
    name: str | None

# pydantic_ai_slim/pydantic_ai/output.py:111-111
    name: str | None

# pydantic_evals/pydantic_evals/evaluators/evaluator.py:72-72
    name: str

# pydantic_ai_slim/pydantic_ai/agent/abstract.py:101-103
    def name(self, value: str | None) -> None:
        """Set the name of the agent, used for logging."""
        raise NotImplementedError

# pydantic_ai_slim/pydantic_ai/output.py:264-264
    name: str | None = None

# pydantic_evals/pydantic_evals/evaluators/spec.py:35-35
    name: str

# tests/test_native_output_schema.py:10-10
    name: str

# pydantic_ai_slim/pydantic_ai/output.py:235-235
    name: str | None

# pydantic_evals/pydantic_evals/reporting/__init__.py:166-166
    name: str

# pydantic_ai_slim/pydantic_ai/agent/__init__.py:448-450
    def name(self, value: str | None) -> None:
        """Set the name of the agent, used for logging."""
        self._name = value

# pydantic_ai_slim/pydantic_ai/durable_exec/temporal/_agent.py:210-213
    def name(self, value: str | None) -> None:  # pragma: no cover
        raise UserError(
            'The agent name cannot be changed after creation. If you need to change the name, create a new agent.'
        )

# pydantic_evals/pydantic_evals/reporting/__init__.py:109-109
    name: str

# pydantic_ai_slim/pydantic_ai/durable_exec/prefect/_agent.py:127-130
    def name(self, value: str | None) -> None:  # pragma: no cover
        raise UserError(
            'The agent name cannot be changed after creation. If you need to change the name, create a new agent.'
        )

# pydantic_ai_slim/pydantic_ai/durable_exec/dbos/_agent.py:235-238
    def name(self, value: str | None) -> None:  # pragma: no cover
        raise UserError(
            'The agent name cannot be changed after creation. If you need to change the name, create a new agent.'
        )

# pydantic_evals/pydantic_evals/evaluators/evaluator.py:101-101
    name: str

# pydantic_evals/pydantic_evals/evaluators/report_evaluator.py:31-31
    name: str

# pydantic_ai_slim/pydantic_ai/models/function.py:244-244
    name: str | None = None

# pydantic_evals/pydantic_evals/reporting/__init__.py:145-145
    name: str

# pydantic_ai_slim/pydantic_ai/durable_exec/temporal/_toolset.py:31-31
    name: str

# pydantic_ai_slim/pydantic_ai/mcp.py:131-131
    name: str

# pydantic_evals/pydantic_evals/dataset.py:104-104
    name: str | None = None

# tests/ext/test_langchain.py:14-14
    name: str

# examples/pydantic_ai_examples/stream_whales.py:28-28
    name: str

# pydantic_ai_slim/pydantic_ai/_otel_messages.py:30-30
    name: str

# pydantic_evals/pydantic_evals/dataset.py:92-92
    name: str | None = None

# pydantic_evals/pydantic_evals/reporting/analyses.py:41-41
    name: str

# tests/test_format_as_xml.py:41-41
    name: str = Field(description="The person's name")

# pydantic_evals/pydantic_evals/_utils.py:49-75
def get_unwrapped_function_name(func: Callable[..., Any]) -> str:
    """Get the name of a function, unwrapping partials and decorators.

    Args:
        func: The function to get the name of.

    Returns:
        The name of the function.

    Raises:
        AttributeError: If the function doesn't have a __name__ attribute and isn't a method.
    """

    def _unwrap(f: Callable[..., Any]) -> Callable[..., Any]:
        """Unwraps f, also unwrapping partials, for the sake of getting f's name."""
        if isinstance(f, partial):
            return _unwrap(f.func)
        return inspect.unwrap(f)

    try:
        return _unwrap(func).__name__
    except AttributeError as e:
        # Handle instances of types with `__call__` as a method
        if inspect.ismethod(getattr(func, '__call__', None)):
            return f'{type(func).__qualname__}.__call__'
        else:
            raise e

# pydantic_ai_slim/pydantic_ai/models/gemini.py:822-822
    name: str

# tests/test_logfire.py:38-38
    name: str

# examples/pydantic_ai_examples/ag_ui/api/shared_state.py:53-53
    name: str

# pydantic_ai_slim/pydantic_ai/models/gemini.py:763-763
    name: str

# pydantic_ai_slim/pydantic_ai/ui/_web/api.py:30-30
    name: str

# tests/test_a2a.py:53-53
    name: str

# pydantic_ai_slim/pydantic_ai/models/gemini.py:778-778
    name: str

# pydantic_ai_slim/pydantic_ai/models/groq.py:659-659
    name: str

# pydantic_ai_slim/pydantic_ai/ui/_web/api.py:38-38
    name: str

# tests/test_agent.py:104-104
    name: str

# tests/test_format_as_xml.py:21-21
    name: str

# tests/test_format_as_xml.py:26-26
    name: str

# pydantic_evals/pydantic_evals/evaluators/evaluator.py:142-144
    def name(cls) -> str:
        """`name` has been renamed, use `get_serialization_name` instead."""
        return cls.get_serialization_name()

# pydantic_ai_slim/pydantic_ai/tools.py:389-431
    def from_schema(
        cls,
        function: Callable[..., Any],
        name: str,
        description: str | None,
        json_schema: JsonSchemaValue,
        takes_ctx: bool = False,
        sequential: bool = False,
    ) -> Self:
        """Creates a Pydantic tool from a function and a JSON schema.

        Args:
            function: The function to call.
                This will be called with keywords only, and no validation of
                the arguments will be performed.
            name: The unique name of the tool that clearly communicates its purpose
            description: Used to tell the model how/when/why to use the tool.
                You can provide few-shot examples as a part of the description.
            json_schema: The schema for the function arguments
            takes_ctx: An optional boolean parameter indicating whether the function
                accepts the context object as an argument.
            sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.

        Returns:
            A Pydantic tool that calls the function
        """
        function_schema = _function_schema.FunctionSchema(
            function=function,
            description=description,
            validator=SchemaValidator(schema=core_schema.any_schema()),
            json_schema=json_schema,
            takes_ctx=takes_ctx,
            is_async=_utils.is_async_callable(function),
        )

        return cls(
            function,
            takes_ctx=takes_ctx,
            name=name,
            description=description,
            function_schema=function_schema,
            sequential=sequential,
        )

# pydantic_ai_slim/pydantic_ai/tools.py:270-270
    function: ToolFuncEither[ToolAgentDepsT]

# tests/test_usage_limits.py:3-3
import operator

# pydantic_ai_slim/pydantic_ai/models/function.py:49-49
    function: FunctionDef | None

# pydantic_ai_slim/pydantic_ai/_function_schema.py:38-38
    function: Callable[..., Any]

# pydantic_ai_slim/pydantic_ai/_output.py:163-163
    function: OutputValidatorFunc[AgentDepsT, OutputDataT_inv]

# pydantic_ai_slim/pydantic_ai/_system_prompt.py:15-15
    function: SystemPromptFunc[AgentDepsT]

# pydantic_ai_slim/pydantic_ai/models/function.py:86-122
    def __init__(
        self,
        function: FunctionDef | None = None,
        *,
        stream_function: StreamFunctionDef | None = None,
        model_name: str | None = None,
        profile: ModelProfileSpec | None = None,
        settings: ModelSettings | None = None,
    ):
        """Initialize a `FunctionModel`.

        Either `function` or `stream_function` must be provided, providing both is allowed.

        Args:
            function: The function to call for non-streamed requests.
            stream_function: The function to call for streamed requests.
            model_name: The name of the model. If not provided, a name is generated from the function names.
            profile: The model profile to use.
            settings: Model-specific settings that will be used as defaults for this model.
        """
        if function is None and stream_function is None:
            raise TypeError('Either `function` or `stream_function` must be provided')

        self.function = function
        self.stream_function = stream_function

        function_name = self.function.__name__ if self.function is not None else ''
        stream_function_name = self.stream_function.__name__ if self.stream_function is not None else ''
        self._model_name = model_name or f'function:{function_name}:{stream_function_name}'

        # Use a default profile that supports JSON schema and object output if none provided
        if profile is None:
            profile = ModelProfile(
                supports_json_schema_output=True,
                supports_json_object_output=True,
            )
        super().__init__(settings=settings, profile=profile)

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:374-374
    function: _OpenRouterFunction  # type: ignore[reportIncompatibleVariableOverride]

# pydantic_evals/pydantic_evals/evaluators/_base.py:48-54
    def get_serialization_name(cls) -> str:
        """Return the 'name' of this evaluator to use during serialization.

        Returns:
            The name of the evaluator, which is typically the class name.
        """
        return cls.__name__

# pydantic_ai_slim/pydantic_ai/toolsets/function.py:239-321
    def add_function(
        self,
        func: ToolFuncEither[AgentDepsT, ToolParams],
        takes_ctx: bool | None = None,
        name: str | None = None,
        description: str | None = None,
        retries: int | None = None,
        prepare: ToolPrepareFunc[AgentDepsT] | None = None,
        docstring_format: DocstringFormat | None = None,
        require_parameter_descriptions: bool | None = None,
        schema_generator: type[GenerateJsonSchema] | None = None,
        strict: bool | None = None,
        sequential: bool | None = None,
        requires_approval: bool | None = None,
        metadata: dict[str, Any] | None = None,
        timeout: float | None = None,
    ) -> None:
        """Add a function as a tool to the toolset.

        Can take a sync or async function.

        The docstring is inspected to extract both the tool description and description of each parameter,
        [learn more](../tools.md#function-tools-and-schema).

        Args:
            func: The tool function to register.
            takes_ctx: Whether the function takes a [`RunContext`][pydantic_ai.tools.RunContext] as its first argument. If `None`, this is inferred from the function signature.
            name: The name of the tool, defaults to the function name.
            description: The description of the tool, defaults to the function docstring.
            retries: The number of retries to allow for this tool, defaults to the agent's default retries,
                which defaults to 1.
            prepare: custom method to prepare the tool definition for each step, return `None` to omit this
                tool from a given step. This is useful if you want to customise a tool at call time,
                or omit it completely from a step. See [`ToolPrepareFunc`][pydantic_ai.tools.ToolPrepareFunc].
            docstring_format: The format of the docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].
                If `None`, the default value is determined by the toolset.
            require_parameter_descriptions: If True, raise an error if a parameter description is missing.
                If `None`, the default value is determined by the toolset.
            schema_generator: The JSON schema generator class to use for this tool.
                If `None`, the default value is determined by the toolset.
            strict: Whether to enforce JSON schema compliance (only affects OpenAI).
                See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.
                If `None`, the default value is determined by the toolset.
            sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.
                If `None`, the default value is determined by the toolset.
            requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.
                See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.
                If `None`, the default value is determined by the toolset.
            metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.
                If `None`, the default value is determined by the toolset. If provided, it will be merged with the toolset's metadata.
            timeout: Timeout in seconds for tool execution. If the tool takes longer, a retry prompt is returned to the model.
                Defaults to None (no timeout).
        """
        if docstring_format is None:
            docstring_format = self.docstring_format
        if require_parameter_descriptions is None:
            require_parameter_descriptions = self.require_parameter_descriptions
        if schema_generator is None:
            schema_generator = self.schema_generator
        if strict is None:
            strict = self.strict
        if sequential is None:
            sequential = self.sequential
        if requires_approval is None:
            requires_approval = self.requires_approval

        tool = Tool[AgentDepsT](
            func,
            takes_ctx=takes_ctx,
            name=name,
            description=description,
            max_retries=retries,
            prepare=prepare,
            docstring_format=docstring_format,
            require_parameter_descriptions=require_parameter_descriptions,
            schema_generator=schema_generator,
            strict=strict,
            sequential=sequential,
            requires_approval=requires_approval,
            metadata=metadata,
            timeout=timeout,
        )
        self.add_tool(tool)

# pydantic_graph/pydantic_graph/_utils.py:169-204
def infer_obj_name(obj: Any, *, depth: int) -> str | None:
    """Infer the variable name of an object from the calling frame's scope.

    This function examines the call stack to find what variable name was used
    for the given object in the calling scope. This is useful for automatic
    naming of objects based on their variable names.

    Args:
        obj: The object whose variable name to infer.
        depth: Number of stack frames to traverse upward from the current frame.

    Returns:
        The inferred variable name if found, None otherwise.

    Example:
        Usage should generally look like `infer_name(self, depth=2)` or similar.
    """
    target_frame = inspect.currentframe()
    if target_frame is None:
        return None  # pragma: no cover
    for _ in range(depth):
        target_frame = target_frame.f_back
        if target_frame is None:
            return None

    for name, item in target_frame.f_locals.items():
        if item is obj:
            return name

    if target_frame.f_locals != target_frame.f_globals:  # pragma: no branch
        # if we couldn't find the agent in locals and globals are a different dict, try globals
        for name, item in target_frame.f_globals.items():
            if item is obj:
                return name

    return None

# pydantic_evals/pydantic_evals/evaluators/evaluator.py:146-162
    def get_default_evaluation_name(self) -> str:
        """Return the default name to use in reports for the output of this evaluator.

        By default, if the evaluator has an attribute called `evaluation_name` of type string, that will be used.
        Otherwise, the serialization name of the evaluator (which is usually the class name) will be used.

        This can be overridden to get a more descriptive name in evaluation reports, e.g. using instance information.

        Note that evaluators that return a mapping of results will always use the keys of that mapping as the names
        of the associated evaluation results.
        """
        evaluation_name = getattr(self, 'evaluation_name', None)
        if isinstance(evaluation_name, str):
            # If the evaluator has an attribute `name` of type string, use that
            return evaluation_name

        return self.get_serialization_name()