# pydantic_evals/pydantic_evals/_utils.py:49-75
def get_unwrapped_function_name(func: Callable[..., Any]) -> str:
    """Get the name of a function, unwrapping partials and decorators.

    Args:
        func: The function to get the name of.

    Returns:
        The name of the function.

    Raises:
        AttributeError: If the function doesn't have a __name__ attribute and isn't a method.
    """

    def _unwrap(f: Callable[..., Any]) -> Callable[..., Any]:
        """Unwraps f, also unwrapping partials, for the sake of getting f's name."""
        if isinstance(f, partial):
            return _unwrap(f.func)
        return inspect.unwrap(f)

    try:
        return _unwrap(func).__name__
    except AttributeError as e:
        # Handle instances of types with `__call__` as a method
        if inspect.ismethod(getattr(func, '__call__', None)):
            return f'{type(func).__qualname__}.__call__'
        else:
            raise e

# pydantic_ai_slim/pydantic_ai/models/function.py:195-197
    def model_name(self) -> str:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/gemini.py:822-822
    name: str

# pydantic_ai_slim/pydantic_ai/models/gemini.py:763-763
    name: str

# pydantic_ai_slim/pydantic_ai/models/gemini.py:778-778
    name: str

# pydantic_evals/pydantic_evals/_utils.py:49-75
def get_unwrapped_function_name(func: Callable[..., Any]) -> str:
    """Get the name of a function, unwrapping partials and decorators.

    Args:
        func: The function to get the name of.

    Returns:
        The name of the function.

    Raises:
        AttributeError: If the function doesn't have a __name__ attribute and isn't a method.
    """

    def _unwrap(f: Callable[..., Any]) -> Callable[..., Any]:
        """Unwraps f, also unwrapping partials, for the sake of getting f's name."""
        if isinstance(f, partial):
            return _unwrap(f.func)
        return inspect.unwrap(f)

    try:
        return _unwrap(func).__name__
    except AttributeError as e:
        # Handle instances of types with `__call__` as a method
        if inspect.ismethod(getattr(func, '__call__', None)):
            return f'{type(func).__qualname__}.__call__'
        else:
            raise e

# pydantic_ai_slim/pydantic_ai/models/function.py:52-52
    _model_name: str = field(repr=False)

# pydantic_ai_slim/pydantic_ai/models/function.py:354-356
    def provider_name(self) -> None:
        """Get the provider name."""
        return None

# pydantic_ai_slim/pydantic_ai/models/function.py:349-351
    def model_name(self) -> str:
        """Get the model name of the response."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/gemini.py:845-845
    allowed_function_names: list[str]

# tests/test_agent.py:3266-3276
async def test_agent_name_changes():
    my_agent = Agent('test')

    await my_agent.run('Hello')
    assert my_agent.name == 'my_agent'

    new_agent = my_agent
    del my_agent

    await new_agent.run('Hello')
    assert new_agent.name == 'my_agent'

# pydantic_ai_slim/pydantic_ai/toolsets/renamed.py:18-18
    name_map: dict[str, str]

# pydantic_ai_slim/pydantic_ai/_function_schema.py:45-45
    single_arg_name: str | None = None

# tests/evals/test_utils.py:45-51
def test_get_unwrapped_function_name_basic():
    """Test get_unwrapped_function_name with basic function."""

    def test_func():
        pass

    assert get_unwrapped_function_name(test_func) == 'test_func'

# pydantic_ai_slim/pydantic_ai/__init__.py:115-128
from .toolsets import (
    AbstractToolset,
    ApprovalRequiredToolset,
    CombinedToolset,
    ExternalToolset,
    FilteredToolset,
    FunctionToolset,
    PrefixedToolset,
    PreparedToolset,
    RenamedToolset,
    ToolsetFunc,
    ToolsetTool,
    WrapperToolset,
)

# pydantic_ai_slim/pydantic_ai/__init__.py:115-128
from .toolsets import (
    AbstractToolset,
    ApprovalRequiredToolset,
    CombinedToolset,
    ExternalToolset,
    FilteredToolset,
    FunctionToolset,
    PrefixedToolset,
    PreparedToolset,
    RenamedToolset,
    ToolsetFunc,
    ToolsetTool,
    WrapperToolset,
)

# pydantic_ai_slim/pydantic_ai/models/function.py:296-296
    _model_name: str

# tests/evals/test_utils.py:54-61
def test_get_unwrapped_function_name_partial():
    """Test get_unwrapped_function_name with partial function."""

    def test_func(x: int, y: int):
        raise NotImplementedError

    partial_func = partial(test_func, y=42)
    assert get_unwrapped_function_name(partial_func) == 'test_func'

# tests/evals/test_utils.py:94-101
def test_get_unwrapped_function_name_method():
    """Test get_unwrapped_function_name with method."""

    class TestClass:
        def test_method(self):
            pass

    assert get_unwrapped_function_name(TestClass().test_method) == 'test_method'

# tests/evals/test_utils.py:64-78
def test_get_unwrapped_function_name_decorated():
    """Test get_unwrapped_function_name with decorated function."""

    def decorator(func: Callable[..., Any]) -> Callable[..., Any]:
        @functools.wraps(func)
        def wrapper(*args: Any, **kwargs: Any) -> Any:
            raise NotImplementedError

        return wrapper

    @decorator
    def test_func():
        pass

    assert get_unwrapped_function_name(test_func) == 'test_func'

# tests/test_ssrf.py:301-320
class TestResolveHostname:
    """Tests for resolve_hostname function."""

    async def test_resolve_success(self) -> None:
        """Test that hostname resolution returns IP addresses."""
        with patch('pydantic_ai._ssrf.run_in_executor') as mock_executor:
            mock_executor.return_value = [
                (2, 1, 6, '', ('93.184.215.14', 0)),
                (2, 1, 6, '', ('93.184.215.14', 0)),  # Duplicate should be removed
            ]
            ips = await resolve_hostname('example.com')
            assert ips == ['93.184.215.14']

    async def test_resolve_failure(self) -> None:
        """Test that DNS resolution failure raises ValueError."""
        import socket

        with patch('pydantic_ai._ssrf.run_in_executor', side_effect=socket.gaierror('DNS lookup failed')):
            with pytest.raises(ValueError, match='DNS resolution failed for hostname'):
                await resolve_hostname('nonexistent.invalid')

# tests/evals/test_utils.py:104-113
def test_get_unwrapped_function_name_error():
    """Test get_unwrapped_function_name with invalid input."""

    class InvalidCallable:
        pass

    with pytest.raises(AttributeError) as exc_info:
        get_unwrapped_function_name(InvalidCallable())  # type: ignore

    assert str(exc_info.value) == "'InvalidCallable' object has no attribute '__name__'"

# pydantic_ai_slim/pydantic_ai/agent/abstract.py:1155-1172
    def _infer_name(self, function_frame: FrameType | None) -> None:
        """Infer the agent name from the call frame.

        RunUsage should be `self._infer_name(inspect.currentframe())`.
        """
        assert self.name is None, 'Name already set'
        if function_frame is not None:  # pragma: no branch
            if parent_frame := function_frame.f_back:  # pragma: no branch
                for name, item in parent_frame.f_locals.items():
                    if item is self:
                        self.name = name
                        return
                if parent_frame.f_locals != parent_frame.f_globals:  # pragma: no branch
                    # if we couldn't find the agent in locals and globals are a different dict, try globals
                    for name, item in parent_frame.f_globals.items():
                        if item is self:
                            self.name = name
                            return

# pydantic_ai_slim/pydantic_ai/providers/__init__.py:30-32
    def name(self) -> str:
        """The provider name."""
        raise NotImplementedError()

# tests/evals/test_utils.py:81-91
def test_get_unwrapped_function_name_callable_class():
    """Test get_unwrapped_function_name with callable class."""

    class CallableClass:
        def __call__(self):
            pass

    assert (
        get_unwrapped_function_name(CallableClass())
        == 'test_get_unwrapped_function_name_callable_class.<locals>.CallableClass.__call__'
    )

# pydantic_ai_slim/pydantic_ai/_output.py:821-821
    _str_argument_name: str

# pydantic_ai_slim/pydantic_ai/models/__init__.py:780-782
    def model_name(self) -> str:
        """The model name."""
        raise NotImplementedError()

# tests/test_temporal.py:1125-1125
    user_name: str

# tests/test_agent.py:1382-1418
def test_output_type_function_with_custom_tool_name():
    class Weather(BaseModel):
        temperature: float
        description: str

    def get_weather(city: str) -> Weather:
        return Weather(temperature=28.7, description='sunny')

    output_tools = None

    def call_tool(_: list[ModelMessage], info: AgentInfo) -> ModelResponse:
        assert info.output_tools is not None

        nonlocal output_tools
        output_tools = info.output_tools

        args_json = '{"city": "Mexico City"}'
        return ModelResponse(parts=[ToolCallPart(info.output_tools[0].name, args_json)])

    agent = Agent(FunctionModel(call_tool), output_type=ToolOutput(get_weather, name='get_weather'))
    result = agent.run_sync('Mexico City')
    assert result.output == snapshot(Weather(temperature=28.7, description='sunny'))
    assert output_tools == snapshot(
        [
            ToolDefinition(
                name='get_weather',
                description='The final response which ends this conversation',
                parameters_json_schema={
                    'additionalProperties': False,
                    'properties': {'city': {'type': 'string'}},
                    'required': ['city'],
                    'type': 'object',
                },
                kind='output',
            )
        ]
    )

# pydantic_ai_slim/pydantic_ai/providers/outlines.py:13-15
    def name(self) -> str:
        """The provider name."""
        return 'outlines'

# pydantic_graph/pydantic_graph/graph.py:527-545
    def _infer_name(self, function_frame: types.FrameType | None) -> None:
        """Infer the agent name from the call frame.

        Usage should be `self._infer_name(inspect.currentframe())`.

        Copied from `Agent`.
        """
        assert self.name is None, 'Name already set'
        if function_frame is not None and (parent_frame := function_frame.f_back):  # pragma: no branch
            for name, item in parent_frame.f_locals.items():
                if item is self:
                    self.name = name
                    return
            if parent_frame.f_locals != parent_frame.f_globals:  # pragma: no branch
                # if we couldn't find the agent in locals and globals are a different dict, try globals
                for name, item in parent_frame.f_globals.items():  # pragma: no branch
                    if item is self:
                        self.name = name
                        return

# pydantic_ai_slim/pydantic_ai/models/xai.py:192-194
    def model_name(self) -> str:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/__init__.py:115-128
from .toolsets import (
    AbstractToolset,
    ApprovalRequiredToolset,
    CombinedToolset,
    ExternalToolset,
    FilteredToolset,
    FunctionToolset,
    PrefixedToolset,
    PreparedToolset,
    RenamedToolset,
    ToolsetFunc,
    ToolsetTool,
    WrapperToolset,
)

# pydantic_ai_slim/pydantic_ai/models/groq.py:166-168
    def model_name(self) -> GroqModelName:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/test.py:152-154
    def model_name(self) -> str:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/providers/together.py:33-34
    def name(self) -> str:
        return 'together'

# pydantic_ai_slim/pydantic_ai/models/cohere.py:146-148
    def model_name(self) -> CohereModelName:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/gemini.py:160-162
    def model_name(self) -> GeminiModelName:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/google.py:244-246
    def model_name(self) -> GoogleModelName:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/toolsets/abstract.py:170-177
    def renamed(self, name_map: dict[str, str]) -> RenamedToolset[AgentDepsT]:
        """Returns a new toolset that renames this toolset's tools using a dictionary mapping new names to original names.

        See [toolset docs](../toolsets.md#renaming-tools) for more information.
        """
        from .renamed import RenamedToolset

        return RenamedToolset(self, name_map)

# pydantic_ai_slim/pydantic_ai/models/mistral.py:172-174
    def model_name(self) -> MistralModelName:
        """The model name."""
        return self._model_name

# pydantic_graph/pydantic_graph/beta/graph_builder.py:48-48
from pydantic_graph.beta.util import TypeOrTypeExpression, get_callable_name, unpack_type_expression

# pydantic_ai_slim/pydantic_ai/models/fallback.py:57-59
    def model_name(self) -> str:
        """The model name."""
        return f'fallback:{",".join(model.model_name for model in self.models)}'

# pydantic_ai_slim/pydantic_ai/agent/__init__.py:448-450
    def name(self, value: str | None) -> None:
        """Set the name of the agent, used for logging."""
        self._name = value

# pydantic_ai_slim/pydantic_ai/models/anthropic.py:287-289
    def model_name(self) -> AnthropicModelName:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/openai.py:560-562
    def model_name(self) -> OpenAIModelName:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/providers/sambanova.py:36-38
    def name(self) -> str:
        """Return the provider name."""
        return 'sambanova'

# pydantic_ai_slim/pydantic_ai/models/huggingface.py:158-160
    def model_name(self) -> HuggingFaceModelName:
        """The model name."""
        return self._model_name

# tests/evals/test_dataset.py:625-691
async def test_repeated_name_outputs(example_dataset: Dataset[TaskInput, TaskOutput, TaskMetadata]):
    """Test the increment_eval_metric function."""

    async def my_task(inputs: TaskInput) -> TaskOutput:
        return TaskOutput(answer=f'answer to {inputs.query}')

    example_dataset.add_evaluator(MockEvaluator({'output': 'a'}))
    example_dataset.add_evaluator(MockEvaluator({'output': 'b'}))
    example_dataset.add_evaluator(MockEvaluator({'output': 'c'}))

    report = await example_dataset.evaluate(my_task)
    assert report.cases == snapshot(
        [
            ReportCase(
                name='case1',
                inputs=TaskInput(query='What is 2+2?'),
                metadata=TaskMetadata(difficulty='easy', category='general'),
                expected_output=TaskOutput(answer='4', confidence=1.0),
                output=TaskOutput(answer='answer to What is 2+2?', confidence=1.0),
                metrics={},
                attributes={},
                scores={},
                labels={
                    'output': EvaluationResult(
                        name='output', value='a', reason=None, source=MockEvaluator(output={'output': 'a'}).as_spec()
                    ),
                    'output_2': EvaluationResult(
                        name='output', value='b', reason=None, source=MockEvaluator(output={'output': 'b'}).as_spec()
                    ),
                    'output_3': EvaluationResult(
                        name='output', value='c', reason=None, source=MockEvaluator(output={'output': 'c'}).as_spec()
                    ),
                },
                assertions={},
                task_duration=1.0,
                total_duration=18.0,
                trace_id='00000000000000000000000000000001',
                span_id='0000000000000003',
            ),
            ReportCase(
                name='case2',
                inputs=TaskInput(query='What is the capital of France?'),
                metadata=TaskMetadata(difficulty='medium', category='geography'),
                expected_output=TaskOutput(answer='Paris', confidence=1.0),
                output=TaskOutput(answer='answer to What is the capital of France?', confidence=1.0),
                metrics={},
                attributes={},
                scores={},
                labels={
                    'output': EvaluationResult(
                        name='output', value='a', reason=None, source=MockEvaluator(output={'output': 'a'}).as_spec()
                    ),
                    'output_2': EvaluationResult(
                        name='output', value='b', reason=None, source=MockEvaluator(output={'output': 'b'}).as_spec()
                    ),
                    'output_3': EvaluationResult(
                        name='output', value='c', reason=None, source=MockEvaluator(output={'output': 'c'}).as_spec()
                    ),
                },
                assertions={},
                task_duration=1.0,
                total_duration=16.0,
                trace_id='00000000000000000000000000000001',
                span_id='0000000000000007',
            ),
        ]
    )

# pydantic_ai_slim/pydantic_ai/providers/sentence_transformers.py:12-14
    def name(self) -> str:
        """The provider name."""
        return 'sentence-transformers'  # pragma: no cover

# pydantic_ai_slim/pydantic_ai/models/bedrock.py:344-346
    def model_name(self) -> str:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/tools.py:273-273
    name: str

# pydantic_evals/pydantic_evals/dataset.py:132-132
    name: str | None