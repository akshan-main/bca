# pydantic_evals/pydantic_evals/_utils.py:49-75
def get_unwrapped_function_name(func: Callable[..., Any]) -> str:
    """Get the name of a function, unwrapping partials and decorators.

    Args:
        func: The function to get the name of.

    Returns:
        The name of the function.

    Raises:
        AttributeError: If the function doesn't have a __name__ attribute and isn't a method.
    """

    def _unwrap(f: Callable[..., Any]) -> Callable[..., Any]:
        """Unwraps f, also unwrapping partials, for the sake of getting f's name."""
        if isinstance(f, partial):
            return _unwrap(f.func)
        return inspect.unwrap(f)

    try:
        return _unwrap(func).__name__
    except AttributeError as e:
        # Handle instances of types with `__call__` as a method
        if inspect.ismethod(getattr(func, '__call__', None)):
            return f'{type(func).__qualname__}.__call__'
        else:
            raise e

# pydantic_ai_slim/pydantic_ai/models/function.py:195-197
    def model_name(self) -> str:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/gemini.py:822-822
    name: str

# pydantic_ai_slim/pydantic_ai/models/gemini.py:763-763
    name: str

# pydantic_ai_slim/pydantic_ai/models/gemini.py:778-778
    name: str

# pydantic_evals/pydantic_evals/_utils.py:49-75
def get_unwrapped_function_name(func: Callable[..., Any]) -> str:
    """Get the name of a function, unwrapping partials and decorators.

    Args:
        func: The function to get the name of.

    Returns:
        The name of the function.

    Raises:
        AttributeError: If the function doesn't have a __name__ attribute and isn't a method.
    """

    def _unwrap(f: Callable[..., Any]) -> Callable[..., Any]:
        """Unwraps f, also unwrapping partials, for the sake of getting f's name."""
        if isinstance(f, partial):
            return _unwrap(f.func)
        return inspect.unwrap(f)

    try:
        return _unwrap(func).__name__
    except AttributeError as e:
        # Handle instances of types with `__call__` as a method
        if inspect.ismethod(getattr(func, '__call__', None)):
            return f'{type(func).__qualname__}.__call__'
        else:
            raise e

# pydantic_ai_slim/pydantic_ai/models/function.py:52-52
    _model_name: str = field(repr=False)

# pydantic_ai_slim/pydantic_ai/models/function.py:354-356
    def provider_name(self) -> None:
        """Get the provider name."""
        return None

# pydantic_ai_slim/pydantic_ai/models/function.py:349-351
    def model_name(self) -> str:
        """Get the model name of the response."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/gemini.py:845-845
    allowed_function_names: list[str]

# tests/test_agent.py:3266-3276
async def test_agent_name_changes():
    my_agent = Agent('test')

    await my_agent.run('Hello')
    assert my_agent.name == 'my_agent'

    new_agent = my_agent
    del my_agent

    await new_agent.run('Hello')
    assert new_agent.name == 'my_agent'

# pydantic_ai_slim/pydantic_ai/toolsets/renamed.py:18-18
    name_map: dict[str, str]

# pydantic_ai_slim/pydantic_ai/_function_schema.py:45-45
    single_arg_name: str | None = None

# tests/evals/test_utils.py:45-51
def test_get_unwrapped_function_name_basic():
    """Test get_unwrapped_function_name with basic function."""

    def test_func():
        pass

    assert get_unwrapped_function_name(test_func) == 'test_func'

# pydantic_ai_slim/pydantic_ai/__init__.py:115-128
from .toolsets import (
    AbstractToolset,
    ApprovalRequiredToolset,
    CombinedToolset,
    ExternalToolset,
    FilteredToolset,
    FunctionToolset,
    PrefixedToolset,
    PreparedToolset,
    RenamedToolset,
    ToolsetFunc,
    ToolsetTool,
    WrapperToolset,
)

# pydantic_ai_slim/pydantic_ai/__init__.py:115-128
from .toolsets import (
    AbstractToolset,
    ApprovalRequiredToolset,
    CombinedToolset,
    ExternalToolset,
    FilteredToolset,
    FunctionToolset,
    PrefixedToolset,
    PreparedToolset,
    RenamedToolset,
    ToolsetFunc,
    ToolsetTool,
    WrapperToolset,
)

# pydantic_ai_slim/pydantic_ai/models/function.py:296-296
    _model_name: str

# tests/evals/test_utils.py:54-61
def test_get_unwrapped_function_name_partial():
    """Test get_unwrapped_function_name with partial function."""

    def test_func(x: int, y: int):
        raise NotImplementedError

    partial_func = partial(test_func, y=42)
    assert get_unwrapped_function_name(partial_func) == 'test_func'

# tests/evals/test_utils.py:94-101
def test_get_unwrapped_function_name_method():
    """Test get_unwrapped_function_name with method."""

    class TestClass:
        def test_method(self):
            pass

    assert get_unwrapped_function_name(TestClass().test_method) == 'test_method'

# tests/evals/test_utils.py:64-78
def test_get_unwrapped_function_name_decorated():
    """Test get_unwrapped_function_name with decorated function."""

    def decorator(func: Callable[..., Any]) -> Callable[..., Any]:
        @functools.wraps(func)
        def wrapper(*args: Any, **kwargs: Any) -> Any:
            raise NotImplementedError

        return wrapper

    @decorator
    def test_func():
        pass

    assert get_unwrapped_function_name(test_func) == 'test_func'

# tests/test_ssrf.py:301-320
class TestResolveHostname:
    """Tests for resolve_hostname function."""

    async def test_resolve_success(self) -> None:
        """Test that hostname resolution returns IP addresses."""
        with patch('pydantic_ai._ssrf.run_in_executor') as mock_executor:
            mock_executor.return_value = [
                (2, 1, 6, '', ('93.184.215.14', 0)),
                (2, 1, 6, '', ('93.184.215.14', 0)),  # Duplicate should be removed
            ]
            ips = await resolve_hostname('example.com')
            assert ips == ['93.184.215.14']

    async def test_resolve_failure(self) -> None:
        """Test that DNS resolution failure raises ValueError."""
        import socket

        with patch('pydantic_ai._ssrf.run_in_executor', side_effect=socket.gaierror('DNS lookup failed')):
            with pytest.raises(ValueError, match='DNS resolution failed for hostname'):
                await resolve_hostname('nonexistent.invalid')

# tests/evals/test_utils.py:104-113
def test_get_unwrapped_function_name_error():
    """Test get_unwrapped_function_name with invalid input."""

    class InvalidCallable:
        pass

    with pytest.raises(AttributeError) as exc_info:
        get_unwrapped_function_name(InvalidCallable())  # type: ignore

    assert str(exc_info.value) == "'InvalidCallable' object has no attribute '__name__'"

# pydantic_ai_slim/pydantic_ai/agent/abstract.py:1155-1172
    def _infer_name(self, function_frame: FrameType | None) -> None:
        """Infer the agent name from the call frame.

        RunUsage should be `self._infer_name(inspect.currentframe())`.
        """
        assert self.name is None, 'Name already set'
        if function_frame is not None:  # pragma: no branch
            if parent_frame := function_frame.f_back:  # pragma: no branch
                for name, item in parent_frame.f_locals.items():
                    if item is self:
                        self.name = name
                        return
                if parent_frame.f_locals != parent_frame.f_globals:  # pragma: no branch
                    # if we couldn't find the agent in locals and globals are a different dict, try globals
                    for name, item in parent_frame.f_globals.items():
                        if item is self:
                            self.name = name
                            return

# pydantic_ai_slim/pydantic_ai/providers/__init__.py:30-32
    def name(self) -> str:
        """The provider name."""
        raise NotImplementedError()

# tests/evals/test_utils.py:81-91
def test_get_unwrapped_function_name_callable_class():
    """Test get_unwrapped_function_name with callable class."""

    class CallableClass:
        def __call__(self):
            pass

    assert (
        get_unwrapped_function_name(CallableClass())
        == 'test_get_unwrapped_function_name_callable_class.<locals>.CallableClass.__call__'
    )

# pydantic_ai_slim/pydantic_ai/_output.py:821-821
    _str_argument_name: str

# pydantic_ai_slim/pydantic_ai/models/__init__.py:780-782
    def model_name(self) -> str:
        """The model name."""
        raise NotImplementedError()

# tests/test_temporal.py:1125-1125
    user_name: str

# tests/test_agent.py:1382-1418
def test_output_type_function_with_custom_tool_name():
    class Weather(BaseModel):
        temperature: float
        description: str

    def get_weather(city: str) -> Weather:
        return Weather(temperature=28.7, description='sunny')

    output_tools = None

    def call_tool(_: list[ModelMessage], info: AgentInfo) -> ModelResponse:
        assert info.output_tools is not None

        nonlocal output_tools
        output_tools = info.output_tools

        args_json = '{"city": "Mexico City"}'
        return ModelResponse(parts=[ToolCallPart(info.output_tools[0].name, args_json)])

    agent = Agent(FunctionModel(call_tool), output_type=ToolOutput(get_weather, name='get_weather'))
    result = agent.run_sync('Mexico City')
    assert result.output == snapshot(Weather(temperature=28.7, description='sunny'))
    assert output_tools == snapshot(
        [
            ToolDefinition(
                name='get_weather',
                description='The final response which ends this conversation',
                parameters_json_schema={
                    'additionalProperties': False,
                    'properties': {'city': {'type': 'string'}},
                    'required': ['city'],
                    'type': 'object',
                },
                kind='output',
            )
        ]
    )

# pydantic_ai_slim/pydantic_ai/providers/outlines.py:13-15
    def name(self) -> str:
        """The provider name."""
        return 'outlines'

# pydantic_graph/pydantic_graph/graph.py:527-545
    def _infer_name(self, function_frame: types.FrameType | None) -> None:
        """Infer the agent name from the call frame.

        Usage should be `self._infer_name(inspect.currentframe())`.

        Copied from `Agent`.
        """
        assert self.name is None, 'Name already set'
        if function_frame is not None and (parent_frame := function_frame.f_back):  # pragma: no branch
            for name, item in parent_frame.f_locals.items():
                if item is self:
                    self.name = name
                    return
            if parent_frame.f_locals != parent_frame.f_globals:  # pragma: no branch
                # if we couldn't find the agent in locals and globals are a different dict, try globals
                for name, item in parent_frame.f_globals.items():  # pragma: no branch
                    if item is self:
                        self.name = name
                        return

# pydantic_ai_slim/pydantic_ai/models/xai.py:192-194
    def model_name(self) -> str:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/__init__.py:115-128
from .toolsets import (
    AbstractToolset,
    ApprovalRequiredToolset,
    CombinedToolset,
    ExternalToolset,
    FilteredToolset,
    FunctionToolset,
    PrefixedToolset,
    PreparedToolset,
    RenamedToolset,
    ToolsetFunc,
    ToolsetTool,
    WrapperToolset,
)

# pydantic_ai_slim/pydantic_ai/models/groq.py:166-168
    def model_name(self) -> GroqModelName:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/test.py:152-154
    def model_name(self) -> str:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/providers/together.py:33-34
    def name(self) -> str:
        return 'together'

# pydantic_ai_slim/pydantic_ai/models/cohere.py:146-148
    def model_name(self) -> CohereModelName:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/gemini.py:160-162
    def model_name(self) -> GeminiModelName:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/google.py:244-246
    def model_name(self) -> GoogleModelName:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/toolsets/abstract.py:170-177
    def renamed(self, name_map: dict[str, str]) -> RenamedToolset[AgentDepsT]:
        """Returns a new toolset that renames this toolset's tools using a dictionary mapping new names to original names.

        See [toolset docs](../toolsets.md#renaming-tools) for more information.
        """
        from .renamed import RenamedToolset

        return RenamedToolset(self, name_map)

# pydantic_ai_slim/pydantic_ai/models/mistral.py:172-174
    def model_name(self) -> MistralModelName:
        """The model name."""
        return self._model_name

# pydantic_graph/pydantic_graph/beta/graph_builder.py:48-48
from pydantic_graph.beta.util import TypeOrTypeExpression, get_callable_name, unpack_type_expression

# pydantic_ai_slim/pydantic_ai/models/fallback.py:57-59
    def model_name(self) -> str:
        """The model name."""
        return f'fallback:{",".join(model.model_name for model in self.models)}'

# pydantic_ai_slim/pydantic_ai/agent/__init__.py:448-450
    def name(self, value: str | None) -> None:
        """Set the name of the agent, used for logging."""
        self._name = value

# pydantic_ai_slim/pydantic_ai/models/anthropic.py:287-289
    def model_name(self) -> AnthropicModelName:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/openai.py:560-562
    def model_name(self) -> OpenAIModelName:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/providers/sambanova.py:36-38
    def name(self) -> str:
        """Return the provider name."""
        return 'sambanova'

# pydantic_ai_slim/pydantic_ai/models/huggingface.py:158-160
    def model_name(self) -> HuggingFaceModelName:
        """The model name."""
        return self._model_name

# tests/evals/test_dataset.py:625-691
async def test_repeated_name_outputs(example_dataset: Dataset[TaskInput, TaskOutput, TaskMetadata]):
    """Test the increment_eval_metric function."""

    async def my_task(inputs: TaskInput) -> TaskOutput:
        return TaskOutput(answer=f'answer to {inputs.query}')

    example_dataset.add_evaluator(MockEvaluator({'output': 'a'}))
    example_dataset.add_evaluator(MockEvaluator({'output': 'b'}))
    example_dataset.add_evaluator(MockEvaluator({'output': 'c'}))

    report = await example_dataset.evaluate(my_task)
    assert report.cases == snapshot(
        [
            ReportCase(
                name='case1',
                inputs=TaskInput(query='What is 2+2?'),
                metadata=TaskMetadata(difficulty='easy', category='general'),
                expected_output=TaskOutput(answer='4', confidence=1.0),
                output=TaskOutput(answer='answer to What is 2+2?', confidence=1.0),
                metrics={},
                attributes={},
                scores={},
                labels={
                    'output': EvaluationResult(
                        name='output', value='a', reason=None, source=MockEvaluator(output={'output': 'a'}).as_spec()
                    ),
                    'output_2': EvaluationResult(
                        name='output', value='b', reason=None, source=MockEvaluator(output={'output': 'b'}).as_spec()
                    ),
                    'output_3': EvaluationResult(
                        name='output', value='c', reason=None, source=MockEvaluator(output={'output': 'c'}).as_spec()
                    ),
                },
                assertions={},
                task_duration=1.0,
                total_duration=18.0,
                trace_id='00000000000000000000000000000001',
                span_id='0000000000000003',
            ),
            ReportCase(
                name='case2',
                inputs=TaskInput(query='What is the capital of France?'),
                metadata=TaskMetadata(difficulty='medium', category='geography'),
                expected_output=TaskOutput(answer='Paris', confidence=1.0),
                output=TaskOutput(answer='answer to What is the capital of France?', confidence=1.0),
                metrics={},
                attributes={},
                scores={},
                labels={
                    'output': EvaluationResult(
                        name='output', value='a', reason=None, source=MockEvaluator(output={'output': 'a'}).as_spec()
                    ),
                    'output_2': EvaluationResult(
                        name='output', value='b', reason=None, source=MockEvaluator(output={'output': 'b'}).as_spec()
                    ),
                    'output_3': EvaluationResult(
                        name='output', value='c', reason=None, source=MockEvaluator(output={'output': 'c'}).as_spec()
                    ),
                },
                assertions={},
                task_duration=1.0,
                total_duration=16.0,
                trace_id='00000000000000000000000000000001',
                span_id='0000000000000007',
            ),
        ]
    )

# pydantic_ai_slim/pydantic_ai/providers/sentence_transformers.py:12-14
    def name(self) -> str:
        """The provider name."""
        return 'sentence-transformers'  # pragma: no cover

# pydantic_ai_slim/pydantic_ai/models/bedrock.py:344-346
    def model_name(self) -> str:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/openai.py:1336-1338
    def model_name(self) -> OpenAIModelName:
        """The model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/tools.py:273-273
    name: str

# pydantic_evals/pydantic_evals/dataset.py:132-132
    name: str | None

# tests/test_native_output_schema.py:10-10
    name: str

# pydantic_ai_slim/pydantic_ai/agent/abstract.py:101-103
    def name(self, value: str | None) -> None:
        """Set the name of the agent, used for logging."""
        raise NotImplementedError

# examples/pydantic_ai_examples/stream_whales.py:28-28
    name: str

# pydantic_graph/pydantic_graph/beta/graph.py:123-123
    name: str | None

# pydantic_graph/pydantic_graph/beta/graph.py:123-123
    name: str | None

# pydantic_ai_slim/pydantic_ai/embeddings/base.py:47-49
    def model_name(self) -> str:
        """The name of the embedding model."""
        raise NotImplementedError()

# tests/test_agent.py:104-104
    name: str

# pydantic_ai_slim/pydantic_ai/agent/__init__.py:127-127
    _name: str | None

# pydantic_evals/pydantic_evals/dataset.py:228-228
    name: str | None = None

# pydantic_evals/pydantic_evals/evaluators/evaluator.py:142-144
    def name(cls) -> str:
        """`name` has been renamed, use `get_serialization_name` instead."""
        return cls.get_serialization_name()

# pydantic_evals/pydantic_evals/otel/span_tree.py:85-85
    name: str

# pydantic_ai_slim/pydantic_ai/models/__init__.py:1035-1037
    def model_name(self) -> str:
        """Get the model name of the response."""
        raise NotImplementedError()

# pydantic_ai_slim/pydantic_ai/durable_exec/dbos/_agent.py:235-238
    def name(self, value: str | None) -> None:  # pragma: no cover
        raise UserError(
            'The agent name cannot be changed after creation. If you need to change the name, create a new agent.'
        )

# pydantic_ai_slim/pydantic_ai/ui/_web/api.py:30-30
    name: str

# pydantic_ai_slim/pydantic_ai/embeddings/test.py:88-90
    def model_name(self) -> str:
        """The embedding model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/embeddings/bedrock.py:223-223
    model_name: str

# pydantic_ai_slim/pydantic_ai/toolsets/renamed.py:20-34
    async def get_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:
        original_to_new_name_map = {v: k for k, v in self.name_map.items()}
        original_tools = await super().get_tools(ctx)
        tools: dict[str, ToolsetTool[AgentDepsT]] = {}
        for original_name, tool in original_tools.items():
            new_name = original_to_new_name_map.get(original_name, None)
            if new_name:
                tools[new_name] = replace(
                    tool,
                    toolset=self,
                    tool_def=replace(tool.tool_def, name=new_name),
                )
            else:
                tools[original_name] = tool
        return tools

# pydantic_ai_slim/pydantic_ai/concurrency.py:141-143
    def name(self) -> str | None:
        """Name of the limiter for observability."""
        return self._name

# pydantic_ai_slim/pydantic_ai/models/__init__.py:1041-1043
    def provider_name(self) -> str | None:
        """Get the provider name."""
        raise NotImplementedError()

# examples/pydantic_ai_examples/ag_ui/api/shared_state.py:53-53
    name: str

# pydantic_ai_slim/pydantic_ai/output.py:111-111
    name: str | None

# pydantic_evals/pydantic_evals/dataset.py:92-92
    name: str | None = None

# pydantic_evals/pydantic_evals/reporting/__init__.py:72-72
    name: str

# pydantic_ai_slim/pydantic_ai/models/xai.py:886-888
    def model_name(self) -> str:
        """Get the model name of the response."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/embeddings/cohere.py:139-141
    def model_name(self) -> CohereEmbeddingModelName:
        """The embedding model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/embeddings/google.py:141-143
    def model_name(self) -> GoogleEmbeddingModelName:
        """The embedding model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/embeddings/openai.py:109-111
    def model_name(self) -> OpenAIEmbeddingModelName:
        """The embedding model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/direct.py:395-397
    def model_name(self) -> str:
        """Get the model name of the response."""
        return self._ensure_stream_ready().model_name

# pydantic_ai_slim/pydantic_ai/models/groq.py:622-624
    def model_name(self) -> GroqModelName:
        """Get the model name of the response."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/test.py:347-349
    def model_name(self) -> str:
        """Get the model name of the response."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/providers/xai.py:24-25
    def name(self) -> str:
        return 'xai'

# tests/test_a2a.py:53-53
    name: str

# tests/test_logfire.py:38-38
    name: str

# pydantic_ai_slim/pydantic_ai/embeddings/bedrock.py:553-555
    def model_name(self) -> BedrockEmbeddingModelName:
        """The embedding model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/embeddings/voyageai.py:138-140
    def model_name(self) -> VoyageAIEmbeddingModelName:
        """The embedding model name."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/gemini.py:531-533
    def model_name(self) -> GeminiModelName:
        """Get the model name of the response."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/gemini.py:531-533
    def model_name(self) -> GeminiModelName:
        """Get the model name of the response."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/openai.py:2334-2336
    def model_name(self) -> OpenAIModelName:
        """Get the model name of the response."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/_otel_messages.py:22-22
    name: str

# pydantic_ai_slim/pydantic_ai/agent/wrapper.py:47-48
    def name(self, value: str | None) -> None:
        self.wrapped.name = value

# pydantic_ai_slim/pydantic_ai/durable_exec/prefect/_agent.py:127-130
    def name(self, value: str | None) -> None:  # pragma: no cover
        raise UserError(
            'The agent name cannot be changed after creation. If you need to change the name, create a new agent.'
        )

# pydantic_ai_slim/pydantic_ai/mcp.py:131-131
    name: str

# pydantic_ai_slim/pydantic_ai/output.py:162-162
    name: str | None

# pydantic_ai_slim/pydantic_ai/providers/grok.py:54-55
    def name(self) -> str:
        return 'grok'

# pydantic_ai_slim/pydantic_ai/providers/groq.py:51-52
    def name(self) -> str:
        return 'groq'

# pydantic_graph/pydantic_graph/beta/graph_builder.py:79-79
    name: str | None

# tests/test_toolsets.py:194-227
async def test_prepared_toolset_user_error_change_tool_names():
    """Test that PreparedToolset raises UserError when prepare function tries to change tool names."""
    context = build_run_context(None)
    base_toolset = FunctionToolset[None]()

    @base_toolset.tool
    def add(a: int, b: int) -> int:
        """Add two numbers"""
        return a + b  # pragma: no cover

    @base_toolset.tool
    def subtract(a: int, b: int) -> int:
        """Subtract two numbers"""
        return a - b  # pragma: no cover

    async def prepare_change_names(ctx: RunContext[None], tool_defs: list[ToolDefinition]) -> list[ToolDefinition]:
        # Try to change the name of an existing tool
        modified_tool_defs: list[ToolDefinition] = []
        for tool_def in tool_defs:
            if tool_def.name == 'add':
                modified_tool_defs.append(replace(tool_def, name='modified_add'))
            else:
                modified_tool_defs.append(tool_def)
        return modified_tool_defs

    prepared_toolset = PreparedToolset(base_toolset, prepare_change_names)

    with pytest.raises(
        UserError,
        match=re.escape(
            'Prepare function cannot add or rename tools. Use `FunctionToolset.add_function()` or `RenamedToolset` instead.'
        ),
    ):
        await ToolManager[None](prepared_toolset).for_run_step(context)

# pydantic_ai_slim/pydantic_ai/models/groq.py:627-629
    def provider_name(self) -> str:
        """Get the provider name."""
        return self._provider_name

# pydantic_ai_slim/pydantic_ai/models/test.py:352-354
    def provider_name(self) -> str:
        """Get the provider name."""
        return self._provider_name

# pydantic_ai_slim/pydantic_ai/models/bedrock.py:1129-1131
    def model_name(self) -> str:
        """Get the model name of the response."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/mistral.py:682-684
    def model_name(self) -> MistralModelName:
        """Get the model name of the response."""
        return self._model_name

# .github/set_docs_main_preview_url.py:17-17
worker_name = m.group(1)

# .github/set_docs_main_preview_url.py:17-17
worker_name = m.group(1)

# pydantic_ai_slim/pydantic_ai/durable_exec/temporal/_agent.py:210-213
    def name(self, value: str | None) -> None:  # pragma: no cover
        raise UserError(
            'The agent name cannot be changed after creation. If you need to change the name, create a new agent.'
        )

# pydantic_ai_slim/pydantic_ai/ext/langchain.py:21-21
    def name(self) -> str: ...

# pydantic_ai_slim/pydantic_ai/models/function.py:244-244
    name: str | None = None

# pydantic_ai_slim/pydantic_ai/providers/azure.py:36-37
    def name(self) -> str:
        return 'azure'

# pydantic_evals/pydantic_evals/dataset.py:104-104
    name: str | None = None

# pydantic_evals/pydantic_evals/evaluators/spec.py:35-35
    name: str

# pydantic_ai_slim/pydantic_ai/models/outlines.py:551-553
    def model_name(self) -> str:
        """Get the model name of the response."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/anthropic.py:1359-1361
    def model_name(self) -> AnthropicModelName:
        """Get the model name of the response."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/gemini.py:536-538
    def provider_name(self) -> str:
        """Get the provider name."""
        return self._provider_name

# pydantic_ai_slim/pydantic_ai/models/gemini.py:536-538
    def provider_name(self) -> str:
        """Get the provider name."""
        return self._provider_name

# pydantic_ai_slim/pydantic_ai/models/openai.py:2339-2341
    def provider_name(self) -> str:
        """Get the provider name."""
        return self._provider_name

# pydantic_ai_slim/pydantic_ai/durable_exec/temporal/_toolset.py:31-31
    name: str

# pydantic_ai_slim/pydantic_ai/output.py:235-235
    name: str | None

# pydantic_ai_slim/pydantic_ai/providers/cohere.py:26-27
    def name(self) -> str:
        return 'cohere'

# pydantic_ai_slim/pydantic_ai/providers/github.py:36-37
    def name(self) -> str:
        return 'github'

# pydantic_ai_slim/pydantic_ai/providers/google.py:29-30
    def name(self) -> str:
        return 'google-vertex' if self._client._api_client.vertexai else 'google-gla'  # type: ignore[reportPrivateUsage]

# pydantic_ai_slim/pydantic_ai/providers/heroku.py:28-29
    def name(self) -> str:
        return 'heroku'

# pydantic_ai_slim/pydantic_ai/providers/nebius.py:34-35
    def name(self) -> str:
        return 'nebius'

# pydantic_ai_slim/pydantic_ai/providers/ollama.py:34-35
    def name(self) -> str:
        return 'ollama'

# pydantic_ai_slim/pydantic_ai/providers/openai.py:26-27
    def name(self) -> str:
        return 'openai'

# pydantic_ai_slim/pydantic_ai/providers/vercel.py:34-35
    def name(self) -> str:
        return 'vercel'

# pydantic_ai_slim/pydantic_ai/tools.py:482-482
    name: str

# pydantic_ai_slim/pydantic_ai/models/bedrock.py:1134-1136
    def provider_name(self) -> str:
        """Get the provider name."""
        return self._provider_name

# pydantic_ai_slim/pydantic_ai/models/mistral.py:687-689
    def provider_name(self) -> str:
        """Get the provider name."""
        return self._provider_name

# pydantic_ai_slim/pydantic_ai/models/huggingface.py:513-515
    def model_name(self) -> str:
        """Get the model name of the response."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/models/xai.py:69-69
XaiModelName = str | ChatModel

# pydantic_ai_slim/pydantic_ai/providers/alibaba.py:29-30
    def name(self) -> str:
        return 'alibaba'

# pydantic_ai_slim/pydantic_ai/providers/bedrock.py:99-100
    def name(self) -> str:
        return 'bedrock'

# pydantic_ai_slim/pydantic_ai/providers/litellm.py:37-38
    def name(self) -> str:
        return 'litellm'

# pydantic_ai_slim/pydantic_ai/providers/mistral.py:27-28
    def name(self) -> str:
        return 'mistral'

# pydantic_ai_slim/pydantic_ai/ui/_web/api.py:38-38
    name: str

# pydantic_evals/pydantic_evals/reporting/__init__.py:145-145
    name: str

# pydantic_ai_slim/pydantic_ai/models/outlines.py:556-558
    def provider_name(self) -> str:
        """Get the provider name."""
        return self._provider_name

# pydantic_ai_slim/pydantic_ai/_instrumentation.py:22-22
    tool_span_name: str

# tests/models/test_xai.py:4803-4829
async def test_xai_stream_empty_tool_call_name(allow_model_requests: None):
    """Test streaming skips tool calls with empty function name."""
    # Create a tool call with empty name
    empty_name_tool_call = chat_pb2.ToolCall(
        id='empty_name_001',
        type=chat_pb2.ToolCallType.TOOL_CALL_TYPE_CLIENT_SIDE_TOOL,
        function=chat_pb2.FunctionCall(name='', arguments='{}'),  # Empty name
    )

    # Create a streaming response with a tool call that has an empty name
    chunk = create_stream_chunk(content='Hello', finish_reason='stop')
    response = create_response_with_tool_calls(
        content='Hello',
        tool_calls=[empty_name_tool_call],
        finish_reason='stop',
        usage=create_usage(prompt_tokens=5, completion_tokens=2),
    )

    stream = [(response, chunk)]
    mock_client = MockXai.create_mock_stream([stream])
    m = XaiModel(XAI_NON_REASONING_MODEL, provider=XaiProvider(xai_client=mock_client))
    agent = Agent(m)

    async with agent.run_stream('Hello') as result:
        text_chunks = [c async for c in result.stream_text(debounce_by=None)]
        # Should get text, but skip the empty-name tool call
        assert 'Hello' in text_chunks[-1]

# pydantic_ai_slim/pydantic_ai/models/anthropic.py:1364-1366
    def provider_name(self) -> str:
        """Get the provider name."""
        return self._provider_name

# pydantic_ai_slim/pydantic_ai/providers/cerebras.py:31-32
    def name(self) -> str:
        return 'cerebras'

# pydantic_ai_slim/pydantic_ai/providers/deepseek.py:32-33
    def name(self) -> str:
        return 'deepseek'

# pydantic_ai_slim/pydantic_ai/providers/ovhcloud.py:32-33
    def name(self) -> str:
        return 'ovhcloud'

# pydantic_ai_slim/pydantic_ai/providers/voyageai.py:22-23
    def name(self) -> str:
        return 'voyageai'

# pydantic_evals/pydantic_evals/evaluators/context.py:55-55
    name: str | None

# pydantic_evals/pydantic_evals/evaluators/evaluator.py:72-72
    name: str

# pydantic_evals/pydantic_evals/evaluators/evaluator.py:101-101
    name: str

# pydantic_evals/pydantic_evals/reporting/__init__.py:302-302
    name: str

# tests/test_format_as_xml.py:21-21
    name: str

# pydantic_ai_slim/pydantic_ai/toolsets/prefixed.py:21-22
    def tool_name_conflict_hint(self) -> str:
        return 'Change the `prefix` attribute to avoid name conflicts.'

# pydantic_ai_slim/pydantic_ai/_instrumentation.py:19-19
    agent_name_attr: str

# examples/pydantic_ai_examples/slack_lead_qualifier/models.py:13-13
    last_name: str | None = None

# pydantic_ai_slim/pydantic_ai/models/groq.py:89-89
GroqModelName = str | ProductionGroqModelNames | PreviewGroqModelNames

# pydantic_ai_slim/pydantic_ai/providers/anthropic.py:33-34
    def name(self) -> str:
        return 'anthropic'

# pydantic_ai_slim/pydantic_ai/providers/fireworks.py:33-34
    def name(self) -> str:
        return 'fireworks'

# pydantic_ai_slim/pydantic_ai/providers/google_gla.py:20-21
    def name(self):
        return 'google-gla'

# pydantic_ai_slim/pydantic_ai/providers/grok.py:26-43
GrokModelName = Literal[
    'grok-4',
    'grok-4-0709',
    'grok-4-latest',
    'grok-4-1-fast',
    'grok-4-1-fast-reasoning',
    'grok-4-1-fast-non-reasoning',
    'grok-4-fast',
    'grok-4-fast-reasoning',
    'grok-4-fast-non-reasoning',
    'grok-code-fast-1',
    'grok-3',
    'grok-3-mini',
    'grok-3-fast',
    'grok-3-mini-fast',
    'grok-2-vision-1212',
    'grok-2-image-1212',
]

# pydantic_evals/pydantic_evals/reporting/__init__.py:109-109
    name: str

# pydantic_ai_slim/pydantic_ai/models/huggingface.py:518-520
    def provider_name(self) -> str:
        """Get the provider name."""
        return self._provider_name

# pydantic_ai_slim/pydantic_ai/models/openai.py:2727-2729
    def model_name(self) -> OpenAIModelName:
        """Get the model name of the response."""
        return self._model_name

# pydantic_ai_slim/pydantic_ai/_instrumentation.py:71-82
    def get_tool_span_name(self, tool_name: str) -> str:
        """Get the formatted tool span name.

        Args:
            tool_name: Name of the tool being executed

        Returns:
            Formatted span name
        """
        if self.tool_span_name == 'execute_tool':
            return f'execute_tool {tool_name}'
        return self.tool_span_name

# pydantic_ai_slim/pydantic_ai/providers/moonshotai.py:36-37
    def name(self) -> str:
        return 'moonshotai'

# pydantic_ai_slim/pydantic_ai/providers/openrouter.py:98-99
    def name(self) -> str:
        return 'openrouter'

# pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py:86-86
    filename: str | None = None

# pydantic_ai_slim/pydantic_ai/embeddings/sentence_transformers.py:115-117
    def model_name(self) -> str:
        """The embedding model name."""
        return self._model_name

# examples/pydantic_ai_examples/slack_lead_qualifier/models.py:12-12
    first_name: str | None = None

# examples/pydantic_ai_examples/stream_markdown.py:19-19
from pydantic_ai.models import KnownModelName

# examples/pydantic_ai_examples/stream_markdown.py:19-19
from pydantic_ai.models import KnownModelName

# pydantic_ai_slim/pydantic_ai/_ssrf.py:61-61
    hostname: str

# examples/pydantic_ai_examples/stream_markdown.py:19-19
from pydantic_ai.models import KnownModelName

# examples/pydantic_ai_examples/stream_markdown.py:19-19
from pydantic_ai.models import KnownModelName

# examples/pydantic_ai_examples/stream_markdown.py:19-19
from pydantic_ai.models import KnownModelName

# examples/pydantic_ai_examples/stream_markdown.py:19-19
from pydantic_ai.models import KnownModelName

# examples/pydantic_ai_examples/stream_markdown.py:19-19
from pydantic_ai.models import KnownModelName

# pydantic_ai_slim/pydantic_ai/providers/huggingface.py:32-33
    def name(self) -> str:
        return 'huggingface'

# examples/pydantic_ai_examples/stream_markdown.py:19-19
from pydantic_ai.models import KnownModelName

# examples/pydantic_ai_examples/stream_markdown.py:19-19
from pydantic_ai.models import KnownModelName

# examples/pydantic_ai_examples/stream_markdown.py:19-19
from pydantic_ai.models import KnownModelName

# pydantic_evals/pydantic_evals/reporting/__init__.py:166-166
    name: str

# pydantic_graph/pydantic_graph/_utils.py:169-204
def infer_obj_name(obj: Any, *, depth: int) -> str | None:
    """Infer the variable name of an object from the calling frame's scope.

    This function examines the call stack to find what variable name was used
    for the given object in the calling scope. This is useful for automatic
    naming of objects based on their variable names.

    Args:
        obj: The object whose variable name to infer.
        depth: Number of stack frames to traverse upward from the current frame.

    Returns:
        The inferred variable name if found, None otherwise.

    Example:
        Usage should generally look like `infer_name(self, depth=2)` or similar.
    """
    target_frame = inspect.currentframe()
    if target_frame is None:
        return None  # pragma: no cover
    for _ in range(depth):
        target_frame = target_frame.f_back
        if target_frame is None:
            return None

    for name, item in target_frame.f_locals.items():
        if item is obj:
            return name

    if target_frame.f_locals != target_frame.f_globals:  # pragma: no branch
        # if we couldn't find the agent in locals and globals are a different dict, try globals
        for name, item in target_frame.f_globals.items():
            if item is obj:
                return name

    return None

# pydantic_graph/pydantic_graph/_utils.py:169-204
def infer_obj_name(obj: Any, *, depth: int) -> str | None:
    """Infer the variable name of an object from the calling frame's scope.

    This function examines the call stack to find what variable name was used
    for the given object in the calling scope. This is useful for automatic
    naming of objects based on their variable names.

    Args:
        obj: The object whose variable name to infer.
        depth: Number of stack frames to traverse upward from the current frame.

    Returns:
        The inferred variable name if found, None otherwise.

    Example:
        Usage should generally look like `infer_name(self, depth=2)` or similar.
    """
    target_frame = inspect.currentframe()
    if target_frame is None:
        return None  # pragma: no cover
    for _ in range(depth):
        target_frame = target_frame.f_back
        if target_frame is None:
            return None

    for name, item in target_frame.f_locals.items():
        if item is obj:
            return name

    if target_frame.f_locals != target_frame.f_globals:  # pragma: no branch
        # if we couldn't find the agent in locals and globals are a different dict, try globals
        for name, item in target_frame.f_globals.items():
            if item is obj:
                return name

    return None

# tests/models/test_instrumented.py:65-66
    def model_name(self) -> str:
        return 'gpt-4o'

# examples/pydantic_ai_examples/stream_markdown.py:19-19
from pydantic_ai.models import KnownModelName

# tests/test_dbos.py:942-943
async def get_model_name(ctx: RunContext[UnserializableDeps]) -> int:
    return ctx.deps.client.max_redirects  # pragma: lax no cover

# examples/pydantic_ai_examples/stream_markdown.py:19-19
from pydantic_ai.models import KnownModelName

# tests/test_dbos.py:942-943
async def get_model_name(ctx: RunContext[UnserializableDeps]) -> int:
    return ctx.deps.client.max_redirects  # pragma: lax no cover

# tests/test_tools.py:833-841
def test_tool_name():
    agent = Agent(FunctionModel(get_json_schema))

    def my_tool(ctx: RunContext, arg: str) -> str: ...  # pragma: no branch

    agent.tool(name='foo_tool')(my_tool)
    result = agent.run_sync('Hello')
    json_schema = json.loads(result.output)
    assert json_schema['name'] == 'foo_tool'

# tests/test_logfire.py:1748-1807
def test_output_type_function_with_custom_tool_name_logfire_attributes(
    get_logfire_summary: Callable[[], LogfireSummary],
    include_content: bool,
) -> None:
    def call_tool(_: list[ModelMessage], info: AgentInfo) -> ModelResponse:
        assert info.output_tools is not None
        args_json = '{"city": "Mexico City"}'
        return ModelResponse(parts=[ToolCallPart(info.output_tools[0].name, args_json)])

    from pydantic_ai.output import ToolOutput

    instrumentation_settings = InstrumentationSettings(include_content=include_content)
    my_agent = Agent(model=FunctionModel(call_tool), instrument=instrumentation_settings)

    result = my_agent.run_sync('Mexico City', output_type=ToolOutput(get_weather_info, name='get_weather'))
    assert result.output == WeatherInfo(temperature=28.7, description='sunny')

    summary = get_logfire_summary()

    # Find the output function span attributes with custom tool name
    [output_function_attributes] = [
        attributes for attributes in summary.attributes.values() if attributes.get('gen_ai.tool.name') == 'get_weather'
    ]

    if include_content:
        assert output_function_attributes == snapshot(
            {
                'gen_ai.tool.name': 'get_weather',
                'gen_ai.tool.call.id': IsStr(),
                'tool_arguments': '{"city":"Mexico City"}',
                'logfire.msg': 'running output function: get_weather',
                'logfire.json_schema': IsJson(
                    snapshot(
                        {
                            'type': 'object',
                            'properties': {
                                'tool_arguments': {'type': 'object'},
                                'tool_response': {'type': 'object'},
                                'gen_ai.tool.name': {},
                                'gen_ai.tool.call.id': {},
                            },
                        }
                    )
                ),
                'logfire.span_type': 'span',
                'tool_response': '{"temperature": 28.7, "description": "sunny"}',
            }
        )
    else:
        assert output_function_attributes == snapshot(
            {
                'gen_ai.tool.name': 'get_weather',
                'gen_ai.tool.call.id': IsStr(),
                'logfire.msg': 'running output function: get_weather',
                'logfire.json_schema': IsJson(
                    snapshot({'type': 'object', 'properties': {'gen_ai.tool.name': {}, 'gen_ai.tool.call.id': {}}})
                ),
                'logfire.span_type': 'span',
            }
        )

# pydantic_graph/pydantic_graph/_utils.py:169-204
def infer_obj_name(obj: Any, *, depth: int) -> str | None:
    """Infer the variable name of an object from the calling frame's scope.

    This function examines the call stack to find what variable name was used
    for the given object in the calling scope. This is useful for automatic
    naming of objects based on their variable names.

    Args:
        obj: The object whose variable name to infer.
        depth: Number of stack frames to traverse upward from the current frame.

    Returns:
        The inferred variable name if found, None otherwise.

    Example:
        Usage should generally look like `infer_name(self, depth=2)` or similar.
    """
    target_frame = inspect.currentframe()
    if target_frame is None:
        return None  # pragma: no cover
    for _ in range(depth):
        target_frame = target_frame.f_back
        if target_frame is None:
            return None

    for name, item in target_frame.f_locals.items():
        if item is obj:
            return name

    if target_frame.f_locals != target_frame.f_globals:  # pragma: no branch
        # if we couldn't find the agent in locals and globals are a different dict, try globals
        for name, item in target_frame.f_globals.items():
            if item is obj:
                return name

    return None

# pydantic_ai_slim/pydantic_ai/models/openai.py:2732-2734
    def provider_name(self) -> str:
        """Get the provider name."""
        return self._provider_name

# pydantic_ai_slim/pydantic_ai/_otel_messages.py:30-30
    name: str

# pydantic_ai_slim/pydantic_ai/_run_context.py:55-55
    tool_name: str | None = None

# pydantic_ai_slim/pydantic_ai/providers/google_vertex.py:39-40
    def name(self) -> str:
        return 'google-vertex'

# pydantic_evals/pydantic_evals/evaluators/common.py:135-135
    type_name: str

# pydantic_evals/pydantic_evals/reporting/analyses.py:41-41
    name: str

# tests/models/test_bedrock.py:102-103
    def name(self) -> str:
        return 'bedrock-stub'

# tests/test_format_as_xml.py:26-26
    name: str

# pydantic_ai_slim/pydantic_ai/models/mcp_sampling.py:89-94
    def model_name(self) -> str:
        """The model name.

        Since the model name isn't known until the request is made, this property always returns `'mcp-sampling'`.
        """
        return 'mcp-sampling'

# pydantic_evals/pydantic_evals/evaluators/_base.py:48-54
    def get_serialization_name(cls) -> str:
        """Return the 'name' of this evaluator to use during serialization.

        Returns:
            The name of the evaluator, which is typically the class name.
        """
        return cls.__name__

# pydantic_ai_slim/pydantic_ai/models/cohere.py:72-72
CohereModelName = str | LatestCohereModelNames

# pydantic_ai_slim/pydantic_ai/models/gemini.py:68-68
GeminiModelName = str | LatestGeminiModelNames

# pydantic_ai_slim/pydantic_ai/models/google.py:128-128
GoogleModelName = str | LatestGoogleModelNames

# pydantic_ai_slim/pydantic_ai/models/openai.py:130-130
OpenAIModelName = str | AllModels

# pydantic_ai_slim/pydantic_ai/result.py:791-791
    tool_name: str | None = None

# tests/models/test_bedrock.py:4-4
from types import SimpleNamespace

# tests/test_agent.py:3245-3254
async def test_agent_name():
    my_agent = Agent('test')

    assert my_agent.name is None

    await my_agent.run('Hello', infer_name=False)
    assert my_agent.name is None

    await my_agent.run('Hello')
    assert my_agent.name == 'my_agent'

# tests/test_format_as_xml.py:41-41
    name: str = Field(description="The person's name")

# pydantic_evals/pydantic_evals/evaluators/spec.py:145-153
    def _name(self) -> str:
        """Get the name of the evaluator from the serialized form.

        Returns:
            The name of the evaluator.
        """
        if isinstance(self.root, str):
            return self.root
        return next(iter(self.root.keys()))

# pydantic_ai_slim/pydantic_ai/_instrumentation.py:58-69
    def get_agent_run_span_name(self, agent_name: str) -> str:
        """Get the formatted agent span name.

        Args:
            agent_name: Name of the agent being executed

        Returns:
            Formatted span name
        """
        if self.agent_run_span_name == 'invoke_agent':
            return f'invoke_agent {agent_name}'
        return self.agent_run_span_name

# pydantic_ai_slim/pydantic_ai/_instrumentation.py:18-18
    agent_run_span_name: str

# pydantic_ai_slim/pydantic_ai/models/xai.py:163-163
    _model_name: str

# pydantic_ai_slim/pydantic_ai/output.py:264-264
    name: str | None = None

# pydantic_evals/pydantic_evals/evaluators/report_evaluator.py:31-31
    name: str

# tests/ext/test_langchain.py:14-14
    name: str

# tests/test_concurrency.py:456-459
    async def test_limiter_with_name(self):
        """Test that limiter name is properly set and accessible."""
        limiter = ConcurrencyLimiter(max_running=5, name='my-limiter')
        assert limiter.name == 'my-limiter'

# pydantic_ai_slim/pydantic_ai/toolsets/abstract.py:94-96
    def tool_name_conflict_hint(self) -> str:
        """A hint for how to avoid name conflicts with other toolsets for use in error messages."""
        return 'Rename the tool or wrap the toolset in a `PrefixedToolset` to avoid name conflicts.'

# examples/pydantic_ai_examples/slack_lead_qualifier/models.py:14-14
    display_name: str | None = None

# pydantic_ai_slim/pydantic_ai/models/bedrock.py:148-148
BedrockModelName = str | LatestBedrockModelNames

# pydantic_ai_slim/pydantic_ai/models/groq.py:130-130
    _model_name: GroqModelName = field(repr=False)

# pydantic_ai_slim/pydantic_ai/models/mistral.py:97-97
MistralModelName = str | LatestMistralModelNames

# pydantic_ai_slim/pydantic_ai/models/test.py:89-89
    _model_name: str = field(default='test', repr=False)

# pydantic_evals/pydantic_evals/otel/span_tree.py:38-38
    name_equals: str

# tests/mcp_server.py:105-112
async def get_product_name() -> EmbeddedResource:
    return EmbeddedResource(
        type='resource',
        resource=TextResourceContents(
            uri=AnyUrl('resource://product_name.txt'),
            text='Pydantic AI',
        ),
    )

# pydantic_ai_slim/pydantic_ai/_ssrf.py:100-127
async def resolve_hostname(hostname: str) -> list[str]:
    """Resolve a hostname to its IP addresses using DNS.

    Uses run_in_executor to run DNS resolution in a thread pool to avoid blocking.

    Returns:
        List of IP address strings, preserving DNS order with duplicates removed.

    Raises:
        ValueError: If DNS resolution fails.
    """
    try:
        # getaddrinfo returns list of (family, type, proto, canonname, sockaddr)
        # sockaddr is (ip, port) for IPv4 or (ip, port, flowinfo, scope_id) for IPv6
        results = await run_in_executor(socket.getaddrinfo, hostname, None, socket.AF_UNSPEC, socket.SOCK_STREAM)
        # Extract unique IP addresses, preserving order (first IP is typically preferred)
        seen: set[str] = set()
        ips: list[str] = []
        for result in results:
            ip = str(result[4][0])
            if ip not in seen:
                seen.add(ip)
                ips.append(ip)
        if not ips:
            raise ValueError(f'DNS resolution failed for hostname: {hostname}')  # pragma: no cover
        return ips
    except socket.gaierror as e:
        raise ValueError(f'DNS resolution failed for hostname "{hostname}": {e}') from e

# pydantic_ai_slim/pydantic_ai/_instrumentation.py:84-95
    def get_output_tool_span_name(self, tool_name: str) -> str:
        """Get the formatted output tool span name.

        Args:
            tool_name: Name of the tool being executed

        Returns:
            Formatted span name
        """
        if self.output_tool_span_name == 'execute_tool':
            return f'execute_tool {tool_name}'
        return self.output_tool_span_name

# pydantic_graph/pydantic_graph/_utils.py:98-113
def get_parent_namespace(frame: types.FrameType | None) -> dict[str, Any] | None:
    """Attempt to get the namespace where the graph was defined.

    If the graph is defined with generics `Graph[a, b]` then another frame is inserted, and we have to skip that
    to get the correct namespace.
    """
    if frame is not None:  # pragma: no branch
        if back := frame.f_back:  # pragma: no branch
            if back.f_globals.get('__name__') == 'typing':
                # If the class calling this function is generic, explicitly parameterizing the class
                # results in a `typing._GenericAlias` instance, which proxies instantiation calls to the
                # "real" class and thus adding an extra frame to the call. To avoid pulling anything
                # from the `typing` module, use the correct frame (the one before):
                return get_parent_namespace(back)
            else:
                return back.f_locals

# pydantic_ai_slim/pydantic_ai/models/wrapper.py:71-72
    def model_name(self) -> str:
        return self.wrapped.model_name

# pydantic_ai_slim/pydantic_ai/_instrumentation.py:27-27
    output_tool_span_name: str

# examples/pydantic_ai_examples/bank_support.py:66-68
async def add_customer_name(ctx: RunContext[SupportDependencies]) -> str:
    customer_name = await ctx.deps.db.customer_name(id=ctx.deps.customer_id)
    return f"The customer's name is {customer_name!r}"

# examples/pydantic_ai_examples/evals/custom_evaluators.py:53-53
    tool_name: str

# pydantic_ai_slim/pydantic_ai/exceptions.py:170-170
    model_name: str

# pydantic_ai_slim/pydantic_ai/messages.py:955-955
    tool_name: str | None = None

# pydantic_ai_slim/pydantic_ai/messages.py:1308-1308
    model_name: str | None = None

# pydantic_ai_slim/pydantic_ai/models/cerebras.py:36-36
CerebrasModelName = str | LatestCerebrasModelNames

# pydantic_ai_slim/pydantic_ai/models/cohere.py:109-109
    _model_name: CohereModelName = field(repr=False)

# pydantic_ai_slim/pydantic_ai/models/gemini.py:114-114
    _model_name: GeminiModelName = field(repr=False)