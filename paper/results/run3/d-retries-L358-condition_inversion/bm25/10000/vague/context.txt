# pydantic_ai_slim/pydantic_ai/providers/gateway.py:212-219
def _merge_url_path(base_url: str, path: str) -> str:
    """Merge a base URL and a path.

    Args:
        base_url: The base URL to merge.
        path: The path to merge.
    """
    return base_url.rstrip('/') + '/' + path.lstrip('/')

# tests/graph/beta/test_parent_forks.py:178-197
def test_parent_fork_multiple_paths_to_fork():
    """Test parent fork with multiple paths from start to the fork."""
    join_id = 'J'
    nodes = {'start1', 'start2', 'F', 'A', 'B', 'J', 'end'}
    start_ids = {'start1', 'start2'}
    fork_ids = {'F'}
    edges = {
        'start1': ['F'],
        'start2': ['F'],
        'F': ['A', 'B'],
        'A': ['J'],
        'B': ['J'],
        'J': ['end'],
    }

    finder = ParentForkFinder(nodes, start_ids, fork_ids, edges)
    parent_fork = finder.find_parent_fork(join_id)

    assert parent_fork is not None
    assert parent_fork.fork_id == 'F'

# pydantic_graph/pydantic_graph/beta/graph.py:857-873
    def _handle_path(self, path: Path, inputs: Any, fork_stack: ForkStack) -> Sequence[GraphTask]:
        if not path.items:
            return []  # pragma: no cover

        item = path.items[0]
        assert not isinstance(item, MapMarker | BroadcastMarker), (
            'These markers should be removed from paths during graph building'
        )
        if isinstance(item, DestinationMarker):
            return [GraphTask(item.destination_id, inputs, fork_stack, self.get_next_task_id())]
        elif isinstance(item, TransformMarker):
            inputs = item.transform(StepContext(state=self.state, deps=self.deps, inputs=inputs))
            return self._handle_path(path.next_path, inputs, fork_stack)
        elif isinstance(item, LabelMarker):
            return self._handle_path(path.next_path, inputs, fork_stack)
        else:
            assert_never(item)

# pydantic_graph/pydantic_graph/beta/graph_builder.py:38-46
from pydantic_graph.beta.paths import (
    BroadcastMarker,
    DestinationMarker,
    EdgePath,
    EdgePathBuilder,
    MapMarker,
    Path,
    PathBuilder,
)

# pydantic_graph/pydantic_graph/beta/paths.py:153-159
    def next_path(self) -> Path:
        """Create a new path with the first item removed.

        Returns:
            A new Path with all items except the first one
        """
        return Path(self.items[1:])

# tests/graph/beta/test_paths.py:30-33
async def test_path_last_fork_with_no_forks():
    """Test Path.last_fork property when there are no forks."""
    path = Path(items=[LabelMarker('test'), DestinationMarker(NodeID('dest'))])
    assert path.last_fork is None

# pydantic_graph/pydantic_graph/exceptions.py:59-62
    def check(cls, status: 'SnapshotStatus') -> None:
        """Check if the status is valid."""
        if status not in {'created', 'pending'}:
            raise cls(status)

# tests/test_ssrf.py:285-288
    def test_absolute_path(self) -> None:
        """Test that absolute paths are resolved against the current URL."""
        result = resolve_redirect_url('https://example.com/old/path', '/new/path')
        assert result == 'https://example.com/new/path'

# tests/test_ssrf.py:290-293
    def test_relative_path(self) -> None:
        """Test that relative paths are resolved against the current URL."""
        result = resolve_redirect_url('https://example.com/old/path', 'new-file.txt')
        assert result == 'https://example.com/old/new-file.txt'

# clai/update_readme.py:4-4
from pathlib import Path

# pydantic_graph/pydantic_graph/beta/paths.py:278-278
    path: Path

# tests/graph/beta/test_graph_edge_cases.py:301-317
async def test_empty_path_handling():
    """Test handling of empty paths in graph execution."""
    g = GraphBuilder(state_type=MyState, output_type=int)

    @g.step
    async def return_value(ctx: StepContext[MyState, None, None]) -> int:
        return 42

    # Just connect start to step to end - this should work fine
    g.add(
        g.edge_from(g.start_node).to(return_value),
        g.edge_from(return_value).to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=MyState())
    assert result == 42

# pydantic_ai_slim/pydantic_ai/messages.py:533-549
    def from_path(cls, path: PathLike[str]) -> BinaryContent:
        """Create a `BinaryContent` from a path.

        Defaults to 'application/octet-stream' if the media type cannot be inferred.

        Raises:
            FileNotFoundError: if the file does not exist.
            PermissionError: if the file cannot be read.
        """
        path = Path(path)
        if not path.exists():
            raise FileNotFoundError(f'File not found: {path}')
        media_type, _ = _mime_types.guess_type(path)
        if media_type is None:
            media_type = 'application/octet-stream'

        return cls.narrow_type(cls(data=path.read_bytes(), media_type=media_type))

# pydantic_graph/pydantic_graph/beta/paths.py:308-318
    def __init__(
        self, sources: Sequence[SourceNode[StateT, DepsT, Any]], path_builder: PathBuilder[StateT, DepsT, OutputT]
    ):
        """Initialize an edge path builder.

        Args:
            sources: The source nodes for this edge path
            path_builder: The path builder for defining the data flow
        """
        self.sources = sources
        self._path_builder = path_builder

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# tests/graph/beta/test_paths.py:100-108
async def test_path_next_path():
    """Test Path.next_path removes first item."""
    items: list[PathItem] = [LabelMarker('first'), LabelMarker('second'), DestinationMarker(NodeID('dest'))]
    path = Path(items=items)

    next_path = path.next_path
    assert len(next_path.items) == 2
    assert next_path.items[0] == items[1]
    assert next_path.items[1] == items[2]

# tests/graph/beta/test_graph_edge_cases.py:358-379
async def test_path_with_label_marker():
    """Test that LabelMarker in paths doesn't affect execution."""
    g = GraphBuilder(state_type=MyState, output_type=int)

    @g.step
    async def step_a(ctx: StepContext[MyState, None, None]) -> int:
        return 10

    @g.step
    async def step_b(ctx: StepContext[MyState, None, int]) -> int:
        return ctx.inputs * 2

    # Add labels to the path
    g.add(
        g.edge_from(g.start_node).label('start').to(step_a),
        g.edge_from(step_a).label('middle').to(step_b),
        g.edge_from(step_b).label('end').to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=MyState())
    assert result == 20

# pydantic_graph/pydantic_graph/beta/decision.py:19-19
from pydantic_graph.beta.paths import Path, PathBuilder, TransformFunction

# tests/test_ssrf.py:220-225
    def test_empty_path(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('https://example.com')
        assert hostname == 'example.com'
        assert path == '/'
        assert port == 443
        assert is_https is True

# pydantic_ai_slim/pydantic_ai/models/openai.py:236-263
def _check_azure_content_filter(e: APIStatusError, system: str, model_name: str) -> ModelResponse | None:
    """Check if the error is an Azure content filter error."""
    # Assign to Any to avoid 'dict[Unknown, Unknown]' inference in strict mode
    body_any: Any = e.body

    if system == 'azure' and e.status_code == 400 and isinstance(body_any, dict):
        try:
            error_data = _AzureErrorResponse.model_validate(body_any)

            if error_data.error.code == 'content_filter':
                provider_details: dict[str, Any] = {'finish_reason': 'content_filter'}

                if error_data.error.innererror:
                    provider_details['content_filter_result'] = (
                        error_data.error.innererror.content_filter_result.model_dump(exclude_none=True)
                    )

                return ModelResponse(
                    parts=[],  # Empty parts to trigger content filter error in agent graph
                    model_name=model_name,
                    timestamp=_utils.now_utc(),
                    provider_name=system,
                    finish_reason='content_filter',
                    provider_details=provider_details,
                )
        except ValidationError:
            pass
    return None

# pydantic_ai_slim/pydantic_ai/messages.py:12-12
from os import PathLike

# pydantic_graph/pydantic_graph/beta/graph_builder.py:38-46
from pydantic_graph.beta.paths import (
    BroadcastMarker,
    DestinationMarker,
    EdgePath,
    EdgePathBuilder,
    MapMarker,
    Path,
    PathBuilder,
)

# pydantic_graph/pydantic_graph/beta/paths.py:125-125
PathItem = TypeAliasType('PathItem', TransformMarker | MapMarker | BroadcastMarker | LabelMarker | DestinationMarker)

# pydantic_graph/pydantic_graph/beta/paths.py:125-125
PathItem = TypeAliasType('PathItem', TransformMarker | MapMarker | BroadcastMarker | LabelMarker | DestinationMarker)

# examples/pydantic_ai_examples/ag_ui/api/agentic_generative_ui.py:41-41
    path: str = Field(description='JSON Pointer (RFC 6901) to the target location')

# examples/pydantic_ai_examples/rag.py:171-171
    path: str

# pydantic_ai_slim/pydantic_ai/_ssrf.py:70-70
    path: str

# tests/models/test_google.py:5035-5053
async def test_google_api_errors_are_handled(
    allow_model_requests: None,
    google_provider: GoogleProvider,
    mocker: MockerFixture,
    error_class: Any,
    error_response: dict[str, Any],
    expected_status: int,
):
    model = GoogleModel('gemini-1.5-flash', provider=google_provider)
    mocked_error = error_class(expected_status, error_response)
    mocker.patch.object(model.client.aio.models, 'generate_content', side_effect=mocked_error)

    agent = Agent(model=model)

    with pytest.raises(ModelHTTPError) as exc_info:
        await agent.run('This prompt will trigger the mocked error.')

    assert exc_info.value.status_code == expected_status
    assert error_response['error']['message'] in str(exc_info.value.body)

# docs/.hooks/main.py:29-29
bundle_path: Path | None = None

# pydantic_graph/pydantic_graph/beta/decision.py:19-19
from pydantic_graph.beta.paths import Path, PathBuilder, TransformFunction

# pydantic_graph/pydantic_graph/beta/decision.py:19-19
from pydantic_graph.beta.paths import Path, PathBuilder, TransformFunction

# tests/conftest.py:374-375
def assets_path() -> Path:
    return Path(__file__).parent / 'assets'

# pydantic_graph/pydantic_graph/beta/decision.py:19-19
from pydantic_graph.beta.paths import Path, PathBuilder, TransformFunction

# pydantic_graph/pydantic_graph/beta/decision.py:116-116
    path: Path

# tests/test_examples.py:99-112
def tmp_path_cwd(tmp_path: Path):
    cwd = os.getcwd()

    root_dir = Path(__file__).parent.parent
    for file in (root_dir / 'tests' / 'example_modules').glob('*.py'):
        shutil.copy(file, tmp_path)
    sys.path.append(str(tmp_path))
    os.chdir(tmp_path)

    try:
        yield tmp_path
    finally:
        os.chdir(cwd)
        sys.path.remove(str(tmp_path))

# docs/.hooks/test_snippets.py:71-75
def test_parse_snippet_directive_missing_path():
    """Test that missing path raises ValueError."""
    line = '```snippet {title="Test"}'
    with pytest.raises(ValueError, match='Missing required key "path" in snippet directive'):
        parse_snippet_directive(line)

# docs/.hooks/snippets.py:13-13
    path: str

# pydantic_graph/pydantic_graph/beta/paths.py:141-150
    def last_fork(self) -> BroadcastMarker | MapMarker | None:
        """Get the most recent fork or map marker in this path.

        Returns:
            The last BroadcastMarker or MapMarker in the path, or None if no forks exist
        """
        for item in reversed(self.items):
            if isinstance(item, BroadcastMarker | MapMarker):
                return item
        return None

# pydantic_graph/pydantic_graph/beta/paths.py:94-94
    paths: Sequence[Path]

# tests/test_ssrf.py:213-218
    def test_path_with_fragment(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('https://example.com/path#fragment')
        assert hostname == 'example.com'
        assert path == '/path#fragment'
        assert port == 443
        assert is_https is True

# pydantic_graph/pydantic_graph/beta/graph_builder.py:334-398
    def add(self, *edges: EdgePath[StateT, DepsT]) -> None:  # noqa: C901
        """Add one or more edge paths to the graph.

        This method processes edge paths and automatically creates any necessary
        fork nodes for broadcasts and maps.

        Args:
            *edges: The edge paths to add to the graph
        """

        def _handle_path(p: Path):
            """Process a path and create necessary fork nodes.

            Args:
                p: The path to process
            """
            for item in p.items:
                if isinstance(item, BroadcastMarker):
                    new_node = Fork[Any, Any](id=item.fork_id, is_map=False, downstream_join_id=None)
                    self._insert_node(new_node)
                    for path in item.paths:
                        _handle_path(Path(items=[*path.items]))
                elif isinstance(item, MapMarker):
                    new_node = Fork[Any, Any](id=item.fork_id, is_map=True, downstream_join_id=item.downstream_join_id)
                    self._insert_node(new_node)
                elif isinstance(item, DestinationMarker):
                    pass

        def _handle_destination_node(d: AnyDestinationNode):
            if id(d) in destination_ids:
                return  # prevent infinite recursion if there is a cycle of decisions

            destination_ids.add(id(d))
            destinations.append(d)
            self._insert_node(d)
            if isinstance(d, Decision):
                for branch in d.branches:
                    _handle_path(branch.path)
                    for d2 in branch.destinations:
                        _handle_destination_node(d2)

        destination_ids = set[int]()
        destinations: list[AnyDestinationNode] = []
        for edge in edges:
            for source_node in edge.sources:
                self._insert_node(source_node)
                self._edges_by_source[source_node.id].append(edge.path)
            for destination_node in edge.destinations:
                _handle_destination_node(destination_node)
            _handle_path(edge.path)

        # Automatically create edges from step function return hints including `BaseNode`s
        for destination in destinations:
            if not isinstance(destination, Step) or isinstance(destination, NodeStep):
                continue
            parent_namespace = _utils.get_parent_namespace(inspect.currentframe())
            type_hints = get_type_hints(destination.call, localns=parent_namespace, include_extras=True)
            try:
                return_hint = type_hints['return']
            except KeyError:
                pass
            else:
                edge = self._edge_from_return_hint(destination, return_hint)
                if edge is not None:
                    self.add(edge)

# pydantic_graph/pydantic_graph/beta/graph_builder.py:789-828
def _flatten_paths(
    nodes: dict[NodeID, AnyNode], edges: dict[NodeID, list[Path]]
) -> tuple[dict[NodeID, AnyNode], dict[NodeID, list[Path]]]:
    new_nodes = nodes.copy()
    new_edges: dict[NodeID, list[Path]] = defaultdict(list)

    paths_to_handle: list[tuple[NodeID, Path]] = []

    def _split_at_first_fork(path: Path) -> tuple[Path, list[tuple[NodeID, Path]]]:
        for i, item in enumerate(path.items):
            if isinstance(item, MapMarker):
                assert item.fork_id in nodes, 'This should have been added to the node during GraphBuilder.add'
                upstream = Path(list(path.items[:i]) + [DestinationMarker(item.fork_id)])
                downstream = Path(path.items[i + 1 :])
                return upstream, [(item.fork_id, downstream)]

            if isinstance(item, BroadcastMarker):
                assert item.fork_id in nodes, 'This should have been added to the node during GraphBuilder.add'
                upstream = Path(list(path.items[:i]) + [DestinationMarker(item.fork_id)])
                return upstream, [(item.fork_id, p) for p in item.paths]
        return path, []

    for node in new_nodes.values():
        if isinstance(node, Decision):
            for branch in node.branches:
                upstream, downstreams = _split_at_first_fork(branch.path)
                branch.path = upstream
                paths_to_handle.extend(downstreams)

    for source_id, edges_from_source in edges.items():
        for path in edges_from_source:
            paths_to_handle.append((source_id, path))

    while paths_to_handle:
        source_id, path = paths_to_handle.pop()
        upstream, downstreams = _split_at_first_fork(path)
        new_edges[source_id].append(upstream)
        paths_to_handle.extend(downstreams)

    return new_nodes, dict(new_edges)

# pydantic_graph/pydantic_graph/beta/graph_builder.py:38-46
from pydantic_graph.beta.paths import (
    BroadcastMarker,
    DestinationMarker,
    EdgePath,
    EdgePathBuilder,
    MapMarker,
    Path,
    PathBuilder,
)

# pydantic_ai_slim/pydantic_ai/_utils.py:286-294
def guard_tool_call_id(
    t: _messages.ToolCallPart
    | _messages.ToolReturnPart
    | _messages.RetryPromptPart
    | _messages.BuiltinToolCallPart
    | _messages.BuiltinToolReturnPart,
) -> str:
    """Type guard that either returns the tool call id or generates a new one if it's None."""
    return t.tool_call_id or generate_tool_call_id()

# pydantic_graph/pydantic_graph/beta/graph_builder.py:444-455
    def edge_from(self, *sources: Source[SourceOutputT]) -> EdgePathBuilder[StateT, DepsT, SourceOutputT]:
        """Create an edge path builder starting from the given source nodes.

        Args:
            *sources: The source nodes to start the edge path from

        Returns:
            An EdgePathBuilder for constructing the complete edge path
        """
        return EdgePathBuilder[StateT, DepsT, SourceOutputT](
            sources=sources, path_builder=PathBuilder(working_items=[])
        )

# pydantic_graph/pydantic_graph/beta/graph_builder.py:38-46
from pydantic_graph.beta.paths import (
    BroadcastMarker,
    DestinationMarker,
    EdgePath,
    EdgePathBuilder,
    MapMarker,
    Path,
    PathBuilder,
)

# tests/test_ssrf.py:206-211
    def test_path_with_query_string(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('https://example.com/path?query=value')
        assert hostname == 'example.com'
        assert path == '/path?query=value'
        assert port == 443
        assert is_https is True

# tests/graph/beta/test_decisions.py:19-19
    path_taken: str | None = None

# pydantic_graph/pydantic_graph/beta/paths.py:219-229
    def transform(self, func: TransformFunction[StateT, DepsT, OutputT, T], /) -> PathBuilder[StateT, DepsT, T]:
        """Add a transformation step to the path.

        Args:
            func: The step function that will transform the data

        Returns:
            A new PathBuilder with the transformation added
        """
        next_item = TransformMarker(func)
        return PathBuilder[StateT, DepsT, T](working_items=[*self.working_items, next_item])

# tests/graph/beta/test_edge_labels.py:193-221
async def test_complex_labeled_path():
    """Test a complex path with multiple labels, transforms, and operations."""
    g = GraphBuilder(state_type=LabelState, output_type=list[str])

    @g.step
    async def start(ctx: StepContext[LabelState, None, None]) -> list[int]:
        return [1, 2, 3]

    @g.step
    async def process(ctx: StepContext[LabelState, None, int]) -> int:
        return ctx.inputs * 2

    @g.step
    async def stringify(ctx: StepContext[LabelState, None, int]) -> str:
        return f'value={ctx.inputs}'

    collect = g.join(reduce_list_append, initial_factory=list[str])

    g.add(
        g.edge_from(g.start_node).label('initialize').to(start),
        g.edge_from(start).label('before map').map().label('mapping').to(process),
        g.edge_from(process).label('to stringify').to(stringify),
        g.edge_from(stringify).label('collecting').to(collect),
        g.edge_from(collect).label('done').to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=LabelState())
    assert sorted(result) == ['value=2', 'value=4', 'value=6']

# pydantic_graph/pydantic_graph/beta/node_types.py:63-75
def is_source(node: AnyNode) -> TypeGuard[AnySourceNode]:
    """Check if a node can serve as a source in the graph.

    Source nodes are capable of producing output data and can be the starting
    point for data flow in graph execution paths.

    Args:
        node: The node to check

    Returns:
        True if the node can serve as a source, False otherwise
    """
    return isinstance(node, StartNode | Step | Join)

# pydantic_graph/pydantic_graph/beta/graph.py:33-40
from pydantic_graph.beta.paths import (
    BroadcastMarker,
    DestinationMarker,
    LabelMarker,
    MapMarker,
    Path,
    TransformMarker,
)

# pydantic_evals/pydantic_evals/dataset.py:77-77
DEFAULT_DATASET_PATH = './test_cases.yaml'

# pydantic_graph/pydantic_graph/beta/paths.py:401-410
    def transform(self, func: TransformFunction[StateT, DepsT, OutputT, T], /) -> EdgePathBuilder[StateT, DepsT, T]:
        """Add a transformation step to the edge path.

        Args:
            func: The step function that will transform the data

        Returns:
            A new EdgePathBuilder with the transformation added
        """
        return EdgePathBuilder(sources=self.sources, path_builder=self._path_builder.transform(func))

# tests/models/xai_proto_cassettes.py:299-300
    def from_path(cls, path: Path) -> XaiProtoCassetteClient:
        return cls(cassette=XaiProtoCassette.load(path))

# tests/graph/beta/test_paths.py:90-97
async def test_path_builder_label():
    """Test PathBuilder.label method."""
    builder = PathBuilder[MyState, None, int](working_items=[])
    new_builder = builder.label('my label')

    assert len(new_builder.working_items) == 1
    assert isinstance(new_builder.working_items[0], LabelMarker)
    assert new_builder.working_items[0].label == 'my label'

# pydantic_ai_slim/pydantic_ai/mcp.py:1387-1420
def load_mcp_servers(config_path: str | Path) -> list[MCPServerStdio | MCPServerStreamableHTTP | MCPServerSSE]:
    """Load MCP servers from a configuration file.

    Environment variables can be referenced in the configuration file using:
    - `${VAR_NAME}` syntax - expands to the value of VAR_NAME, raises error if not defined
    - `${VAR_NAME:-default}` syntax - expands to VAR_NAME if set, otherwise uses the default value

    Args:
        config_path: The path to the configuration file.

    Returns:
        A list of MCP servers.

    Raises:
        FileNotFoundError: If the configuration file does not exist.
        ValidationError: If the configuration file does not match the schema.
        ValueError: If an environment variable referenced in the configuration is not defined and no default value is provided.
    """
    config_path = Path(config_path)

    if not config_path.exists():
        raise FileNotFoundError(f'Config file {config_path} not found')

    config_data = pydantic_core.from_json(config_path.read_bytes())
    expanded_config_data = _expand_env_vars(config_data)
    config = MCPServerConfig.model_validate(expanded_config_data)

    servers: list[MCPServerStdio | MCPServerStreamableHTTP | MCPServerSSE] = []
    for name, server in config.mcp_servers.items():
        server.id = name
        server.tool_prefix = name
        servers.append(server)

    return servers

# pydantic_graph/pydantic_graph/beta/node_types.py:78-90
def is_destination(node: AnyNode) -> TypeGuard[AnyDestinationNode]:
    """Check if a node can serve as a destination in the graph.

    Destination nodes are capable of consuming input data and can be the ending
    point for data flow in graph execution paths.

    Args:
        node: The node to check

    Returns:
        True if the node can serve as a destination, False otherwise
    """
    return isinstance(node, EndNode | Step | Join | Decision)

# pydantic_evals/pydantic_evals/dataset.py:103-103
    json_schema_path: str | None = Field(default=None, alias='$schema')

# pydantic_graph/pydantic_graph/beta/graph.py:33-40
from pydantic_graph.beta.paths import (
    BroadcastMarker,
    DestinationMarker,
    LabelMarker,
    MapMarker,
    Path,
    TransformMarker,
)

# pydantic_graph/pydantic_graph/beta/graph.py:33-40
from pydantic_graph.beta.paths import (
    BroadcastMarker,
    DestinationMarker,
    LabelMarker,
    MapMarker,
    Path,
    TransformMarker,
)

# pydantic_graph/pydantic_graph/beta/paths.py:204-217
    def broadcast(self, forks: Sequence[Path], /, *, fork_id: str | None = None) -> Path:
        """Create a fork that broadcasts data to multiple parallel paths.

        Args:
            forks: The sequence of paths to run in parallel
            fork_id: Optional ID for the fork, defaults to a generated value

        Returns:
            A complete Path that forks to the specified parallel paths
        """
        next_item = BroadcastMarker(
            paths=forks, fork_id=ForkID(NodeID(fork_id or generate_placeholder_node_id('broadcast')))
        )
        return Path(items=[*self.working_items, next_item])

# pydantic_graph/pydantic_graph/beta/decision.py:152-152
    _path_builder: PathBuilder[StateT, DepsT, OutputT]

# tests/graph/beta/test_paths.py:63-87
async def test_edge_path_builder_transform():
    """Test EdgePathBuilder.transform method creates proper path."""
    g = GraphBuilder(state_type=MyState, output_type=int)

    @g.step
    async def step_a(ctx: StepContext[MyState, None, None]) -> int:
        return 10

    @g.step
    async def step_b(ctx: StepContext[MyState, None, int]) -> int:
        return ctx.inputs * 3

    def double(ctx: StepContext[MyState, None, int]) -> int:
        return ctx.inputs * 2

    # Build graph with transform in the path
    g.add(
        g.edge_from(g.start_node).to(step_a),
        g.edge_from(step_a).transform(double).to(step_b),
        g.edge_from(step_b).to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=MyState())
    assert result == 60  # 10 * 2 * 3

# pydantic_graph/pydantic_graph/beta/paths.py:255-265
    def label(self, label: str, /) -> PathBuilder[StateT, DepsT, OutputT]:
        """Add a human-readable label to this point in the path.

        Args:
            label: The label to add for documentation/debugging purposes

        Returns:
            A new PathBuilder with the label added
        """
        next_item = LabelMarker(label)
        return PathBuilder[StateT, DepsT, OutputT](working_items=[*self.working_items, next_item])

# tests/models/xai_proto_cassettes.py:574-574
    cassette_path: Path

# tests/graph/beta/test_paths.py:50-60
async def test_path_builder_transform():
    """Test PathBuilder.transform method."""

    async def transform_func(ctx: StepContext[MyState, None, int]) -> int:
        return ctx.inputs * 2  # pragma: no cover

    builder = PathBuilder[MyState, None, int](working_items=[])
    new_builder = builder.transform(transform_func)

    assert len(new_builder.working_items) == 1
    assert isinstance(new_builder.working_items[0], TransformMarker)

# pydantic_ai_slim/pydantic_ai/_agent_graph.py:14-14
from typing import TYPE_CHECKING, Any, Generic, Literal, TypeGuard, cast

# pydantic_ai_slim/pydantic_ai/_agent_graph.py:14-14
from typing import TYPE_CHECKING, Any, Generic, Literal, TypeGuard, cast

# pydantic_ai_slim/pydantic_ai/_agent_graph.py:14-14
from typing import TYPE_CHECKING, Any, Generic, Literal, TypeGuard, cast

# pydantic_ai_slim/pydantic_ai/_agent_graph.py:14-14
from typing import TYPE_CHECKING, Any, Generic, Literal, TypeGuard, cast

# pydantic_graph/pydantic_graph/beta/paths.py:137-137
    items: list[PathItem]