# httpx/_models.py:1117-1141
    def set(self, name: str, value: str, domain: str = "", path: str = "/") -> None:
        """
        Set a cookie value by name. May optionally include domain and path.
        """
        kwargs = {
            "version": 0,
            "name": name,
            "value": value,
            "port": None,
            "port_specified": False,
            "domain": domain,
            "domain_specified": bool(domain),
            "domain_initial_dot": domain.startswith("."),
            "path": path,
            "path_specified": bool(path),
            "secure": False,
            "expires": None,
            "discard": True,
            "comment": None,
            "comment_url": None,
            "rest": {"HttpOnly": None},
            "rfc2109": False,
        }
        cookie = Cookie(**kwargs)  # type: ignore
        self.jar.set_cookie(cookie)

# tests/client/test_cookies.py:8-15
def get_and_set_cookies(request: httpx.Request) -> httpx.Response:
    if request.url.path == "/echo_cookies":
        data = {"cookies": request.headers.get("cookie")}
        return httpx.Response(200, json=data)
    elif request.url.path == "/set_cookie":
        return httpx.Response(200, headers={"set-cookie": "example-name=example-value"})
    else:
        raise NotImplementedError()  # pragma: no cover

# tests/models/test_responses.py:934-938
def test_cannot_access_unset_request():
    response = httpx.Response(200, content=b"Hello, world!")

    with pytest.raises(RuntimeError):
        response.request  # noqa: B018

# httpx/_config.py:20-20
UNSET = UnsetType()

# httpx/_config.py:16-17
class UnsetType:
    pass  # pragma: no cover

# httpx/_models.py:304-326
    def __setitem__(self, key: str, value: str) -> None:
        """
        Set the header `key` to `value`, removing any duplicate entries.
        Retains insertion order.
        """
        set_key = key.encode(self._encoding or "utf-8")
        set_value = value.encode(self._encoding or "utf-8")
        lookup_key = set_key.lower()

        found_indexes = [
            idx
            for idx, (_, item_key, _) in enumerate(self._list)
            if item_key == lookup_key
        ]

        for idx in reversed(found_indexes[1:]):
            del self._list[idx]

        if found_indexes:
            idx = found_indexes[0]
            self._list[idx] = (set_key, lookup_key, set_value)
        else:
            self._list.append((set_key, lookup_key, set_value))

# tests/test_auth.py:107-117
def set_cookies(request: httpx.Request) -> httpx.Response:
    headers = {
        "Set-Cookie": "session=.session_value...",
        "WWW-Authenticate": 'Digest realm="...", qop="auth", nonce="...", opaque="..."',
    }
    if request.url.path == "/auth":
        return httpx.Response(
            content=b"Auth required", status_code=401, headers=headers
        )
    else:
        raise NotImplementedError()  # pragma: no cover

# httpx/_client.py:31-31
from ._transports.base import AsyncBaseTransport, BaseTransport

# httpx/_client.py:31-31
from ._transports.base import AsyncBaseTransport, BaseTransport

# httpx/_client.py:31-31
from ._transports.base import AsyncBaseTransport, BaseTransport

# httpx/_client.py:31-31
from ._transports.base import AsyncBaseTransport, BaseTransport

# httpx/_client.py:31-31
from ._transports.base import AsyncBaseTransport, BaseTransport

# httpx/_models.py:1110-1115
    def set_cookie_header(self, request: Request) -> None:
        """
        Sets an appropriate 'Cookie:' HTTP header on the `Request`.
        """
        urllib_request = self._CookieCompatRequest(request)
        self.jar.add_cookie_header(urllib_request)

# httpx/_models.py:1210-1211
    def __setitem__(self, name: str, value: str) -> None:
        return self.set(name, value)

# httpx/_models.py:508-512
    def __setstate__(self, state: dict[str, typing.Any]) -> None:
        for name, value in state.items():
            setattr(self, name, value)
        self.extensions = {}
        self.stream = UnattachedStream()

# httpx/_status_codes.py:99-99
    RESET_CONTENT = 205, "Reset Content"

# httpx/_urls.py:342-343
    def copy_set_param(self, key: str, value: typing.Any = None) -> URL:
        return self.copy_with(params=self.params.set(key, value))

# httpx/_models.py:869-874
    def __setstate__(self, state: dict[str, typing.Any]) -> None:
        for name, value in state.items():
            setattr(self, name, value)
        self.is_closed = True
        self.extensions = {}
        self.stream = UnattachedStream()

# httpx/_urls.py:637-641
    def __setitem__(self, key: str, value: str) -> None:
        raise RuntimeError(
            "QueryParams are immutable since 0.18.0. "
            "Use `q = q.set(key, value)` to create an updated copy."
        )

# httpx/_client.py:584-591
    def _set_timeout(self, request: Request) -> None:
        if "timeout" not in request.extensions:
            timeout = (
                self.timeout
                if isinstance(self.timeout, UseClientDefault)
                else Timeout(self.timeout)
            )
            request.extensions = dict(**request.extensions, timeout=timeout.as_dict())

# httpx/_client.py:31-31
from ._transports.base import AsyncBaseTransport, BaseTransport

# httpx/_client.py:31-31
from ._transports.base import AsyncBaseTransport, BaseTransport

# httpx/_client.py:31-31
from ._transports.base import AsyncBaseTransport, BaseTransport

# httpx/_client.py:31-31
from ._transports.base import AsyncBaseTransport, BaseTransport

# httpx/_client.py:31-31
from ._transports.base import AsyncBaseTransport, BaseTransport

# tests/models/test_queryparams.py:102-105
def test_queryparam_set():
    q = httpx.QueryParams("a=123")
    q = q.set("a", "456")
    assert q == httpx.QueryParams("a=456")

# httpx/_models.py:85-90
def _parse_content_type_charset(content_type: str) -> str | None:
    # We used to use `cgi.parse_header()` here, but `cgi` became a dead battery.
    # See: https://peps.python.org/pep-0594/#cgi
    msg = email.message.Message()
    msg["content-type"] = content_type
    return msg.get_content_charset(failobj=None)

# httpx/_content.py:26-26
from ._utils import peek_filelike_length, primitive_value_to_str