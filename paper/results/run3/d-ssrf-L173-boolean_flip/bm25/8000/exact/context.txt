# pydantic_graph/pydantic_graph/beta/paths.py:278-278
    path: Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# tests/graph/beta/test_paths.py:100-108
async def test_path_next_path():
    """Test Path.next_path removes first item."""
    items: list[PathItem] = [LabelMarker('first'), LabelMarker('second'), DestinationMarker(NodeID('dest'))]
    path = Path(items=items)

    next_path = path.next_path
    assert len(next_path.items) == 2
    assert next_path.items[0] == items[1]
    assert next_path.items[1] == items[2]

# pydantic_graph/pydantic_graph/beta/graph.py:857-873
    def _handle_path(self, path: Path, inputs: Any, fork_stack: ForkStack) -> Sequence[GraphTask]:
        if not path.items:
            return []  # pragma: no cover

        item = path.items[0]
        assert not isinstance(item, MapMarker | BroadcastMarker), (
            'These markers should be removed from paths during graph building'
        )
        if isinstance(item, DestinationMarker):
            return [GraphTask(item.destination_id, inputs, fork_stack, self.get_next_task_id())]
        elif isinstance(item, TransformMarker):
            inputs = item.transform(StepContext(state=self.state, deps=self.deps, inputs=inputs))
            return self._handle_path(path.next_path, inputs, fork_stack)
        elif isinstance(item, LabelMarker):
            return self._handle_path(path.next_path, inputs, fork_stack)
        else:
            assert_never(item)

# pydantic_ai_slim/pydantic_ai/messages.py:12-12
from os import PathLike

# pydantic_graph/pydantic_graph/beta/graph_builder.py:38-46
from pydantic_graph.beta.paths import (
    BroadcastMarker,
    DestinationMarker,
    EdgePath,
    EdgePathBuilder,
    MapMarker,
    Path,
    PathBuilder,
)

# pydantic_graph/pydantic_graph/beta/paths.py:125-125
PathItem = TypeAliasType('PathItem', TransformMarker | MapMarker | BroadcastMarker | LabelMarker | DestinationMarker)

# pydantic_graph/pydantic_graph/beta/paths.py:125-125
PathItem = TypeAliasType('PathItem', TransformMarker | MapMarker | BroadcastMarker | LabelMarker | DestinationMarker)

# pydantic_ai_slim/pydantic_ai/providers/gateway.py:212-219
def _merge_url_path(base_url: str, path: str) -> str:
    """Merge a base URL and a path.

    Args:
        base_url: The base URL to merge.
        path: The path to merge.
    """
    return base_url.rstrip('/') + '/' + path.lstrip('/')

# examples/pydantic_ai_examples/ag_ui/api/agentic_generative_ui.py:41-41
    path: str = Field(description='JSON Pointer (RFC 6901) to the target location')

# examples/pydantic_ai_examples/rag.py:171-171
    path: str

# pydantic_ai_slim/pydantic_ai/_ssrf.py:70-70
    path: str

# docs/.hooks/main.py:29-29
bundle_path: Path | None = None

# pydantic_graph/pydantic_graph/beta/decision.py:19-19
from pydantic_graph.beta.paths import Path, PathBuilder, TransformFunction

# pydantic_graph/pydantic_graph/beta/decision.py:19-19
from pydantic_graph.beta.paths import Path, PathBuilder, TransformFunction

# tests/conftest.py:374-375
def assets_path() -> Path:
    return Path(__file__).parent / 'assets'

# pydantic_graph/pydantic_graph/beta/decision.py:19-19
from pydantic_graph.beta.paths import Path, PathBuilder, TransformFunction

# pydantic_graph/pydantic_graph/beta/decision.py:116-116
    path: Path

# tests/test_examples.py:99-112
def tmp_path_cwd(tmp_path: Path):
    cwd = os.getcwd()

    root_dir = Path(__file__).parent.parent
    for file in (root_dir / 'tests' / 'example_modules').glob('*.py'):
        shutil.copy(file, tmp_path)
    sys.path.append(str(tmp_path))
    os.chdir(tmp_path)

    try:
        yield tmp_path
    finally:
        os.chdir(cwd)
        sys.path.remove(str(tmp_path))

# docs/.hooks/snippets.py:13-13
    path: str

# tests/graph/beta/test_graph_edge_cases.py:301-317
async def test_empty_path_handling():
    """Test handling of empty paths in graph execution."""
    g = GraphBuilder(state_type=MyState, output_type=int)

    @g.step
    async def return_value(ctx: StepContext[MyState, None, None]) -> int:
        return 42

    # Just connect start to step to end - this should work fine
    g.add(
        g.edge_from(g.start_node).to(return_value),
        g.edge_from(return_value).to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=MyState())
    assert result == 42

# pydantic_graph/pydantic_graph/beta/paths.py:94-94
    paths: Sequence[Path]

# pydantic_graph/pydantic_graph/beta/graph_builder.py:789-828
def _flatten_paths(
    nodes: dict[NodeID, AnyNode], edges: dict[NodeID, list[Path]]
) -> tuple[dict[NodeID, AnyNode], dict[NodeID, list[Path]]]:
    new_nodes = nodes.copy()
    new_edges: dict[NodeID, list[Path]] = defaultdict(list)

    paths_to_handle: list[tuple[NodeID, Path]] = []

    def _split_at_first_fork(path: Path) -> tuple[Path, list[tuple[NodeID, Path]]]:
        for i, item in enumerate(path.items):
            if isinstance(item, MapMarker):
                assert item.fork_id in nodes, 'This should have been added to the node during GraphBuilder.add'
                upstream = Path(list(path.items[:i]) + [DestinationMarker(item.fork_id)])
                downstream = Path(path.items[i + 1 :])
                return upstream, [(item.fork_id, downstream)]

            if isinstance(item, BroadcastMarker):
                assert item.fork_id in nodes, 'This should have been added to the node during GraphBuilder.add'
                upstream = Path(list(path.items[:i]) + [DestinationMarker(item.fork_id)])
                return upstream, [(item.fork_id, p) for p in item.paths]
        return path, []

    for node in new_nodes.values():
        if isinstance(node, Decision):
            for branch in node.branches:
                upstream, downstreams = _split_at_first_fork(branch.path)
                branch.path = upstream
                paths_to_handle.extend(downstreams)

    for source_id, edges_from_source in edges.items():
        for path in edges_from_source:
            paths_to_handle.append((source_id, path))

    while paths_to_handle:
        source_id, path = paths_to_handle.pop()
        upstream, downstreams = _split_at_first_fork(path)
        new_edges[source_id].append(upstream)
        paths_to_handle.extend(downstreams)

    return new_nodes, dict(new_edges)

# pydantic_graph/pydantic_graph/beta/paths.py:153-159
    def next_path(self) -> Path:
        """Create a new path with the first item removed.

        Returns:
            A new Path with all items except the first one
        """
        return Path(self.items[1:])

# pydantic_graph/pydantic_graph/beta/graph_builder.py:38-46
from pydantic_graph.beta.paths import (
    BroadcastMarker,
    DestinationMarker,
    EdgePath,
    EdgePathBuilder,
    MapMarker,
    Path,
    PathBuilder,
)

# tests/test_ssrf.py:220-225
    def test_empty_path(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('https://example.com')
        assert hostname == 'example.com'
        assert path == '/'
        assert port == 443
        assert is_https is True

# tests/graph/beta/test_decisions.py:19-19
    path_taken: str | None = None

# pydantic_graph/pydantic_graph/beta/paths.py:308-318
    def __init__(
        self, sources: Sequence[SourceNode[StateT, DepsT, Any]], path_builder: PathBuilder[StateT, DepsT, OutputT]
    ):
        """Initialize an edge path builder.

        Args:
            sources: The source nodes for this edge path
            path_builder: The path builder for defining the data flow
        """
        self.sources = sources
        self._path_builder = path_builder

# pydantic_evals/pydantic_evals/dataset.py:77-77
DEFAULT_DATASET_PATH = './test_cases.yaml'

# tests/models/xai_proto_cassettes.py:299-300
    def from_path(cls, path: Path) -> XaiProtoCassetteClient:
        return cls(cassette=XaiProtoCassette.load(path))

# tests/graph/beta/test_paths.py:90-97
async def test_path_builder_label():
    """Test PathBuilder.label method."""
    builder = PathBuilder[MyState, None, int](working_items=[])
    new_builder = builder.label('my label')

    assert len(new_builder.working_items) == 1
    assert isinstance(new_builder.working_items[0], LabelMarker)
    assert new_builder.working_items[0].label == 'my label'

# pydantic_graph/pydantic_graph/beta/graph_builder.py:38-46
from pydantic_graph.beta.paths import (
    BroadcastMarker,
    DestinationMarker,
    EdgePath,
    EdgePathBuilder,
    MapMarker,
    Path,
    PathBuilder,
)

# tests/test_ssrf.py:213-218
    def test_path_with_fragment(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('https://example.com/path#fragment')
        assert hostname == 'example.com'
        assert path == '/path#fragment'
        assert port == 443
        assert is_https is True

# pydantic_evals/pydantic_evals/dataset.py:103-103
    json_schema_path: str | None = Field(default=None, alias='$schema')

# pydantic_graph/pydantic_graph/beta/decision.py:152-152
    _path_builder: PathBuilder[StateT, DepsT, OutputT]

# tests/graph/beta/test_paths.py:63-87
async def test_edge_path_builder_transform():
    """Test EdgePathBuilder.transform method creates proper path."""
    g = GraphBuilder(state_type=MyState, output_type=int)

    @g.step
    async def step_a(ctx: StepContext[MyState, None, None]) -> int:
        return 10

    @g.step
    async def step_b(ctx: StepContext[MyState, None, int]) -> int:
        return ctx.inputs * 3

    def double(ctx: StepContext[MyState, None, int]) -> int:
        return ctx.inputs * 2

    # Build graph with transform in the path
    g.add(
        g.edge_from(g.start_node).to(step_a),
        g.edge_from(step_a).transform(double).to(step_b),
        g.edge_from(step_b).to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=MyState())
    assert result == 60  # 10 * 2 * 3

# tests/models/xai_proto_cassettes.py:574-574
    cassette_path: Path

# clai/update_readme.py:4-4
from pathlib import Path

# tests/graph/beta/test_paths.py:50-60
async def test_path_builder_transform():
    """Test PathBuilder.transform method."""

    async def transform_func(ctx: StepContext[MyState, None, int]) -> int:
        return ctx.inputs * 2  # pragma: no cover

    builder = PathBuilder[MyState, None, int](working_items=[])
    new_builder = builder.transform(transform_func)

    assert len(new_builder.working_items) == 1
    assert isinstance(new_builder.working_items[0], TransformMarker)

# tests/graph/beta/test_edge_labels.py:193-221
async def test_complex_labeled_path():
    """Test a complex path with multiple labels, transforms, and operations."""
    g = GraphBuilder(state_type=LabelState, output_type=list[str])

    @g.step
    async def start(ctx: StepContext[LabelState, None, None]) -> list[int]:
        return [1, 2, 3]

    @g.step
    async def process(ctx: StepContext[LabelState, None, int]) -> int:
        return ctx.inputs * 2

    @g.step
    async def stringify(ctx: StepContext[LabelState, None, int]) -> str:
        return f'value={ctx.inputs}'

    collect = g.join(reduce_list_append, initial_factory=list[str])

    g.add(
        g.edge_from(g.start_node).label('initialize').to(start),
        g.edge_from(start).label('before map').map().label('mapping').to(process),
        g.edge_from(process).label('to stringify').to(stringify),
        g.edge_from(stringify).label('collecting').to(collect),
        g.edge_from(collect).label('done').to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=LabelState())
    assert sorted(result) == ['value=2', 'value=4', 'value=6']

# tests/test_ssrf.py:206-211
    def test_path_with_query_string(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('https://example.com/path?query=value')
        assert hostname == 'example.com'
        assert path == '/path?query=value'
        assert port == 443
        assert is_https is True

# pydantic_graph/pydantic_graph/beta/paths.py:137-137
    items: list[PathItem]

# pydantic_evals/pydantic_evals/dataset.py:79-79
DEFAULT_SCHEMA_PATH_TEMPLATE = './{stem}_schema.json'

# tests/graph/beta/test_edge_labels.py:43-63
async def test_multiple_labels_in_path():
    """Test multiple labels within a single path."""
    g = GraphBuilder(state_type=LabelState, output_type=int)

    @g.step
    async def step_a(ctx: StepContext[LabelState, None, None]) -> int:
        return 5

    @g.step
    async def step_b(ctx: StepContext[LabelState, None, int]) -> int:
        return ctx.inputs + 10

    g.add(
        g.edge_from(g.start_node).label('first label').label('second label').to(step_a),
        g.edge_from(step_a).to(step_b),
        g.edge_from(step_b).to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=LabelState())
    assert result == 15

# tests/graph/beta/test_paths.py:30-33
async def test_path_last_fork_with_no_forks():
    """Test Path.last_fork property when there are no forks."""
    path = Path(items=[LabelMarker('test'), DestinationMarker(NodeID('dest'))])
    assert path.last_fork is None

# tests/test_messages.py:692-741
def test_binary_content_from_path(tmp_path: Path):
    # test normal file
    test_xml_file = tmp_path / 'test.xml'
    test_xml_file.write_text('<think>about trains</think>', encoding='utf-8')
    binary_content = BinaryContent.from_path(test_xml_file)
    assert binary_content == snapshot(BinaryContent(data=b'<think>about trains</think>', media_type='application/xml'))

    # test non-existent file
    non_existent_file = tmp_path / 'non-existent.txt'
    with pytest.raises(FileNotFoundError, match='File not found:'):
        BinaryContent.from_path(non_existent_file)

    # test file with unknown media type
    test_unknown_file = tmp_path / 'test.unknownext'
    test_unknown_file.write_text('some content', encoding='utf-8')
    binary_content = BinaryContent.from_path(test_unknown_file)
    assert binary_content == snapshot(BinaryContent(data=b'some content', media_type='application/octet-stream'))

    # test string path
    test_txt_file = tmp_path / 'test.txt'
    test_txt_file.write_text('just some text', encoding='utf-8')
    string_path = test_txt_file.as_posix()
    binary_content = BinaryContent.from_path(string_path)  # pyright: ignore[reportArgumentType]
    assert binary_content == snapshot(BinaryContent(data=b'just some text', media_type='text/plain'))

    # test image file
    test_jpg_file = tmp_path / 'test.jpg'
    test_jpg_file.write_bytes(b'\xff\xd8\xff\xe0' + b'0' * 100)  # minimal JPEG header + padding
    binary_content = BinaryContent.from_path(test_jpg_file)
    assert binary_content == snapshot(
        BinaryImage(data=b'\xff\xd8\xff\xe0' + b'0' * 100, media_type='image/jpeg', _identifier='bc8d49')
    )

    # test yaml file
    test_yaml_file = tmp_path / 'config.yaml'
    test_yaml_file.write_text('key: value', encoding='utf-8')
    binary_content = BinaryContent.from_path(test_yaml_file)
    assert binary_content == snapshot(BinaryContent(data=b'key: value', media_type='application/yaml'))

    # test yml file (alternative extension)
    test_yml_file = tmp_path / 'docker-compose.yml'
    test_yml_file.write_text('version: "3"', encoding='utf-8')
    binary_content = BinaryContent.from_path(test_yml_file)
    assert binary_content == snapshot(BinaryContent(data=b'version: "3"', media_type='application/yaml'))

    # test toml file
    test_toml_file = tmp_path / 'pyproject.toml'
    test_toml_file.write_text('[project]\nname = "test"', encoding='utf-8')
    binary_content = BinaryContent.from_path(test_toml_file)
    assert binary_content == snapshot(BinaryContent(data=b'[project]\nname = "test"', media_type='application/toml'))

# tests/test_ssrf.py:285-288
    def test_absolute_path(self) -> None:
        """Test that absolute paths are resolved against the current URL."""
        result = resolve_redirect_url('https://example.com/old/path', '/new/path')
        assert result == 'https://example.com/new/path'

# tests/test_ssrf.py:290-293
    def test_relative_path(self) -> None:
        """Test that relative paths are resolved against the current URL."""
        result = resolve_redirect_url('https://example.com/old/path', 'new-file.txt')
        assert result == 'https://example.com/old/new-file.txt'

# tests/graph/beta/test_paths.py:43-47
async def test_path_last_fork_with_map():
    """Test Path.last_fork property with a MapMarker."""
    map = MapMarker(fork_id=ForkID(NodeID('map1')), downstream_join_id=None)
    path = Path(items=[map, LabelMarker('after map')])
    assert path.last_fork is map

# pydantic_graph/pydantic_graph/beta/graph_builder.py:1041-1055
def _update_path_with_id_remapping(path: Path, node_id_remapping: dict[NodeID, NodeID]) -> Path:
    # Note: we have already deepcopied the node provided to this function so it should be okay to make mutations,
    # this could change if we change the code surrounding the code paths leading to this function call though.
    for item in path.items:
        if isinstance(item, MapMarker):
            downstream_join_id = item.downstream_join_id
            if downstream_join_id is not None:
                item.downstream_join_id = JoinID(node_id_remapping.get(downstream_join_id, downstream_join_id))
            item.fork_id = ForkID(node_id_remapping.get(item.fork_id, item.fork_id))
        elif isinstance(item, BroadcastMarker):
            item.fork_id = ForkID(node_id_remapping.get(item.fork_id, item.fork_id))
            item.paths = [_update_path_with_id_remapping(p, node_id_remapping) for p in item.paths]
        elif isinstance(item, DestinationMarker):
            item.destination_id = node_id_remapping.get(item.destination_id, item.destination_id)
    return path

# tests/graph/beta/test_graph_edge_cases.py:358-379
async def test_path_with_label_marker():
    """Test that LabelMarker in paths doesn't affect execution."""
    g = GraphBuilder(state_type=MyState, output_type=int)

    @g.step
    async def step_a(ctx: StepContext[MyState, None, None]) -> int:
        return 10

    @g.step
    async def step_b(ctx: StepContext[MyState, None, int]) -> int:
        return ctx.inputs * 2

    # Add labels to the path
    g.add(
        g.edge_from(g.start_node).label('start').to(step_a),
        g.edge_from(step_a).label('middle').to(step_b),
        g.edge_from(step_b).label('end').to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=MyState())
    assert result == 20

# pydantic_graph/pydantic_graph/beta/paths.py:141-150
    def last_fork(self) -> BroadcastMarker | MapMarker | None:
        """Get the most recent fork or map marker in this path.

        Returns:
            The last BroadcastMarker or MapMarker in the path, or None if no forks exist
        """
        for item in reversed(self.items):
            if isinstance(item, BroadcastMarker | MapMarker):
                return item
        return None

# tests/graph/beta/test_parent_forks.py:178-197
def test_parent_fork_multiple_paths_to_fork():
    """Test parent fork with multiple paths from start to the fork."""
    join_id = 'J'
    nodes = {'start1', 'start2', 'F', 'A', 'B', 'J', 'end'}
    start_ids = {'start1', 'start2'}
    fork_ids = {'F'}
    edges = {
        'start1': ['F'],
        'start2': ['F'],
        'F': ['A', 'B'],
        'A': ['J'],
        'B': ['J'],
        'J': ['end'],
    }

    finder = ParentForkFinder(nodes, start_ids, fork_ids, edges)
    parent_fork = finder.find_parent_fork(join_id)

    assert parent_fork is not None
    assert parent_fork.fork_id == 'F'

# tests/graph/beta/test_paths.py:36-40
async def test_path_last_fork_with_broadcast():
    """Test Path.last_fork property with a BroadcastMarker."""
    broadcast = BroadcastMarker(paths=[], fork_id=ForkID(NodeID('fork1')))
    path = Path(items=[broadcast, LabelMarker('after fork')])
    assert path.last_fork is broadcast

# pydantic_graph/pydantic_graph/beta/paths.py:291-292
    def sources(self) -> Sequence[SourceNode[StateT, DepsT, Any]]:
        return self._sources

# pydantic_graph/pydantic_graph/beta/decision.py:19-19
from pydantic_graph.beta.paths import Path, PathBuilder, TransformFunction

# docs/.hooks/test_snippets.py:71-75
def test_parse_snippet_directive_missing_path():
    """Test that missing path raises ValueError."""
    line = '```snippet {title="Test"}'
    with pytest.raises(ValueError, match='Missing required key "path" in snippet directive'):
        parse_snippet_directive(line)

# pydantic_graph/pydantic_graph/beta/paths.py:276-276
    _sources: Sequence[SourceNode[StateT, DepsT, Any]]

# pydantic_graph/pydantic_graph/beta/paths.py:283-288
    def __init__(
        self, sources: Sequence[SourceNode[StateT, DepsT, Any]], path: Path, destinations: list[AnyDestinationNode]
    ):
        self._sources = sources
        self.path = path
        self.destinations = destinations

# tests/test_ui_web.py:543-552
async def test_get_ui_html_local_file_path_instance(monkeypatch: pytest.MonkeyPatch, tmp_path: Path):
    """Test that _get_ui_html supports Path instances."""
    # Create a test HTML file
    test_html = b'<html><body>Path Instance UI</body></html>'
    local_file = tmp_path / 'path-ui.html'
    local_file.write_bytes(test_html)

    result = await app_module._get_ui_html(html_source=local_file)  # pyright: ignore[reportPrivateUsage]

    assert result == test_html

# tests/test_cli.py:129-131
def test_agent_flag_bad_module_variable_path(capfd: CaptureFixture[str], mocker: MockerFixture, env: TestEnv):
    assert cli(['--agent', 'bad_path', 'hello']) == 1
    assert 'Could not load agent from bad_path' in capfd.readouterr().out

# pydantic_graph/pydantic_graph/beta/graph_builder.py:334-398
    def add(self, *edges: EdgePath[StateT, DepsT]) -> None:  # noqa: C901
        """Add one or more edge paths to the graph.

        This method processes edge paths and automatically creates any necessary
        fork nodes for broadcasts and maps.

        Args:
            *edges: The edge paths to add to the graph
        """

        def _handle_path(p: Path):
            """Process a path and create necessary fork nodes.

            Args:
                p: The path to process
            """
            for item in p.items:
                if isinstance(item, BroadcastMarker):
                    new_node = Fork[Any, Any](id=item.fork_id, is_map=False, downstream_join_id=None)
                    self._insert_node(new_node)
                    for path in item.paths:
                        _handle_path(Path(items=[*path.items]))
                elif isinstance(item, MapMarker):
                    new_node = Fork[Any, Any](id=item.fork_id, is_map=True, downstream_join_id=item.downstream_join_id)
                    self._insert_node(new_node)
                elif isinstance(item, DestinationMarker):
                    pass

        def _handle_destination_node(d: AnyDestinationNode):
            if id(d) in destination_ids:
                return  # prevent infinite recursion if there is a cycle of decisions

            destination_ids.add(id(d))
            destinations.append(d)
            self._insert_node(d)
            if isinstance(d, Decision):
                for branch in d.branches:
                    _handle_path(branch.path)
                    for d2 in branch.destinations:
                        _handle_destination_node(d2)

        destination_ids = set[int]()
        destinations: list[AnyDestinationNode] = []
        for edge in edges:
            for source_node in edge.sources:
                self._insert_node(source_node)
                self._edges_by_source[source_node.id].append(edge.path)
            for destination_node in edge.destinations:
                _handle_destination_node(destination_node)
            _handle_path(edge.path)

        # Automatically create edges from step function return hints including `BaseNode`s
        for destination in destinations:
            if not isinstance(destination, Step) or isinstance(destination, NodeStep):
                continue
            parent_namespace = _utils.get_parent_namespace(inspect.currentframe())
            type_hints = get_type_hints(destination.call, localns=parent_namespace, include_extras=True)
            try:
                return_hint = type_hints['return']
            except KeyError:
                pass
            else:
                edge = self._edge_from_return_hint(destination, return_hint)
                if edge is not None:
                    self.add(edge)

# docs/.hooks/snippets.py:62-118
class ParsedFile:
    lines: list[str]
    sections: dict[str, list[LineRange]]
    lines_mapping: dict[int, int]

    def render(self, fragment_sections: list[str], highlight_sections: list[str]) -> RenderedSnippet:
        fragment_ranges: list[LineRange] = []
        if fragment_sections:
            for k in fragment_sections:
                if k not in self.sections:
                    raise ValueError(f'Unrecognized fragment section: {k!r} (expected {list(self.sections)})')
                fragment_ranges.extend(self.sections[k])
            fragment_ranges = LineRange.merge(fragment_ranges)
        else:
            fragment_ranges = [LineRange(0, len(self.lines))]

        highlight_ranges: list[LineRange] = []
        for k in highlight_sections:
            if k not in self.sections:
                raise ValueError(f'Unrecognized highlight section: {k!r} (expected {list(self.sections)})')
            highlight_ranges.extend(self.sections[k])
        highlight_ranges = LineRange.merge(highlight_ranges)

        rendered_highlight_ranges = list[LineRange]()
        rendered_lines: list[str] = []
        last_end_line = 1
        current_line = 0
        for fragment_range in fragment_ranges:
            if fragment_range.start_line > last_end_line:
                if current_line == 0:
                    rendered_lines.append('...\n')
                else:
                    rendered_lines.append('\n...\n')

                current_line += 1
            fragment_highlight_ranges = fragment_range.intersection(highlight_ranges)
            for fragment_highlight_range in fragment_highlight_ranges:
                rendered_highlight_ranges.append(
                    LineRange(
                        fragment_highlight_range.start_line - fragment_range.start_line + current_line,
                        fragment_highlight_range.end_line - fragment_range.start_line + current_line,
                    )
                )

            for i in range(fragment_range.start_line, fragment_range.end_line):
                rendered_lines.append(self.lines[i])
                current_line += 1
            last_end_line = fragment_range.end_line

        if last_end_line < len(self.lines):
            rendered_lines.append('\n...')

        original_range = LineRange(
            self.lines_mapping[fragment_ranges[0].start_line],
            self.lines_mapping[fragment_ranges[-1].end_line - 1] + 1,
        )
        return RenderedSnippet('\n'.join(rendered_lines), LineRange.merge(rendered_highlight_ranges), original_range)

# tests/test_ui_web.py:530-539
async def test_get_ui_html_local_file_path_string(monkeypatch: pytest.MonkeyPatch, tmp_path: Path):
    """Test that _get_ui_html supports local file paths as strings."""
    # Create a test HTML file
    test_html = b'<html><body>Local UI Content</body></html>'
    local_file = tmp_path / 'custom-ui.html'
    local_file.write_bytes(test_html)

    result = await app_module._get_ui_html(html_source=str(local_file))  # pyright: ignore[reportPrivateUsage]

    assert result == test_html

# pydantic_graph/pydantic_graph/beta/graph_builder.py:444-455
    def edge_from(self, *sources: Source[SourceOutputT]) -> EdgePathBuilder[StateT, DepsT, SourceOutputT]:
        """Create an edge path builder starting from the given source nodes.

        Args:
            *sources: The source nodes to start the edge path from

        Returns:
            An EdgePathBuilder for constructing the complete edge path
        """
        return EdgePathBuilder[StateT, DepsT, SourceOutputT](
            sources=sources, path_builder=PathBuilder(working_items=[])
        )

# pydantic_graph/pydantic_graph/beta/paths.py:280-280
    destinations: list[AnyDestinationNode]

# pydantic_graph/pydantic_graph/beta/paths.py:175-175
    working_items: Sequence[PathItem]

# pydantic_ai_slim/pydantic_ai/models/bedrock.py:249-249
    bedrock_additional_model_response_fields_paths: list[str]

# pydantic_ai_slim/pydantic_ai/retries.py:38-38
from email.utils import parsedate_to_datetime

# docs/.hooks/snippets.py:63-63
    lines: list[str]

# docs/.hooks/snippets.py:64-64
    sections: dict[str, list[LineRange]]