```
FILE: pydantic_ai_slim/pydantic_ai/agent/__init__.py
SEARCH:
        if model is None or defer_model_check:
            self._model = model
REPLACE:
        if model is None and not defer_model_check:
            self._model = models.infer_model(model)
        else:
            self._model = model
```

```
FILE: pydantic_ai_slim/pydantic_ai/_parts_manager.py
SEARCH:
        if vendor_part_id is None:
            # vendor_part_id is None, so check if the latest part is a matching tool call or delta to update
            # When the vendor_part_id is None, if the tool_name is _not_ None, assume this should be a new part rather
            # than a delta on an existing one. We can change this behavior in the future if necessary for some model.
            if tool_name is None:
                existing_matching_part_and_index = self._latest_part_if_of_type(
                    ToolCallPart, BuiltinToolCallPart, ToolCallPartDelta
                )
REPLACE:
        if vendor_part_id is None and tool_name is None:
            existing_matching_part_and_index = self._latest_part_if_of_type(
                ToolCallPart, BuiltinToolCallPart, ToolCallPartDelta
            )
```

```
FILE: pydantic_ai_slim/pydantic_ai/models/instrumented.py
SEARCH:
        for typ in ['input', 'output']:
            if not (tokens := getattr(response.usage, f'{typ}_tokens', 0)):  # pragma: no cover
                continue
REPLACE:
        for typ in ['input', 'output']:
            tokens = getattr(response.usage, f'{typ}_tokens', 0)
            if tokens is None or tokens == 0:  # pragma: no cover
                continue
```