# tests/test_tools.py:2665-2675
def test_tool_timeout_default_none():
    """Test that timeout defaults to None when not specified."""
    agent = Agent(TestModel())

    @agent.tool_plain
    def tool_without_timeout() -> str:
        return 'done'  # pragma: no cover

    tool = agent._function_toolset.tools['tool_without_timeout']
    assert tool.timeout is None
    assert tool.tool_def.timeout is None

# tests/test_mcp.py:2289-2301
async def test_tools_no_caching_when_disabled() -> None:
    """Test that list_tools() does not cache when cache_tools=False."""
    server = MCPServerStdio('python', ['-m', 'tests.mcp_server'], cache_tools=False)
    async with server:
        # First call - should not populate cache
        tools1 = await server.list_tools()
        assert len(tools1) > 0
        assert server._cached_tools is None  # pyright: ignore[reportPrivateUsage]

        # Second call - cache should still be None
        tools2 = await server.list_tools()
        assert tools2 == tools1
        assert server._cached_tools is None  # pyright: ignore[reportPrivateUsage]

# tests/test_mcp.py:2339-2352
async def test_resources_no_caching_when_disabled() -> None:
    """Test that list_resources() does not cache when cache_resources=False."""
    server = MCPServerStdio('python', ['-m', 'tests.mcp_server'], cache_resources=False)
    async with server:
        assert server.capabilities.resources

        # First call - should not populate cache
        resources1 = await server.list_resources()
        assert server._cached_resources is None  # pyright: ignore[reportPrivateUsage]

        # Second call - cache should still be None
        resources2 = await server.list_resources()
        assert resources2 == resources1
        assert server._cached_resources is None  # pyright: ignore[reportPrivateUsage]

# tests/example_modules/weather_service.py:7-18
class WeatherService:
    def get_historic_weather(self, location: str, forecast_date: date) -> str:
        return 'Sunny with a chance of rain'

    def get_forecast(self, location: str, forecast_date: date) -> str:
        return 'Rainy with a chance of sun'

    async def __aenter__(self) -> WeatherService:
        return self

    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
        pass

# pydantic_ai_slim/pydantic_ai/ui/_event_stream.py:211-230
    async def _turn_to(self, to_turn: Literal['request', 'response'] | None) -> AsyncIterator[EventT]:
        """Fire hooks when turning from request to response or vice versa."""
        if to_turn == self._turn:
            return

        if self._turn == 'request':
            async for e in self.after_request():
                yield e
        elif self._turn == 'response':
            async for e in self.after_response():
                yield e

        self._turn = to_turn

        if to_turn == 'request':
            async for e in self.before_request():
                yield e
        elif to_turn == 'response':
            async for e in self.before_response():
                yield e

# tests/test_mcp.py:2218-2227
async def test_client_info_not_set() -> None:
    """Test that when client_info is not set, the default MCP client info is used."""
    server = MCPServerStdio('python', ['-m', 'tests.mcp_server'])

    async with server:
        result = await server.direct_call_tool('get_client_info', {})
        # When client_info is not set, the MCP library provides default client info
        assert result is not None
        assert isinstance(result, dict)
        assert result['name'] == 'mcp'

# tests/profiles/test_google.py:77-83
def test_const_array_does_not_infer_type():
    """When const is an array, type cannot be inferred and should not be added."""
    schema = {'const': [1, 2, 3]}
    transformer = GoogleJsonSchemaTransformer(schema)
    transformed = transformer.walk()

    assert transformed == snapshot({'enum': [[1, 2, 3]]})

# tests/test_concurrency.py:216-219
    async def test_returns_null_context_when_none(self):
        """Test that get_concurrency_context returns a no-op context when None."""
        async with get_concurrency_context(None, 'test'):
            pass  # Should be a no-op

# tests/profiles/test_anthropic.py:191-209
def test_strict_none_simple_schema():
    """With strict=None, simple schemas are not transformed (only title/$schema removed)."""

    class Person(BaseModel):
        name: str
        age: int

    transformer = AnthropicJsonSchemaTransformer(Person.model_json_schema(), strict=None)
    transformed = transformer.walk()

    assert transformer.is_strict_compatible is False
    # No additionalProperties added, title removed
    assert transformed == snapshot(
        {
            'type': 'object',
            'properties': {'name': {'type': 'string'}, 'age': {'type': 'integer'}},
            'required': ['name', 'age'],
        }
    )

# tests/graph/beta/test_edge_cases.py:34-57
async def test_step_returning_none():
    """Test steps that return None."""
    g = GraphBuilder(state_type=EdgeCaseState)

    @g.step
    async def do_nothing(ctx: StepContext[EdgeCaseState, None, None]) -> None:
        ctx.state.value = 99
        return None

    @g.step
    async def return_none(ctx: StepContext[EdgeCaseState, None, None]) -> None:
        return None

    g.add(
        g.edge_from(g.start_node).to(do_nothing),
        g.edge_from(do_nothing).to(return_none),
        g.edge_from(return_none).to(g.end_node),
    )

    graph = g.build()
    state = EdgeCaseState()
    result = await graph.run(state=state)
    assert result is None
    assert state.value == 99

# tests/profiles/test_anthropic.py:167-188
def test_strict_none_preserves_schema():
    """With strict=None (default), schemas are not transformed (only title/$schema removed)."""

    class User(BaseModel):
        username: Annotated[str, Field(min_length=3)]
        age: int

    transformer = AnthropicJsonSchemaTransformer(User.model_json_schema(), strict=None)
    transformed = transformer.walk()

    assert transformer.is_strict_compatible is False
    # Constraints preserved, title removed
    assert transformed == snapshot(
        {
            'type': 'object',
            'properties': {
                'username': {'minLength': 3, 'type': 'string'},
                'age': {'type': 'integer'},
            },
            'required': ['username', 'age'],
        }
    )

# examples/pydantic_ai_examples/evals/example_01_generate_dataset.py:3-3
from types import NoneType

# examples/pydantic_ai_examples/evals/example_01_generate_dataset.py:3-3
from types import NoneType

# examples/pydantic_ai_examples/evals/example_01_generate_dataset.py:3-3
from types import NoneType

# examples/pydantic_ai_examples/evals/example_01_generate_dataset.py:3-3
from types import NoneType

# examples/pydantic_ai_examples/evals/example_01_generate_dataset.py:3-3
from types import NoneType

# examples/pydantic_ai_examples/evals/example_01_generate_dataset.py:3-3
from types import NoneType

# examples/pydantic_ai_examples/evals/example_01_generate_dataset.py:3-3
from types import NoneType

# examples/pydantic_ai_examples/evals/example_01_generate_dataset.py:3-3
from types import NoneType

# examples/pydantic_ai_examples/evals/example_01_generate_dataset.py:3-3
from types import NoneType

# tests/mcp_server.py:164-165
async def get_none():
    return None

# pydantic_evals/pydantic_evals/otel/span_tree.py:94-96
    def duration(self) -> timedelta:
        """Return the span's duration as a timedelta, or None if start/end not set."""
        return self.end_timestamp - self.start_timestamp

# tests/evals/test_otel.py:881-895
async def test_context_subtree_not_configured(mocker: MockerFixture):
    """Test that context_subtree correctly records spans in independent async contexts."""
    from opentelemetry.trace import ProxyTracerProvider

    mocker.patch(
        'pydantic_evals.otel._context_in_memory_span_exporter.get_tracer_provider', return_value=ProxyTracerProvider()
    )
    with context_subtree() as span_tree:
        pass
    assert str(span_tree) == snapshot(
        'To make use of the `span_tree` in an evaluator, you need to call '
        '`logfire.configure(...)` before running an evaluation. For more information, '
        'refer to the documentation at '
        'https://ai.pydantic.dev/evals/#opentelemetry-integration.'
    )

# tests/test_usage_limits.py:258-284
def test_add_usages_with_none_detail_value():
    """Test that None values in details are skipped when incrementing usage."""
    usage = RunUsage(
        requests=1,
        input_tokens=10,
        output_tokens=20,
        details={'reasoning_tokens': 5},
    )

    # Create a usage with None in details (simulating model response with missing detail)
    incr_usage = RunUsage(
        requests=1,
        input_tokens=5,
        output_tokens=10,
    )
    # Manually set a None value in details to simulate edge case from model responses
    incr_usage.details = {'reasoning_tokens': None, 'other_tokens': 10}  # type: ignore[dict-item]

    result = usage + incr_usage
    assert result == snapshot(
        RunUsage(
            requests=2,
            input_tokens=15,
            output_tokens=30,
            details={'reasoning_tokens': 5, 'other_tokens': 10},
        )
    )

# pydantic_evals/pydantic_evals/otel/span_tree.py:483-485
    def first(self, predicate: SpanQuery | SpanPredicate) -> SpanNode | None:
        """Find the first node that matches a predicate, scanning from each root in DFS order. Returns `None` if not found."""
        return next(self._filter(predicate), None)

# pydantic_ai_slim/pydantic_ai/format_prompt.py:84-84
    none_str: str

# tests/models/test_model_settings.py:121-144
def test_none_settings_in_hierarchy():
    """Test that None settings at any level don't break the merge hierarchy."""
    captured_settings = None

    def capture_settings(messages: list[ModelMessage], agent_info: AgentInfo) -> ModelResponse:
        nonlocal captured_settings
        captured_settings = agent_info.model_settings
        return ModelResponse(parts=[TextPart('captured')])

    # Model with no settings
    model = FunctionModel(capture_settings, settings=None)

    # Agent with settings
    agent_settings = ModelSettings(max_tokens=150, temperature=0.5)
    agent = Agent(model=model, model_settings=agent_settings)

    # Run with no additional settings
    result = agent.run_sync('test', model_settings=None)
    assert result.output == 'captured'

    # Should have agent settings
    assert captured_settings is not None
    assert captured_settings['max_tokens'] == 150
    assert captured_settings['temperature'] == 0.5

# tests/evals/test_multi_run.py:180-189
async def test_case_groups_returns_none_for_single_run():
    """case_groups() should return None when no cases have source_case_name (single-run experiment)."""

    async def task(inputs: str) -> str:
        return inputs.upper()

    dataset = Dataset(cases=[Case(name='case1', inputs='hello')])
    report = await dataset.evaluate(task, name='test', progress=False, repeat=1)

    assert report.case_groups() is None

# pydantic_graph/pydantic_graph/_utils.py:75-86
def unpack_annotated(tp: Any) -> tuple[Any, list[Any]]:
    """Strip `Annotated` from the type if present.

    Returns:
        `(tp argument, ())` if not annotated, otherwise `(stripped type, annotations)`.
    """
    origin = get_origin(tp)
    if typing_objects.is_annotated(origin):
        inner_tp, *args = get_args(tp)
        return inner_tp, args
    else:
        return tp, []

# tests/models/test_model_function.py:279-296
def test_deps_none():
    agent = Agent(FunctionModel(call_tool))

    @agent.tool
    async def get_none(ctx: RunContext[None]):
        nonlocal called

        called = True
        assert ctx.deps is None
        return ''

    called = False
    agent.run_sync('Hello')
    assert called

    called = False
    agent.run_sync('Hello')
    assert called

# pydantic_ai_slim/pydantic_ai/durable_exec/temporal/_logfire.py:8-8
from temporalio.service import ConnectConfig, ServiceClient

# pydantic_graph/pydantic_graph/nodes.py:197-197
    note: str | None

# tests/test_ag_ui.py:244-262
async def test_agui_adapter_state_none() -> None:
    """Ensure adapter exposes `None` state when no frontend state provided."""
    agent = Agent(
        model=FunctionModel(stream_function=simple_stream),
    )

    run_input = RunAgentInput(
        thread_id=uuid_str(),
        run_id=uuid_str(),
        messages=[],
        state=None,
        context=[],
        tools=[],
        forwarded_props=None,
    )

    adapter = AGUIAdapter(agent=agent, run_input=run_input, accept=None)

    assert adapter.state is None

# tests/models/test_openai.py:808-822
async def test_none_delta(allow_model_requests: None):
    stream = [
        none_delta_chunk(),
        text_chunk('hello '),
        text_chunk('world'),
    ]
    mock_client = MockOpenAI.create_mock_stream(stream)
    m = OpenAIChatModel('gpt-4o', provider=OpenAIProvider(openai_client=mock_client))
    agent = Agent(m)

    async with agent.run_stream('') as result:
        assert not result.is_complete
        assert [c async for c in result.stream_text(debounce_by=None)] == snapshot(['hello ', 'hello world'])
        assert result.is_complete
        assert result.usage() == snapshot(RunUsage(requests=1, input_tokens=6, output_tokens=3))

# tests/typed_deps.py:53-54
async def my_prepare_none(ctx: RunContext, tool_defn: ToolDefinition) -> None:
    pass

# pydantic_graph/pydantic_graph/beta/decision.py:54-54
    note: str | None

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# pydantic_evals/pydantic_evals/otel/span_tree.py:51-51
    not_: SpanQuery

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# examples/pydantic_ai_examples/chat_app.py:20-20
from typing import Annotated, Any, Literal, TypeVar

# tests/models/test_openai.py:794-805
def none_delta_chunk(finish_reason: FinishReason | None = None) -> chat.ChatCompletionChunk:
    choice = ChunkChoice(index=0, delta=ChoiceDelta())
    # When using Azure OpenAI and an async content filter is enabled, the openai SDK can return None deltas.
    choice.delta = None  # pyright: ignore[reportAttributeAccessIssue]
    return chat.ChatCompletionChunk(
        id='123',
        choices=[choice],
        created=1704067200,  # 2024-01-01
        model='gpt-4o-123',
        object='chat.completion.chunk',
        usage=CompletionUsage(completion_tokens=1, prompt_tokens=2, total_tokens=3),
    )

# pydantic_evals/pydantic_evals/otel/span_tree.py:158-160
    def first_child(self, predicate: SpanQuery | SpanPredicate) -> SpanNode | None:
        """Return the first immediate child that satisfies the given predicate, or None if none match."""
        return next(self._filter_children(predicate), None)

# pydantic_graph/pydantic_graph/beta/mermaid.py:40-40
    note: str | None

# pydantic_evals/pydantic_evals/otel/span_tree.py:211-215
    def first_ancestor(
        self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None
    ) -> SpanNode | None:
        """Return the closest ancestor that satisfies the given predicate, or `None` if none match."""
        return next(self._filter_ancestors(predicate, stop_recursing_when), None)

# tests/test_json_schema.py:55-89
def test_schema_defs_not_modified():
    """Test that the original schema $defs are not modified during transformation."""

    # Create a concrete subclass for testing
    class TestTransformer(JsonSchemaTransformer):
        def transform(self, schema: dict[str, Any]) -> dict[str, Any]:
            return schema

    # Create a schema with $defs that should not be modified
    original_schema = {
        'type': 'object',
        'properties': {'value': {'$ref': '#/$defs/TestUnion'}},
        '$defs': {
            'TestUnion': {
                'anyOf': [
                    {'type': 'string'},
                    {'type': 'number'},
                ],
                'title': 'TestUnion',
            }
        },
    }

    # Keep a deepcopy to compare against later
    original_schema_copy = deepcopy(original_schema)

    # Transform the schema
    transformer = TestTransformer(original_schema)
    result = transformer.walk()

    # Verify the original schema was not modified
    assert original_schema == original_schema_copy

    # Verify the result is correct
    assert result == original_schema_copy

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/stream_whales.py:18-18
from typing_extensions import NotRequired, TypedDict

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/stream_whales.py:18-18
from typing_extensions import NotRequired, TypedDict

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/stream_whales.py:18-18
from typing_extensions import NotRequired, TypedDict

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/stream_whales.py:18-18
from typing_extensions import NotRequired, TypedDict

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# tests/mcp_server.py:7-17
from mcp.types import (
    Annotations,
    BlobResourceContents,
    CreateMessageResult,
    EmbeddedResource,
    ResourceLink,
    SamplingMessage,
    TextContent,
    TextResourceContents,
    ToolAnnotations,
)

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/stream_whales.py:18-18
from typing_extensions import NotRequired, TypedDict

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/stream_whales.py:18-18
from typing_extensions import NotRequired, TypedDict

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# examples/pydantic_ai_examples/ag_ui/__init__.py:14-14
from __future__ import annotations

# tests/test_mcp.py:1774-1781
async def test_elicitation_callback_not_set(run_context: RunContext[int]):
    """Test that elicitation fails when no callback is set."""
    server = MCPServerStdio('python', ['-m', 'tests.mcp_server'])

    async with server:
        # Should raise an error when elicitation is attempted without callback
        with pytest.raises(ModelRetry, match='Elicitation not supported'):
            await server.direct_call_tool('use_elicitation', {'question': 'Should I continue?'})

# docs/.hooks/test_snippets.py:598-602
def test_inject_snippets_nonexistent_file():
    """Test that nonexistent files raise an error.."""
    markdown = '```snippet {path="nonexistent.py"}```'
    with pytest.raises(FileNotFoundError):
        inject_snippets(markdown, REPO_ROOT)

# tests/test_prefect.py:1217-1248
async def test_disabled_tool():
    """Test that tools can be disabled via tool_task_config_by_name."""

    # Create an agent with a tool
    test_agent = Agent(TestModel(), name='test_disabled_tool')

    @test_agent.tool_plain
    def my_tool() -> str:
        return 'Tool executed'

    # Create PrefectAgent with the tool disabled
    test_prefect_agent = PrefectAgent(
        test_agent,
        tool_task_config_by_name={
            'my_tool': None,
        },
    )

    # Test outside a flow
    result = await test_prefect_agent.run('Call my_tool')
    messages = result.all_messages()
    assert any('my_tool' in str(msg) for msg in messages)

    # Test inside a flow to ensure disabled tools work there too
    @flow
    async def test_flow():
        result = await test_prefect_agent.run('Call my_tool')
        return result

    flow_result = await test_flow()
    flow_messages = flow_result.all_messages()
    assert any('my_tool' in str(msg) for msg in flow_messages)

# tests/models/test_xai.py:989-1003
async def test_xai_none_delta(allow_model_requests: None):
    # Test handling of chunks without deltas
    stream = [
        get_grok_text_chunk('hello '),
        get_grok_text_chunk('world'),
    ]
    mock_client = MockXai.create_mock_stream([stream])
    m = XaiModel(XAI_NON_REASONING_MODEL, provider=XaiProvider(xai_client=mock_client))
    agent = Agent(m)

    async with agent.run_stream('') as result:
        assert not result.is_complete
        assert [c async for c in result.stream_text(debounce_by=None)] == snapshot(['hello ', 'hello world'])
        assert result.is_complete
        assert result.usage() == snapshot(RunUsage(input_tokens=2, output_tokens=1, requests=1))

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# pydantic_graph/pydantic_graph/mermaid.py:237-237
    notes: bool

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# docs/.hooks/algolia.py:2-2
from __future__ import annotations as _annotations

# tests/test_tools.py:2969-2985
def test_tool_call_metadata_not_available_for_unapproved_calls():
    """Test that tool_call_metadata is None for non-approved tool calls."""
    received_metadata: list[Any] = []

    agent = Agent(TestModel())

    @agent.tool
    def my_tool(ctx: RunContext[None], x: int) -> int:
        # Capture the tool_call_metadata from context
        received_metadata.append(ctx.tool_call_metadata)
        return x * 42

    result = agent.run_sync('Hello')
    assert result.output == snapshot('{"my_tool":0}')
    # For regular tool calls (not via ToolApproved), metadata should be None
    assert len(received_metadata) == 1
    assert received_metadata[0] is None

# pydantic_ai_slim/pydantic_ai/durable_exec/temporal/_model.py:243-262
    def _get_model_id(self, model: models.Model | models.KnownModelName | str | None = None) -> str | None:
        """Get the model ID for the given model parameter.

        Returns a string that will be checked against registered model IDs,
        or passed to infer_model if not found. Returns None to use the default model.
        """
        if model in (None, 'default'):
            return None

        if isinstance(model, Model):
            # Check if this model instance is already registered
            model_id = next((model_id for model_id, m in self._models_by_id.items() if m is model), ...)
            if model_id is ...:
                raise UserError(
                    'Arbitrary model instances cannot be used at runtime inside a Temporal workflow. '
                    'Register the model via `models` or reference a registered model by id.'
                )
            return None if model_id == 'default' else model_id

        return model

# tests/example_modules/weather_service.py:17-18
    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
        pass

# tests/graph/beta/test_edge_cases.py:60-80
async def test_step_with_zero_value():
    """Test handling of zero values (ensure they're not confused with None/falsy)."""
    g = GraphBuilder(state_type=EdgeCaseState, output_type=int)

    @g.step
    async def return_zero(ctx: StepContext[EdgeCaseState, None, None]) -> int:
        return 0

    @g.step
    async def process_zero(ctx: StepContext[EdgeCaseState, None, int]) -> int:
        return ctx.inputs + 1

    g.add(
        g.edge_from(g.start_node).to(return_zero),
        g.edge_from(return_zero).to(process_zero),
        g.edge_from(process_zero).to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=EdgeCaseState())
    assert result == 1

# tests/providers/test_google_vertex.py:143-146
def save_service_account(service_account_path: Path, project_id: str) -> None:
    service_account = prepare_service_account_contents(project_id)

    service_account_path.write_text(json.dumps(service_account, indent=2), encoding='utf-8')

# pydantic_graph/pydantic_graph/persistence/__init__.py:208-213
    def should_set_types(self) -> bool:
        """Whether types need to be set.

        Implementations should override this method to return `True` when types have not been set if they are needed.
        """
        return False

# tests/mcp_server.py:7-17
from mcp.types import (
    Annotations,
    BlobResourceContents,
    CreateMessageResult,
    EmbeddedResource,
    ResourceLink,
    SamplingMessage,
    TextContent,
    TextResourceContents,
    ToolAnnotations,
)

# tests/test_mcp.py:2304-2320
async def test_tools_cache_invalidation_on_notification() -> None:
    """Test that tools cache is invalidated when ToolListChangedNotification is received."""
    server = MCPServerStdio('python', ['-m', 'tests.mcp_server'])
    async with server:
        # Get initial tools - hidden_tool should NOT be present (it's disabled at startup)
        tools1 = await server.list_tools()
        tool_names1 = [t.name for t in tools1]
        assert 'hidden_tool' not in tool_names1
        assert 'enable_hidden_tool' in tool_names1

        # Enable the hidden tool (server sends ToolListChangedNotification)
        await server.direct_call_tool('enable_hidden_tool', {})

        # Get tools again - hidden_tool should now be present (cache was invalidated)
        tools2 = await server.list_tools()
        tool_names2 = [t.name for t in tools2]
        assert 'hidden_tool' in tool_names2

# tests/models/test_xai.py:1547-1557
async def test_xai_audio_url_not_supported(allow_model_requests: None):
    """Test that AudioUrl raises NotImplementedError."""
    response = create_response(content='This should not be reached')
    mock_client = MockXai.create_mock([response])
    m = XaiModel(XAI_NON_REASONING_MODEL, provider=XaiProvider(xai_client=mock_client))
    agent = Agent(m)

    audio_url = AudioUrl(url='https://example.com/audio.mp3')

    with pytest.raises(NotImplementedError, match='AudioUrl is not supported by xAI SDK'):
        await agent.run(['What is in this audio?', audio_url])

# tests/models/test_xai.py:1560-1570
async def test_xai_video_url_not_supported(allow_model_requests: None):
    """Test that VideoUrl raises NotImplementedError."""
    response = create_response(content='This should not be reached')
    mock_client = MockXai.create_mock([response])
    m = XaiModel(XAI_NON_REASONING_MODEL, provider=XaiProvider(xai_client=mock_client))
    agent = Agent(m)

    video_url = VideoUrl(url='https://example.com/video.mp4')

    with pytest.raises(NotImplementedError, match='VideoUrl is not supported by xAI SDK'):
        await agent.run(['What is in this video?', video_url])

# tests/example_modules/weather_service.py:14-15
    async def __aenter__(self) -> WeatherService:
        return self

# examples/pydantic_ai_examples/bank_support.py:45-45
    support_advice: str

# examples/pydantic_ai_examples/evals/models.py:41-47
class TimeRangeBuilderError(BaseModel):
    """Response when a time range cannot not be generated."""

    error_message: str

    def __str__(self):
        return f'TimeRangeBuilderError:\n* {self.error_message}'

# pydantic_graph/pydantic_graph/nodes.py:85-102
    def get_note(cls) -> str | None:
        """Get a note about the node to render on mermaid charts.

        By default, this returns a note only if [`docstring_notes`][pydantic_graph.nodes.BaseNode.docstring_notes]
        is `True`. You can override this method to customise the node notes.
        """
        if not cls.docstring_notes:
            return None
        docstring = cls.__doc__
        # dataclasses get an automatic docstring which is just their signature, we don't want that
        if docstring and is_dataclass(cls) and docstring.startswith(f'{cls.__name__}('):
            docstring = None  # pragma: no cover
        if docstring:  # pragma: no branch
            # remove indentation from docstring
            import inspect

            docstring = inspect.cleandoc(docstring)
        return docstring

# pydantic_ai_slim/pydantic_ai/mcp.py:118-124
    def from_mcp_sdk(cls, mcp_annotations: mcp_types.Annotations) -> ResourceAnnotations:
        """Convert from MCP SDK Annotations to ResourceAnnotations.

        Args:
            mcp_annotations: The MCP SDK annotations object.
        """
        return cls(audience=mcp_annotations.audience, priority=mcp_annotations.priority)

# pydantic_ai_slim/pydantic_ai/_utils.py:520-525
def _unwrap_annotated(tp: Any) -> Any:
    origin = get_origin(tp)
    while typing_objects.is_annotated(origin):
        tp = tp.__origin__
        origin = get_origin(tp)
    return tp

# pydantic_ai_slim/pydantic_ai/mcp.py:143-143
    annotations: ResourceAnnotations | None = None

# tests/graph/test_mermaid.py:51-51
    docstring_notes = True

# tests/graph/test_mermaid.py:61-61
    docstring_notes = False

# pydantic_ai_slim/pydantic_ai/_utils.py:159-160
def is_set(t_or_unset: T | Unset) -> TypeGuard[T]:
    return t_or_unset is not UNSET

# tests/example_modules/weather_service.py:8-9
    def get_historic_weather(self, location: str, forecast_date: date) -> str:
        return 'Sunny with a chance of rain'

# pydantic_ai_slim/pydantic_ai/_function_schema.py:300-302
def _is_call_ctx(annotation: Any) -> bool:
    """Return whether the annotation is the `RunContext` class, parameterized or not."""
    return annotation is RunContext or get_origin(annotation) is RunContext

# tests/test_agent.py:7142-7156
def test_override_none_clears_instructions():
    """Test that passing None for instructions clears all instructions."""
    agent = Agent('test', instructions='BASE')

    @agent.instructions
    def instr_fn() -> str:  # pragma: no cover - ignored under override
        return 'ALSO_BASE'

    with agent.override(instructions=None):
        with capture_run_messages() as messages:
            agent.run_sync('Hello', model=TestModel(custom_output_text='ok'))

    req = messages[0]
    assert isinstance(req, ModelRequest)
    assert req.instructions is None

# tests/example_modules/weather_service.py:11-12
    def get_forecast(self, location: str, forecast_date: date) -> str:
        return 'Rainy with a chance of sun'

# pydantic_evals/pydantic_evals/otel/span_tree.py:178-182
    def first_descendant(
        self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None
    ) -> SpanNode | None:
        """DFS: Return the first descendant (in DFS order) that satisfies the given predicate, or `None` if none match."""
        return next(self._filter_descendants(predicate, stop_recursing_when), None)

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:349-357
class _OpenRouterFileAnnotation(BaseModel, frozen=True):
    """File annotation from OpenRouter.

    OpenRouter can return file annotations when processing uploaded files like PDFs.
    The schema is flexible since OpenRouter doesn't document the exact fields.
    """

    type: Literal['file']
    file: dict[str, Any] | None = None

# pydantic_graph/pydantic_graph/nodes.py:40-40
    docstring_notes: ClassVar[bool] = False

# pydantic_ai_slim/pydantic_ai/models/openrouter.py:360-360
_OpenRouterAnnotation: TypeAlias = _OpenAIAnnotation | _OpenRouterFileAnnotation