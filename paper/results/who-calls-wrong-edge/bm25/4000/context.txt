# tests/test_graph.py:170-175
    def test_who_calls(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        callers = query.who_calls("helper_function")
        # main() calls helper_function()
        caller_names = [c["name"] for c in callers]
        assert any("main" in name for name in caller_names)

# tests/test_cli.py:71-75
    def test_who_calls(self, runner: CliRunner, indexed_project: Path):
        result = runner.invoke(
            main, ["who-calls", "helper_function", "--path", str(indexed_project)]
        )
        assert result.exit_code == 0

# src/cegraph/cli.py:202-218
def who_calls(symbol_name: str, path: str | None, depth: int):
    """Find all callers of a function or method."""
    root = _get_project_root(path)
    graph, store = _load_graph(root)

    from cegraph.graph.query import GraphQuery

    query = GraphQuery(graph, store)
    callers = query.who_calls(symbol_name, max_depth=depth)

    if callers:
        console.info(f"Callers of '{symbol_name}':")
        console.show_callers(callers, symbol_name)
    else:
        console.warning(f"No callers found for '{symbol_name}'")

    store.close()

# tests/test_mcp.py:103-109
    def test_who_calls(self, mcp_server: MCPServer):
        """Test the who_calls tool."""
        result = mcp_server._dispatch("tools/call", {
            "name": "who_calls",
            "arguments": {"symbol": "helper_function"},
        })
        assert not result.get("isError")

# src/cegraph/mcp/server.py:269-281
    def _tool_who_calls(self, args: dict) -> str:
        self._ensure_graph()
        callers = self._query.who_calls(
            args["symbol"], max_depth=args.get("max_depth", 3)
        )
        if not callers:
            return f"No callers found for '{args['symbol']}'"

        lines = [f"Callers of '{args['symbol']}':"]
        for c in callers:
            indent = "  " * c.get("depth", 1)
            lines.append(f"{indent}{c['name']} ({c['kind']}) at {c['file_path']}:{c['line']}")
        return "\n".join(lines)

# src/cegraph/tools/definitions.py:77-89
    def who_calls(self, symbol_name: str, max_depth: int = 2) -> str:
        """Find all callers of a function/method."""
        results = self.query.who_calls(symbol_name, max_depth=max_depth)
        if not results:
            return f"No callers found for '{symbol_name}'"

        output = [f"Callers of `{symbol_name}`:"]
        for r in results:
            indent = "  " * r["depth"]
            output.append(
                f"{indent}← **{r['name']}** ({r['kind']}) at {r['file_path']}:{r['line']}"
            )
        return "\n".join(output)

# tests/test_cli.py:77-82
    def test_who_calls_not_found(self, runner: CliRunner, indexed_project: Path):
        result = runner.invoke(
            main, ["who-calls", "nonexistent_func", "--path", str(indexed_project)]
        )
        assert result.exit_code == 0
        assert "No callers" in result.output

# tests/test_tools.py:35-38
    def test_who_calls(self, tmp_project: Path):
        tools = self._build_tools(tmp_project)
        result = tools.who_calls("helper_function")
        assert "main" in result.lower() or "Callers" in result

# tests/test_cli.py:70-82
class TestCLIWhoCalls:
    def test_who_calls(self, runner: CliRunner, indexed_project: Path):
        result = runner.invoke(
            main, ["who-calls", "helper_function", "--path", str(indexed_project)]
        )
        assert result.exit_code == 0

    def test_who_calls_not_found(self, runner: CliRunner, indexed_project: Path):
        result = runner.invoke(
            main, ["who-calls", "nonexistent_func", "--path", str(indexed_project)]
        )
        assert result.exit_code == 0
        assert "No callers" in result.output

# src/cegraph/graph/query.py:122-160
    def who_calls(self, name: str, max_depth: int = 1) -> list[dict]:
        """Find all callers of a symbol, optionally going N levels deep.

        Returns list of {symbol_id, name, file_path, line, depth}
        """
        symbol_ids = self.find_symbol(name)
        if not symbol_ids:
            return []

        results = []
        visited = set()

        def _traverse(node_id: str, depth: int) -> None:
            if depth > max_depth or node_id in visited:
                return
            visited.add(node_id)

            for pred in self.graph.predecessors(node_id):
                edge_data = self.graph.edges[pred, node_id]
                if edge_data.get("kind") != "contains":
                    continue
                pred_data = self.graph.nodes.get(pred, {})
                if pred_data.get("type") != "symbol":
                    continue

                results.append({
                    "symbol_id": pred,
                    "name": pred_data.get("qualified_name", pred_data.get("name", "")),
                    "kind": pred_data.get("kind", ""),
                    "file_path": pred_data.get("file_path", ""),
                    "line": pred_data.get("line_start", 0),
                    "depth": depth,
                })
                _traverse(pred, depth + 1)

        for sid in symbol_ids:
            _traverse(sid, 1)

        return results

# src/cegraph/parser/python_parser.py:286-302
def _extract_calls(
    node: ast.AST, file_path: str, caller_id: str, result: FileSymbols
) -> None:
    """Walk a function body and extract all function calls."""
    for child in ast.walk(node):
        if isinstance(child, ast.Call):
            callee = _node_to_name(child.func)
            if callee:
                result.relationships.append(
                    Relationship(
                        source=caller_id,
                        target=callee,
                        kind=RelKind.CALLS,
                        file_path=file_path,
                        line=child.lineno if hasattr(child, "lineno") else 0,
                    )
                )

# tests/test_graph.py:177-182
    def test_what_calls(self, tmp_project: Path):
        query = self._build_query(tmp_project)
        callees = query.what_calls("main")
        callee_names = [c["name"] for c in callees]
        # main() should call several functions
        assert len(callees) > 0

# src/cegraph/parser/tree_sitter_parser.py:220-247
def _extract_ts_calls(
    node, file_path: str, language: str, source: bytes,
    caller_id: str, call_types: list[str], result: FileSymbols
) -> None:
    """Extract function calls from a tree-sitter node."""
    if node.type in call_types:
        # Get the function being called
        func_node = node.child_by_field_name("function")
        if func_node is None and node.children:
            func_node = node.children[0]
        if func_node:
            callee = func_node.text.decode("utf-8")
            # Clean up multiline callees
            callee = callee.split("(")[0].strip()
            if callee and len(callee) < 100:
                result.relationships.append(
                    Relationship(
                        source=caller_id,
                        target=callee,
                        kind=RelKind.CALLS,
                        file_path=file_path,
                        line=node.start_point[0] + 1,
                    )
                )
        return

    for child in node.children:
        _extract_ts_calls(child, file_path, language, source, caller_id, call_types, result)

# src/cegraph/parser/models.py:28-28
    CALLS = "calls"

# src/cegraph/tools/definitions.py:91-102
    def what_calls(self, symbol_name: str) -> str:
        """Find all symbols called by a function/method."""
        results = self.query.what_calls(symbol_name)
        if not results:
            return f"No callees found for '{symbol_name}'"

        output = [f"`{symbol_name}` calls:"]
        for r in results:
            output.append(
                f"→ **{r['name']}** ({r['kind']}) at {r['file_path']}:{r['line']}"
            )
        return "\n".join(output)

# src/cegraph/graph/query.py:162-183
    def what_calls(self, name: str) -> list[dict]:
        """Find all symbols called by the given symbol."""
        symbol_ids = self.find_symbol(name)
        results = []

        for sid in symbol_ids:
            for succ in self.graph.successors(sid):
                edge_data = self.graph.edges[sid, succ]
                if edge_data.get("kind") != "calls":
                    continue
                succ_data = self.graph.nodes.get(succ, {})
                if succ_data.get("type") != "symbol":
                    continue
                results.append({
                    "symbol_id": succ,
                    "name": succ_data.get("qualified_name", succ_data.get("name", "")),
                    "kind": succ_data.get("kind", ""),
                    "file_path": succ_data.get("file_path", ""),
                    "line": succ_data.get("line_start", 0),
                })

        return results

# src/cegraph/llm/base.py:55-56
    def has_tool_calls(self) -> bool:
        return len(self.tool_calls) > 0

# tests/test_tools.py:40-43
    def test_what_calls(self, tmp_project: Path):
        tools = self._build_tools(tmp_project)
        result = tools.what_calls("main")
        assert len(result) > 0

# tests/test_parser.py:91-98
    def test_parse_calls(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)
        calls = [r for r in result.relationships if r.kind == RelKind.CALLS]
        # run_pipeline calls create_processor
        assert any(
            "run_pipeline" in r.source and "create_processor" in r.target
            for r in calls
        )

# src/cegraph/parser/python_parser.py:204-256
def _extract_class(
    node: ast.ClassDef,
    file_path: str,
    lines: list[str],
    result: FileSymbols,
    parent_name: str,
    parent_id: str,
) -> None:
    """Extract class definition and its members."""
    qualified = f"{parent_name}.{node.name}" if parent_name else node.name

    symbol = Symbol(
        name=node.name,
        qualified_name=qualified,
        kind=SymbolKind.CLASS,
        file_path=file_path,
        line_start=node.lineno,
        line_end=node.end_lineno or node.lineno,
        signature=f"class {node.name}",
        docstring=_get_docstring(node),
        decorators=_get_decorators(node),
        parent=parent_id,
    )
    result.symbols.append(symbol)

    # Add contains relationship
    if parent_id:
        result.relationships.append(
            Relationship(
                source=parent_id,
                target=symbol.id,
                kind=RelKind.CONTAINS,
                file_path=file_path,
                line=node.lineno,
            )
        )

    # Extract inheritance
    for base in node.bases:
        base_name = _node_to_name(base)
        if base_name:
            result.relationships.append(
                Relationship(
                    source=symbol.id,
                    target=base_name,
                    kind=RelKind.INHERITS,
                    file_path=file_path,
                    line=node.lineno,
                )
            )

    # Recurse into class body
    _extract_from_module(node, file_path, lines, result, qualified, symbol.id)

# tests/test_parser.py:106-110
    def test_parse_contains_relationships(self, sample_python_source: str):
        result = parse_python_file("sample.py", sample_python_source)
        contains = [r for r in result.relationships if r.kind == RelKind.CONTAINS]
        # BaseProcessor should contain process, _transform, __init__
        assert any("BaseProcessor" in r.source and "process" in r.target for r in contains)

# src/cegraph/tools/definitions.py:225-262
    def get_context(self, symbol_name: str) -> str:
        """Get full context for a symbol including its source code and relationships."""
        symbol_ids = self.query.find_symbol(symbol_name)
        if not symbol_ids:
            return f"Symbol '{symbol_name}' not found"

        output = []
        for sid in symbol_ids[:3]:  # Limit to 3 matches
            info = self.query.get_symbol_info(sid)
            if not info:
                continue

            output.append(f"## {info.qualified_name} ({info.kind})")
            output.append(f"**File:** {info.file_path}:{info.line_start}-{info.line_end}")
            if info.signature:
                output.append(f"**Signature:** `{info.signature}`")
            if info.docstring:
                output.append(f"**Docstring:** {info.docstring[:200]}")

            # Show source code
            file_content = self.read_file(
                info.file_path,
                start_line=info.line_start,
                end_line=info.line_end,
            )
            output.append(f"\n```\n{file_content}\n```")

            # Show relationships
            if info.callers:
                output.append(f"\n**Called by:** {', '.join(c.split('::')[-1] for c in info.callers[:5])}")
            if info.callees:
                output.append(f"**Calls:** {', '.join(c.split('::')[-1] for c in info.callees[:5])}")
            if info.children:
                output.append(f"**Contains:** {', '.join(c.split('::')[-1] for c in info.children[:5])}")

            output.append("")

        return "\n".join(output)

# src/cegraph/graph/builder.py:12-12
from cegraph.parser.models import FileSymbols, RelKind, Relationship, Symbol, SymbolKind

# src/cegraph/agent/loop.py:14-14
from typing import Any, AsyncIterator, Callable

# src/cegraph/agent/loop.py:17-17
from cegraph.llm.base import LLMProvider, LLMResponse, Message, ToolCall, ToolResult

# src/cegraph/agent/loop.py:17-17
from cegraph.llm.base import LLMProvider, LLMResponse, Message, ToolCall, ToolResult

# src/cegraph/agent/loop.py:17-17
from cegraph.llm.base import LLMProvider, LLMResponse, Message, ToolCall, ToolResult

# src/cegraph/agent/loop.py:17-17
from cegraph.llm.base import LLMProvider, LLMResponse, Message, ToolCall, ToolResult

# src/cegraph/agent/loop.py:14-14
from typing import Any, AsyncIterator, Callable

# paper/experiments/ablation.py:17-17
from dataclasses import asdict, dataclass, field

# paper/experiments/ablation.py:17-17
from dataclasses import asdict, dataclass, field

# paper/experiments/ablation.py:17-17
from dataclasses import asdict, dataclass, field

# paper/experiments/ablation.py:17-17
from dataclasses import asdict, dataclass, field

# paper/experiments/ablation.py:17-17
from dataclasses import asdict, dataclass, field

# paper/experiments/ablation.py:17-17
from dataclasses import asdict, dataclass, field

# paper/experiments/ablation.py:17-17
from dataclasses import asdict, dataclass, field

# paper/experiments/ablation.py:17-17
from dataclasses import asdict, dataclass, field

# src/cegraph/agent/loop.py:17-17
from cegraph.llm.base import LLMProvider, LLMResponse, Message, ToolCall, ToolResult

# src/cegraph/parser/models.py:14-14
    CLASS = "class"

# src/cegraph/parser/models.py:30-30
    INHERITS = "inherits"

# src/cegraph/ui/console.py:131-145
    def show_callers(self, callers: list[dict], symbol_name: str) -> None:
        """Display caller tree."""
        tree = Tree(f"[bold cyan]{symbol_name}[/bold cyan]")
        depth_nodes: dict[int, Tree] = {0: tree}

        for caller in callers:
            depth = caller.get("depth", 1)
            parent = depth_nodes.get(depth - 1, tree)
            node = parent.add(
                f"[bold]{caller['name']}[/bold] [dim]({caller['kind']})[/dim] "
                f"at [cyan]{caller['file_path']}:{caller['line']}[/cyan]"
            )
            depth_nodes[depth] = node

        self.console.print(tree)

# src/cegraph/graph/builder.py:12-12
from cegraph.parser.models import FileSymbols, RelKind, Relationship, Symbol, SymbolKind

# src/cegraph/parser/tree_sitter_parser.py:64-70
_CALL_NODE_TYPES = {
    "javascript": ["call_expression"],
    "typescript": ["call_expression"],
    "go": ["call_expression"],
    "rust": ["call_expression", "macro_invocation"],
    "java": ["method_invocation"],
}

# src/cegraph/tools/registry.py:21-24
    def register(self, func: Callable, definition: ToolDefinition) -> None:
        """Register a tool function with its definition."""
        self._tools[definition.name] = func
        self._definitions[definition.name] = definition