FILE: pydantic_ai_slim/pydantic_ai/_utils.py
SEARCH:
    async def group_by_temporal(
        aiterable: AsyncIterable[T], soft_max_interval: float | None
    ) -> AsyncIterator[AsyncIterable[list[T]]]:
        """Group items from an async iterable into lists based on time interval between them.
        
        Effectively, this debounces the iterator.
        
        This returns a context manager usable as an iterator so any pending tasks can be cancelled if an error occurs
        during iteration.
        
        Usage:
        
        

        
        Args:
            aiterable: The async iterable to group.
            soft_max_interval: Maximum interval over which to group items, this should avoid a trickle of items causing
                a group to never be yielded. It's a soft max in the sense that once we're over this time, we yield items
                as soon as `anext(aiter)` returns. If `None`, no grouping/debouncing is performed
        
        Returns:
            A context manager usable as an async iterable of lists of items produced by the input async iterable.
        """
        if soft_max_interval is None:
            ...
        # we might wait for the next item more than once, so we store the task to await next time
        task: asyncio.Task[T] | None = None
        
        async def async_iter_groups() -> AsyncIterator[list[T]]:
            nonlocal task
            
            assert soft_max_interval is not None and soft_max_interval >= 0, 'soft_max_interval must be a positive number'
            buffer: list[T] = []
            group_start_time = time.monotonic()
        
            aiterator = aiter(aiterable)
            while True:
                if group_start_time is None:
                    # group hasn't started, we just wait for the maximum interval
                    wait_time = soft_max_interval
                else:
                    # wait for the time remaining in the group
                    wait_time = soft_max_interval - (time.monotonic() - group_start_time)
        
                # if there's no current task, we get the next one
                if task is None:
                    task = asyncio.create_task(anext(aiterator))  # pyright: ignore[reportArgumentType,reportUnknownVariableType]
        
                # we use asyncio.wait to avoid cancelling the coroutine if it's not done
                done, _ = await asyncio.wait((task,), timeout=wait_time)
        
                if done:
                    # the one task we waited for completed
                    try:
                        item = done.pop().result()
                    except StopAsyncIteration:
                        # if the task raised StopAsyncIteration, we're done iterating
                        if buffer:
                            yield buffer
                        task = None
                        break
                    else:
                        # we got an item, add it to the buffer and set task to None to get the next item
                        buffer.append(item)
                        task = None
                        # if this is the first item in the group, set the group start time
                        if group_start_time is not None:
                            group_start_time = time.monotonic()
                elif buffer:
                    # otherwise if the task timeout expired and we have items in the buffer, yield the buffer
                    yield buffer
                    # clear the buffer and reset the group start time ready for the next group
                    buffer = []
                    group_start_time = None
        
        try:
            yield async_iter_groups()
        finally:  # pragma: no cover
            # after iteration if a tasks still exists, cancel it, this will only happen if an error occurred
            if task:
                task.cancel('Cancelling due to error in iterator')
                with suppress(asyncio.CancelledError):
                    await task
REPLACE:
    async def group_by_temporal(
        aiterable: AsyncIterable[T], soft_max_interval: float | None
    ) -> AsyncIterator[AsyncIterable[list[T]]]:
        """Group items from an async iterable into lists based on time interval between them.
        
        Effectively, this debounces the iterator.
        
        This returns a context manager usable as an iterator so any pending tasks can be cancelled if an error occurs
        during iteration.
        
        Usage:
        
        

        
        Args:
            aiterable: The async iterable to group.
            soft_max_interval: Maximum interval over which to group items, this should avoid a trickle of items causing
                a group to never be yielded. It's a soft max in the sense that once we're over this time, we yield items
                as soon as `anext(aiter)` returns. If `None`, no grouping/debouncing is performed
        
        Returns:
            A context manager usable as an async iterable of lists of items produced by the input async iterable.
        """
        if soft_max_interval is None:
            async def async_iter_groups_noop() -> AsyncIterator[list[T]]:
                async for item in aiterable:
                    yield [item]

            yield async_iter_groups_noop()
            return
        
        # we might wait for the next item more than once, so we store the task to await next time
        task: asyncio.Task[T] | None = None
        
        async def async_iter_groups() -> AsyncIterator[list[T]]:
            nonlocal task
            
            assert soft_max_interval is not None and soft_max_interval >= 0, 'soft_max_interval must be a positive number'
            buffer: list[T] = []
            group_start_time = time.monotonic()
        
            aiterator = aiter(aiterable)
            while True:
                if group_start_time is None:
                    # group hasn't started, we just wait for the maximum interval
                    wait_time = soft_max_interval
                else:
                    # wait for the time remaining in the group
                    wait_time = soft_max_interval - (time.monotonic() - group_start_time)
        
                # if there's no current task, we get the next one
                if task is None:
                    task = asyncio.create_task(anext(aiterator))  # pyright: ignore[reportArgumentType,reportUnknownVariableType]
        
                # we use asyncio.wait to avoid cancelling the coroutine if it's not done
                done, _ = await asyncio.wait((task,), timeout=wait_time)
        
                if done:
                    # the one task we waited for completed
                    try:
                        item = done.pop().result()
                    except StopAsyncIteration:
                        # if the task raised StopAsyncIteration, we're done iterating
                        if buffer:
                            yield buffer
                        task = None
                        break
                    else:
                        # we got an item, add it to the buffer and set task to None to get the next item
                        buffer.append(item)
                        task = None
                        # if this is the first item in the group, set the group start time
                        if group_start_time is not None:
                            group_start_time = time.monotonic()
                elif buffer:
                    # otherwise if the task timeout expired and we have items in the buffer, yield the buffer
                    yield buffer
                    # clear the buffer and reset the group start time ready for the next group
                    buffer = []
                    group_start_time = None
        
        try:
            yield async_iter_groups()
        finally:  # pragma: no cover
            # after iteration if a tasks still exists, cancel it, this will only happen if an error occurred
            if task:
                task.cancel('Cancelling due to error in iterator')
                with suppress(asyncio.CancelledError):
                    await task
