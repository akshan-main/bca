# tests/test_ssrf.py:242-247
    def test_https_default_port(self) -> None:
        resolved = ResolvedUrl(
            resolved_ip='203.0.113.50', hostname='example.com', port=443, is_https=True, path='/path'
        )
        url = build_url_with_ip(resolved)
        assert url == 'https://203.0.113.50/path'

# pydantic_ai_slim/pydantic_ai/_ssrf.py:70-70
    path: str

# pydantic_ai_slim/pydantic_ai/_ssrf.py:67-67
    is_https: bool

# tests/graph/beta/test_paths.py:100-108
async def test_path_next_path():
    """Test Path.next_path removes first item."""
    items: list[PathItem] = [LabelMarker('first'), LabelMarker('second'), DestinationMarker(NodeID('dest'))]
    path = Path(items=items)

    next_path = path.next_path
    assert len(next_path.items) == 2
    assert next_path.items[0] == items[1]
    assert next_path.items[1] == items[2]

# pydantic_graph/pydantic_graph/beta/paths.py:278-278
    path: Path

# tests/test_ssrf.py:285-288
    def test_absolute_path(self) -> None:
        """Test that absolute paths are resolved against the current URL."""
        result = resolve_redirect_url('https://example.com/old/path', '/new/path')
        assert result == 'https://example.com/new/path'

# tests/test_ssrf.py:290-293
    def test_relative_path(self) -> None:
        """Test that relative paths are resolved against the current URL."""
        result = resolve_redirect_url('https://example.com/old/path', 'new-file.txt')
        assert result == 'https://example.com/old/new-file.txt'

# pydantic_ai_slim/pydantic_ai/providers/gateway.py:212-219
def _merge_url_path(base_url: str, path: str) -> str:
    """Merge a base URL and a path.

    Args:
        base_url: The base URL to merge.
        path: The path to merge.
    """
    return base_url.rstrip('/') + '/' + path.lstrip('/')

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# clai/update_readme.py:4-4
from pathlib import Path

# pydantic_ai_slim/pydantic_ai/messages.py:12-12
from os import PathLike

# pydantic_graph/pydantic_graph/beta/graph_builder.py:38-46
from pydantic_graph.beta.paths import (
    BroadcastMarker,
    DestinationMarker,
    EdgePath,
    EdgePathBuilder,
    MapMarker,
    Path,
    PathBuilder,
)

# pydantic_graph/pydantic_graph/beta/paths.py:125-125
PathItem = TypeAliasType('PathItem', TransformMarker | MapMarker | BroadcastMarker | LabelMarker | DestinationMarker)

# pydantic_graph/pydantic_graph/beta/paths.py:125-125
PathItem = TypeAliasType('PathItem', TransformMarker | MapMarker | BroadcastMarker | LabelMarker | DestinationMarker)

# pydantic_evals/pydantic_evals/dataset.py:77-77
DEFAULT_DATASET_PATH = './test_cases.yaml'

# tests/test_ssrf.py:220-225
    def test_empty_path(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('https://example.com')
        assert hostname == 'example.com'
        assert path == '/'
        assert port == 443
        assert is_https is True

# examples/pydantic_ai_examples/ag_ui/api/agentic_generative_ui.py:41-41
    path: str = Field(description='JSON Pointer (RFC 6901) to the target location')

# examples/pydantic_ai_examples/rag.py:171-171
    path: str

# docs/.hooks/main.py:29-29
bundle_path: Path | None = None

# pydantic_graph/pydantic_graph/beta/decision.py:19-19
from pydantic_graph.beta.paths import Path, PathBuilder, TransformFunction

# pydantic_graph/pydantic_graph/beta/decision.py:19-19
from pydantic_graph.beta.paths import Path, PathBuilder, TransformFunction

# tests/conftest.py:374-375
def assets_path() -> Path:
    return Path(__file__).parent / 'assets'

# pydantic_graph/pydantic_graph/beta/decision.py:19-19
from pydantic_graph.beta.paths import Path, PathBuilder, TransformFunction

# pydantic_graph/pydantic_graph/beta/decision.py:116-116
    path: Path

# tests/test_examples.py:99-112
def tmp_path_cwd(tmp_path: Path):
    cwd = os.getcwd()

    root_dir = Path(__file__).parent.parent
    for file in (root_dir / 'tests' / 'example_modules').glob('*.py'):
        shutil.copy(file, tmp_path)
    sys.path.append(str(tmp_path))
    os.chdir(tmp_path)

    try:
        yield tmp_path
    finally:
        os.chdir(cwd)
        sys.path.remove(str(tmp_path))

# docs/.hooks/snippets.py:13-13
    path: str

# pydantic_graph/pydantic_graph/beta/paths.py:94-94
    paths: Sequence[Path]

# tests/test_ssrf.py:232-266
class TestBuildUrlWithIp:
    """Tests for build_url_with_ip function."""

    def test_http_default_port(self) -> None:
        resolved = ResolvedUrl(
            resolved_ip='203.0.113.50', hostname='example.com', port=80, is_https=False, path='/path'
        )
        url = build_url_with_ip(resolved)
        assert url == 'http://203.0.113.50/path'

    def test_https_default_port(self) -> None:
        resolved = ResolvedUrl(
            resolved_ip='203.0.113.50', hostname='example.com', port=443, is_https=True, path='/path'
        )
        url = build_url_with_ip(resolved)
        assert url == 'https://203.0.113.50/path'

    def test_custom_port(self) -> None:
        resolved = ResolvedUrl(
            resolved_ip='203.0.113.50', hostname='example.com', port=8080, is_https=False, path='/path'
        )
        url = build_url_with_ip(resolved)
        assert url == 'http://203.0.113.50:8080/path'

    def test_ipv6_address(self) -> None:
        resolved = ResolvedUrl(resolved_ip='2001:db8::1', hostname='example.com', port=443, is_https=True, path='/path')
        url = build_url_with_ip(resolved)
        assert url == 'https://[2001:db8::1]/path'

    def test_ipv6_address_custom_port(self) -> None:
        resolved = ResolvedUrl(
            resolved_ip='2001:db8::1', hostname='example.com', port=8443, is_https=True, path='/path'
        )
        url = build_url_with_ip(resolved)
        assert url == 'https://[2001:db8::1]:8443/path'

# tests/test_ssrf.py:192-197
    def test_basic_https_url(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('https://example.com/path')
        assert hostname == 'example.com'
        assert path == '/path'
        assert port == 443
        assert is_https is True

# pydantic_ai_slim/pydantic_ai/_ssrf.py:151-179
def extract_host_and_port(url: str) -> tuple[str, str, int, bool]:
    """Extract hostname, path, port, and protocol info from a URL.

    Returns:
        Tuple of (hostname, path_with_query, port, is_https)

    Raises:
        ValueError: If the URL is malformed or uses an unsupported protocol.
    """
    # Validate protocol first, before trying to extract hostname
    _, is_https = validate_url_protocol(url)

    parsed = urlparse(url)
    hostname = parsed.hostname

    if not hostname:
        raise ValueError(f'Invalid URL: no hostname found in "{url}"')

    default_port = 443 if is_https else 80
    port = parsed.port or default_port

    # Reconstruct path with query string
    path = parsed.path or '/'
    if parsed.query:
        path = f'{path}?{parsed.query}'
    if parsed.fragment:
        path = f'{path}#{parsed.fragment}'

    return hostname, path, port, is_https

# pydantic_graph/pydantic_graph/beta/graph_builder.py:789-828
def _flatten_paths(
    nodes: dict[NodeID, AnyNode], edges: dict[NodeID, list[Path]]
) -> tuple[dict[NodeID, AnyNode], dict[NodeID, list[Path]]]:
    new_nodes = nodes.copy()
    new_edges: dict[NodeID, list[Path]] = defaultdict(list)

    paths_to_handle: list[tuple[NodeID, Path]] = []

    def _split_at_first_fork(path: Path) -> tuple[Path, list[tuple[NodeID, Path]]]:
        for i, item in enumerate(path.items):
            if isinstance(item, MapMarker):
                assert item.fork_id in nodes, 'This should have been added to the node during GraphBuilder.add'
                upstream = Path(list(path.items[:i]) + [DestinationMarker(item.fork_id)])
                downstream = Path(path.items[i + 1 :])
                return upstream, [(item.fork_id, downstream)]

            if isinstance(item, BroadcastMarker):
                assert item.fork_id in nodes, 'This should have been added to the node during GraphBuilder.add'
                upstream = Path(list(path.items[:i]) + [DestinationMarker(item.fork_id)])
                return upstream, [(item.fork_id, p) for p in item.paths]
        return path, []

    for node in new_nodes.values():
        if isinstance(node, Decision):
            for branch in node.branches:
                upstream, downstreams = _split_at_first_fork(branch.path)
                branch.path = upstream
                paths_to_handle.extend(downstreams)

    for source_id, edges_from_source in edges.items():
        for path in edges_from_source:
            paths_to_handle.append((source_id, path))

    while paths_to_handle:
        source_id, path = paths_to_handle.pop()
        upstream, downstreams = _split_at_first_fork(path)
        new_edges[source_id].append(upstream)
        paths_to_handle.extend(downstreams)

    return new_nodes, dict(new_edges)

# pydantic_graph/pydantic_graph/beta/graph_builder.py:38-46
from pydantic_graph.beta.paths import (
    BroadcastMarker,
    DestinationMarker,
    EdgePath,
    EdgePathBuilder,
    MapMarker,
    Path,
    PathBuilder,
)

# tests/graph/beta/test_paths.py:90-97
async def test_path_builder_label():
    """Test PathBuilder.label method."""
    builder = PathBuilder[MyState, None, int](working_items=[])
    new_builder = builder.label('my label')

    assert len(new_builder.working_items) == 1
    assert isinstance(new_builder.working_items[0], LabelMarker)
    assert new_builder.working_items[0].label == 'my label'

# pydantic_evals/pydantic_evals/dataset.py:79-79
DEFAULT_SCHEMA_PATH_TEMPLATE = './{stem}_schema.json'

# tests/test_ssrf.py:213-218
    def test_path_with_fragment(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('https://example.com/path#fragment')
        assert hostname == 'example.com'
        assert path == '/path#fragment'
        assert port == 443
        assert is_https is True

# tests/graph/beta/test_decisions.py:19-19
    path_taken: str | None = None

# tests/graph/beta/test_edge_labels.py:193-221
async def test_complex_labeled_path():
    """Test a complex path with multiple labels, transforms, and operations."""
    g = GraphBuilder(state_type=LabelState, output_type=list[str])

    @g.step
    async def start(ctx: StepContext[LabelState, None, None]) -> list[int]:
        return [1, 2, 3]

    @g.step
    async def process(ctx: StepContext[LabelState, None, int]) -> int:
        return ctx.inputs * 2

    @g.step
    async def stringify(ctx: StepContext[LabelState, None, int]) -> str:
        return f'value={ctx.inputs}'

    collect = g.join(reduce_list_append, initial_factory=list[str])

    g.add(
        g.edge_from(g.start_node).label('initialize').to(start),
        g.edge_from(start).label('before map').map().label('mapping').to(process),
        g.edge_from(process).label('to stringify').to(stringify),
        g.edge_from(stringify).label('collecting').to(collect),
        g.edge_from(collect).label('done').to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=LabelState())
    assert sorted(result) == ['value=2', 'value=4', 'value=6']

# tests/graph/beta/test_paths.py:63-87
async def test_edge_path_builder_transform():
    """Test EdgePathBuilder.transform method creates proper path."""
    g = GraphBuilder(state_type=MyState, output_type=int)

    @g.step
    async def step_a(ctx: StepContext[MyState, None, None]) -> int:
        return 10

    @g.step
    async def step_b(ctx: StepContext[MyState, None, int]) -> int:
        return ctx.inputs * 3

    def double(ctx: StepContext[MyState, None, int]) -> int:
        return ctx.inputs * 2

    # Build graph with transform in the path
    g.add(
        g.edge_from(g.start_node).to(step_a),
        g.edge_from(step_a).transform(double).to(step_b),
        g.edge_from(step_b).to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=MyState())
    assert result == 60  # 10 * 2 * 3

# tests/graph/beta/test_paths.py:50-60
async def test_path_builder_transform():
    """Test PathBuilder.transform method."""

    async def transform_func(ctx: StepContext[MyState, None, int]) -> int:
        return ctx.inputs * 2  # pragma: no cover

    builder = PathBuilder[MyState, None, int](working_items=[])
    new_builder = builder.transform(transform_func)

    assert len(new_builder.working_items) == 1
    assert isinstance(new_builder.working_items[0], TransformMarker)

# pydantic_graph/pydantic_graph/beta/graph.py:857-873
    def _handle_path(self, path: Path, inputs: Any, fork_stack: ForkStack) -> Sequence[GraphTask]:
        if not path.items:
            return []  # pragma: no cover

        item = path.items[0]
        assert not isinstance(item, MapMarker | BroadcastMarker), (
            'These markers should be removed from paths during graph building'
        )
        if isinstance(item, DestinationMarker):
            return [GraphTask(item.destination_id, inputs, fork_stack, self.get_next_task_id())]
        elif isinstance(item, TransformMarker):
            inputs = item.transform(StepContext(state=self.state, deps=self.deps, inputs=inputs))
            return self._handle_path(path.next_path, inputs, fork_stack)
        elif isinstance(item, LabelMarker):
            return self._handle_path(path.next_path, inputs, fork_stack)
        else:
            assert_never(item)

# tests/test_ssrf.py:206-211
    def test_path_with_query_string(self) -> None:
        hostname, path, port, is_https = extract_host_and_port('https://example.com/path?query=value')
        assert hostname == 'example.com'
        assert path == '/path?query=value'
        assert port == 443
        assert is_https is True

# tests/models/xai_proto_cassettes.py:299-300
    def from_path(cls, path: Path) -> XaiProtoCassetteClient:
        return cls(cassette=XaiProtoCassette.load(path))

# pydantic_graph/pydantic_graph/beta/paths.py:153-159
    def next_path(self) -> Path:
        """Create a new path with the first item removed.

        Returns:
            A new Path with all items except the first one
        """
        return Path(self.items[1:])

# tests/graph/beta/test_graph_edge_cases.py:301-317
async def test_empty_path_handling():
    """Test handling of empty paths in graph execution."""
    g = GraphBuilder(state_type=MyState, output_type=int)

    @g.step
    async def return_value(ctx: StepContext[MyState, None, None]) -> int:
        return 42

    # Just connect start to step to end - this should work fine
    g.add(
        g.edge_from(g.start_node).to(return_value),
        g.edge_from(return_value).to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=MyState())
    assert result == 42

# tests/graph/beta/test_edge_labels.py:43-63
async def test_multiple_labels_in_path():
    """Test multiple labels within a single path."""
    g = GraphBuilder(state_type=LabelState, output_type=int)

    @g.step
    async def step_a(ctx: StepContext[LabelState, None, None]) -> int:
        return 5

    @g.step
    async def step_b(ctx: StepContext[LabelState, None, int]) -> int:
        return ctx.inputs + 10

    g.add(
        g.edge_from(g.start_node).label('first label').label('second label').to(step_a),
        g.edge_from(step_a).to(step_b),
        g.edge_from(step_b).to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=LabelState())
    assert result == 15

# pydantic_evals/pydantic_evals/dataset.py:103-103
    json_schema_path: str | None = Field(default=None, alias='$schema')

# tests/test_messages.py:692-741
def test_binary_content_from_path(tmp_path: Path):
    # test normal file
    test_xml_file = tmp_path / 'test.xml'
    test_xml_file.write_text('<think>about trains</think>', encoding='utf-8')
    binary_content = BinaryContent.from_path(test_xml_file)
    assert binary_content == snapshot(BinaryContent(data=b'<think>about trains</think>', media_type='application/xml'))

    # test non-existent file
    non_existent_file = tmp_path / 'non-existent.txt'
    with pytest.raises(FileNotFoundError, match='File not found:'):
        BinaryContent.from_path(non_existent_file)

    # test file with unknown media type
    test_unknown_file = tmp_path / 'test.unknownext'
    test_unknown_file.write_text('some content', encoding='utf-8')
    binary_content = BinaryContent.from_path(test_unknown_file)
    assert binary_content == snapshot(BinaryContent(data=b'some content', media_type='application/octet-stream'))

    # test string path
    test_txt_file = tmp_path / 'test.txt'
    test_txt_file.write_text('just some text', encoding='utf-8')
    string_path = test_txt_file.as_posix()
    binary_content = BinaryContent.from_path(string_path)  # pyright: ignore[reportArgumentType]
    assert binary_content == snapshot(BinaryContent(data=b'just some text', media_type='text/plain'))

    # test image file
    test_jpg_file = tmp_path / 'test.jpg'
    test_jpg_file.write_bytes(b'\xff\xd8\xff\xe0' + b'0' * 100)  # minimal JPEG header + padding
    binary_content = BinaryContent.from_path(test_jpg_file)
    assert binary_content == snapshot(
        BinaryImage(data=b'\xff\xd8\xff\xe0' + b'0' * 100, media_type='image/jpeg', _identifier='bc8d49')
    )

    # test yaml file
    test_yaml_file = tmp_path / 'config.yaml'
    test_yaml_file.write_text('key: value', encoding='utf-8')
    binary_content = BinaryContent.from_path(test_yaml_file)
    assert binary_content == snapshot(BinaryContent(data=b'key: value', media_type='application/yaml'))

    # test yml file (alternative extension)
    test_yml_file = tmp_path / 'docker-compose.yml'
    test_yml_file.write_text('version: "3"', encoding='utf-8')
    binary_content = BinaryContent.from_path(test_yml_file)
    assert binary_content == snapshot(BinaryContent(data=b'version: "3"', media_type='application/yaml'))

    # test toml file
    test_toml_file = tmp_path / 'pyproject.toml'
    test_toml_file.write_text('[project]\nname = "test"', encoding='utf-8')
    binary_content = BinaryContent.from_path(test_toml_file)
    assert binary_content == snapshot(BinaryContent(data=b'[project]\nname = "test"', media_type='application/toml'))

# tests/test_ui_web.py:543-552
async def test_get_ui_html_local_file_path_instance(monkeypatch: pytest.MonkeyPatch, tmp_path: Path):
    """Test that _get_ui_html supports Path instances."""
    # Create a test HTML file
    test_html = b'<html><body>Path Instance UI</body></html>'
    local_file = tmp_path / 'path-ui.html'
    local_file.write_bytes(test_html)

    result = await app_module._get_ui_html(html_source=local_file)  # pyright: ignore[reportPrivateUsage]

    assert result == test_html

# tests/graph/beta/test_paths.py:43-47
async def test_path_last_fork_with_map():
    """Test Path.last_fork property with a MapMarker."""
    map = MapMarker(fork_id=ForkID(NodeID('map1')), downstream_join_id=None)
    path = Path(items=[map, LabelMarker('after map')])
    assert path.last_fork is map

# pydantic_graph/pydantic_graph/beta/decision.py:152-152
    _path_builder: PathBuilder[StateT, DepsT, OutputT]

# docs/.hooks/test_snippets.py:71-75
def test_parse_snippet_directive_missing_path():
    """Test that missing path raises ValueError."""
    line = '```snippet {title="Test"}'
    with pytest.raises(ValueError, match='Missing required key "path" in snippet directive'):
        parse_snippet_directive(line)

# tests/models/xai_proto_cassettes.py:574-574
    cassette_path: Path

# tests/graph/beta/test_graph_edge_cases.py:358-379
async def test_path_with_label_marker():
    """Test that LabelMarker in paths doesn't affect execution."""
    g = GraphBuilder(state_type=MyState, output_type=int)

    @g.step
    async def step_a(ctx: StepContext[MyState, None, None]) -> int:
        return 10

    @g.step
    async def step_b(ctx: StepContext[MyState, None, int]) -> int:
        return ctx.inputs * 2

    # Add labels to the path
    g.add(
        g.edge_from(g.start_node).label('start').to(step_a),
        g.edge_from(step_a).label('middle').to(step_b),
        g.edge_from(step_b).label('end').to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=MyState())
    assert result == 20

# tests/test_ui_web.py:530-539
async def test_get_ui_html_local_file_path_string(monkeypatch: pytest.MonkeyPatch, tmp_path: Path):
    """Test that _get_ui_html supports local file paths as strings."""
    # Create a test HTML file
    test_html = b'<html><body>Local UI Content</body></html>'
    local_file = tmp_path / 'custom-ui.html'
    local_file.write_bytes(test_html)

    result = await app_module._get_ui_html(html_source=str(local_file))  # pyright: ignore[reportPrivateUsage]

    assert result == test_html

# pydantic_ai_slim/pydantic_ai/retries.py:18-26
from httpx import (
    AsyncBaseTransport,
    AsyncHTTPTransport,
    BaseTransport,
    HTTPStatusError,
    HTTPTransport,
    Request,
    Response,
)

# pydantic_graph/pydantic_graph/beta/paths.py:137-137
    items: list[PathItem]

# pydantic_graph/pydantic_graph/beta/paths.py:308-318
    def __init__(
        self, sources: Sequence[SourceNode[StateT, DepsT, Any]], path_builder: PathBuilder[StateT, DepsT, OutputT]
    ):
        """Initialize an edge path builder.

        Args:
            sources: The source nodes for this edge path
            path_builder: The path builder for defining the data flow
        """
        self.sources = sources
        self._path_builder = path_builder

# tests/graph/beta/test_paths.py:30-33
async def test_path_last_fork_with_no_forks():
    """Test Path.last_fork property when there are no forks."""
    path = Path(items=[LabelMarker('test'), DestinationMarker(NodeID('dest'))])
    assert path.last_fork is None

# tests/graph/beta/test_paths.py:36-40
async def test_path_last_fork_with_broadcast():
    """Test Path.last_fork property with a BroadcastMarker."""
    broadcast = BroadcastMarker(paths=[], fork_id=ForkID(NodeID('fork1')))
    path = Path(items=[broadcast, LabelMarker('after fork')])
    assert path.last_fork is broadcast

# pydantic_graph/pydantic_graph/beta/graph_builder.py:1041-1055
def _update_path_with_id_remapping(path: Path, node_id_remapping: dict[NodeID, NodeID]) -> Path:
    # Note: we have already deepcopied the node provided to this function so it should be okay to make mutations,
    # this could change if we change the code surrounding the code paths leading to this function call though.
    for item in path.items:
        if isinstance(item, MapMarker):
            downstream_join_id = item.downstream_join_id
            if downstream_join_id is not None:
                item.downstream_join_id = JoinID(node_id_remapping.get(downstream_join_id, downstream_join_id))
            item.fork_id = ForkID(node_id_remapping.get(item.fork_id, item.fork_id))
        elif isinstance(item, BroadcastMarker):
            item.fork_id = ForkID(node_id_remapping.get(item.fork_id, item.fork_id))
            item.paths = [_update_path_with_id_remapping(p, node_id_remapping) for p in item.paths]
        elif isinstance(item, DestinationMarker):
            item.destination_id = node_id_remapping.get(item.destination_id, item.destination_id)
    return path

# pydantic_graph/pydantic_graph/beta/graph_builder.py:38-46
from pydantic_graph.beta.paths import (
    BroadcastMarker,
    DestinationMarker,
    EdgePath,
    EdgePathBuilder,
    MapMarker,
    Path,
    PathBuilder,
)

# pydantic_ai_slim/pydantic_ai/_ssrf.py:58-58
    resolved_ip: str

# tests/test_cli.py:129-131
def test_agent_flag_bad_module_variable_path(capfd: CaptureFixture[str], mocker: MockerFixture, env: TestEnv):
    assert cli(['--agent', 'bad_path', 'hello']) == 1
    assert 'Could not load agent from bad_path' in capfd.readouterr().out

# pydantic_ai_slim/pydantic_ai/ui/_adapter.py:8-8
from http import HTTPStatus

# pydantic_ai_slim/pydantic_ai/ui/_adapter.py:8-8
from http import HTTPStatus

# tests/test_tenacity.py:8-8
from http.server import BaseHTTPRequestHandler, HTTPServer

# tests/graph/beta/test_parent_forks.py:178-197
def test_parent_fork_multiple_paths_to_fork():
    """Test parent fork with multiple paths from start to the fork."""
    join_id = 'J'
    nodes = {'start1', 'start2', 'F', 'A', 'B', 'J', 'end'}
    start_ids = {'start1', 'start2'}
    fork_ids = {'F'}
    edges = {
        'start1': ['F'],
        'start2': ['F'],
        'F': ['A', 'B'],
        'A': ['J'],
        'B': ['J'],
        'J': ['end'],
    }

    finder = ParentForkFinder(nodes, start_ids, fork_ids, edges)
    parent_fork = finder.find_parent_fork(join_id)

    assert parent_fork is not None
    assert parent_fork.fork_id == 'F'

# pydantic_graph/pydantic_graph/beta/paths.py:291-292
    def sources(self) -> Sequence[SourceNode[StateT, DepsT, Any]]:
        return self._sources

# clai/update_readme.py:4-4
from pathlib import Path

# pydantic_graph/pydantic_graph/beta/paths.py:276-276
    _sources: Sequence[SourceNode[StateT, DepsT, Any]]

# pydantic_graph/pydantic_graph/beta/paths.py:283-288
    def __init__(
        self, sources: Sequence[SourceNode[StateT, DepsT, Any]], path: Path, destinations: list[AnyDestinationNode]
    ):
        self._sources = sources
        self.path = path
        self.destinations = destinations

# pydantic_ai_slim/pydantic_ai/_ssrf.py:64-64
    port: int

# tests/test_ssrf.py:235-240
    def test_http_default_port(self) -> None:
        resolved = ResolvedUrl(
            resolved_ip='203.0.113.50', hostname='example.com', port=80, is_https=False, path='/path'
        )
        url = build_url_with_ip(resolved)
        assert url == 'http://203.0.113.50/path'

# pydantic_evals/pydantic_evals/reporting/__init__.py:88-88
    assertions: dict[str, EvaluationResult[bool]]

# pydantic_graph/pydantic_graph/beta/paths.py:280-280
    destinations: list[AnyDestinationNode]

# pydantic_ai_slim/pydantic_ai/_ssrf.py:55-71
class ResolvedUrl:
    """Result of URL validation and DNS resolution."""

    resolved_ip: str
    """The resolved IP address to connect to."""

    hostname: str
    """The original hostname (used for Host header)."""

    port: int
    """The port number."""

    is_https: bool
    """Whether to use HTTPS."""

    path: str
    """The path including query string and fragment."""

# pydantic_graph/pydantic_graph/beta/paths.py:204-217
    def broadcast(self, forks: Sequence[Path], /, *, fork_id: str | None = None) -> Path:
        """Create a fork that broadcasts data to multiple parallel paths.

        Args:
            forks: The sequence of paths to run in parallel
            fork_id: Optional ID for the fork, defaults to a generated value

        Returns:
            A complete Path that forks to the specified parallel paths
        """
        next_item = BroadcastMarker(
            paths=forks, fork_id=ForkID(NodeID(fork_id or generate_placeholder_node_id('broadcast')))
        )
        return Path(items=[*self.working_items, next_item])

# tests/models/test_xai.py:4425-4440
async def test_xai_stream_reasoning_delta_non_prefix_path(allow_model_requests: None):
    """Force the reasoning-delta fallback path where accumulated reasoning resets mid-stream."""
    # Frame 1: reasoning starts.
    r1 = create_response(content='', reasoning_content='abc')
    c1 = create_stream_chunk(reasoning_content='abc')

    # Frame 2: accumulated reasoning changes to a different non-prefix string, forcing the fallback branch.
    r2 = create_response(content='done', reasoning_content='XYZ', finish_reason='stop')
    c2 = create_stream_chunk(content='done', reasoning_content='XYZ', finish_reason='stop')

    mock_client = MockXai.create_mock_stream([[(r1, c1), (r2, c2)]])
    m = XaiModel(XAI_NON_REASONING_MODEL, provider=XaiProvider(xai_client=mock_client))
    agent = Agent(m)

    async with agent.run_stream('') as result:
        assert [t async for t in result.stream_text(debounce_by=None)] == ['done']

# pydantic_graph/pydantic_graph/beta/paths.py:141-150
    def last_fork(self) -> BroadcastMarker | MapMarker | None:
        """Get the most recent fork or map marker in this path.

        Returns:
            The last BroadcastMarker or MapMarker in the path, or None if no forks exist
        """
        for item in reversed(self.items):
            if isinstance(item, BroadcastMarker | MapMarker):
                return item
        return None

# pydantic_ai_slim/pydantic_ai/_ssrf.py:61-61
    hostname: str

# pydantic_graph/pydantic_graph/beta/paths.py:175-175
    working_items: Sequence[PathItem]

# pydantic_evals/pydantic_evals/reporting/__init__.py:171-171
    assertions: float | None

# tests/test_ssrf.py:249-254
    def test_custom_port(self) -> None:
        resolved = ResolvedUrl(
            resolved_ip='203.0.113.50', hostname='example.com', port=8080, is_https=False, path='/path'
        )
        url = build_url_with_ip(resolved)
        assert url == 'http://203.0.113.50:8080/path'

# pydantic_evals/pydantic_evals/dataset.py:897-924
def _get_relative_path_reference(target: Path, source: Path, _prefix: str = '') -> Path:  # pragma: no cover
    """Get a relative path reference from source to target.

    Recursively resolve a relative path to target from source, adding '..' as needed.
    This is useful for creating a relative path reference from a source file to a target file.

    Args:
        target: The target path to reference.
        source: The source path to reference from.
        _prefix: Internal prefix used during recursion.

    Returns:
        A Path object representing the relative path from source to target.

    Example:
        If source is '/a/b/c.py' and target is '/a/d/e.py', the relative path reference
        would be '../../d/e.py'.
    """
    # Recursively resolve a relative path to target from source, adding '..' as needed.
    # This is useful for creating a relative path reference from a source file to a target file.
    # For example, if source is '/a/b/c.py' and target is '/a/d/e.py', the relative path reference
    # would be '../../d/e.py'.
    if not target.is_absolute():
        target = target.resolve()
    try:
        return Path(f'{_prefix}{Path(target).relative_to(source)}')
    except ValueError:
        return _get_relative_path_reference(target, source.parent, _prefix=f'{_prefix}../')

# pydantic_graph/pydantic_graph/beta/graph_builder.py:444-455
    def edge_from(self, *sources: Source[SourceOutputT]) -> EdgePathBuilder[StateT, DepsT, SourceOutputT]:
        """Create an edge path builder starting from the given source nodes.

        Args:
            *sources: The source nodes to start the edge path from

        Returns:
            An EdgePathBuilder for constructing the complete edge path
        """
        return EdgePathBuilder[StateT, DepsT, SourceOutputT](
            sources=sources, path_builder=PathBuilder(working_items=[])
        )

# pydantic_ai_slim/pydantic_ai/models/bedrock.py:249-249
    bedrock_additional_model_response_fields_paths: list[str]

# pydantic_evals/pydantic_evals/reporting/__init__.py:946-946
    include_assertions: bool

# tests/typed_agent.py:11-11
from typing_extensions import assert_type

# tests/typed_agent.py:11-11
from typing_extensions import assert_type

# tests/typed_agent.py:11-11
from typing_extensions import assert_type