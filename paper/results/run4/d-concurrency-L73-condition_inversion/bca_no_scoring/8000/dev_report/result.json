{
  "task_id": "d-concurrency-L73-condition_inversion",
  "method": "bca_no_scoring",
  "budget": 8000,
  "query_type": "dev_report",
  "tokens_used": 7599,
  "symbols_selected": 54,
  "files_included": 12,
  "assembly_time_ms": 1363.9,
  "llm_time_ms": 6328.0,
  "llm_input_tokens": 7214,
  "llm_output_tokens": 347,
  "tests_passed": false,
  "test_output": "yncio_default_fixture_loop_scope\" is unset.\nThe event loop scope for asynchronous fixtures will default to the fixture caching scope. Future versions of pytest-asyncio will default the loop scope for asynchronous fixtures to function scope. Set the default fixture loop scope explicitly in order to avoid unexpected behavior in the future. Valid fixture loop scopes are: \"function\", \"class\", \"module\", \"package\", \"session\"\n\n  warnings.warn(PytestDeprecationWarning(_DEFAULT_FIXTURE_LOOP_SCOPE_UNSET))",
  "patch": "FILE: tests/test_concurrency.py\nSEARCH:\n    async def test_basic_acquisition(self):\n        \"\"\"Test that limiter limits concurrent access.\"\"\"\n        limiter = ConcurrencyLimiter(max_running=2)\n        acquired: list[int] = []\n\n        async def acquire_and_hold(id: int, hold_time: float):\n            async with get_concurrency_context(limiter, 'test'):\n                acquired.append(id)\n                await anyio.sleep(hold_time)\n\n        # Start 3 tasks with limit of 2\n        async with anyio.create_task_group() as tg:\n            for i in range(3):\n                tg.start_soon(acquire_and_hold, i, 0.1)\n            await anyio.sleep(0.05)\n            assert len(acquired) == 2  # Only 2 can proceed\n        assert len(acquired) == 3\nREPLACE:\n    async def test_basic_acquisition(self):\n        \"\"\"Test that limiter limits concurrent access.\"\"\"\n        limiter = ConcurrencyLimiter(max_running=2)\n        acquired: list[int] = []\n\n        async def acquire_and_hold(id: int, hold_time: float):\n            async with get_concurrency_context(limiter, 'test'):\n                acquired.append(id)\n                await anyio.sleep(hold_time)\n\n        # Start 3 tasks with limit of 2\n        async with anyio.create_task_group() as tg:\n            for i in range(3):\n                tg.start_soon(acquire_and_hold, i, 0.1)\n            await anyio.sleep(0.15)  # Increase sleep time to allow all tasks to complete\n            assert len(acquired) == 3  # All should be acquired\n",
  "error": "",
  "test_time_ms": 2449.3,
  "failure_mode": "test_fail",
  "target_file_hit": true,
  "target_symbol_hit": true,
  "context_patch_overlap": 0.083,
  "patch_files_changed": 1,
  "patch_lines_changed": 17,
  "edit_distance_lines": 29,
  "entity_count_extracted": 28,
  "entity_count_mapped": 59,
  "query_identifier_density": 0.1683,
  "seed_symbol_keys": [
    "tests/test_concurrency.py::TestConcurrencyLimitedModel",
    "tests/test_concurrency.py::TestConcurrencyLimitedModel.test_basic_concurrency_limit",
    "pydantic_ai_slim/pydantic_ai/models/gemini.py::_function_call_part_from_call",
    "tests/test_concurrency.py::annotations",
    "tests/test_concurrency.py::importlib.util",
    "tests/test_concurrency.py::TYPE_CHECKING",
    "tests/test_concurrency.py::Any",
    "tests/test_concurrency.py::anyio",
    "tests/test_concurrency.py::pytest",
    "tests/test_concurrency.py::Agent",
    "tests/test_concurrency.py::ConcurrencyLimit",
    "tests/test_concurrency.py::ConcurrencyLimiter",
    "tests/test_concurrency.py::ConcurrencyLimitExceeded",
    "tests/test_concurrency.py::get_concurrency_context",
    "tests/test_concurrency.py::TestModel",
    "tests/test_concurrency.py::logfire_installed",
    "tests/test_concurrency.py::pytestmark",
    "tests/test_concurrency.py::AsyncBarrier",
    "tests/test_concurrency.py::AsyncBarrier.__init__",
    "tests/test_concurrency.py::AsyncBarrier.wait",
    "tests/test_concurrency.py::TestConcurrencyLimiter",
    "tests/test_concurrency.py::TestConcurrencyLimiter.test_basic_acquisition",
    "tests/test_concurrency.py::TestConcurrencyLimiter.test_nowait_acquisition",
    "tests/test_concurrency.py::TestConcurrencyLimiter.test_waiting_count_tracking",
    "tests/test_concurrency.py::TestConcurrencyLimiter.test_backpressure_raises",
    "tests/test_concurrency.py::TestConcurrencyLimiter.test_backpressure_race_condition",
    "tests/test_concurrency.py::TestConcurrencyLimiter.test_from_int_limit",
    "tests/test_concurrency.py::TestConcurrencyLimiter.test_from_limiter_config",
    "tests/test_concurrency.py::TestConcurrencyLimiter.test_properties",
    "tests/test_concurrency.py::TestGetConcurrencyContext",
    "tests/test_concurrency.py::TestGetConcurrencyContext.test_returns_context_when_provided",
    "tests/test_concurrency.py::TestGetConcurrencyContext.test_returns_null_context_when_none",
    "tests/test_concurrency.py::TestAgentConcurrency",
    "tests/test_concurrency.py::TestAgentConcurrency.test_agent_concurrency_limit",
    "tests/test_concurrency.py::TestAgentConcurrency.test_agent_concurrency_backpressure",
    "tests/test_concurrency.py::TestAgentConcurrency.test_agent_no_limit_by_default",
    "tests/test_concurrency.py::TestAgentConcurrency.test_agent_with_int_concurrency",
    "tests/test_concurrency.py::TestAgentConcurrency.test_agent_with_limiter_concurrency",
    "tests/test_concurrency.py::TestConcurrencyLimitedModel.test_with_int_limiter",
    "tests/test_concurrency.py::TestConcurrencyLimitedModel.test_with_concurrency_limit",
    "tests/test_concurrency.py::TestConcurrencyLimitedModel.test_with_shared_limiter",
    "tests/test_concurrency.py::TestConcurrencyLimitedModel.test_shared_limiter_limits_across_models",
    "tests/test_concurrency.py::TestConcurrencyLimitedModel.test_limit_model_concurrency_helper",
    "tests/test_concurrency.py::TestConcurrencyLimitedModel.test_model_properties_delegated",
    "tests/test_concurrency.py::TestAgentWithSharedLimiter",
    "tests/test_concurrency.py::TestAgentWithSharedLimiter.test_agent_with_shared_limiter",
    "tests/test_concurrency.py::TestConcurrencyLimiterName",
    "tests/test_concurrency.py::TestConcurrencyLimiterName.test_limiter_with_name",
    "tests/test_concurrency.py::TestConcurrencyLimiterName.test_limiter_without_name",
    "tests/test_concurrency.py::TestConcurrencyLimiterName.test_from_limit_with_name",
    "tests/test_concurrency.py::TestConcurrencyLimiterName.test_named_limiter_waiting_adds_limiter_name_attribute",
    "tests/test_concurrency.py::TestConcurrencyLimiterName.test_unnamed_limiter_waiting_uses_source_in_span_name",
    "tests/test_concurrency.py::TestConcurrencyLimiterName.test_limiter_with_max_queued_includes_attribute_in_span",
    "tests/test_concurrency.py::TestConcurrencyLimiterWithTracer",
    "tests/test_concurrency.py::TestConcurrencyLimiterWithTracer.test_custom_tracer_is_stored",
    "tests/test_concurrency.py::TestConcurrencyLimiterWithTracer.test_from_limit_with_tracer",
    "tests/test_concurrency.py::TestConcurrencyLimitedModelMethods",
    "tests/test_concurrency.py::TestConcurrencyLimitedModelMethods.test_count_tokens",
    "tests/test_concurrency.py::TestConcurrencyLimitedModelMethods.test_request_stream"
  ],
  "mutation_symbol_key": "pydantic_ai_slim/pydantic_ai/models/concurrency.py::ConcurrencyLimitedModel.__init__",
  "min_hops_seed_to_mutation": 2,
  "median_hops_seed_to_mutation": 4.0,
  "bca_closure_added_symbols": 0,
  "bca_closure_added_tokens": 0,
  "bca_frontier_visited": 1982,
  "context_symbol_keys": [
    "pydantic_ai_slim/pydantic_ai/_utils.py::PeekableAsyncStream.__init__",
    "pydantic_ai_slim/pydantic_ai/_utils.py::get_traceparent",
    "pydantic_ai_slim/pydantic_ai/concurrency.py::AbstractConcurrencyLimiter.acquire",
    "pydantic_ai_slim/pydantic_ai/concurrency.py::ConcurrencyLimit",
    "pydantic_ai_slim/pydantic_ai/concurrency.py::ConcurrencyLimiter",
    "pydantic_ai_slim/pydantic_ai/concurrency.py::ConcurrencyLimiter.__init__",
    "pydantic_ai_slim/pydantic_ai/concurrency.py::ConcurrencyLimiter.from_limit",
    "pydantic_ai_slim/pydantic_ai/concurrency.py::ConcurrencyLimiter.acquire",
    "pydantic_ai_slim/pydantic_ai/concurrency.py::_null_context",
    "pydantic_ai_slim/pydantic_ai/concurrency.py::get_concurrency_context",
    "pydantic_ai_slim/pydantic_ai/direct.py::StreamedResponseSync.__exit__",
    "pydantic_ai_slim/pydantic_ai/models/gemini.py::GeminiModel.__init__",
    "pydantic_ai_slim/pydantic_ai/models/gemini.py::_GeminiFunctionCallPart",
    "pydantic_ai_slim/pydantic_ai/models/gemini.py::_function_call_part_from_call",
    "pydantic_ai_slim/pydantic_ai/models/gemini.py::_GeminiFunctionCall",
    "pydantic_ai_slim/pydantic_ai/models/gemini.py::_GeminiFunction",
    "pydantic_ai_slim/pydantic_ai/retries.py::RetryConfig",
    "pydantic_ai_slim/pydantic_ai/retries.py::RetryConfig.wait",
    "pydantic_ai_slim/pydantic_ai/retries.py::TenacityTransport",
    "pydantic_ai_slim/pydantic_ai/retries.py::TenacityTransport.__init__",
    "pydantic_ai_slim/pydantic_ai/retries.py::TenacityTransport.__exit__",
    "pydantic_ai_slim/pydantic_ai/retries.py::AsyncTenacityTransport.__init__",
    "pydantic_graph/pydantic_graph/beta/graph.py::EndMarker.__init__",
    "pydantic_graph/pydantic_graph/beta/graph.py::Graph",
    "pydantic_graph/pydantic_graph/beta/graph.py::GraphRun",
    "pydantic_graph/pydantic_graph/beta/graph.py::GraphRun.__init__",
    "pydantic_graph/pydantic_graph/beta/graph.py::_unwrap_exception_groups",
    "tests/conftest.py::TestEnv.__init__",
    "tests/conftest.py::raise_if_exception",
    "tests/conftest.py::model",
    "tests/models/test_fallback.py::pytestmark",
    "tests/models/test_fallback.py::PotatoException",
    "tests/test_agent.py::pytestmark",
    "tests/test_agent.py::UserContext",
    "tests/test_concurrency.py::logfire_installed",
    "tests/test_concurrency.py::pytestmark",
    "tests/test_concurrency.py::AsyncBarrier",
    "tests/test_concurrency.py::AsyncBarrier.__init__",
    "tests/test_concurrency.py::AsyncBarrier.wait",
    "tests/test_concurrency.py::TestConcurrencyLimiter",
    "tests/test_concurrency.py::TestConcurrencyLimiter.test_basic_acquisition",
    "tests/test_concurrency.py::TestConcurrencyLimiter.test_nowait_acquisition",
    "tests/test_concurrency.py::TestConcurrencyLimiter.test_waiting_count_tracking",
    "tests/test_concurrency.py::TestConcurrencyLimiter.test_backpressure_raises",
    "tests/test_concurrency.py::TestConcurrencyLimiter.test_backpressure_race_condition",
    "tests/test_concurrency.py::TestConcurrencyLimiter.test_from_int_limit",
    "tests/test_concurrency.py::TestConcurrencyLimiter.test_from_limiter_config",
    "tests/test_concurrency.py::TestConcurrencyLimiter.test_properties",
    "tests/test_concurrency.py::TestGetConcurrencyContext",
    "tests/test_concurrency.py::TestGetConcurrencyContext.test_returns_context_when_provided",
    "tests/test_concurrency.py::TestGetConcurrencyContext.test_returns_null_context_when_none",
    "tests/test_concurrency.py::TestAgentConcurrency",
    "tests/test_concurrency.py::TestAgentConcurrency.test_agent_concurrency_limit",
    "tests/test_concurrency.py::TestAgentConcurrency.test_agent_concurrency_backpressure",
    "tests/test_concurrency.py::TestAgentConcurrency.test_agent_no_limit_by_default",
    "tests/test_concurrency.py::TestAgentConcurrency.test_agent_with_int_concurrency",
    "tests/test_concurrency.py::TestAgentConcurrency.test_agent_with_limiter_concurrency",
    "tests/test_concurrency.py::TestConcurrencyLimitedModel",
    "tests/test_concurrency.py::TestConcurrencyLimitedModel.test_with_int_limiter",
    "tests/test_concurrency.py::TestConcurrencyLimitedModel.test_with_concurrency_limit",
    "tests/test_concurrency.py::TestConcurrencyLimitedModel.test_with_shared_limiter",
    "tests/test_concurrency.py::TestConcurrencyLimitedModel.test_shared_limiter_limits_across_models",
    "tests/test_concurrency.py::TestConcurrencyLimitedModel.test_limit_model_concurrency_helper",
    "tests/test_concurrency.py::TestConcurrencyLimitedModel.test_model_properties_delegated",
    "tests/test_concurrency.py::TestAgentWithSharedLimiter",
    "tests/test_concurrency.py::TestAgentWithSharedLimiter.test_agent_with_shared_limiter",
    "tests/test_concurrency.py::TestConcurrencyLimiterName.test_limiter_with_name",
    "tests/test_concurrency.py::TestConcurrencyLimiterName.test_limiter_without_name",
    "tests/test_concurrency.py::TestConcurrencyLimiterName.test_from_limit_with_name",
    "tests/test_concurrency.py::TestConcurrencyLimiterName.test_named_limiter_waiting_adds_limiter_name_attribute",
    "tests/test_concurrency.py::TestConcurrencyLimiterName.test_unnamed_limiter_waiting_uses_source_in_span_name",
    "tests/test_concurrency.py::TestConcurrencyLimiterName.test_limiter_with_max_queued_includes_attribute_in_span",
    "tests/test_concurrency.py::TestConcurrencyLimiterWithTracer",
    "tests/test_concurrency.py::TestConcurrencyLimiterWithTracer.test_custom_tracer_is_stored",
    "tests/test_concurrency.py::TestConcurrencyLimiterWithTracer.test_from_limit_with_tracer",
    "tests/test_concurrency.py::TestConcurrencyLimitedModelMethods",
    "tests/test_concurrency.py::TestConcurrencyLimitedModelMethods.test_count_tokens",
    "tests/test_concurrency.py::TestConcurrencyLimitedModelMethods.test_request_stream",
    "tests/test_prefect.py::pytestmark",
    "tests/test_prefect.py::model",
    "tests/test_prefect.py::Deps",
    "tests/test_prefect.py::Response",
    "tests/test_prefect.py::test_model",
    "tests/test_prefect.py::SimpleDeps",
    "tests/test_tenacity.py::pytestmark",
    "tests/test_tenacity.py::TestTenacityTransport.test_retry_on_exception",
    "tests/test_tenacity.py::TestAsyncTenacityTransport.test_retry_on_exception"
  ],
  "mutation_symbol_lines": 19,
  "mutation_symbol_kind": "method",
  "mutation_file_symbols": 28,
  "graph_node_count": 18010,
  "retrieval_top1_top2_gap": 0.0,
  "retrieval_softmax_entropy": 4.32,
  "retrieval_softmax_tau": 0.855,
  "retrieval_effective_candidates": 19.97,
  "retrieval_top5_ratio": 1.0,
  "retrieval_within95_count": 6,
  "retrieval_scored_symbols": 50,
  "retrieval_top1_score": 0.95,
  "retrieval_top5_mean_score": 0.95,
  "retrieval_budget_utilization": 0.9499,
  "retrieval_file_concentration": 0.0,
  "repo_name": "pydantic-ai",
  "category": "concurrency",
  "mutation_type": "condition_inversion",
  "source": "discovered"
}