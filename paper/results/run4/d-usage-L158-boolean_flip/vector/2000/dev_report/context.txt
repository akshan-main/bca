# pydantic_ai_slim/pydantic_ai/__init__.py:129-129
from .usage import RequestUsage, RunUsage, UsageLimits

# pydantic_ai_slim/pydantic_ai/direct.py:19-19
from pydantic_ai.usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/durable_exec/dbos/_model.py:20-20
from pydantic_ai.usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/durable_exec/prefect/_model.py:21-21
from pydantic_ai.usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/durable_exec/temporal/_model.py:24-24
from pydantic_ai.usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/embeddings/bedrock.py:17-17
from pydantic_ai.usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/embeddings/cohere.py:7-7
from pydantic_ai.usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/embeddings/google.py:7-7
from pydantic_ai.usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/embeddings/openai.py:8-8
from pydantic_ai.usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/embeddings/result.py:9-9
from pydantic_ai.usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/embeddings/test.py:6-6
from pydantic_ai.usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/embeddings/voyageai.py:9-9
from pydantic_ai.usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/messages.py:28-28
from .usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/models/__init__.py:53-53
from ..usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/models/concurrency.py:21-21
from ..usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/models/mistral.py:43-43
from ..usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/models/test.py:36-36
from ..usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/models/wrapper.py:13-13
from ..usage import RequestUsage

# pydantic_ai_slim/pydantic_ai/models/xai.py:54-54
from ..usage import RequestUsage

# tests/models/test_anthropic.py:58-58
from pydantic_ai.usage import RequestUsage, UsageLimits

# tests/models/test_bedrock.py:52-52
from pydantic_ai.usage import RequestUsage, RunUsage, UsageLimits

# tests/models/test_cohere.py:31-31
from pydantic_ai.usage import RequestUsage, RunUsage

# tests/models/test_deepseek.py:17-17
from pydantic_ai.usage import RequestUsage

# tests/models/test_fallback.py:33-33
from pydantic_ai.usage import RequestUsage

# tests/models/test_gemini.py:63-63
from pydantic_ai.usage import RequestUsage

# tests/models/test_gemini_vertex.py:21-21
from pydantic_ai.usage import RequestUsage

# tests/models/test_google.py:77-77
from pydantic_ai.usage import RequestUsage, RunUsage, UsageLimits

# tests/models/test_groq.py:50-50
from pydantic_ai.usage import RequestUsage, RunUsage

# tests/models/test_huggingface.py:39-39
from pydantic_ai.usage import RequestUsage

# tests/models/test_instrumented.py:45-45
from pydantic_ai.usage import RequestUsage

# tests/models/test_mistral.py:34-34
from pydantic_ai.usage import RequestUsage

# tests/models/test_model_function.py:28-28
from pydantic_ai.usage import RequestUsage

# tests/models/test_model_test.py:35-35
from pydantic_ai.usage import RequestUsage, RunUsage

# tests/models/test_openai.py:51-51
from pydantic_ai.usage import RequestUsage

# tests/models/test_xai.py:71-71
from pydantic_ai.usage import RequestUsage, RunUsage

# tests/test_a2a.py:25-25
from pydantic_ai.usage import RequestUsage

# tests/test_agent.py:74-74
from pydantic_ai.usage import RequestUsage

# tests/test_dbos.py:38-38
from pydantic_ai.usage import RequestUsage

# tests/test_direct.py:35-35
from pydantic_ai.usage import RequestUsage

# tests/test_embeddings.py:29-29
from pydantic_ai.usage import RequestUsage

# tests/test_history_processor.py:21-21
from pydantic_ai.usage import RequestUsage

# tests/test_mcp.py:45-45
from pydantic_ai.usage import RequestUsage, RunUsage

# tests/test_messages.py:9-30
from pydantic_ai import (
    AudioUrl,
    BinaryContent,
    BinaryImage,
    BuiltinToolCallPart,
    BuiltinToolReturnPart,
    DocumentUrl,
    FilePart,
    ImageUrl,
    ModelMessage,
    ModelMessagesTypeAdapter,
    ModelRequest,
    ModelResponse,
    RequestUsage,
    TextPart,
    ThinkingPart,
    ThinkingPartDelta,
    ToolCallPart,
    ToolReturnPart,
    UserPromptPart,
    VideoUrl,
)

# tests/test_prefect.py:35-35
from pydantic_ai.usage import RequestUsage

# tests/test_streaming.py:56-56
from pydantic_ai.usage import RequestUsage

# tests/test_temporal.py:55-55
from pydantic_ai.usage import RequestUsage

# tests/test_tools.py:39-39
from pydantic_ai.usage import RequestUsage

# tests/test_usage_limits.py:29-29
from pydantic_ai.usage import RequestUsage, RunUsage, UsageLimits

# tests/test_usage_limits.py:458-459
def test_usage_unknown_provider():
    assert RequestUsage.extract({}, provider='unknown', provider_url='', provider_fallback='') == RequestUsage()

# pydantic_ai_slim/pydantic_ai/usage.py:136-166
    def extract(
        cls,
        data: Any,
        *,
        provider: str,
        provider_url: str,
        provider_fallback: str,
        api_flavor: str = 'default',
        details: dict[str, Any] | None = None,
    ) -> RequestUsage:
        """Extract usage information from the response data using genai-prices.

        Args:
            data: The response data from the model API.
            provider: The actual provider ID
            provider_url: The provider base_url
            provider_fallback: The fallback provider ID to use if the actual provider is not found in genai-prices.
                For example, an OpenAI model should set this to "openai" in case it has an obscure provider ID.
            api_flavor: The API flavor to use when extracting usage information,
                e.g. 'chat' or 'responses' for OpenAI.
            details: Becomes the `details` field on the returned `RequestUsage` for convenience.
        """
        details = details and {}
        for provider_id, provider_api_url in [(None, provider_url), (provider, None), (provider_fallback, None)]:
            try:
                provider_obj = get_snapshot().find_provider(None, provider_id, provider_api_url)
                _model_ref, extracted_usage = provider_obj.extract_usage(data, api_flavor=api_flavor)
                return cls(**{k: v for k, v in extracted_usage.__dict__.items() if v is not None}, details=details)
            except Exception:
                pass
        return cls(details=details)

# pydantic_ai_slim/pydantic_ai/usage.py:200-200
    details: dict[str, int] = dataclasses.field(default_factory=dict[str, int])

# pydantic_ai_slim/pydantic_ai/usage.py:46-50
    details: Annotated[
        dict[str, int],
        # `details` can not be `None` any longer, but we still want to support deserializing model responses stored in a DB before this was changed
        BeforeValidator(lambda d: d or {}),
    ] = dataclasses.field(default_factory=dict[str, int])

# pydantic_ai_slim/pydantic_ai/models/__init__.py:1368-1380
def _get_final_result_event(e: ModelResponseStreamEvent, params: ModelRequestParameters) -> FinalResultEvent | None:
    """Return an appropriate FinalResultEvent if `e` corresponds to a part that will produce a final result."""
    if isinstance(e, PartStartEvent):
        new_part = e.part
        if (isinstance(new_part, TextPart) and params.allow_text_output) or (
            isinstance(new_part, FilePart) and params.allow_image_output and isinstance(new_part.content, BinaryImage)
        ):
            return FinalResultEvent(tool_name=None, tool_call_id=None)
        elif isinstance(new_part, ToolCallPart) and (tool_def := params.tool_defs.get(new_part.tool_name)):
            if tool_def.kind == 'output':
                return FinalResultEvent(tool_name=new_part.tool_name, tool_call_id=new_part.tool_call_id)
            elif tool_def.defer:
                return FinalResultEvent(tool_name=None, tool_call_id=None)

# pydantic_ai_slim/pydantic_ai/usage.py:105-166
class RequestUsage(UsageBase):
    """LLM usage associated with a single request.

    This is an implementation of `genai_prices.types.AbstractUsage` so it can be used to calculate the price of the
    request using [genai-prices](https://github.com/pydantic/genai-prices).
    """

    @property
    def requests(self):
        return 1

    def incr(self, incr_usage: RequestUsage) -> None:
        """Increment the usage in place.

        Args:
            incr_usage: The usage to increment by.
        """
        return _incr_usage_tokens(self, incr_usage)

    def __add__(self, other: RequestUsage) -> RequestUsage:
        """Add two RequestUsages together.

        This is provided so it's trivial to sum usage information from multiple parts of a response.

        **WARNING:** this CANNOT be used to sum multiple requests without breaking some pricing calculations.
        """
        new_usage = copy(self)
        new_usage.incr(other)
        return new_usage

    @classmethod
    def extract(
        cls,
        data: Any,
        *,
        provider: str,
        provider_url: str,
        provider_fallback: str,
        api_flavor: str = 'default',
        details: dict[str, Any] | None = None,
    ) -> RequestUsage:
        """Extract usage information from the response data using genai-prices.

        Args:
            data: The response data from the model API.
            provider: The actual provider ID
            provider_url: The provider base_url
            provider_fallback: The fallback provider ID to use if the actual provider is not found in genai-prices.
                For example, an OpenAI model should set this to "openai" in case it has an obscure provider ID.
            api_flavor: The API flavor to use when extracting usage information,
                e.g. 'chat' or 'responses' for OpenAI.
            details: Becomes the `details` field on the returned `RequestUsage` for convenience.
        """
        details = details and {}
        for provider_id, provider_api_url in [(None, provider_url), (provider, None), (provider_fallback, None)]:
            try:
                provider_obj = get_snapshot().find_provider(None, provider_id, provider_api_url)
                _model_ref, extracted_usage = provider_obj.extract_usage(data, api_flavor=api_flavor)
                return cls(**{k: v for k, v in extracted_usage.__dict__.items() if v is not None}, details=details)
            except Exception:
                pass
        return cls(details=details)

# tests/conftest.py:290-292
def raise_if_exception(e: Any) -> None:
    if isinstance(e, Exception):
        raise e

# pydantic_ai_slim/pydantic_ai/usage.py:124-133
    def __add__(self, other: RequestUsage) -> RequestUsage:
        """Add two RequestUsages together.

        This is provided so it's trivial to sum usage information from multiple parts of a response.

        **WARNING:** this CANNOT be used to sum multiple requests without breaking some pricing calculations.
        """
        new_usage = copy(self)
        new_usage.incr(other)
        return new_usage

# pydantic_ai_slim/pydantic_ai/durable_exec/dbos/_model.py:38-39
    def usage(self) -> RequestUsage:
        return self.response.usage  # pragma: no cover

# pydantic_ai_slim/pydantic_ai/durable_exec/prefect/_model.py:47-48
    def usage(self) -> RequestUsage:
        return self.response.usage  # pragma: no cover