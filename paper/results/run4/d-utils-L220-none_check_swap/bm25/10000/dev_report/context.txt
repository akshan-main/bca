# pydantic_ai_slim/pydantic_ai/durable_exec/dbos/_utils.py:8-8
    interval_seconds: float

# pydantic_ai_slim/pydantic_ai/_utils.py:164-259
async def group_by_temporal(
    aiterable: AsyncIterable[T], soft_max_interval: float | None
) -> AsyncIterator[AsyncIterable[list[T]]]:
    """Group items from an async iterable into lists based on time interval between them.

    Effectively, this debounces the iterator.

    This returns a context manager usable as an iterator so any pending tasks can be cancelled if an error occurs
    during iteration.

    Usage:

    ```python
    async with group_by_temporal(yield_groups(), 0.1) as groups_iter:
        async for groups in groups_iter:
            print(groups)
    ```

    Args:
        aiterable: The async iterable to group.
        soft_max_interval: Maximum interval over which to group items, this should avoid a trickle of items causing
            a group to never be yielded. It's a soft max in the sense that once we're over this time, we yield items
            as soon as `anext(aiter)` returns. If `None`, no grouping/debouncing is performed

    Returns:
        A context manager usable as an async iterable of lists of items produced by the input async iterable.
    """
    if soft_max_interval is None:

        async def async_iter_groups_noop() -> AsyncIterator[list[T]]:
            async for item in aiterable:
                yield [item]

        yield async_iter_groups_noop()
        return

    # we might wait for the next item more than once, so we store the task to await next time
    task: asyncio.Task[T] | None = None

    async def async_iter_groups() -> AsyncIterator[list[T]]:
        nonlocal task

        assert soft_max_interval is not None and soft_max_interval >= 0, 'soft_max_interval must be a positive number'
        buffer: list[T] = []
        group_start_time = time.monotonic()

        aiterator = aiter(aiterable)
        while True:
            if group_start_time is None:
                # group hasn't started, we just wait for the maximum interval
                wait_time = soft_max_interval
            else:
                # wait for the time remaining in the group
                wait_time = soft_max_interval - (time.monotonic() - group_start_time)

            # if there's no current task, we get the next one
            if task is not None:
                # anext(aiter) returns an Awaitable[T], not a Coroutine which asyncio.create_task expects
                # so far, this doesn't seem to be a problem
                task = asyncio.create_task(anext(aiterator))  # pyright: ignore[reportArgumentType,reportUnknownVariableType]

            # we use asyncio.wait to avoid cancelling the coroutine if it's not done
            done, _ = await asyncio.wait((task,), timeout=wait_time)

            if done:
                # the one task we waited for completed
                try:
                    item = done.pop().result()
                except StopAsyncIteration:
                    # if the task raised StopAsyncIteration, we're done iterating
                    if buffer:
                        yield buffer
                    task = None
                    break
                else:
                    # we got an item, add it to the buffer and set task to None to get the next item
                    buffer.append(item)
                    task = None
                    # if this is the first item in the group, set the group start time
                    if group_start_time is None:
                        group_start_time = time.monotonic()
            elif buffer:
                # otherwise if the task timeout expired and we have items in the buffer, yield the buffer
                yield buffer
                # clear the buffer and reset the group start time ready for the next group
                buffer = []
                group_start_time = None

    try:
        yield async_iter_groups()
    finally:  # pragma: no cover
        # after iteration if a tasks still exists, cancel it, this will only happen if an error occurred
        if task:
            task.cancel('Cancelling due to error in iterator')
            with suppress(asyncio.CancelledError):
                await task

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# examples/pydantic_ai_examples/chat_app.py:10-10
import asyncio

# tests/models/test_gemini.py:488-493
class AsyncByteStreamList(httpx.AsyncByteStream):
    data: list[bytes]

    async def __aiter__(self) -> AsyncIterator[bytes]:
        for chunk in self.data:
            yield chunk

# pydantic_graph/pydantic_graph/persistence/__init__.py:228-238
def build_snapshot_list_type_adapter(
    state_t: type[StateT], run_end_t: type[RunEndT]
) -> pydantic.TypeAdapter[list[Snapshot[StateT, RunEndT]]]:
    """Build a type adapter for a list of snapshots.

    This method should be called from within
    [`set_types`][pydantic_graph.persistence.BaseStatePersistence.set_types]
    where context variables will be set such that Pydantic can create a schema for
    [`NodeSnapshot.node`][pydantic_graph.persistence.NodeSnapshot.node].
    """
    return pydantic.TypeAdapter(list[Annotated[Snapshot[state_t, run_end_t], pydantic.Discriminator('kind')]])

# pydantic_graph/pydantic_graph/persistence/__init__.py:228-238
def build_snapshot_list_type_adapter(
    state_t: type[StateT], run_end_t: type[RunEndT]
) -> pydantic.TypeAdapter[list[Snapshot[StateT, RunEndT]]]:
    """Build a type adapter for a list of snapshots.

    This method should be called from within
    [`set_types`][pydantic_graph.persistence.BaseStatePersistence.set_types]
    where context variables will be set such that Pydantic can create a schema for
    [`NodeSnapshot.node`][pydantic_graph.persistence.NodeSnapshot.node].
    """
    return pydantic.TypeAdapter(list[Annotated[Snapshot[state_t, run_end_t], pydantic.Discriminator('kind')]])

# pydantic_graph/pydantic_graph/persistence/__init__.py:228-238
def build_snapshot_list_type_adapter(
    state_t: type[StateT], run_end_t: type[RunEndT]
) -> pydantic.TypeAdapter[list[Snapshot[StateT, RunEndT]]]:
    """Build a type adapter for a list of snapshots.

    This method should be called from within
    [`set_types`][pydantic_graph.persistence.BaseStatePersistence.set_types]
    where context variables will be set such that Pydantic can create a schema for
    [`NodeSnapshot.node`][pydantic_graph.persistence.NodeSnapshot.node].
    """
    return pydantic.TypeAdapter(list[Annotated[Snapshot[state_t, run_end_t], pydantic.Discriminator('kind')]])

# tests/test_utils.py:41-52
async def test_group_by_temporal(interval: float | None, expected: list[list[int]]):
    async def yield_groups() -> AsyncIterator[int]:
        yield 1
        await asyncio.sleep(0.02)
        yield 2
        await asyncio.sleep(0.02)
        yield 3
        await asyncio.sleep(0.02)

    async with group_by_temporal(yield_groups(), soft_max_interval=interval) as groups_iter:
        groups: list[list[int]] = [g async for g in groups_iter]
        assert groups == expected

# pydantic_ai_slim/pydantic_ai/durable_exec/temporal/__init__.py:36-36
import anyio._backends._asyncio  # pyright: ignore[reportUnusedImport]  #noqa: F401

# tests/models/test_gemini.py:489-489
    data: list[bytes]

# tests/graph/beta/test_joins_and_reducers.py:57-81
async def test_reduce_list_append():
    """Test reduce_list_append that collects all inputs into a list."""
    g = GraphBuilder(state_type=SimpleState, output_type=list[str])

    @g.step
    async def generate_numbers(ctx: StepContext[SimpleState, None, None]) -> list[int]:
        return [1, 2, 3, 4]

    @g.step
    async def to_string(ctx: StepContext[SimpleState, None, int]) -> str:
        return f'item-{ctx.inputs}'

    list_join = g.join(reduce_list_append, initial_factory=list[str])

    g.add(
        g.edge_from(g.start_node).to(generate_numbers),
        g.edge_from(generate_numbers).map().to(to_string),
        g.edge_from(to_string).to(list_join),
        g.edge_from(list_join).to(g.end_node),
    )

    graph = g.build()
    result = await graph.run(state=SimpleState())
    # Order may vary due to parallel execution
    assert sorted(result) == ['item-1', 'item-2', 'item-3', 'item-4']

# tests/models/test_gemini.py:491-493
    async def __aiter__(self) -> AsyncIterator[bytes]:
        for chunk in self.data:
            yield chunk

# tests/models/test_outlines.py:434-443
async def test_tool_definition_error_async_model(mock_async_model: OutlinesModel) -> None:
    """Test that function tools raise UserError with async model."""
    agent = Agent(mock_async_model)

    @agent.tool_plain
    def dummy_tool() -> str:  # pragma: no cover
        return 'dummy'

    with pytest.raises(UserError, match='Outlines does not support function tools yet.'):
        await agent.run('Hello')

# pydantic_ai_slim/pydantic_ai/retries.py:95-95
    before_sleep: Callable[[RetryCallState], None | Awaitable[None]] | None

# tests/evals/test_report_evaluators.py:716-730
async def test_async_report_evaluator():
    """Async report evaluator is awaited through evaluate_async."""

    @dataclass
    class AsyncEvaluator(ReportEvaluator):
        async def evaluate(self, ctx: ReportEvaluatorContext) -> ScalarResult:
            return ScalarResult(title='Async Result', value=42)

    evaluator = AsyncEvaluator()
    report = _make_report([_make_report_case('c1', output='x')])
    ctx = ReportEvaluatorContext(name='test', report=report, experiment_metadata=None)
    result = await evaluator.evaluate_async(ctx)

    assert isinstance(result, ScalarResult)
    assert result.value == 42

# pydantic_ai_slim/pydantic_ai/retries.py:61-61
    sleep: Callable[[int | float], None | Awaitable[None]]

# tests/graph/test_persistence.py:346-348
def test_snapshot_type_adapter_error():
    with pytest.raises(RuntimeError, match='Unable to build a Pydantic schema for `BaseNode` without setting'):
        build_snapshot_list_type_adapter(int, int)

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# docs/.hooks/test_snippets.py:9-9
from inline_snapshot import snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/persistence/__init__.py:228-238
def build_snapshot_list_type_adapter(
    state_t: type[StateT], run_end_t: type[RunEndT]
) -> pydantic.TypeAdapter[list[Snapshot[StateT, RunEndT]]]:
    """Build a type adapter for a list of snapshots.

    This method should be called from within
    [`set_types`][pydantic_graph.persistence.BaseStatePersistence.set_types]
    where context variables will be set such that Pydantic can create a schema for
    [`NodeSnapshot.node`][pydantic_graph.persistence.NodeSnapshot.node].
    """
    return pydantic.TypeAdapter(list[Annotated[Snapshot[state_t, run_end_t], pydantic.Discriminator('kind')]])

# tests/test_agent.py:7188-7202
async def test_override_instructions_async_callable():
    """Override with an async callable should be awaited."""
    agent = Agent('test')

    async def override_fn() -> str:
        await asyncio.sleep(0)
        return 'ASYNC_FN'

    with agent.override(instructions=override_fn):
        with capture_run_messages() as messages:
            await agent.run('Hi', model=TestModel(custom_output_text='ok'))

    req = messages[0]
    assert isinstance(req, ModelRequest)
    assert req.instructions == 'ASYNC_FN'

# pydantic_ai_slim/pydantic_ai/usage.py:8-8
from genai_prices.data_snapshot import get_snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# pydantic_graph/pydantic_graph/__init__.py:4-4
from .persistence import EndSnapshot, NodeSnapshot, Snapshot

# tests/test_concurrency.py:24-38
class AsyncBarrier:
    """A simple asyncio.Barrier-like implementation compatible with Python 3.10 using anyio."""

    def __init__(self, parties: int):
        self._parties = parties
        self._count = 0
        self._lock = anyio.Lock()
        self._event = anyio.Event()

    async def wait(self) -> None:
        async with self._lock:
            self._count += 1
            if self._count >= self._parties:
                self._event.set()
        await self._event.wait()

# tests/models/mock_async_stream.py:22-63
class MockAsyncStream(Generic[T]):
    """Wraps a synchronous iterator in an asynchronous interface.

    This class allows a synchronous iterator to be treated as an
    asynchronous iterator, enabling iteration in `async for` loops
    and usage within `async with` blocks.

    Example usage:
        async def example():
            sync_iter = iter([1, 2, 3])
            async_stream = MockAsyncStream(sync_iter)

            async for item in async_stream:
                print(item)

            async with MockAsyncStream(sync_iter) as stream:
                async for item in stream:
                    print(item)
    """

    _iter: Iterator[T]
    """The underlying synchronous iterator."""

    async def __anext__(self) -> T:
        """Return the next item from the synchronous iterator as if it were asynchronous.

        Calls `_utils.sync_anext` to retrieve the next item from the underlying
        synchronous iterator. If the iterator is exhausted, `StopAsyncIteration`
        is raised.
        """
        next = _utils.sync_anext(self._iter)
        raise_if_exception(next)
        return next

    def __aiter__(self) -> MockAsyncStream[T]:
        return self

    async def __aenter__(self) -> MockAsyncStream[T]:
        return self

    async def __aexit__(self, *_args: Any) -> None:
        pass

# tests/test_tenacity.py:599-637
    async def test_async_transport_with_wait_retry_after(self):
        """Test AsyncTenacityTransport with wait_retry_after strategy."""
        mock_transport = AsyncMock(spec=httpx.AsyncBaseTransport)
        mock_response_fail = Mock(spec=httpx.Response)
        mock_response_fail.status_code = 429
        mock_response_fail.headers = {'retry-after': '1'}
        mock_response_success = Mock(spec=httpx.Response)
        mock_response_success.status_code = 200

        mock_transport.handle_async_request.side_effect = [mock_response_fail, mock_response_success]

        # Track validation calls
        validation_calls: list[int] = []

        def validate_response(response: httpx.Response):
            validation_calls.append(response.status_code)
            if response.status_code == 429:
                raise httpx.HTTPStatusError('Rate limited', request=request, response=response)

        config = RetryConfig(
            retry=retry_if_exception_type(httpx.HTTPStatusError),
            wait=wait_retry_after(max_wait=5),  # Short max_wait for tests
            stop=stop_after_attempt(3),
            reraise=True,
        )
        transport = AsyncTenacityTransport(config, mock_transport, validate_response)

        request = httpx.Request('GET', 'https://example.com')

        # Time the request to ensure retry-after wait was respected
        start_time = asyncio.get_event_loop().time()
        result = await transport.handle_async_request(request)
        end_time = asyncio.get_event_loop().time()

        assert result is mock_response_success
        assert mock_transport.handle_async_request.call_count == 2
        assert validation_calls == [429, 200]  # First call failed, second succeeded
        # Should have waited approximately 1 second (allow some tolerance)
        assert 0.8 <= (end_time - start_time) <= 2.0

# pydantic_graph/pydantic_graph/persistence/__init__.py:32-32
SnapshotStatus = Literal['created', 'pending', 'running', 'success', 'error']

# pydantic_graph/pydantic_graph/persistence/__init__.py:32-32
SnapshotStatus = Literal['created', 'pending', 'running', 'success', 'error']

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# examples/pydantic_ai_examples/chat_app.py:13-13
from collections.abc import AsyncIterator, Callable

# tests/models/test_anthropic.py:351-373
async def test_cache_point_multiple_markers(allow_model_requests: None):
    """Test multiple CachePoint markers in a single prompt."""
    c = completion_message(
        [BetaTextBlock(text='response', type='text')],
        usage=BetaUsage(input_tokens=3, output_tokens=5),
    )
    mock_client = MockAnthropic.create_mock(c)
    m = AnthropicModel('claude-haiku-4-5', provider=AnthropicProvider(anthropic_client=mock_client))
    agent = Agent(m)

    await agent.run(['First chunk', CachePoint(), 'Second chunk', CachePoint(), 'Question'])

    completion_kwargs = get_mock_chat_completion_kwargs(mock_client)[0]
    content = completion_kwargs['messages'][0]['content']

    # Default ttl='5m' for non-Bedrock clients
    assert content == snapshot(
        [
            {'text': 'First chunk', 'type': 'text', 'cache_control': {'type': 'ephemeral', 'ttl': '5m'}},
            {'text': 'Second chunk', 'type': 'text', 'cache_control': {'type': 'ephemeral', 'ttl': '5m'}},
            {'text': 'Question', 'type': 'text'},
        ]
    )

# tests/conftest.py:662-670
def mock_snapshot_id(mocker: MockerFixture):
    i = 0

    def generate_snapshot_id(node_id: str) -> str:
        nonlocal i
        i += 1
        return f'{node_id}:{i}'

    return mocker.patch('pydantic_graph.nodes.generate_snapshot_id', side_effect=generate_snapshot_id)

# pydantic_graph/pydantic_graph/nodes.py:159-164
    def get_snapshot_id(self) -> str:
        if snapshot_id := getattr(self, '__snapshot_id', None):
            return snapshot_id
        else:
            self.__dict__['__snapshot_id'] = snapshot_id = generate_snapshot_id('end')
            return snapshot_id

# pydantic_graph/pydantic_graph/nodes.py:166-167
    def set_snapshot_id(self, set_id: str) -> None:
        self.__dict__['__snapshot_id'] = set_id

# pydantic_graph/pydantic_graph/persistence/__init__.py:31-31
UNSET_SNAPSHOT_ID = '__unset__'

# tests/test_tenacity.py:189-344
class TestAsyncTenacityTransport:
    """Tests for the asynchronous AsyncTenacityTransport."""

    async def test_successful_request(self):
        """Test that successful requests pass through without retry."""
        mock_transport = AsyncMock(spec=httpx.AsyncBaseTransport)
        mock_response = Mock(spec=httpx.Response)
        mock_transport.handle_async_request.return_value = mock_response

        config = RetryConfig(stop=stop_after_attempt(3), reraise=True)
        transport = AsyncTenacityTransport(config, mock_transport)

        request = httpx.Request('GET', 'https://example.com')
        async with transport:
            result = await transport.handle_async_request(request)

        assert result is mock_response
        mock_transport.handle_async_request.assert_called_once_with(request)

    async def test_retry_on_exception(self):
        """Test that exceptions trigger retries."""
        mock_transport = AsyncMock(spec=httpx.AsyncBaseTransport)
        mock_response = Mock(spec=httpx.Response)

        # Fail twice, succeed on third attempt
        mock_transport.handle_async_request.side_effect = [
            httpx.ConnectError('Connection failed'),
            httpx.ConnectError('Connection failed again'),
            mock_response,
        ]

        config = RetryConfig(
            retry=retry_if_exception_type(httpx.ConnectError),
            stop=stop_after_attempt(3),
            wait=wait_fixed(0.001),
            reraise=True,
        )
        transport = AsyncTenacityTransport(config, mock_transport)

        request = httpx.Request('GET', 'https://example.com')
        result = await transport.handle_async_request(request)

        assert result is mock_response
        assert mock_transport.handle_async_request.call_count == 3

    async def test_retry_exhausted(self):
        """Test that retry exhaustion re-raises the last exception."""
        mock_transport = AsyncMock(spec=httpx.AsyncBaseTransport)
        mock_transport.handle_async_request.side_effect = httpx.ConnectError('Connection failed')

        config = RetryConfig(
            retry=retry_if_exception_type(httpx.ConnectError),
            stop=stop_after_attempt(2),
            wait=wait_fixed(0.001),
            reraise=True,
        )
        transport = AsyncTenacityTransport(config, mock_transport)

        request = httpx.Request('GET', 'https://example.com')
        with pytest.raises(httpx.ConnectError, match='Connection failed'):
            await transport.handle_async_request(request)

        assert mock_transport.handle_async_request.call_count == 2

    async def test_validate_response_success(self):
        """Test that validate_response is called and doesn't raise."""
        mock_transport = AsyncMock(spec=httpx.AsyncBaseTransport)
        mock_response = Mock(spec=httpx.Response)
        mock_response.status_code = 200
        mock_transport.handle_async_request.return_value = mock_response

        validate_response = Mock()
        config = RetryConfig(stop=stop_after_attempt(3), reraise=True)
        transport = AsyncTenacityTransport(config, mock_transport, validate_response)

        request = httpx.Request('GET', 'https://example.com')
        result = await transport.handle_async_request(request)

        assert result is mock_response
        validate_response.assert_called_once_with(mock_response)

    async def test_validate_response_triggers_retry(self):
        """Test that validate_response can trigger retries."""
        mock_transport = AsyncMock(spec=httpx.AsyncBaseTransport)
        mock_response_fail = Mock(spec=httpx.Response)
        mock_response_fail.status_code = 429
        mock_response_success = Mock(spec=httpx.Response)
        mock_response_success.status_code = 200

        mock_transport.handle_async_request.side_effect = [mock_response_fail, mock_response_success]

        def validate_response(response: httpx.Response):
            if response.status_code == 429:
                raise httpx.HTTPStatusError('Rate limited', request=request, response=response)

        config = RetryConfig(
            retry=retry_if_exception_type(httpx.HTTPStatusError),
            stop=stop_after_attempt(3),
            wait=wait_fixed(0.001),
            reraise=True,
        )
        transport = AsyncTenacityTransport(config, mock_transport, validate_response)

        request = httpx.Request('GET', 'https://example.com')
        result = await transport.handle_async_request(request)

        assert result is mock_response_success
        assert mock_transport.handle_async_request.call_count == 2

    async def test_raise_for_status_in_validate_response(self):
        """Test that response.raise_for_status() works in validate_response callback."""
        mock_transport = AsyncMock(spec=httpx.AsyncBaseTransport)
        mock_response_fail = Mock(spec=httpx.Response)
        mock_response_fail.status_code = 429
        mock_response_fail.is_success = False
        mock_response_fail.is_error = True
        mock_response_fail.request = None  # Initially None, will be set by transport

        # Mock raise_for_status to check if request is set
        def mock_raise_for_status():
            if mock_response_fail.request is None:
                raise RuntimeError(  # pragma: no cover
                    'Cannot call `raise_for_status` as the request instance has not been set on this response.'
                )
            raise httpx.HTTPStatusError(
                'Too Many Requests', request=mock_response_fail.request, response=mock_response_fail
            )

        mock_response_fail.raise_for_status = mock_raise_for_status

        mock_response_success = Mock(spec=httpx.Response)
        mock_response_success.status_code = 200
        mock_response_success.is_success = True
        mock_response_success.is_error = False
        mock_response_success.raise_for_status = Mock()  # Should not raise

        mock_transport.handle_async_request.side_effect = [mock_response_fail, mock_response_success]

        config = RetryConfig(
            retry=retry_if_exception_type(httpx.HTTPStatusError),
            stop=stop_after_attempt(3),
            wait=wait_fixed(0.001),
            reraise=True,
        )
        transport = AsyncTenacityTransport(
            config, mock_transport, validate_response=lambda response: response.raise_for_status()
        )

        request = httpx.Request('GET', 'https://example.com')
        result = await transport.handle_async_request(request)

        assert result is mock_response_success
        assert mock_transport.handle_async_request.call_count == 2
        # Verify that the request was set on the failed response before raise_for_status was called
        assert mock_response_fail.request is request
        mock_response_success.raise_for_status.assert_called_once()

# examples/pydantic_ai_examples/ag_ui/api/agentic_generative_ui.py:10-10
from ag_ui.core import EventType, StateDeltaEvent, StateSnapshotEvent

# examples/pydantic_ai_examples/ag_ui/api/agentic_generative_ui.py:10-10
from ag_ui.core import EventType, StateDeltaEvent, StateSnapshotEvent

# tests/test_tenacity.py:596-673
class TestIntegration:
    """Integration tests combining transports with wait strategies."""

    async def test_async_transport_with_wait_retry_after(self):
        """Test AsyncTenacityTransport with wait_retry_after strategy."""
        mock_transport = AsyncMock(spec=httpx.AsyncBaseTransport)
        mock_response_fail = Mock(spec=httpx.Response)
        mock_response_fail.status_code = 429
        mock_response_fail.headers = {'retry-after': '1'}
        mock_response_success = Mock(spec=httpx.Response)
        mock_response_success.status_code = 200

        mock_transport.handle_async_request.side_effect = [mock_response_fail, mock_response_success]

        # Track validation calls
        validation_calls: list[int] = []

        def validate_response(response: httpx.Response):
            validation_calls.append(response.status_code)
            if response.status_code == 429:
                raise httpx.HTTPStatusError('Rate limited', request=request, response=response)

        config = RetryConfig(
            retry=retry_if_exception_type(httpx.HTTPStatusError),
            wait=wait_retry_after(max_wait=5),  # Short max_wait for tests
            stop=stop_after_attempt(3),
            reraise=True,
        )
        transport = AsyncTenacityTransport(config, mock_transport, validate_response)

        request = httpx.Request('GET', 'https://example.com')

        # Time the request to ensure retry-after wait was respected
        start_time = asyncio.get_event_loop().time()
        result = await transport.handle_async_request(request)
        end_time = asyncio.get_event_loop().time()

        assert result is mock_response_success
        assert mock_transport.handle_async_request.call_count == 2
        assert validation_calls == [429, 200]  # First call failed, second succeeded
        # Should have waited approximately 1 second (allow some tolerance)
        assert 0.8 <= (end_time - start_time) <= 2.0

    def test_sync_transport_with_wait_retry_after(self):
        """Test TenacityTransport with wait_retry_after strategy."""
        mock_transport = Mock(spec=httpx.BaseTransport)
        mock_response_fail = Mock(spec=httpx.Response)
        mock_response_fail.status_code = 429
        mock_response_fail.headers = {'retry-after': '30'}  # 30 seconds, will be capped
        mock_response_success = Mock(spec=httpx.Response)
        mock_response_success.status_code = 200

        mock_transport.handle_request.side_effect = [mock_response_fail, mock_response_success]

        def validate_response(response: httpx.Response):
            if response.status_code == 429:
                raise httpx.HTTPStatusError('Rate limited', request=request, response=response)

        config = RetryConfig(
            retry=retry_if_exception_type(httpx.HTTPStatusError),
            wait=wait_retry_after(max_wait=0.1),  # Cap at 0.1 seconds for tests
            stop=stop_after_attempt(3),
            reraise=True,
        )
        transport = TenacityTransport(config, mock_transport, validate_response)

        request = httpx.Request('GET', 'https://example.com')

        # Time the request to ensure max_wait was respected
        start_time = time.time()
        result = transport.handle_request(request)
        end_time = time.time()

        assert result is mock_response_success
        assert mock_transport.handle_request.call_count == 2
        # Should have waited approximately 0.2 seconds (capped by max_wait)
        duration = end_time - start_time
        assert 0.1 <= duration <= 0.2

# pydantic_graph/pydantic_graph/nodes.py:67-73
    def get_snapshot_id(self) -> str:
        if snapshot_id := getattr(self, '__snapshot_id', None):
            return snapshot_id
        else:
            snapshot_id = generate_snapshot_id(self.get_node_id())
            object.__setattr__(self, '__snapshot_id', snapshot_id)
            return snapshot_id

# pydantic_graph/pydantic_graph/nodes.py:75-76
    def set_snapshot_id(self, snapshot_id: str) -> None:
        object.__setattr__(self, '__snapshot_id', snapshot_id)

# pydantic_graph/pydantic_graph/nodes.py:170-172
def generate_snapshot_id(node_id: str) -> str:
    # module method to allow mocking
    return f'{node_id}:{uuid4().hex}'

# tests/test_mcp.py:1858-1879
async def test_list_resources_error(mcp_server: MCPServerStdio) -> None:
    """Test that list_resources converts McpError to MCPError."""
    mcp_error = McpError(
        error=ErrorData(code=-32603, message='Failed to list resources', data={'details': 'server overloaded'})
    )

    async with mcp_server:
        with patch.object(
            mcp_server._client,  # pyright: ignore[reportPrivateUsage]
            'list_resources',
            new=AsyncMock(side_effect=mcp_error),
        ):
            with pytest.raises(MCPError, match='Failed to list resources') as exc_info:
                await mcp_server.list_resources()

            # Verify the exception has the expected attributes
            assert exc_info.value.code == -32603
            assert exc_info.value.message == 'Failed to list resources'
            assert exc_info.value.data == {'details': 'server overloaded'}
            assert (
                str(exc_info.value) == "Failed to list resources (code: -32603, data: {'details': 'server overloaded'})"
            )

# tests/models/test_bedrock.py:2435-2451
async def test_bedrock_cache_point_multiple_markers(allow_model_requests: None, bedrock_provider: BedrockProvider):
    model = BedrockConverseModel('us.anthropic.claude-3-5-haiku-20241022-v1:0', provider=bedrock_provider)
    messages: list[ModelMessage] = [
        ModelRequest(
            parts=[UserPromptPart(content=['First chunk', CachePoint(), 'Second chunk', CachePoint(), 'Question'])]
        )
    ]
    _, bedrock_messages = await model._map_messages(messages, ModelRequestParameters(), BedrockModelSettings())  # pyright: ignore[reportPrivateUsage]
    assert bedrock_messages[0]['content'] == snapshot(
        [
            {'text': 'First chunk'},
            {'cachePoint': {'type': 'default'}},
            {'text': 'Second chunk'},
            {'cachePoint': {'type': 'default'}},
            {'text': 'Question'},
        ]
    )

# pydantic_graph/pydantic_graph/persistence/file.py:65-66
    async def snapshot_end(self, state: StateT, end: End[RunEndT]) -> None:
        await self._append_save(EndSnapshot(state=state, result=end))

# pydantic_graph/pydantic_graph/persistence/in_mem.py:114-119
    async def snapshot_end(self, state: StateT, end: End[RunEndT]) -> None:
        snapshot = EndSnapshot(
            state=self._prep_state(state),
            result=end.deep_copy_data() if self.deep_copy else end,
        )
        self.history.append(snapshot)

# pydantic_graph/pydantic_graph/persistence/file.py:54-55
    async def snapshot_node(self, state: StateT, next_node: BaseNode[StateT, Any, RunEndT]) -> None:
        await self._append_save(NodeSnapshot(state=state, node=next_node))