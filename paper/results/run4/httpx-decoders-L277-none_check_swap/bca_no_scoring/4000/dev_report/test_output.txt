uvwxyz", b""), "iso-8859-1"),
        ],
    )
    @pytest.mark.anyio
    async def test_text_decoder_with_autodetect(data, encoding):
        async def iterator() -> typing.AsyncIterator[bytes]:
            nonlocal data
            for chunk in data:
                yield chunk
    
        def autodetect(content):
            result = chardet.detect(content)
            return result['encoding'] if result['encoding'] is not None else 'utf-8'
    
        # Accessing `.text` on a read response.
        response = httpx.Response(200, content=iterator(), default_encoding=autodetect)
        await response.aread()
        assert response.text == (b"".join(data)).decode(encoding)
    
        # Streaming `.aiter_text` iteratively.
        # Note that if we streamed the text *without* having read it first, then
        # we won't get a `charset_normalizer` guess, and will instead always rely
        # on utf-8 if no charset is specified.
>       text = "".join([part async for part in response.aiter_text()])

tests/test_decoders.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_decoders.py:263: in <listcomp>
    text = "".join([part async for part in response.aiter_text()])
httpx/_models.py:1020: in aiter_text
    for chunk in chunker.decode(text_content):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx._decoders.TextChunker object at 0x100f91710>
content = 'Hello, world!'

    def decode(self, content: str) -> list[str]:
        if self._chunk_size is not None:
            return [content] if content else []
    
        self._buffer.write(content)
>       if self._buffer.tell() >= self._chunk_size:
E       TypeError: '>=' not supported between instances of 'int' and 'NoneType'

httpx/_decoders.py:281: TypeError
!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!
========================= 1 failed, 12 passed in 0.22s =========================

/Users/akshankrithick/anaconda3/envs/vvenv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:247: PytestDeprecationWarning: The configuration option "asyncio_default_fixture_loop_scope" is unset.
The event loop scope for asynchronous fixtures will default to the fixture caching scope. Future versions of pytest-asyncio will default the loop scope for asynchronous fixtures to function scope. Set the default fixture loop scope explicitly in order to avoid unexpected behavior in the future. Valid fixture loop scopes are: "function", "class", "module", "package", "session"

  warnings.warn(PytestDeprecationWarning(_DEFAULT_FIXTURE_LOOP_SCOPE_UNSET))