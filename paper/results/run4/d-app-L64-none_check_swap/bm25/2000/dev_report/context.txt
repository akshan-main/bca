# pydantic_graph/pydantic_graph/mermaid.py:268-268
    httpx_client: httpx.Client

# tests/conftest.py:345-370
async def close_cached_httpx_client(anyio_backend: str, monkeypatch: pytest.MonkeyPatch) -> AsyncIterator[None]:
    """Track and close cached httpx clients created during each test.

    Prevents reusing AsyncClient instances across tests (and event loops),
    which can cause 'Event loop is closed' errors, without touching prod code.
    """
    created_clients: set[httpx.AsyncClient] = set()

    # Patch the cached factory to record returned clients while preserving caching.
    original_cached_func = pydantic_ai.models._cached_async_http_client  # type: ignore[reportPrivateUsage]

    def tracked_cached_async_http_client(*args: Any, **kwargs: Any):
        client = original_cached_func(*args, **kwargs)
        created_clients.add(client)
        return client

    monkeypatch.setattr(pydantic_ai.models, '_cached_async_http_client', tracked_cached_async_http_client)

    yield

    # Close only the clients that were actually created/accessed in this test
    for client in created_clients:
        await client.aclose()

    # Ensure no stale cached clients persist between tests (new event loop per test)
    original_cached_func.cache_clear()

# tests/conftest.py:345-370
async def close_cached_httpx_client(anyio_backend: str, monkeypatch: pytest.MonkeyPatch) -> AsyncIterator[None]:
    """Track and close cached httpx clients created during each test.

    Prevents reusing AsyncClient instances across tests (and event loops),
    which can cause 'Event loop is closed' errors, without touching prod code.
    """
    created_clients: set[httpx.AsyncClient] = set()

    # Patch the cached factory to record returned clients while preserving caching.
    original_cached_func = pydantic_ai.models._cached_async_http_client  # type: ignore[reportPrivateUsage]

    def tracked_cached_async_http_client(*args: Any, **kwargs: Any):
        client = original_cached_func(*args, **kwargs)
        created_clients.add(client)
        return client

    monkeypatch.setattr(pydantic_ai.models, '_cached_async_http_client', tracked_cached_async_http_client)

    yield

    # Close only the clients that were actually created/accessed in this test
    for client in created_clients:
        await client.aclose()

    # Ensure no stale cached clients persist between tests (new event loop per test)
    original_cached_func.cache_clear()

# tests/conftest.py:345-370
async def close_cached_httpx_client(anyio_backend: str, monkeypatch: pytest.MonkeyPatch) -> AsyncIterator[None]:
    """Track and close cached httpx clients created during each test.

    Prevents reusing AsyncClient instances across tests (and event loops),
    which can cause 'Event loop is closed' errors, without touching prod code.
    """
    created_clients: set[httpx.AsyncClient] = set()

    # Patch the cached factory to record returned clients while preserving caching.
    original_cached_func = pydantic_ai.models._cached_async_http_client  # type: ignore[reportPrivateUsage]

    def tracked_cached_async_http_client(*args: Any, **kwargs: Any):
        client = original_cached_func(*args, **kwargs)
        created_clients.add(client)
        return client

    monkeypatch.setattr(pydantic_ai.models, '_cached_async_http_client', tracked_cached_async_http_client)

    yield

    # Close only the clients that were actually created/accessed in this test
    for client in created_clients:
        await client.aclose()

    # Ensure no stale cached clients persist between tests (new event loop per test)
    original_cached_func.cache_clear()

# tests/models/test_google.py:3952-3960
async def test_google_httpx_client_is_not_closed(allow_model_requests: None, gemini_api_key: str):
    # This should not raise any errors, see https://github.com/pydantic/pydantic-ai/issues/3242.
    agent = Agent(GoogleModel('gemini-2.5-flash-lite', provider=GoogleProvider(api_key=gemini_api_key)))
    result = await agent.run('What is the capital of France?')
    assert result.output == snapshot('The capital of France is **Paris**.')

    agent = Agent(GoogleModel('gemini-2.5-flash-lite', provider=GoogleProvider(api_key=gemini_api_key)))
    result = await agent.run('What is the capital of Mexico?')
    assert result.output == snapshot('The capital of Mexico is **Mexico City**.')

# tests/providers/test_alibaba_provider.py:83-86
def test_alibaba_provider_with_http_client():
    http_client = httpx.AsyncClient()
    provider = AlibabaProvider(api_key='foo', http_client=http_client)
    assert provider.client.api_key == 'foo'

# tests/providers/test_alibaba_provider.py:77-80
def test_alibaba_provider_with_openai_client():
    client = openai.AsyncOpenAI(api_key='foo')
    provider = AlibabaProvider(openai_client=client)
    assert provider.client is client

# tests/models/test_gemini.py:501-537
async def get_gemini_client(
    client_with_handler: ClientWithHandler, env: TestEnv, allow_model_requests: None
) -> GetGeminiClient:
    env.set('GEMINI_API_KEY', 'via-env-var')

    def create_client(response_or_list: ResOrList) -> httpx.AsyncClient:
        index = 0

        def handler(request: httpx.Request) -> httpx.Response:
            nonlocal index

            ua = request.headers.get('User-Agent')
            assert isinstance(ua, str) and ua.startswith('pydantic-ai')

            if isinstance(response_or_list, Sequence):
                response = response_or_list[index]
                index += 1
            else:
                response = response_or_list

            if isinstance(response, httpx.AsyncByteStream):
                content: bytes | None = None
                stream: httpx.AsyncByteStream | None = response
            else:
                content = _gemini_response_ta.dump_json(response, by_alias=True)
                stream = None

            return httpx.Response(
                200,
                content=content,
                stream=stream,
                headers={'Content-Type': 'application/json'},
            )

        return client_with_handler(handler)

    return create_client

# tests/providers/test_together.py:57-60
def test_together_pass_openai_client() -> None:
    openai_client = openai.AsyncOpenAI(api_key='api-key')
    provider = TogetherProvider(openai_client=openai_client)
    assert provider.client == openai_client

# tests/models/test_huggingface.py:788-801
async def test_model_client_response_error(allow_model_requests: None) -> None:
    request_info = Mock(spec=aiohttp.RequestInfo)
    request_info.url = 'http://test.com'
    request_info.method = 'POST'
    request_info.headers = {}
    request_info.real_url = 'http://test.com'
    error = aiohttp.ClientResponseError(request_info, history=(), status=400, message='Bad Request')

    mock_client = MockHuggingFace.create_mock(error)
    m = HuggingFaceModel('not_a_model', provider=HuggingFaceProvider(hf_client=mock_client, api_key='x'))
    agent = Agent(m)
    with pytest.raises(ModelHTTPError) as exc_info:
        await agent.run('hello')
    assert str(exc_info.value) == snapshot('status_code: 400, model_name: not_a_model, body: Bad Request')

# tests/test_ui_web.py:193-204
def test_chat_app_index_endpoint():
    """Test that the index endpoint serves HTML with proper caching headers."""
    agent = Agent('test')
    app = create_web_app(agent)

    with TestClient(app) as client:
        response = client.get('/')
        assert response.status_code == 200
        assert response.headers['content-type'] == 'text/html; charset=utf-8'
        assert 'cache-control' in response.headers
        assert response.headers['cache-control'] == 'public, max-age=3600'
        assert len(response.content) > 0

# tests/providers/test_together.py:51-54
def test_together_provider_pass_http_client() -> None:
    http_client = httpx.AsyncClient()
    provider = TogetherProvider(http_client=http_client, api_key='api-key')
    assert provider.client._client == http_client  # type: ignore[reportPrivateUsage]

# tests/conftest.py:345-370
async def close_cached_httpx_client(anyio_backend: str, monkeypatch: pytest.MonkeyPatch) -> AsyncIterator[None]:
    """Track and close cached httpx clients created during each test.

    Prevents reusing AsyncClient instances across tests (and event loops),
    which can cause 'Event loop is closed' errors, without touching prod code.
    """
    created_clients: set[httpx.AsyncClient] = set()

    # Patch the cached factory to record returned clients while preserving caching.
    original_cached_func = pydantic_ai.models._cached_async_http_client  # type: ignore[reportPrivateUsage]

    def tracked_cached_async_http_client(*args: Any, **kwargs: Any):
        client = original_cached_func(*args, **kwargs)
        created_clients.add(client)
        return client

    monkeypatch.setattr(pydantic_ai.models, '_cached_async_http_client', tracked_cached_async_http_client)

    yield

    # Close only the clients that were actually created/accessed in this test
    for client in created_clients:
        await client.aclose()

    # Ensure no stale cached clients persist between tests (new event loop per test)
    original_cached_func.cache_clear()

# tests/models/test_google.py:15-15
from httpx import AsyncClient as HttpxAsyncClient, Timeout

# tests/models/test_cohere.py:75-75
    _client_wrapper: MockClientWrapper = None  # type: ignore

# tests/providers/test_gateway.py:65-68
async def test_init_with_http_client():
    async with httpx.AsyncClient() as http_client:
        provider = gateway_provider('openai', http_client=http_client, api_key='foobar')
        assert provider.client._client == http_client  # type: ignore

# tests/providers/test_gateway.py:65-68
async def test_init_with_http_client():
    async with httpx.AsyncClient() as http_client:
        provider = gateway_provider('openai', http_client=http_client, api_key='foobar')
        assert provider.client._client == http_client  # type: ignore

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx

# .github/set_docs_main_preview_url.py:6-6
import httpx