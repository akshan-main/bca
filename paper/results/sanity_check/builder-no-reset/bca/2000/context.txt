# Codebase Context for: GraphBuilder accumulates stale nodes and edges when build_from_directory is called multiple times â€” the second build has duplicate symbols from the first.
# 20 symbols from 9 files (~1,677 tokens, 84% of budget)

## paper/experiments/baselines.py
# Included because: graph expansion (depth 3)

# [class] BaselineResult (relevance: 0.43, depth: 3)
  34 | class BaselineResult:
  35 |     """Result of a single baseline run."""
  36 | 
  37 |     method: str
  38 |     task: str
  39 |     budget: int
  40 |     tokens_used: int
  41 |     symbols_selected: int
  42 |     files_included: int
  43 |     assembly_time_ms: float
  44 |     selected_symbols: list[str] = field(default_factory=list)
  45 |     recall: float | None = None

## paper/experiments/benchmark.py
# Included because: graph expansion (depth 2); graph expansion (depth 3)

# [class] SearchReplaceEdit (relevance: 0.35, depth: 3)
 634 | class SearchReplaceEdit:
 635 |     """A single search/replace edit."""
 636 |     file_path: str
 637 |     search: str
 638 |     replace: str

# [function] extract_patch (relevance: 0.42, depth: 2)
 726 | def extract_patch(llm_output: str) -> str:
 727 |     """Extract patch info from LLM output. Returns raw text for logging."""
 728 |     edits = extract_edits(llm_output)
 729 |     if not edits:
 730 |         return ""
 731 |     parts = []
 732 |     for e in edits:
 733 |         parts.append(f"FILE: {e.file_path}")
 734 |         parts.append(f"SEARCH:\n{e.search}")
 735 |         parts.append(f"REPLACE:\n{e.replace}")
 736 |         parts.append("")
 737 |     return "\n".join(parts)

# [function] _restore_mutation (relevance: 0.40, depth: 2)
 831 | def _restore_mutation(repo_path: Path, mutation: dict, original: str) -> None:
 832 |     """Restore original content after mutation."""
 833 |     file_path = repo_path / mutation["file"]
 834 |     file_path.write_text(original)

## src/cegraph/cli.py
# Included because: graph expansion (depth 2); graph expansion (depth 3)

# [function] _get_project_root (relevance: 0.61, depth: 3)
  28 | def _get_project_root(path: str | None = None) -> Path:
  29 |     """Find the project root or error."""
  30 |     if path:
  31 |         root = Path(path).resolve()
  32 |         if not root.exists():
  33 |             console.error(f"Path does not exist: {path}")
  34 |             sys.exit(1)
  35 |         return root
  36 | 
  37 |     root = find_project_root()
  38 |     if root is None:
  39 |         console.error(
  40 |             "No CeGraph project found. Run 'cegraph init' first, "
  41 |             "or specify a path with --path."
  42 |         )
  43 |         sys.exit(1)
  44 |     return root

# [function] _load_graph (relevance: 0.59, depth: 3)
  47 | def _load_graph(root: Path):
  48 |     """Load the knowledge graph and related objects."""
  49 |     from cegraph.graph.store import GraphStore
  50 | 
  51 |     db_path = get_cegraph_dir(root) / GRAPH_DB_FILE
  52 |     store = GraphStore(db_path)
  53 |     graph = store.load()
  54 |     if graph is None:
  55 |         console.error("No index found. Run 'cegraph init' or 'cegraph reindex' first.")
  56 |         sys.exit(1)
  57 |     return graph, store

# [function] reindex (relevance: 0.34, depth: 2)
 100 | def reindex(path: str | None):
 101 |     """Rebuild the knowledge graph from scratch."""
 102 |     root = _get_project_root(path)
 103 |     config = load_config(root)
 104 |     _do_index(root, config)

# [function] who_calls (relevance: 0.64, depth: 2)
 202 | def who_calls(symbol_name: str, path: str | None, depth: int):
 203 |     """Find all callers of a function or method."""
 204 |     root = _get_project_root(path)
 205 |     graph, store = _load_graph(root)
 206 | 
 207 |     from cegraph.graph.query import GraphQuery
 208 | 
 209 |     query = GraphQuery(graph, store)
 210 |     callers = query.who_calls(symbol_name, max_depth=depth)
 211 | 
 212 |     if callers:
 213 |         console.info(f"Callers of '{symbol_name}':")
 214 |         console.show_callers(callers, symbol_name)
 215 |     else:
 216 |         console.warning(f"No callers found for '{symbol_name}'")
 217 | 
 218 |     store.close()

## src/cegraph/config.py
# Included because: required dependency of FileSymbols; graph expansion (depth 3)

# [import] BaseModel (relevance: 0.20, depth: 1)
  10 | from pydantic import BaseModel, Field

# [function] get_cegraph_dir (relevance: 0.12, depth: 3)
 103 | def get_cegraph_dir(root: Path) -> Path:
 104 |     """Get the .cegraph directory for a project root."""
 105 |     return root / CEGRAPH_DIR

# [function] save_config (relevance: 0.14, depth: 3)
 117 | def save_config(root: Path, config: ProjectConfig) -> None:
 118 |     """Save configuration to .cegraph/config.json."""
 119 |     cs_dir = get_cegraph_dir(root)
 120 |     cs_dir.mkdir(parents=True, exist_ok=True)
 121 |     config_path = cs_dir / CONFIG_FILE
 122 |     config_path.write_text(json.dumps(config.model_dump(), indent=2))

## src/cegraph/github/diff_parser.py
# Included because: graph expansion (depth 2); graph expansion (depth 3)

# [class] DiffHunk (relevance: 0.49, depth: 2)
  18 | class DiffHunk:
  19 |     """A single hunk from a unified diff."""
  20 |     old_start: int
  21 |     old_count: int
  22 |     new_start: int
  23 |     new_count: int
  24 |     lines: list[str] = field(default_factory=list)

# [class] FileDiff (relevance: 0.53, depth: 2)
  28 | class FileDiff:
  29 |     """Changes to a single file."""
  30 |     path: str
  31 |     status: str  # 'added', 'modified', 'deleted', 'renamed'
  32 |     old_path: str | None = None  # For renames
  33 |     hunks: list[DiffHunk] = field(default_factory=list)
  34 |     added_lines: int = 0
  35 |     deleted_lines: int = 0
  36 | 
  37 |     @property
  38 |     def changed_line_ranges(self) -> list[tuple[int, int]]:
  39 |         """Get ranges of changed lines in the new file."""
  40 |         ranges = []
  41 |         for hunk in self.hunks:
  42 |             ranges.append((hunk.new_start, hunk.new_start + hunk.new_count))
  43 |         return ranges

# [class] ChangedSymbol (relevance: 0.42, depth: 3)
  47 | class ChangedSymbol:
  48 |     """A symbol that was affected by the diff."""
  49 |     name: str
  50 |     qualified_name: str
  51 |     kind: str
  52 |     file_path: str
  53 |     line_start: int
  54 |     line_end: int
  55 |     change_type: str  # 'modified', 'added', 'deleted'
  56 |     lines_changed: int = 0

# [function] get_pr_diff (relevance: 0.42, depth: 3)
 205 | def get_pr_diff(root: Path) -> str:
 206 |     """Get the diff for the current PR (GitHub Actions context)."""
 207 |     import os
 208 |     base_ref = os.environ.get("GITHUB_BASE_REF", "main")
 209 |     return get_git_diff(root, base=f"origin/{base_ref}")

## src/cegraph/graph/builder.py
# Included because: matches 'build_from_directory'

# [method] GraphBuilder.build_from_directory (relevance: 1.24, depth: 0)
  30 |     def build_from_directory(
  31 |         self,
  32 |         root: str | Path,
  33 |         config: ProjectConfig | None = None,
  34 |         progress_callback: callable | None = None,
  35 |     ) -> nx.DiGraph:
  36 |         """Build the full knowledge graph from a directory.
  37 | 
  38 |         Args:
  39 |             root: Root directory to index.
  40 |             config: Project configuration.
  41 |             progress_callback: Optional callback(file_path, current, total).
  42 | 
  43 |         Returns:
  44 |             The constructed NetworkX directed graph.
  45 |         """
  46 |         root = Path(root).resolve()
  47 |         indexer_config = config.indexer if config else IndexerConfig()
  48 | 
  49 |         # Reset state so reusing a builder doesn't accumulate stale data
  50 |         # self.graph = nx.DiGraph()
  51 |         # self._file_hashes = {}
  52 |         # self._unresolved = []
  53 | 
  54 |         # Parse all files
  55 |         all_parsed = parse_directory(root, indexer_config, progress_callback)
  56 | 
  57 |         # Build graph from parsed results
  58 |         for file_symbols in all_parsed:
  59 |             self._add_file(file_symbols, root)
  60 | 
  61 |         # Resolve cross-file references
  62 |         self._resolve_references()
  63 | 
  64 |         return self.graph

## src/cegraph/parser/models.py
# Included because: matches 'symbols'; graph expansion (depth 3)

# [class] FileSymbols (relevance: 0.40, depth: 0)
  74 | class FileSymbols(BaseModel):
  75 |     """All symbols and relationships extracted from a single file."""
  76 | 
  77 |     file_path: str
  78 |     language: str
  79 |     symbols: list[Symbol] = Field(default_factory=list)
  80 |     relationships: list[Relationship] = Field(default_factory=list)
  81 |     imports: list[str] = Field(default_factory=list)  # raw import strings
  82 |     errors: list[str] = Field(default_factory=list)

# [function] detect_language (relevance: 0.40, depth: 3)
 100 | def detect_language(file_path: str) -> str | None:
 101 |     """Detect programming language from file extension."""
 102 |     from pathlib import Path
 103 | 
 104 |     ext = Path(file_path).suffix.lower()
 105 |     return EXTENSION_LANGUAGE_MAP.get(ext)

## src/cegraph/parser/tree_sitter_parser.py
# Included because: graph expansion (depth 3)

# [function] _get_language (relevance: 0.32, depth: 3)
  94 | def _get_language(lang: str):
  95 |     """Get a tree-sitter Language object for the given language."""
  96 |     from tree_sitter import Language
  97 | 
  98 |     module_name = _TS_LANGUAGE_MODULES.get(lang)
  99 |     if not module_name:
 100 |         raise ValueError(f"No tree-sitter grammar for language: {lang}")
 101 | 
 102 |     module = __import__(module_name)
 103 |     return Language(module.language())

## tests/test_context.py
# Included because: graph expansion (depth 1)

# [function] cag_engine (relevance: 0.53, depth: 1)
  21 | def cag_engine(tmp_project: Path):
  22 |     """Create a context assembler with a built graph."""
  23 |     builder = GraphBuilder()
  24 |     graph = builder.build_from_directory(tmp_project)
  25 |     query = GraphQuery(graph)
  26 |     return ContextAssembler(tmp_project, graph, query)
