# src/cegraph/context/models.py:15-15
    SMART = "balanced"  # Graph-expanded with relevance scoring (default)

# paper/experiments/baselines.py:28-28
from cegraph.context.models import ContextStrategy, TokenEstimator

# src/cegraph/context/engine.py:43-48
from cegraph.context.models import (
    ContextItem,
    ContextPackage,
    ContextStrategy,
    TokenEstimator,
)

# paper/experiments/benchmark.py:55-55
from cegraph.context.models import ContextStrategy, TokenEstimator

# paper/experiments/ablation.py:21-21
from cegraph.context.models import ContextStrategy

# src/cegraph/context/__init__.py:15-15
from cegraph.context.models import ContextPackage, ContextItem, ContextStrategy

# tests/test_context.py:10-15
from cegraph.context.models import (
    ContextItem,
    ContextPackage,
    ContextStrategy,
    TokenEstimator,
)

# src/cegraph/context/engine.py:90-109
_STRATEGY_CONFIG = {
    ContextStrategy.PRECISE: {
        "max_depth": 1,
        "min_score": 0.3,
        "include_callers": True,
        "include_callees": True,
    },
    ContextStrategy.SMART: {
        "max_depth": 3,
        "min_score": 0.1,
        "include_callers": True,
        "include_callees": True,
    },
    ContextStrategy.THOROUGH: {
        "max_depth": 5,
        "min_score": 0.05,
        "include_callers": True,
        "include_callees": True,
    },
}

# src/cegraph/context/models.py:11-16
class ContextStrategy(str, Enum):
    """Strategy for assembling context."""

    PRECISE = "precise"  # Only directly relevant symbols
    SMART = "balanced"  # Graph-expanded with relevance scoring (default)
    THOROUGH = "thorough"  # Deep expansion, all related code

# tests/test_context.py:48-52
class TestContextStrategy:
    def test_strategies_exist(self):
        assert ContextStrategy.PRECISE.value == "precise"
        assert ContextStrategy.SMART.value == "smart"
        assert ContextStrategy.THOROUGH.value == "thorough"

# src/cegraph/context/models.py:14-14
    PRECISE = "precise"  # Only directly relevant symbols

# src/cegraph/context/models.py:16-16
    THOROUGH = "thorough"  # Deep expansion, all related code

# tests/test_context.py:49-52
    def test_strategies_exist(self):
        assert ContextStrategy.PRECISE.value == "precise"
        assert ContextStrategy.SMART.value == "smart"
        assert ContextStrategy.THOROUGH.value == "thorough"

# tests/test_context.py:208-221
    def test_strategies_differ(self, cag_engine: ContextAssembler):
        """Test that different strategies produce different results."""
        precise = cag_engine.assemble(
            task="fix the main function",
            token_budget=8000,
            strategy=ContextStrategy.PRECISE,
        )
        thorough = cag_engine.assemble(
            task="fix the main function",
            token_budget=8000,
            strategy=ContextStrategy.THOROUGH,
        )
        # Thorough should generally find more candidates
        assert thorough.symbols_available >= precise.symbols_available

# tests/test_config.py:60-63
    def test_set_config_invalid_key(self):
        config = ProjectConfig()
        with pytest.raises(KeyError):
            set_config_value(config, "nonexistent.key", "value")

# src/cegraph/github/impact_bot.py:26-33
from cegraph.github.diff_parser import (
    ChangedSymbol,
    FileDiff,
    get_changed_symbols,
    get_git_diff,
    get_pr_diff,
    parse_diff,
)

# src/cegraph/github/renderer.py:15-15
from cegraph.github.diff_parser import ChangedSymbol

# tests/test_impact_bot.py:9-15
from cegraph.github.diff_parser import (
    DiffHunk,
    FileDiff,
    ChangedSymbol,
    get_changed_symbols,
    parse_diff,
)

# tests/test_impact_bot.py:113-142
class TestChangedSymbols:
    def test_get_changed_symbols(self, tmp_project: Path):
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)

        # Create a diff that modifies utils.py around helper_function
        file_diff = FileDiff(
            path="utils.py",
            status="modified",
            hunks=[DiffHunk(old_start=5, old_count=3, new_start=5, new_count=3)],
        )

        changed = get_changed_symbols(tmp_project, graph, [file_diff])
        # Should find symbols that overlap with lines 5-8 in utils.py
        # helper_function is defined around that area
        if changed:
            assert all(isinstance(s, ChangedSymbol) for s in changed)
            names = [s.name for s in changed]
            assert any("helper" in n for n in names)

    def test_deleted_file_symbols(self, tmp_project: Path):
        builder = GraphBuilder()
        graph = builder.build_from_directory(tmp_project)

        file_diff = FileDiff(path="utils.py", status="deleted")
        changed = get_changed_symbols(tmp_project, graph, [file_diff])
        # All symbols in utils.py should be marked as deleted
        for s in changed:
            assert s.change_type == "deleted"
            assert s.file_path == "utils.py"

# src/cegraph/ui/console.py:9-9
from rich.syntax import Syntax

# src/cegraph/parser/models.py:18-18
    CONSTANT = "constant"

# tests/test_context.py:302-305
    def test_is_not_accelerated(self, cag_engine: ContextAssembler):
        """Test that C++ acceleration is reported correctly."""
        # In tests, C++ extension is typically not compiled
        assert isinstance(cag_engine.is_accelerated, bool)

# src/cegraph/parser/tree_sitter_parser.py:26-61
_SYMBOL_NODE_TYPES = {
    "javascript": {
        "function_declaration": SymbolKind.FUNCTION,
        "class_declaration": SymbolKind.CLASS,
        "method_definition": SymbolKind.METHOD,
        "arrow_function": SymbolKind.FUNCTION,
        "lexical_declaration": None,
    },
    "typescript": {
        "function_declaration": SymbolKind.FUNCTION,
        "class_declaration": SymbolKind.CLASS,
        "method_definition": SymbolKind.METHOD,
        "interface_declaration": SymbolKind.INTERFACE,
        "type_alias_declaration": SymbolKind.TYPE_ALIAS,
        "enum_declaration": SymbolKind.ENUM,
        "arrow_function": SymbolKind.FUNCTION,
    },
    "go": {
        "function_declaration": SymbolKind.FUNCTION,
        "method_declaration": SymbolKind.METHOD,
        "type_declaration": SymbolKind.CLASS,
    },
    "rust": {
        "function_item": SymbolKind.FUNCTION,
        "struct_item": SymbolKind.CLASS,
        "enum_item": SymbolKind.ENUM,
        "trait_item": SymbolKind.INTERFACE,
        "impl_item": SymbolKind.CLASS,
    },
    "java": {
        "class_declaration": SymbolKind.CLASS,
        "interface_declaration": SymbolKind.INTERFACE,
        "method_declaration": SymbolKind.METHOD,
        "enum_declaration": SymbolKind.ENUM,
    },
}

# tests/test_parser.py:31-36
    def test_unknown(self):
        assert detect_language("readme.md") is None
        assert detect_language("data.json") is None
        # Languages without tree-sitter grammars are not supported
        assert detect_language("main.rb") is None
        assert detect_language("main.php") is None

# tests/test_mcp.py:189-218
class TestMCPMessageHandling:
    def test_handle_notification(self, mcp_server: MCPServer):
        """Test notification handling (no response)."""
        result = mcp_server._handle_message({
            "jsonrpc": "2.0",
            "method": "notifications/initialized",
        })
        assert result is None  # Notifications don't get responses

    def test_handle_request(self, mcp_server: MCPServer):
        """Test request handling (has id, gets response)."""
        result = mcp_server._handle_message({
            "jsonrpc": "2.0",
            "id": 1,
            "method": "ping",
            "params": {},
        })
        assert result is not None
        assert result["jsonrpc"] == "2.0"
        assert result["id"] == 1

    def test_handle_unknown_method(self, mcp_server: MCPServer):
        """Test error handling for unknown methods."""
        result = mcp_server._handle_message({
            "jsonrpc": "2.0",
            "id": 1,
            "method": "unknown/method",
            "params": {},
        })
        assert "error" in result

# tests/test_config.py:50-53
    def test_set_config_value(self):
        config = ProjectConfig()
        updated = set_config_value(config, "llm.provider", "openai")
        assert updated.llm.provider == "openai"