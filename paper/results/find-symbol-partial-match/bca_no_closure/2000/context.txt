# Codebase Context for: GraphQuery.find_symbol no longer finds symbols by partial name match — only exact matches work.
# 47 symbols from 14 files (~2,378 tokens, 119% of budget)

## src/cegraph/context/_native.py
# Included because: graph expansion (depth 3)

# [method] NativeGraph.add_edge (relevance: 0.43, depth: 3)
 229 |     def add_edge(self, src: int, dst: int, weight: float) -> None:
 230 |         self._lib.cag_graph_add_edge(self._handle, src, dst, weight)

# [method] NativeGraph.set_node_weight (relevance: 0.29, depth: 3)
 232 |     def set_node_weight(self, node: int, weight: float) -> None:
 233 |         self._lib.cag_graph_set_node_weight(self._handle, node, weight)

# [method] NativeGraph.set_lines (relevance: 0.29, depth: 3)
 235 |     def set_lines(self, node: int, start: int, end: int) -> None:
 236 |         self._lib.cag_graph_set_lines(self._handle, node, start, end)

## src/cegraph/context/models.py
# Included because: graph expansion (depth 3)

# [method] TokenEstimator.estimate (relevance: 0.47, depth: 3)
 166 |     def estimate(cls, text: str) -> int:
 167 |         """Estimate token count for a string."""
 168 |         return max(1, int(len(text) / cls.CHARS_PER_TOKEN))

# [method] TokenEstimator.estimate_lines (relevance: 0.37, depth: 3)
 171 |     def estimate_lines(cls, line_count: int, avg_line_length: int = 40) -> int:
 172 |         """Estimate tokens for a given number of lines."""
 173 |         return max(1, int(line_count * avg_line_length / cls.CHARS_PER_TOKEN))

## src/cegraph/github/diff_parser.py
# Included because: graph expansion (depth 2)

# [function] get_pr_diff (relevance: 0.51, depth: 2)
 205 | def get_pr_diff(root: Path) -> str:
 206 |     """Get the diff for the current PR (GitHub Actions context)."""
 207 |     import os
 208 |     base_ref = os.environ.get("GITHUB_BASE_REF", "main")
 209 |     return get_git_diff(root, base=f"origin/{base_ref}")

## src/cegraph/graph/query.py
# Included because: matches 'find_symbol'; graph expansion (depth 1)

# [method] GraphQuery.__init__ (relevance: 0.80, depth: 1)
  38 |     def __init__(self, graph: nx.DiGraph, store: GraphStore | None = None) -> None:
  39 |         self.graph = graph
  40 |         self.store = store
  41 |         self._name_index: dict[str, list[str]] = {}
  42 |         self._build_index()

# [method] GraphQuery._build_index (relevance: 0.82, depth: 1)
  44 |     def _build_index(self) -> None:
  45 |         """Build a name->node_id lookup index."""
  46 |         for node_id, data in self.graph.nodes(data=True):
  47 |             if data.get("type") != "symbol":
  48 |                 continue
  49 |             name = data.get("name", "")
  50 |             qname = data.get("qualified_name", "")
  51 |             if name:
  52 |                 self._name_index.setdefault(name, []).append(node_id)
  53 |             if qname and qname != name:
  54 |                 self._name_index.setdefault(qname, []).append(node_id)

# [method] GraphQuery.find_symbol (relevance: 1.22, depth: 0)
  56 |     def find_symbol(self, name: str) -> list[str]:
  57 |         """Find symbol node IDs matching a name (exact or qualified)."""
  58 |         results = self._name_index.get(name, [])
  59 |         if not results:
  60 |             # Try partial match
  61 |             for key, ids in self._name_index.items():
  62 |                 if name.lower() == key.lower():
  63 |                     results.extend(ids)
  64 |         return list(set(results))

## src/cegraph/graph/store.py
# Included because: graph expansion (depth 3)

# [method] GraphStore._get_conn (relevance: 0.61, depth: 3)
  28 |     def _get_conn(self) -> sqlite3.Connection:
  29 |         if self._conn is None:
  30 |             self.db_path.parent.mkdir(parents=True, exist_ok=True)
  31 |             self._conn = sqlite3.connect(str(self.db_path))
  32 |             self._conn.row_factory = sqlite3.Row
  33 |             self._conn.execute("PRAGMA journal_mode=WAL")
  34 |             self._create_tables()
  35 |         return self._conn

# [method] GraphStore.close (relevance: 0.66, depth: 3)
 499 |     def close(self) -> None:
 500 |         """Close the database connection."""
 501 |         if self._conn:
 502 |             self._conn.close()
 503 |             self._conn = None

## src/cegraph/mcp/server.py
# Included because: matches 'name'; graph expansion (depth 3); graph expansion (depth 2)

# [constant] MCPServer.SERVER_NAME (relevance: 0.20, depth: 0)
  37 |     SERVER_NAME = "cegraph"

# [method] MCPServer._tool_get_structure (relevance: 0.52, depth: 2)
 308 |     def _tool_get_structure(self, _args: dict) -> str:
 309 |         self._ensure_graph()
 310 |         structure = self._query.get_structure()
 311 | 
 312 |         lines = ["Codebase structure:"]
 313 |         self._render_structure(structure, lines, indent=1)
 314 |         return "\n".join(lines)

# [method] MCPServer._handle_notification (relevance: 0.48, depth: 2)
 424 |     def _handle_notification(self, method: str, params: dict) -> None:
 425 |         """Handle a notification (no response needed)."""
 426 |         if method == "notifications/initialized":
 427 |             logger.info("Client initialized")
 428 |         elif method == "notifications/cancelled":
 429 |             logger.info(f"Request cancelled: {params.get('requestId')}")

# [method] MCPServer._rpc_tools_list (relevance: 0.21, depth: 3)
 462 |     def _rpc_tools_list(self, params: dict) -> dict:
 463 |         """List available tools."""
 464 |         return {"tools": self._tools}

## src/cegraph/parser/models.py
# Included because: graph expansion (depth 2)

# [function] detect_language (relevance: 0.49, depth: 2)
 100 | def detect_language(file_path: str) -> str | None:
 101 |     """Detect programming language from file extension."""
 102 |     from pathlib import Path
 103 | 
 104 |     ext = Path(file_path).suffix.lower()
 105 |     return EXTENSION_LANGUAGE_MAP.get(ext)

## src/cegraph/parser/tree_sitter_parser.py
# Included because: graph expansion (depth 3)

# [function] _extract_ts_import (relevance: 0.40, depth: 3)
 250 | def _extract_ts_import(node, file_path: str, source: bytes, result: FileSymbols) -> None:
 251 |     """Extract import information from a tree-sitter node."""
 252 |     text = node.text.decode("utf-8")
 253 |     result.imports.append(text)

## src/cegraph/search/hybrid.py
# Included because: matches 'symbols'

# [method] HybridSearch.search_symbols (relevance: 0.41, depth: 0)
  49 |     def search_symbols(self, query: str, kind: str = "", max_results: int = 20) -> list[dict]:
  50 |         """Search symbols using lexical + optional semantic."""
  51 |         return self.lexical.search_symbols(query, kind, max_results)

## src/cegraph/tools/registry.py
# Included because: graph expansion (depth 2); graph expansion (depth 3); graph expansion (depth 1)

# [method] ToolRegistry.register (relevance: 0.31, depth: 3)
  21 |     def register(self, func: Callable, definition: ToolDefinition) -> None:
  22 |         """Register a tool function with its definition."""
  23 |         self._tools[definition.name] = func
  24 |         self._definitions[definition.name] = definition

# [method] ToolRegistry.get (relevance: 0.85, depth: 1)
  26 |     def get(self, name: str) -> Callable | None:
  27 |         """Get a tool function by name."""
  28 |         return self._tools.get(name)

# [method] ToolRegistry.get_definition (relevance: 0.35, depth: 2)
  30 |     def get_definition(self, name: str) -> ToolDefinition | None:
  31 |         """Get a tool definition by name."""
  32 |         return self._definitions.get(name)

# [method] ToolRegistry.list_tools (relevance: 0.29, depth: 3)
  34 |     def list_tools(self) -> list[str]:
  35 |         """List all registered tool names."""
  36 |         return list(self._tools.keys())

# [method] ToolRegistry.get_definitions (relevance: 0.23, depth: 3)
  38 |     def get_definitions(self) -> list[ToolDefinition]:
  39 |         """Get all tool definitions (for passing to LLM)."""
  40 |         return list(self._definitions.values())

## src/cegraph/ui/console.py
# Included because: graph expansion (depth 3)

# [method] Console.success (relevance: 0.37, depth: 3)
  33 |     def success(self, message: str) -> None:
  34 |         self.console.print(f"[green]✓[/green] {message}")

# [method] Console.error (relevance: 0.51, depth: 3)
  36 |     def error(self, message: str) -> None:
  37 |         self.console.print(f"[red]✗[/red] {message}")

# [method] Console.warning (relevance: 0.42, depth: 3)
  39 |     def warning(self, message: str) -> None:
  40 |         self.console.print(f"[yellow]![/yellow] {message}")

# [method] Console.info (relevance: 0.50, depth: 3)
  42 |     def info(self, message: str) -> None:
  43 |         self.console.print(f"[blue]i[/blue] {message}")

## tests/test_graph.py
# Included because: matches 'symbols'; graph expansion (depth 2); graph expansion (depth 1); matches 'partial'

# [method] TestGraphQuery._build_query (relevance: 0.68, depth: 2)
 155 |     def _build_query(self, tmp_project: Path) -> GraphQuery:
 156 |         builder = GraphBuilder()
 157 |         graph = builder.build_from_directory(tmp_project)
 158 |         return GraphQuery(graph)

# [method] TestGraphQuery.test_find_symbol (relevance: 0.58, depth: 1)
 160 |     def test_find_symbol(self, tmp_project: Path):
 161 |         query = self._build_query(tmp_project)
 162 |         results = query.find_symbol("main")
 163 |         assert len(results) > 0

# [method] TestGraphQuery.test_find_symbol_partial (relevance: 0.58, depth: 1)
 165 |     def test_find_symbol_partial(self, tmp_project: Path):
 166 |         query = self._build_query(tmp_project)
 167 |         results = query.find_symbol("helper")
 168 |         assert len(results) > 0

# [method] TestGraphQuery.test_what_calls (relevance: 0.47, depth: 2)
 177 |     def test_what_calls(self, tmp_project: Path):
 178 |         query = self._build_query(tmp_project)
 179 |         callees = query.what_calls("main")
 180 |         callee_names = [c["name"] for c in callees]
 181 |         # main() should call several functions
 182 |         assert len(callees) > 0

# [method] TestGraphQuery.test_impact_of (relevance: 0.47, depth: 2)
 184 |     def test_impact_of(self, tmp_project: Path):
 185 |         query = self._build_query(tmp_project)
 186 |         impact = query.impact_of("calculate_total")
 187 |         assert impact["found"] is True
 188 |         assert len(impact["affected_files"]) > 0
 189 |         assert impact["risk_score"] >= 0

# [method] TestGraphQuery.test_impact_not_found (relevance: 0.47, depth: 2)
 191 |     def test_impact_not_found(self, tmp_project: Path):
 192 |         query = self._build_query(tmp_project)
 193 |         impact = query.impact_of("nonexistent_function")
 194 |         assert impact["found"] is False

# [method] TestGraphQuery.test_get_file_symbols (relevance: 0.47, depth: 2)
 196 |     def test_get_file_symbols(self, tmp_project: Path):
 197 |         query = self._build_query(tmp_project)
 198 |         symbols = query.get_file_symbols("main.py")
 199 |         assert len(symbols) > 0
 200 |         names = [s["name"] for s in symbols]
 201 |         assert "main" in names

# [method] TestGraphQuery.test_get_structure (relevance: 0.47, depth: 2)
 203 |     def test_get_structure(self, tmp_project: Path):
 204 |         query = self._build_query(tmp_project)
 205 |         structure = query.get_structure()
 206 |         assert "main.py" in structure or len(structure) > 0

# [method] TestGraphQuery.test_find_related (relevance: 0.47, depth: 2)
 208 |     def test_find_related(self, tmp_project: Path):
 209 |         query = self._build_query(tmp_project)
 210 |         related = query.find_related("calculate_total")
 211 |         assert len(related) > 0

## tests/test_search.py
# Included because: matches 'symbols'; graph expansion (depth 3); graph expansion (depth 1)

# [method] TestLexicalSearch._build_search (relevance: 0.51, depth: 1)
  15 |     def _build_search(self, tmp_project: Path) -> LexicalSearch:
  16 |         builder = GraphBuilder()
  17 |         graph = builder.build_from_directory(tmp_project)
  18 |         return LexicalSearch(tmp_project, graph)

# [method] TestLexicalSearch.test_search_regex (relevance: 0.33, depth: 3)
  39 |     def test_search_regex(self, tmp_project: Path):
  40 |         search = self._build_search(tmp_project)
  41 |         results = search.search(r"def \w+\(self", regex=True)
  42 |         assert len(results) > 0

# [method] TestLexicalSearch.test_search_no_results (relevance: 0.33, depth: 3)
  44 |     def test_search_no_results(self, tmp_project: Path):
  45 |         search = self._build_search(tmp_project)
  46 |         results = search.search("xyznonexistent123")
  47 |         assert len(results) == 0

# [method] TestLexicalSearch.test_search_symbols (relevance: 0.41, depth: 0)
  49 |     def test_search_symbols(self, tmp_project: Path):
  50 |         search = self._build_search(tmp_project)
  51 |         results = search.search_symbols("User")
  52 |         assert len(results) > 0
  53 |         assert any(r["name"] == "User" for r in results)

# [method] TestLexicalSearch.test_search_symbols_by_kind (relevance: 0.41, depth: 0)
  55 |     def test_search_symbols_by_kind(self, tmp_project: Path):
  56 |         search = self._build_search(tmp_project)
  57 |         results = search.search_symbols("", kind="function")
  58 |         assert len(results) > 0
  59 |         assert all(r["kind"] == "function" for r in results)

## tests/test_tools.py
# Included because: graph expansion (depth 2); matches 'symbols'; graph expansion (depth 3)

# [method] TestCeGraphTools._build_tools (relevance: 0.60, depth: 3)
  16 |     def _build_tools(self, tmp_project: Path) -> CeGraphTools:
  17 |         builder = GraphBuilder()
  18 |         graph = builder.build_from_directory(tmp_project)
  19 |         query = GraphQuery(graph)
  20 |         search = HybridSearch(tmp_project, graph)
  21 |         return CeGraphTools(tmp_project, graph, query, search)

# [method] TestCeGraphTools.test_search_symbols (relevance: 0.41, depth: 0)
  29 |     def test_search_symbols(self, tmp_project: Path):
  30 |         tools = self._build_tools(tmp_project)
  31 |         result = tools.search_symbols("User")
  32 |         assert "User" in result
  33 |         assert "class" in result

# [method] TestCeGraphTools.test_who_calls (relevance: 0.33, depth: 3)
  35 |     def test_who_calls(self, tmp_project: Path):
  36 |         tools = self._build_tools(tmp_project)
  37 |         result = tools.who_calls("helper_function")
  38 |         assert "main" in result.lower() or "Callers" in result

# [method] TestCeGraphTools.test_what_calls (relevance: 0.47, depth: 2)
  40 |     def test_what_calls(self, tmp_project: Path):
  41 |         tools = self._build_tools(tmp_project)
  42 |         result = tools.what_calls("main")
  43 |         assert len(result) > 0

# [method] TestCeGraphTools.test_impact_of (relevance: 0.47, depth: 2)
  45 |     def test_impact_of(self, tmp_project: Path):
  46 |         tools = self._build_tools(tmp_project)
  47 |         result = tools.impact_of("calculate_total")
  48 |         assert "Risk score" in result or "Impact" in result

# [method] TestCeGraphTools.test_read_file (relevance: 0.28, depth: 3)
  50 |     def test_read_file(self, tmp_project: Path):
  51 |         tools = self._build_tools(tmp_project)
  52 |         result = tools.read_file("main.py")
  53 |         assert "def main" in result
