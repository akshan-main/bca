examples/demo.py
  def main():
paper/experiments/ablation.py
  class AblationResult
  def run_ablation( repo_path: Path, task: str, budgets: list[int], ground_truth_symbols: list[str] | None = None, ) -> list[AblationResult]:
  def format_results_table(results: list[AblationResult]) -> str:
  def main():
paper/experiments/baselines.py
  class BaselineResult
  def baseline_grep( repo_path: Path, task: str, budget: int, graph, ) -> BaselineResult:
  def baseline_bm25( repo_path: Path, task: str, budget: int, graph, ) -> BaselineResult:
  def baseline_unweighted_bfs( repo_path: Path, task: str, budget: int, graph, query_engine: GraphQuery, ) -> BaselineResult:
  def baseline_repo_map( repo_path: Path, task: str, budget: int, graph, ) -> BaselineResult:
  def run_bca( repo_path: Path, task: str, budget: int, graph, query_engine: GraphQuery, ) -> BaselineResult:
  def run_comparison( repo_path: Path, task: str, budgets: list[int], ground_truth_symbols: list[str] | None = None, ) -> list[BaselineResult]:
  def format_comparison_table(results: list[BaselineResult]) -> str:
  def main():
paper/experiments/benchmark.py
  class EvalTask
  class EvalResult
  def assemble_bca( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def assemble_bca_no_closure( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def assemble_bm25( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def assemble_grep( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def assemble_repo_map( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def assemble_vector( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def _vector_score_tfidf(query: str, symbols: list[dict]) -> list[float]:
  def _vector_score_dense(query: str, symbols: list[dict]) -> list[float]:
  def build_prompt(context: str, task: str) -> str:
  async def call_llm( provider, context: str, task: str, ) -> tuple[str, float, int, int]:
  def extract_patch(llm_output: str) -> str:
  def apply_and_test( repo_path: Path, patch: str, test_cmd: str, timeout: int = 60, ) -> tuple[bool, str]:
  def _apply_mutation(repo_path: Path, mutation: dict) -> str | None:
  def _restore_mutation(repo_path: Path, mutation: dict, original: str) -> None:
  async def run_benchmark( tasks: list[EvalTask], budgets: list[int], methods: list[str], llm_config: LLMConfig, output_dir: Path, ) -> list[EvalResult]:
  def format_results(results: list[EvalResult], budgets: list[int]) -> str:
  def main():
paper/experiments/make_tasks.py
  def verify_mutations(repo_path: Path) -> list[dict]:
  def write_eval_tasks( repo_path: Path, mutations: list[dict], output_file: Path, ) -> None:
  def main():
paper/experiments/run_all.py
  def aggregate_baselines(results: list[BaselineResult]) -> str:
  def aggregate_ablation(results: list[AblationResult]) -> str:
  def generate_latex_baseline_table(results: list[BaselineResult]) -> str:
  def generate_latex_ablation_table(results: list[AblationResult]) -> str:
  def main():
src/cegraph/__init__.py
src/cegraph/__main__.py
src/cegraph/agent/__init__.py
src/cegraph/agent/loop.py
  class AgentStep
  class AgentResult
  class AgentLoop
    def __init__( self, llm: LLMProvider, tools: ToolRegistry, project_name: str = "", max_iterations: int = 15, on_step: Callable[[AgentStep], None] | None = None, on_approval_needed: Callable[[str], bool] | None = None, ) -> None:
    async def run(self, task: str, context: str = "") -> AgentResult:
    async def ask(self, question: str) -> str:
src/cegraph/agent/prompts.py
  def get_system_prompt(project_name: str = "") -> str:
  def get_question_prompt(project_name: str = "") -> str:
src/cegraph/cli.py
  def _get_project_root(path: