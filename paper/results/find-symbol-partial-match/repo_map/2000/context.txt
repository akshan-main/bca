examples/demo.py
  def main():
paper/experiments/ablation.py
  class AblationResult
  def run_ablation( repo_path: Path, task: str, budgets: list[int], ground_truth_symbols: list[str] | None = None, ) -> list[AblationResult]:
  def format_results_table(results: list[AblationResult]) -> str:
  def main():
paper/experiments/baselines.py
  class BaselineResult
  def baseline_grep( repo_path: Path, task: str, budget: int, graph, ) -> BaselineResult:
  def baseline_bm25( repo_path: Path, task: str, budget: int, graph, ) -> BaselineResult:
  def baseline_unweighted_bfs( repo_path: Path, task: str, budget: int, graph, query_engine: GraphQuery, ) -> BaselineResult:
  def baseline_repo_map( repo_path: Path, task: str, budget: int, graph, ) -> BaselineResult:
  def run_bca( repo_path: Path, task: str, budget: int, graph, query_engine: GraphQuery, ) -> BaselineResult:
  def run_comparison( repo_path: Path, task: str, budgets: list[int], ground_truth_symbols: list[str] | None = None, ) -> list[BaselineResult]:
  def format_comparison_table(results: list[BaselineResult]) -> str:
  def main():
paper/experiments/benchmark.py
  class EvalTask
  class EvalResult
  def assemble_bca( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def assemble_bca_no_closure( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def assemble_bm25( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def assemble_grep( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def assemble_repo_map( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def assemble_vector( repo_path: Path, task: str, budget: int, graph, query: GraphQuery, ) -> tuple[str, int, int, int, float]:
  def _vector_score_tfidf(query: str, symbols: list[dict]) -> list[float]:
  def _vector_score_dense(query: str, symbols: list[dict]) -> list[float]:
  def build_prompt(context: str, task: str) -> str:
  async def call_llm( provider, context: str, task: str, ) -> tuple[str, float, int, int]:
  def extract_patch(llm_output: str) -> str:
  def apply_and_test( repo_path: Path, patch: str, test_cmd: str, timeout: int = 60, ) -> tuple[bool, str]:
  def _apply_mutation(repo_path: Path, mutation: dict) -> str | None:
  def _restore_mutation(repo_path: Path, mutation: dict, original: str) -> None:
  async def run_benchmark( tasks: list[EvalTask], budgets: list[int], methods: list[str], llm_config: LLMConfig, output_dir: Path, ) -> list[EvalResult]:
  def format_results(results: list[EvalResult], budgets: list[int]) -> str:
  def main():
paper/experiments/make_tasks.py
  def verify_mutations(repo_path: Path) -> list[dict]:
  def write_eval_tasks( repo_path: Path, mutations: list[dict], output_file: Path, ) -> None:
  def main():
paper/experiments/run_all.py
  def aggregate_baselines(results: list[BaselineResult]) -> str:
  def aggregate_ablation(results: list[AblationResult]) -> str:
  def generate_latex_baseline_table(results: list[BaselineResult]) -> str:
  def generate_latex_ablation_table(results: list[AblationResult]) -> str:
  def main():
src/cegraph/__init__.py
src/cegraph/__main__.py
src/cegraph/agent/__init__.py
src/cegraph/agent/loop.py
  class AgentStep
  class AgentResult
  class AgentLoop
    def __init__( self, llm: LLMProvider, tools: ToolRegistry, project_name: str = "", max_iterations: int = 15, on_step: Callable[[AgentStep], None] | None = None, on_approval_needed: Callable[[str], bool] | None = None, ) -> None:
    async def run(self, task: str, context: str = "") -> AgentResult:
    async def ask(self, question: str) -> str:
src/cegraph/agent/prompts.py
  def get_system_prompt(project_name: str = "") -> str:
  def get_question_prompt(project_name: str = "") -> str:
src/cegraph/cli.py
  def _get_project_root(path: str | None = None) -> Path:
  def _load_graph(root: Path):
  def main():
  def init(path: str | None, provider: str | None, model: str | None):
  def reindex(path: str | None):
  def _do_index(root: Path, config: ProjectConfig):
  def status(path: str | None):
  def search(query: str, path: str | None, kind: str):
  def who_calls(symbol_name: str, path: str | None, depth: int):
  def impact(symbol_name: str, path: str | None):
  def context( task: str, path: str | None, budget: int, strategy: str, compact: bool, savings: bool, focus: tuple[str, ...] ):
  def serve(path: str | None, transport: str, generate_config: str | None):
  def impact_pr(path: str | None, base: str, output_format: str):
  def code_map(path: str | None):
  def ask(question: str, path: str | None):
  def agent(task: str, path: str | None, auto: bool):
  def _run_agent( root: Path, config: ProjectConfig, graph, store, task: str, agent_mode: bool = True, auto_approve: bool = False, ):
  def benchmark(path: str | None):
  def config_cmd(action: str, key: str | None, value: str | None, path: str | None):
src/cegraph/config.py
  class LLMConfig
    def api_key(self) -> str | None:
  class AgentConfig
  class IndexerConfig
  class ProjectConfig
  def find_project_root(start: Path | None = None) -> Path | None:
  def get_cegraph_dir(root: Path) -> Path:
  def load_config(root: Path) -> ProjectConfig:
  def save_config(root: Path, config: ProjectConfig) -> None:
  def set_config_value(config: ProjectConfig, key: str, value: Any) -> ProjectConfig:
src/cegraph/context/__init__.py
src/cegraph/context/_native.py
  def _find_library() -> str | None:
  def _load_library():
  def _setup_signatures(lib):
  class NativeCAG
    def is_available() -> bool:
    def version() -> str:
    def create_graph(num_nodes: int) -> NativeGraph:
    def estimate_tokens(text: str) -> int:
    def extract_entities(text: str, max_entities: int = 200) -> list[dict]:
  class NativeGraph
    def __init__(self, lib, handle, num_nodes: int):
    def add_edge(self, src: int, dst: int, weight: float) -> None:
    def set_node_weight(self, node: int, weight: float) -> None:
    def set_lines(self, node: int, start: int, end: int) -> None:
    def weighted_bfs( self, seed_nodes: list[int], seed_scores: list[float], max_depth: int = 3, min_score: float = 0.1, backward_decay: float = 0.7, max_results: int = 5000, ) -> list[dict]:
    def topological_sort(self, nodes: list[int]) -> list[int]:
    def destroy(self) -> None:
    def __del__(self):
src/cegraph/context/engine.py
  class AblationConfig
  class ContextAssembler
    def __init__( self, root: Path, graph: nx.DiGraph, query: GraphQuery, ablation: AblationConfig | None = None, ) -> None:
    def _build_native_graph(self) -> None:
    def is_accelerated(self) -> bool:
    def assemble( self, task: str, token_budget: int = 8000, strategy: ContextStrategy = ContextStrategy.SMART, focus_files: list[str] | None = None, ) -> ContextPackage:
    def _extract_entities(self, task: str) -> list[dict]:
    def _find_seeds( self, entities: list[dict], focus_files: list[str] | None = None ) -> list[dict]:
    def _expand_context_native( self, seeds: list[dict], config: dict ) -> list[dict]:
    def _expand_context( self, seeds: list[dict], config: dict ) -> list[dict]:
    def _expand_context_pagerank( self, seeds: list[dict], config: dict ) -> list[dict]:
    def _score_candidates( self, candidates: list[dict], entities: list[dict], seeds: list[dict], ) -> list[dict]:
    def _compute_closures(self, candidates: list[dict]) -> dict[str, set[str]]:
    def _closure_of(self, symbol_id: str, candidate_ids: set[str]) -> set[str]:
    def _budget_select( self, candidates: list[dict], closures: dict[str, set[str]], token_budget: int, ) -> list[dict]:
    def _token_cost(self, symbol_id: str, cand: dict | None = None) -> int:
    def _marginal_utility( self, symbol_id: str, covered_edges: set[tuple[str, str]] ) -> float:
    def _update_coverage( self, symbol_id: 