\section{Related Work}\label{sec:related}

\paragraph{Code retrieval for LLMs.}
Repository-level code generation requires selecting relevant context from a
codebase.  RepoCoder~\cite{zhang2023repocoder} uses iterative retrieval with a
sliding window, alternating between generation and retrieval.
RepoHyper~\cite{phan2024repohyper} constructs a repository-level semantic
graph and retrieves via graph expansion.  SWE-agent~\cite{yang2024sweagent}
gives the model shell access to search and read files interactively.  These
systems optimize for retrieval quality but do not formalize the budget
constraint or provide approximation guarantees.

\paragraph{Repository maps.}
Aider~\cite{aider2024} generates a structural summary of the repository (file
tree plus function signatures) and includes it as persistent context.
Mentat~\cite{mentat2024} uses a similar approach with tree-sitter-based code
maps.  These methods provide a fixed-cost overview but do not adapt the context
to the specific task.

\paragraph{Code knowledge graphs.}
Static analysis tools have long constructed call graphs and dependency graphs
for program understanding~\cite{ryder1979constructing}.  Recent work applies
graph neural networks to code: CodeQL~\cite{codeql} builds a relational
database over ASTs for vulnerability detection.  We use a simpler directed
graph over symbols with typed edges, focused on context selection rather than
program verification.

\paragraph{Submodular optimization.}
Maximizing a submodular function under a knapsack constraint is a classical
problem~\cite{nemhauser1978analysis}.  The greedy algorithm achieves a
$(1 - 1/e)$ approximation ratio for monotone submodular functions under a
cardinality constraint~\cite{krause2014submodular}.  With a knapsack
(non-uniform costs), the guarantee requires a modified greedy that compares
single-element and greedy solutions~\cite{khuller1999budgeted}.  We apply this
framework to code selection, using edge coverage as the submodular component.

\paragraph{RAG for code.}
Retrieval-augmented generation (RAG) systems for code typically use embedding
similarity (e.g., CodeBERT~\cite{feng2020codebert}, UniXcoder~\cite{guo2022unixcoder})
to retrieve relevant snippets.  These approaches treat code fragments as
independent documents and do not model inter-symbol dependencies.  BCA
complements embedding-based retrieval by adding dependency-aware packing on top
of any retrieval signal.
